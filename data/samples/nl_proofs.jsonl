{"id":"ex1","theorem":"forall a b : nat, a + b = b + a","nl_proof":"Step 1: We proceed by induction on a. Step 2: For the base case when a = 0, we need to show 0 + b = b + 0, which follows from the definition of addition. Step 3: For the inductive step, assume a + b = b + a. We need to show S a + b = b + S a. Step 4: By the definition of addition, S a + b = S (a + b). Step 5: By the inductive hypothesis, this equals S (b + a). Step 6: By commutativity of successor, this equals b + S a."}
{"id":"ex2","theorem":"forall n : nat, n + 0 = n","nl_proof":"Step 1: By induction on n. Step 2: Base case: 0 + 0 = 0 by reflexivity. Step 3: Inductive step: Assume n + 0 = n. Step 4: We show S n + 0 = S n by simplification and the inductive hypothesis."}
{"id":"ex3","theorem":"forall n m : nat, n * 0 = 0","nl_proof":"Step 1: This follows directly from the definition of multiplication in Coq."}
{"id":"ex4","theorem":"forall l : list nat, length (rev l) = length l","nl_proof":"Step 1: Proceed by induction on the list l. Step 2: Base case: For the empty list, rev [] = [] and length [] = 0. Step 3: Inductive case: Assume length (rev l) = length l for some list l. Step 4: For the list h :: l, we have rev (h :: l) = rev l ++ [h]. Step 5: The length of a concatenation is the sum of the lengths. Step 6: Thus length (rev l ++ [h]) = length (rev l) + 1 = length l + 1 = length (h :: l)."}
{"id":"ex5","theorem":"forall P Q : Prop, P /\\ Q -> Q /\\ P","nl_proof":"Step 1: Assume P and Q. Step 2: From the hypothesis P /\\ Q, we can extract both P and Q. Step 3: Constructing Q /\\ P requires showing both Q and P, which we have from step 2."}
