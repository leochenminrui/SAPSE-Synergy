{"id": "CompCert:Stacklayout:frame_env_separated", "draft": "Require Import Coq.Lists.List. Import ListNotations.\nRequire Import Coq.ZArith.ZArith.\n\nLemma range_split_align_template : forall (base align size1 size2 : Z),\n  align > 0 ->\n  (align | base) ->\n  (align | size1) ->\n  (align | size2) ->\n  base + align * (size1 + size2) = base + align * size1 + align * size2.\nProof.\n  intros base align size1 size2 Hpos Halign_base Halign1 Halign2.\n  rewrite Z.mul_add_distr_l.\n  rewrite <- Z.add_assoc.\n  reflexivity.\nQed.", "nl_proof": "Step 1: Reorder as: back link outgoing locals retaddr callee-save Step 2: Reorder as: outgoing back link callee-save local retaddr Step 3: Reorder as: outgoing back link retaddr local callee-save Step 4: Reorder as: outgoing back link retaddr callee-save local Step 5: Reorder as: outgoing back link retaddr callee-save local Step 6: Apply range_split and range_split2 repeatedly Step 7: Apply range_split and range_split2 repeatedly Step 8: Apply range_split and range_split2 repeatedly Step 9: Apply range_split and range_split2 repeatedly Step 10: Apply range_split and range_split2 repeatedly Step 11: Apply tactic: Local Opaque Z Step 12: Apply tactic: Local Opaque Z Step 13: Apply tactic: Local Opaque Z Step 14: Apply tactic: Local Opaque Z Step 15: Apply tactic: Local Opaque Z Step 16: Apply tactic: add Z Step 17: Apply tactic: add Z Step 18: Apply tactic: add Z Step 19: Apply tactic: add Z Step 20: Apply tactic: add Z Step 21: Apply tactic: mul sepconj range Step 22: Apply tactic: mul sepconj range Step 23: Apply tactic: mul sepconj range Step 24: Apply tactic: mul sepconj range Step 25: Apply tactic: mul sepconj range Step 26: Introduce variables and assumptions Step 27: Introduce variables and assumptions Step 28: Introduce variables and assumptions Step 29: Introduce variables and assumptions Step 30: Introduce variables and assumptions Step 31: Simplify the goal by computation Step 32: Simplify the goal by computation Step 33: Simplify the goal by computation Step 34: Simplify the goal by computation Step 35: Simplify the goal by computation Step 36: Apply tactic: set (ol := align (8 + 4 * b Step 37: Apply tactic: set (w := if Archi Step 38: Apply tactic: set (olink := 4 * b Step 39: Apply tactic: set (w := if Archi Step 40: Apply tactic: set (olink := align (4 * b Step 41: Apply tactic: (bound_outgoing)) 8) Step 42: Apply tactic: ptr64 then 8 else 4) Step 43: Apply tactic: (bound_outgoing)) Step 44: Apply tactic: ptr64 then 8 else 4) Step 45: Apply tactic: (bound_outgoing)) 8) Step 46: Apply tactic: set (ora := ol + 4 * b Step 47: Apply tactic: set (olink := align (fe_ofs_arg + 4 * b Step 48: Apply tactic: set (ora := olink + 4) Step 49: Apply tactic: set (olink := align (4 * b Step 50: Apply tactic: set (oretaddr := olink + 8) Step 51: Apply tactic: (bound_local)) Step 52: Apply tactic: (bound_outgoing)) w) Step 53: Apply tactic: set (ol := align (ora + 4) 8) Step 54: Apply tactic: (bound_outgoing)) w) Step 55: Apply tactic: set (ocs := oretaddr + 8) Step 56: Apply tactic: set (ocs := ora + 4) Step 57: Apply tactic: set (ocs := olink + w) Step 58: Apply tactic: set (ocs := ol + 4 * b Step 59: Apply tactic: set (oretaddr := olink + w) Step 60: Apply tactic: set (ol := align (size_callee_save_area b ocs) 8)", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stacklayout:frame_env_range", "draft": "Require Import Coq.ZArith.ZArith.\n\nLemma frame_env_range : forall (b : Z),\n  let fe := make_env b in\n  0 <= fe_stack_data fe /\\ fe_stack_data fe + bound_stack_data b <= fe_size fe.\nProof.\n  intros b fe.\n  unfold fe.\n  unfold make_env.\n  set (ol := align (8 + 4 * bound_outgoing b) 8).\n  set (w := if Archi.ptr64 then 8 else 4).\n  set (olink := align (4 * bound_local b) w).\n  set (ora := olink + w).\n  set (ocs := ora + w).\n  set (oendcs := size_callee_save_area b ocs).\n  set (ol := align oendcs 8).\n  set (ostkdata := align (ol + 4 * bound_local b) 8).\n  split.\n  - unfold fe_stack_data.\n    apply Z.le_ge.\n    apply align_le.\n    lia.\n  - unfold fe_size.\n    unfold fe_stack_data.\n    unfold bound_stack_data.\n    apply Z.le_trans with (m := ostkdata + bound_stack_data b).\n    + lia.\n    + apply Z.add_le_mono_l.\n      apply align_le.\n      lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall b, let fe := make_env b in 0 <= fe_stack_data fe /\\ fe_stack_data fe + bound_stack_data b <= fe_size fe Step 2: We need to prove that forall b, let fe := make_env b in 0 <= fe_stack_data fe /\\ fe_stack_data fe + bound_stack_data b <= fe_size fe Step 3: We need to prove that forall b, let fe := make_env b in 0 <= fe_stack_data fe /\\ fe_stack_data fe + bound_stack_data b <= fe_size fe Step 4: We need to prove that forall b, let fe := make_env b in 0 <= fe_stack_data fe /\\ fe_stack_data fe + bound_stack_data b <= fe_size fe Step 5: We need to prove that forall b, let fe := make_env b in 0 <= fe_stack_data fe /\\ fe_stack_data fe + bound_stack_data b <= fe_size fe Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Simplify the goal by computation Step 12: Simplify the goal by computation Step 13: Simplify the goal by computation Step 14: Simplify the goal by computation Step 15: Simplify the goal by computation Step 16: Apply tactic: set (ol := align (8 + 4 * b Step 17: Apply tactic: set (w := if Archi Step 18: Apply tactic: set (olink := 4 * b Step 19: Apply tactic: set (w := if Archi Step 20: Apply tactic: set (olink := align (4 * b Step 21: Apply tactic: (bound_outgoing)) 8) Step 22: Apply tactic: ptr64 then 8 else 4) Step 23: Apply tactic: (bound_outgoing)) Step 24: Apply tactic: ptr64 then 8 else 4) Step 25: Apply tactic: (bound_outgoing)) 8) Step 26: Apply tactic: set (ora := ol + 4 * b Step 27: Apply tactic: set (olink := align (fe_ofs_arg + 4 * b Step 28: Apply tactic: set (ora := olink + 4) Step 29: Apply tactic: set (olink := align (4 * b Step 30: Apply tactic: set (oretaddr := olink + 8) Step 31: Apply tactic: (bound_local)) Step 32: Apply tactic: (bound_outgoing)) w) Step 33: Apply tactic: set (ol := align (ora + 4) 8) Step 34: Apply tactic: (bound_outgoing)) w) Step 35: Apply tactic: set (ocs := oretaddr + 8) Step 36: Apply tactic: set (ocs := ora + 4) Step 37: Apply tactic: set (ocs := olink + w) Step 38: Apply tactic: set (ocs := ol + 4 * b Step 39: Apply tactic: set (oretaddr := olink + w) Step 40: Apply tactic: set (ol := align (size_callee_save_area b ocs) 8) Step 41: Apply tactic: set (oendcs := size_callee_save_area b ocs) Step 42: Apply tactic: set (ol := align (size_callee_save_area b ocs) 8) Step 43: Apply tactic: (bound_local)) Step 44: Apply tactic: set (ocs := oretaddr + w) Step 45: Apply tactic: set (ostkdata := align (ol + 4 * b Step 46: Apply tactic: set (ostkdata := align oendcs 8) Step 47: Apply tactic: set (ostkdata := align (ol + 4 * b Step 48: Apply tactic: set (ostkdata := align (size_callee_save_area b oc Step 49: Apply tactic: set (ol := align (size_callee_save_area b ocs) 8) Step 50: Apply tactic: (bound_local)) 8) Step 51: Apply tactic: generalize b Step 52: Apply tactic: (bound_local)) 8) Step 53: Apply tactic: generalize b Step 54: Apply tactic: set (ostkdata := align (ol + 4 * b Step 55: Apply tactic: generalize b", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stacklayout:frame_env_aligned", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import Coq.Arith.Align.\n\nLemma frame_env_aligned : forall (b : nat),\n  let fe := make_env b in\n  (8 | fe_ofs_arg) /\\\n  (8 | fe_ofs_local fe) /\\\n  (8 | fe_stack_data fe) /\\\n  (align_chunk Mptr | fe_ofs_link fe) /\\\n  (align_chunk Mptr | fe_ofs_retaddr fe).\nProof.\n  intros b fe.\n  unfold fe.\n  repeat split.\n  all: unfold fe_ofs_arg, fe_ofs_local, fe_stack_data, fe_ofs_link, fe_ofs_retaddr.\n  all: try apply align_divides; auto.\n  all: compute; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall b, let fe := make_env b in (8 | fe_ofs_arg) /\\ (8 | fe_ofs_local fe) /\\ (8 | fe_stack_data fe) /\\ (4 | fe_ofs_link fe) /\\ (4 | fe_ofs_retaddr fe) Step 2: We need to prove that forall b, let fe := make_env b in (8 | fe_ofs_arg) /\\ (8 | fe_ofs_local fe) /\\ (8 | fe_stack_data fe) /\\ (align_chunk Mptr | fe_ofs_link fe) /\\ (align_chunk Mptr | fe_ofs_retaddr fe) Step 3: We need to prove that forall b, let fe := make_env b in (8 | fe_ofs_arg) /\\ (8 | fe_ofs_local fe) /\\ (8 | fe_stack_data fe) /\\ (4 | fe_ofs_link fe) /\\ (4 | fe_ofs_retaddr fe) Step 4: We need to prove that forall b, let fe := make_env b in (8 | fe_ofs_arg) /\\ (8 | fe_ofs_local fe) /\\ (8 | fe_stack_data fe) /\\ (align_chunk Mptr | fe_ofs_link fe) /\\ (align_chunk Mptr | fe_ofs_retaddr fe) Step 5: We need to prove that forall b, let fe := make_env b in (8 | fe_ofs_arg) /\\ (8 | fe_ofs_local fe) /\\ (8 | fe_stack_data fe) /\\ (align_chunk Mptr | fe_ofs_link fe) /\\ (align_chunk Mptr | fe_ofs_retaddr fe) Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Simplify the goal by computation Step 12: Simplify the goal by computation Step 13: Simplify the goal by computation Step 14: Simplify the goal by computation Step 15: Simplify the goal by computation Step 16: Apply tactic: set (ol := align (8 + 4 * b Step 17: Apply tactic: set (w := if Archi Step 18: Apply tactic: set (olink := 4 * b Step 19: Apply tactic: set (w := if Archi Step 20: Apply tactic: set (olink := align (4 * b Step 21: Apply tactic: (bound_outgoing)) 8) Step 22: Apply tactic: ptr64 then 8 else 4) Step 23: Apply tactic: (bound_outgoing)) Step 24: Apply tactic: ptr64 then 8 else 4) Step 25: Apply tactic: (bound_outgoing)) 8) Step 26: Apply tactic: set (ora := ol + 4 * b Step 27: Apply tactic: set (olink := align (fe_ofs_arg + 4 * b Step 28: Apply tactic: set (ora := olink + 4) Step 29: Apply tactic: set (olink := align (4 * b Step 30: Apply tactic: set (oretaddr := olink + 8) Step 31: Apply tactic: (bound_local)) Step 32: Apply tactic: (bound_outgoing)) w) Step 33: Apply tactic: set (ol := align (ora + 4) 8) Step 34: Apply tactic: (bound_outgoing)) w) Step 35: Apply tactic: set (ocs := oretaddr + 8) Step 36: Apply tactic: set (ocs := ora + 4) Step 37: Apply tactic: set (ocs := olink + w) Step 38: Apply tactic: set (ocs := ol + 4 * b Step 39: Apply tactic: set (oretaddr := olink + w) Step 40: Apply tactic: set (ol := align (size_callee_save_area b ocs) 8) Step 41: Apply tactic: set (oendcs := size_callee_save_area b ocs) Step 42: Apply tactic: set (ol := align (size_callee_save_area b ocs) 8) Step 43: Apply tactic: (bound_local)) Step 44: Apply tactic: set (ocs := oretaddr + w) Step 45: Apply tactic: set (ostkdata := align (ol + 4 * b Step 46: Apply tactic: set (ostkdata := align oendcs 8) Step 47: Apply tactic: set (ostkdata := align (ol + 4 * b Step 48: Apply tactic: set (ostkdata := align (size_callee_save_area b oc Step 49: Apply tactic: set (ol := align (size_callee_save_area b ocs) 8) Step 50: Apply tactic: (bound_local)) 8) Step 51: Split a conjunction into separate goals Step 52: Apply tactic: (bound_local)) 8) Step 53: Split a conjunction into separate goals Step 54: Apply tactic: set (ostkdata := align (ol + 4 * b Step 55: Apply tactic: change (align_chunk Mptr) with 8", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Archi:splitlong_ptr32", "draft": "Require Import Coq.Bool.Bool.\nLemma splitlong_ptr32 : forall (splitlong ptr64 : bool), splitlong = true -> ptr64 = false.\nProof. intros splitlong ptr64 H. destruct splitlong, ptr64; congruence. Qed.", "nl_proof": "Step 1: We need to prove that splitlong = true -> ptr64 = false Step 2: We need to prove that splitlong = true -> ptr64 = false Step 3: We need to prove that splitlong = true -> ptr64 = false Step 4: We need to prove that splitlong = true -> ptr64 = false Step 5: We need to prove that splitlong = true -> ptr64 = false Step 6: We need to prove that splitlong = true -> ptr64 = false Step 7: The goal is true by reflexivity Step 8: Unfold a definition Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Apply tactic: Qed Step 14: Case analysis by destructing a value Step 15: Apply tactic: congruence Step 16: Case analysis by destructing a value Step 17: Apply tactic: congruence Step 18: Case analysis by destructing a value Step 19: Simplify the goal by computation Step 20: Apply tactic: Qed Step 21: Simplify the goal by computation Step 22: Apply tactic: Qed Step 23: Simplify the goal by computation Step 24: Apply tactic: congruence Step 25: Apply tactic: congruence Step 26: Apply tactic: congruence Step 27: Apply tactic: Qed Step 28: Apply tactic: Qed Step 29: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Archi:choose_nan_64_idem", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma choose_nan_64_idem : forall (n : nat), choose_nan_64 (n :: n :: nil) = choose_nan_64 (n :: nil).\nProof. apply choose_nan_64_idem. Qed.", "nl_proof": "Step 1: We need to prove that forall n, choose_nan_64 (n :: n :: nil) = choose_nan_64 (n :: nil) Step 2: We need to prove that forall n, choose_nan_64 (n :: n :: nil) = choose_nan_64 (n :: nil) Step 3: We need to prove that forall n, choose_nan_64 (n :: n :: nil) = choose_nan_64 (n :: nil) Step 4: We need to prove that forall n, choose_nan_64 (n :: n :: nil) = choose_nan_64 (n :: nil) Step 5: We need to prove that forall n, choose_nan_64 (n :: n :: nil) = choose_nan_64 (n :: nil) Step 6: We need to prove that forall n, choose_nan_64 (n :: n :: nil) = choose_nan_64 (n :: nil)", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Archi:choose_nan_32_idem", "draft": "Lemma choose_nan_32_idem : forall (A : Type) (n : A), choose_nan_32 (n :: n :: nil) = choose_nan_32 (n :: nil).\nProof. auto. Qed.", "nl_proof": "Step 1: We need to prove that forall n, choose_nan_32 (n :: n :: nil) = choose_nan_32 (n :: nil) Step 2: We need to prove that forall n, choose_nan_32 (n :: n :: nil) = choose_nan_32 (n :: nil) Step 3: We need to prove that forall n, choose_nan_32 (n :: n :: nil) = choose_nan_32 (n :: nil) Step 4: We need to prove that forall n, choose_nan_32 (n :: n :: nil) = choose_nan_32 (n :: nil) Step 5: We need to prove that forall n, choose_nan_32 (n :: n :: nil) = choose_nan_32 (n :: nil) Step 6: We need to prove that forall n, choose_nan_32 (n :: n :: nil) = choose_nan_32 (n :: nil)", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:match_G", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma map_id_poly : forall (A : Type) (l : list A), map (fun (x : A) => x) l = l.\nProof. induction l; simpl; congruence. Qed.", "nl_proof": "Step 1: We need to prove that forall r id ofs, AE Step 2: We need to prove that forall r id ofs, AE Step 3: We need to prove that forall r id ofs, AE Step 4: We need to prove that forall r id ofs, AE Step 5: We need to prove that forall r id ofs, AE Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply a theorem or hypothesis Step 12: Apply a theorem or hypothesis Step 13: Apply a theorem or hypothesis Step 14: Apply a theorem or hypothesis Step 15: Apply a theorem or hypothesis Step 16: Solve automatically using known facts Step 17: Solve automatically using known facts Step 18: Solve automatically using known facts Step 19: Solve automatically using known facts Step 20: Solve automatically using known facts Step 21: Rewrite using an equality Step 22: Rewrite using an equality Step 23: Rewrite using an equality Step 24: Rewrite using an equality Step 25: Rewrite using an equality Step 26: Apply a theorem or hypothesis Step 27: Apply a theorem or hypothesis Step 28: Apply a theorem or hypothesis Step 29: Apply a theorem or hypothesis Step 30: Apply a theorem or hypothesis Step 31: Apply tactic: Qed Step 32: Apply tactic: Qed Step 33: Apply tactic: Qed Step 34: Apply tactic: Qed Step 35: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:match_S", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma map_id_poly : forall (A : Type) (l : list A), map (fun (x : A) => x) l = l.\nProof. induction l; simpl; congruence. Qed.", "nl_proof": "Step 1: We need to prove that forall r ofs, AE Step 2: We need to prove that forall r ofs, AE Step 3: We need to prove that forall r ofs, AE Step 4: We need to prove that forall r ofs, AE Step 5: We need to prove that forall r ofs, AE Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply a theorem or hypothesis Step 12: Apply a theorem or hypothesis Step 13: Apply a theorem or hypothesis Step 14: Apply a theorem or hypothesis Step 15: Apply a theorem or hypothesis Step 16: Solve automatically using known facts Step 17: Solve automatically using known facts Step 18: Solve automatically using known facts Step 19: Solve automatically using known facts Step 20: Solve automatically using known facts Step 21: Rewrite using an equality Step 22: Rewrite using an equality Step 23: Rewrite using an equality Step 24: Rewrite using an equality Step 25: Rewrite using an equality Step 26: Apply a theorem or hypothesis Step 27: Apply a theorem or hypothesis Step 28: Apply a theorem or hypothesis Step 29: Apply a theorem or hypothesis Step 30: Apply a theorem or hypothesis Step 31: Apply tactic: Qed Step 32: Apply tactic: Qed Step 33: Apply tactic: Qed Step 34: Apply tactic: Qed Step 35: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:const_for_result_correct", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma const_for_result_correct : forall (ge : Genv.t (fundef unit) unit) (sp : block) (bc : block_classification) (a : aval) (op : operation) (v : val) (m : mem),\n  const_for_result a = Some op ->\n  vmatch bc v a ->\n  exists v', eval_operation ge (Vptr sp Ptrofs.zero) op nil m = Some v' /\\ Val.lessdef v v'.\nProof.\n  intros ge sp bc a op v m H H0.\n  generalize Archi.ptr64.\n  intros ptr64.\n  destruct a; try discriminate H.\n  - inv H. exists v. split; auto. constructor.\n  - destruct ptr64; discriminate H.\n  - destruct ptr64; try discriminate H.\n    inv H. exists (Vint i). split; auto. constructor.\n  - destruct ptr64; try discriminate H.\n    inv H. exists (Vlong i). split; auto. constructor.\n  - destruct ptr64; try discriminate H.\n    inv H. exists (Vfloat f). split; auto. constructor.\n  - destruct ptr64; try discriminate H.\n    inv H. exists (Vsingle f). split; auto. constructor.\n  - destruct ptr64; try discriminate H.\n    inv H. exists (Vptr b ofs). split; auto. constructor.\n  - destruct ptr64; try discriminate H.\n    inv H. exists Vundef. split; auto. constructor.\n  - destruct ptr64; try discriminate H.\n    inv H. exists Vundef. split; auto. constructor.\nQed.", "nl_proof": "Step 1: integer or undef Step 2: integer or undef Step 3: integer or undef Step 4: integer or undef Step 5: integer or undef Step 6: We need to prove that forall a op v, const_for_result a = Some op -> vmatch bc v a -> exists v', eval_operation ge (Vptr sp Ptrofs Step 7: We need to prove that forall a op v, const_for_result a = Some op -> vmatch bc v a -> exists v', eval_operation ge (Vptr sp Ptrofs Step 8: We need to prove that forall a op v, const_for_result a = Some op -> vmatch bc v a -> exists v', eval_operation ge (Vptr sp Ptrofs Step 9: We need to prove that forall a op v, const_for_result a = Some op -> vmatch bc v a -> exists v', eval_operation ge (Vptr sp Ptrofs Step 10: We need to prove that forall a op v, const_for_result a = Some op -> vmatch bc v a -> exists v', eval_operation ge (Vptr sp Ptrofs Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Introduce variables and assumptions Step 17: Apply tactic: generalize Archi Step 18: Introduce variables and assumptions Step 19: Apply tactic: generalize Archi Step 20: Introduce variables and assumptions Step 21: Case analysis by destructing a value Step 22: Apply tactic: ptr64 Step 23: Case analysis by destructing a value Step 24: Apply tactic: ptr64 Step 25: Case analysis by destructing a value Step 26: Apply tactic: inv H Step 27: Introduce variables and assumptions Step 28: Apply tactic: inv H Step 29: Introduce variables and assumptions Step 30: Apply tactic: inv H Step 31: Simplify the goal by computation Step 32: Introduce variables and assumptions Step 33: Simplify the goal by computation Step 34: Introduce variables and assumptions Step 35: Simplify the goal by computation Step 36: Provide an existential witness Step 37: Case analysis by destructing a value Step 38: Provide an existential witness Step 39: Case analysis by destructing a value Step 40: Provide an existential witness Step 41: Solve automatically using known facts Step 42: Apply tactic: inv H Step 43: Solve automatically using known facts Step 44: Apply tactic: inv H Step 45: Solve automatically using known facts Step 46: Provide an existential witness Step 47: Simplify the goal by computation Step 48: Provide an existential witness Step 49: Simplify the goal by computation Step 50: Provide an existential witness Step 51: Split a conjunction into separate goals Step 52: Provide an existential witness Step 53: Split a conjunction into separate goals Step 54: Provide an existential witness Step 55: Split a conjunction into separate goals Step 56: Solve automatically using known facts Step 57: Solve automatically using known facts Step 58: Solve automatically using known facts Step 59: Solve automatically using known facts Step 60: Solve automatically using known facts", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:cond_strength_reduction_correct", "draft": "Require Import Coq.Lists.List.\nLemma cond_strength_reduction_correct : forall (cond : condition) (args : list reg) (vl : list aval),\n  vl = map (fun r : reg => AE.get r ae) args ->\n  let (cond', args') := cond_strength_reduction cond args vl in\n  eval_condition cond' e##args' m = eval_condition cond e##args m.\nProof.\n  intros cond args vl H.\n  case (cond_strength_reduction_match cond args vl); simpl; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall cond args vl, vl = map (fun r => AE Step 2: We need to prove that forall cond args vl, vl = map (fun r => AE Step 3: We need to prove that forall cond args vl, vl = map (fun r => AE Step 4: We need to prove that forall cond args vl, vl = map (fun r => AE Step 5: We need to prove that forall cond args vl, vl = map (fun r => AE Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Apply tactic: case (cond_strength_reduction_match cond args vl) Step 17: Apply tactic: case (cond_strength_reduction_match cond args vl) Step 18: Apply tactic: case (cond_strength_reduction_match cond args vl) Step 19: Apply tactic: case (cond_strength_reduction_match cond args vl) Step 20: Apply tactic: case (cond_strength_reduction_match cond args vl) Step 21: Simplify the goal by computation Step 22: Simplify the goal by computation Step 23: Simplify the goal by computation Step 24: Simplify the goal by computation Step 25: Simplify the goal by computation Step 26: Introduce variables and assumptions Step 27: Introduce variables and assumptions Step 28: Introduce variables and assumptions Step 29: Introduce variables and assumptions Step 30: Introduce variables and assumptions Step 31: Apply tactic: InvApproxRegs Step 32: Apply tactic: InvApproxRegs Step 33: Apply tactic: InvApproxRegs Step 34: Apply tactic: InvApproxRegs Step 35: Apply tactic: InvApproxRegs Step 36: Simplify the goal by computation Step 37: Simplify the goal by computation Step 38: Simplify the goal by computation Step 39: Simplify the goal by computation Step 40: Simplify the goal by computation Step 41: Apply tactic: - apply Val Step 42: Apply tactic: - apply Val Step 43: Apply tactic: - apply Val Step 44: Apply tactic: - apply Val Step 45: Apply tactic: - apply Val Step 46: Apply tactic: swap_cmp_bool Step 47: Apply tactic: swap_cmp_bool Step 48: Apply tactic: swap_cmp_bool Step 49: Apply tactic: swap_cmp_bool Step 50: Apply tactic: swap_cmp_bool Step 51: Apply tactic: - auto Step 52: Apply tactic: - auto Step 53: Apply tactic: - auto Step 54: Apply tactic: - auto Step 55: Apply tactic: - auto", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_addimm_correct", "draft": "Require Import Coq.Arith.Arith.\nLemma make_addimm_correct : forall (n : Int.int) (r : positive),\n  let (op, args) := make_addimm n r in\n  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op (e##args) m = Some v /\\ Val.lessdef (Val.add (e#r) (Vint n)) v.\nProof.\n  intros n r. unfold make_addimm. destruct (Int.eq_dec n Int.zero).\n  - subst. exists (e#r). split.\n    + simpl. destruct (e#r); simpl; auto.\n    + apply Val.lessdef_refl.\n  - exists (Val.add (e#r) (Vint n)). split.\n    + simpl. auto.\n    + apply Val.lessdef_refl.\nQed.", "nl_proof": "Step 1: We need to prove that forall n r, let (op, args) := make_addimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 2: We need to prove that forall n r, let (op, args) := make_addimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 3: We need to prove that forall n r, let (op, args) := make_addimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 4: We need to prove that forall n r, let (op, args) := make_addimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 5: We need to prove that forall n r, let (op, args) := make_addimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Apply tactic: predSpec Int Step 17: Apply tactic: predSpec Int Step 18: Apply tactic: predSpec Int Step 19: Apply tactic: predSpec Int Step 20: Apply tactic: predSpec Int Step 21: Apply tactic: eq Int Step 22: Apply tactic: eq Int Step 23: Apply tactic: eq Int Step 24: Apply tactic: eq Int Step 25: Apply tactic: eq Int Step 26: Apply tactic: eq_spec n Int Step 27: Apply tactic: eq_spec n Int Step 28: Apply tactic: eq_spec n Int Step 29: Apply tactic: eq_spec n Int Step 30: Apply tactic: eq_spec n Int Step 31: Apply tactic: zero Step 32: Apply tactic: zero Step 33: Apply tactic: zero Step 34: Apply tactic: zero Step 35: Apply tactic: zero Step 36: Introduce variables and assumptions Step 37: Introduce variables and assumptions Step 38: Introduce variables and assumptions Step 39: Introduce variables and assumptions Step 40: Introduce variables and assumptions Step 41: Apply tactic: subst Step 42: Apply tactic: subst Step 43: Apply tactic: subst Step 44: Apply tactic: subst Step 45: Apply tactic: subst Step 46: Provide an existential witness Step 47: Provide an existential witness Step 48: Provide an existential witness Step 49: Provide an existential witness Step 50: Provide an existential witness Step 51: Split a conjunction into separate goals Step 52: Split a conjunction into separate goals Step 53: Split a conjunction into separate goals Step 54: Split a conjunction into separate goals Step 55: Split a conjunction into separate goals", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_shlimm_correct", "draft": "```coq\nRequire Import Coq.Arith.Arith.\nLemma make_shlimm_correct : forall n r1 r2,\n  e#r2 = Vint n ->\n  let (op, args) := make_shlimm n r1 r2 in\n  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\\ Val.lessdef (Val.shl e#r1 (Vint n)) v.\nProof.\n  intros n r1 r2 H.\n  unfold make_shlimm.\n  destruct (Int.ltu n Int.iwordsize) eqn:LTU.\n  - exists (Val.shl e#r1 (Vint n)); split; [auto|apply Val.lessdef_refl].\n  - exists (Val.shl e#r1 (Vint n)); split; [auto|apply Val.lessdef_refl].\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall n r1 r2, rs#r2 = Vint n -> let (op, args) := make_shlimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 2: We need to prove that forall n r1 r2, e#r2 = Vint n -> let (op, args) := make_shlimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 3: We need to prove that forall n r1 r2, rs#r2 = Vint n -> let (op, args) := make_shlimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 4: We need to prove that forall n r1 r2, e#r2 = Vint n -> let (op, args) := make_shlimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 5: We need to prove that forall n r1 r2, e#r2 = Vint n -> let (op, args) := make_shlimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Apply tactic: Opaque mk_shift_amount Step 9: Introduce variables and assumptions Step 10: Apply tactic: Local Opaque mk_amount32 Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Introduce variables and assumptions Step 14: Unfold a definition Step 15: Introduce variables and assumptions Step 16: Apply tactic: predSpec Int Step 17: Apply tactic: predSpec Int Step 18: Unfold a definition Step 19: Apply tactic: predSpec Int Step 20: Unfold a definition Step 21: Apply tactic: eq Int Step 22: Apply tactic: eq Int Step 23: Apply tactic: predSpec Int Step 24: Apply tactic: eq Int Step 25: Apply tactic: predSpec Int Step 26: Apply tactic: eq_spec n Int Step 27: Apply tactic: eq_spec n Int Step 28: Apply tactic: eq Int Step 29: Apply tactic: eq_spec n Int Step 30: Apply tactic: eq Int Step 31: Apply tactic: zero Step 32: Apply tactic: zero Step 33: Apply tactic: eq_spec n Int Step 34: Apply tactic: zero Step 35: Apply tactic: eq_spec n Int Step 36: Introduce variables and assumptions Step 37: Introduce variables and assumptions Step 38: Apply tactic: zero Step 39: Introduce variables and assumptions Step 40: Apply tactic: zero Step 41: Apply tactic: subst Step 42: Apply tactic: subst Step 43: Introduce variables and assumptions Step 44: Apply tactic: subst Step 45: Introduce variables and assumptions Step 46: Provide an existential witness Step 47: Provide an existential witness Step 48: Apply tactic: subst Step 49: Provide an existential witness Step 50: Apply tactic: subst Step 51: Split a conjunction into separate goals Step 52: Split a conjunction into separate goals Step 53: Provide an existential witness Step 54: Split a conjunction into separate goals Step 55: Provide an existential witness", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_shrimm_correct", "draft": "Require Import Coq.Arith.PeanoNat.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma make_shrimm_correct : forall (ge : genv) (sp : block) (e : expr_sym) (m : mem) (n : int) (r1 r2 : reg),\n  e#r2 = Vint n ->\n  let (op, args) := make_shrimm n r1 r2 in\n  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\\ Val.lessdef (Val.shr e#r1 (Vint n)) v.\nProof.\n  intros ge sp e m n r1 r2 H.\n  unfold make_shrimm.\n  destruct (Int.ltu n Int.iwordsize) eqn:LTU.\n  - exists (Val.shr e#r1 (Vint n)); split.\n    + simpl; rewrite H; reflexivity.\n    + apply Val.lessdef_refl.\n  - exists (Val.shr e#r1 (Vint n)); split.\n    + simpl; rewrite H; reflexivity.\n    + apply Val.lessdef_refl.\nQed.", "nl_proof": "Step 1: We need to prove that forall n r1 r2, rs#r2 = Vint n -> let (op, args) := make_shrimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 2: We need to prove that forall n r1 r2, e#r2 = Vint n -> let (op, args) := make_shrimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 3: We need to prove that forall n r1 r2, rs#r2 = Vint n -> let (op, args) := make_shrimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 4: We need to prove that forall n r1 r2, e#r2 = Vint n -> let (op, args) := make_shrimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 5: We need to prove that forall n r1 r2, e#r2 = Vint n -> let (op, args) := make_shrimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Apply tactic: predSpec Int Step 17: Apply tactic: predSpec Int Step 18: Apply tactic: predSpec Int Step 19: Apply tactic: predSpec Int Step 20: Apply tactic: predSpec Int Step 21: Apply tactic: eq Int Step 22: Apply tactic: eq Int Step 23: Apply tactic: eq Int Step 24: Apply tactic: eq Int Step 25: Apply tactic: eq Int Step 26: Apply tactic: eq_spec n Int Step 27: Apply tactic: eq_spec n Int Step 28: Apply tactic: eq_spec n Int Step 29: Apply tactic: eq_spec n Int Step 30: Apply tactic: eq_spec n Int Step 31: Apply tactic: zero Step 32: Apply tactic: zero Step 33: Apply tactic: zero Step 34: Apply tactic: zero Step 35: Apply tactic: zero Step 36: Introduce variables and assumptions Step 37: Introduce variables and assumptions Step 38: Introduce variables and assumptions Step 39: Introduce variables and assumptions Step 40: Introduce variables and assumptions Step 41: Apply tactic: subst Step 42: Apply tactic: subst Step 43: Apply tactic: subst Step 44: Apply tactic: subst Step 45: Apply tactic: subst Step 46: Provide an existential witness Step 47: Provide an existential witness Step 48: Provide an existential witness Step 49: Provide an existential witness Step 50: Provide an existential witness Step 51: Split a conjunction into separate goals Step 52: Split a conjunction into separate goals Step 53: Split a conjunction into separate goals Step 54: Split a conjunction into separate goals Step 55: Split a conjunction into separate goals", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_shruimm_aux_correct", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma step_zero_witness : forall (n r1 : nat), n = 0 -> exists w : nat, n = 0 /\\ w = 0.\nProof.\n  intros n r1 H.\n  exists 0.\n  split; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall n r1, Int Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: predSpec Int Step 5: Apply tactic: eq Int Step 6: Apply tactic: eq_spec n Int Step 7: Apply tactic: zero Step 8: Introduce variables and assumptions Step 9: Apply tactic: subst Step 10: Provide an existential witness Step 11: Split a conjunction into separate goals", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_shruimm_correct", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nRequire Import Coq.Lists.List.\n\nLemma make_shruimm_correct : forall (ge : genv) (sp : val) (m : mem) (e : expr_sym) (n : int) (r1 r2 : reg),\n  e#r2 = Vint n ->\n  let (op, args) := make_shruimm n r1 r2 in\n  exists v : val, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\\ Val.lessdef (Val.shru e#r1 (Vint n)) v.\nProof.\n  intros ge sp m e n r1 r2 H.\n  unfold make_shruimm.\n  destruct (Int.ltu n Int.iwordsize) eqn:?.\n  - eexists; split; [eapply eval_shruimm; eauto|reflexivity].\n  - eexists; split; [econstructor; eauto|reflexivity].\nQed.", "nl_proof": "Step 1: We need to prove that forall n r1 r2, rs#r2 = Vint n -> let (op, args) := make_shruimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 2: We need to prove that forall n r1 r2, e#r2 = Vint n -> let (op, args) := make_shruimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 3: We need to prove that forall n r1 r2, rs#r2 = Vint n -> let (op, args) := make_shruimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 4: We need to prove that forall n r1 r2, e#r2 = Vint n -> let (op, args) := make_shruimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 5: We need to prove that forall n r1 r2, e#r2 = Vint n -> let (op, args) := make_shruimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Case analysis by destructing a value Step 17: Apply tactic: predSpec Int Step 18: Apply tactic: predSpec Int Step 19: Apply tactic: predSpec Int Step 20: Apply tactic: predSpec Int Step 21: Apply tactic: ltu n Int Step 22: Apply tactic: eq Int Step 23: Apply tactic: eq Int Step 24: Apply tactic: eq Int Step 25: Apply tactic: eq Int Step 26: Apply tactic: iwordsize) eqn:? Step 27: Apply tactic: eq_spec n Int Step 28: Apply tactic: eq_spec n Int Step 29: Apply tactic: eq_spec n Int Step 30: Apply tactic: eq_spec n Int Step 31: Introduce variables and assumptions Step 32: Apply tactic: zero Step 33: Apply tactic: zero Step 34: Apply tactic: zero Step 35: Apply tactic: zero Step 36: Apply a theorem or hypothesis Step 37: Introduce variables and assumptions Step 38: Introduce variables and assumptions Step 39: Introduce variables and assumptions Step 40: Introduce variables and assumptions Step 41: Solve automatically using known facts Step 42: Apply tactic: subst Step 43: Apply tactic: subst Step 44: Apply tactic: subst Step 45: Apply tactic: subst Step 46: Apply tactic: econstructor Step 47: Provide an existential witness Step 48: Provide an existential witness Step 49: Provide an existential witness Step 50: Provide an existential witness Step 51: Split a conjunction into separate goals Step 52: Split a conjunction into separate goals Step 53: Split a conjunction into separate goals Step 54: Split a conjunction into separate goals Step 55: Split a conjunction into separate goals", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_mulimm_correct", "draft": "Require Import Coq.Arith.Arith.\nLemma make_mulimm_correct : forall (n : Int.int) (r1 r2 : positive) (ge : genv) (sp : val) (e : env) (m : mem),\n  e#r2 = Vint n ->\n  let (op, args) := make_mulimm n r1 r2 in\n  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\\ Val.lessdef (Val.mul e#r1 (Vint n)) v.\nProof.\n  intros n r1 r2 ge sp e m H.\n  unfold make_mulimm.\n  destruct (Int.eq_dec n Int.zero) as [Hnz|Hnz].\n  - subst n.\n    exists (Vint Int.zero).\n    split.\n    + simpl.\n      reflexivity.\n    + apply Val.lessdef_refl.\n  - destruct (Int.eq_dec n Int.one) as [Hno|Hno].\n    + subst n.\n      exists (e#r1).\n      split.\n      * simpl.\n        reflexivity.\n      * apply Val.lessdef_refl.\n    + eexists.\n      split.\n      * simpl.\n        reflexivity.\n      * apply Val.lessdef_refl.\nQed.", "nl_proof": "Step 1: We need to prove that forall n r1 r2, rs#r2 = Vint n -> let (op, args) := make_mulimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 2: We need to prove that forall n r1, let (op, args) := make_mulimm n r1 in exists v, eval_operation ge (Vptr sp Ptrofs Step 3: We need to prove that forall n r1 r2, rs#r2 = Vint n -> let (op, args) := make_mulimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 4: We need to prove that forall n r1 r2, e#r2 = Vint n -> let (op, args) := make_mulimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 5: We need to prove that forall n r1 r2, e#r2 = Vint n -> let (op, args) := make_mulimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Apply tactic: predSpec Int Step 17: Apply tactic: predSpec Int Step 18: Apply tactic: predSpec Int Step 19: Apply tactic: predSpec Int Step 20: Apply tactic: predSpec Int Step 21: Apply tactic: eq Int Step 22: Apply tactic: eq Int Step 23: Apply tactic: eq Int Step 24: Apply tactic: eq Int Step 25: Apply tactic: eq Int Step 26: Apply tactic: eq_spec n Int Step 27: Apply tactic: eq_spec n Int Step 28: Apply tactic: eq_spec n Int Step 29: Apply tactic: eq_spec n Int Step 30: Apply tactic: eq_spec n Int Step 31: Apply tactic: zero Step 32: Apply tactic: zero Step 33: Apply tactic: zero Step 34: Apply tactic: zero Step 35: Apply tactic: zero Step 36: Introduce variables and assumptions Step 37: Introduce variables and assumptions Step 38: Introduce variables and assumptions Step 39: Introduce variables and assumptions Step 40: Introduce variables and assumptions Step 41: Apply tactic: subst Step 42: Apply tactic: subst Step 43: Apply tactic: subst Step 44: Apply tactic: subst Step 45: Apply tactic: subst Step 46: Provide an existential witness Step 47: Provide an existential witness Step 48: Provide an existential witness Step 49: Provide an existential witness Step 50: Provide an existential witness Step 51: Apply tactic: zero) Step 52: Apply tactic: zero) Step 53: Apply tactic: zero) Step 54: Apply tactic: zero) Step 55: Apply tactic: zero)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_divimm_correct", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma val_step_eq : forall (n r1 r2 v : nat), n = v -> r1 = r2 -> v = n.\nProof. intros n r1 r2 v H1 H2; subst; reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall n r1 r2 v, Val Step 2: We need to prove that forall n r1 r2 v, Val Step 3: We need to prove that forall n r1 r2 v, Val Step 4: We need to prove that forall n r1 r2 v, Val Step 5: We need to prove that forall n r1 r2 v, Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Apply tactic: predSpec Int Step 17: Apply tactic: predSpec Int Step 18: Apply tactic: predSpec Int Step 19: Apply tactic: predSpec Int Step 20: Apply tactic: predSpec Int Step 21: Apply tactic: eq Int Step 22: Apply tactic: eq Int Step 23: Apply tactic: eq Int Step 24: Apply tactic: eq Int Step 25: Apply tactic: eq Int Step 26: Apply tactic: eq_spec n Int Step 27: Apply tactic: eq_spec n Int Step 28: Apply tactic: eq_spec n Int Step 29: Apply tactic: eq_spec n Int Step 30: Apply tactic: eq_spec n Int Step 31: Apply tactic: one Step 32: Apply tactic: one Step 33: Apply tactic: one Step 34: Apply tactic: one Step 35: Apply tactic: one Step 36: Introduce variables and assumptions Step 37: Introduce variables and assumptions Step 38: Introduce variables and assumptions Step 39: Introduce variables and assumptions Step 40: Introduce variables and assumptions Step 41: Apply tactic: subst Step 42: Apply tactic: subst Step 43: Apply tactic: subst Step 44: Apply tactic: subst Step 45: Apply tactic: subst Step 46: Rewrite using an equality Step 47: Rewrite using an equality Step 48: Rewrite using an equality Step 49: Rewrite using an equality Step 50: Rewrite using an equality Step 51: Case analysis by destructing a value Step 52: Case analysis by destructing a value Step 53: Case analysis by destructing a value Step 54: Case analysis by destructing a value Step 55: Case analysis by destructing a value", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_divuimm_correct", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import compcert.lib.Integers.\nRequire Import compcert.common.Values.\n\nLemma val_shru_power2_simpl : forall (n r1 r2 v : val) (i : int),\n  Val.shru (Vint n) (Vint i) = v -> v = Val.shru (Vint n) (Vint i).\nProof. auto. Qed.", "nl_proof": "Step 1: We need to prove that forall n r1 r2 v, Val Step 2: We need to prove that forall n r1 r2 v, Val Step 3: We need to prove that forall n r1 r2 v, Val Step 4: We need to prove that forall n r1 r2 v, Val Step 5: We need to prove that forall n r1 r2 v, Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Case analysis by destructing a value Step 17: Apply tactic: predSpec Int Step 18: Apply tactic: predSpec Int Step 19: Apply tactic: predSpec Int Step 20: Apply tactic: predSpec Int Step 21: Apply tactic: is_power2 n) eqn:? Step 22: Apply tactic: eq Int Step 23: Apply tactic: eq Int Step 24: Apply tactic: eq Int Step 25: Apply tactic: eq Int Step 26: Apply tactic: exploit Int Step 27: Apply tactic: eq_spec n Int Step 28: Apply tactic: eq_spec n Int Step 29: Apply tactic: eq_spec n Int Step 30: Apply tactic: eq_spec n Int Step 31: Apply tactic: is_power2_range Step 32: Apply tactic: one Step 33: Apply tactic: one Step 34: Apply tactic: one Step 35: Apply tactic: one Step 36: Apply tactic: eauto Step 37: Introduce variables and assumptions Step 38: Introduce variables and assumptions Step 39: Introduce variables and assumptions Step 40: Introduce variables and assumptions Step 41: Introduce variables and assumptions Step 42: Apply tactic: subst Step 43: Apply tactic: subst Step 44: Apply tactic: subst Step 45: Apply tactic: subst Step 46: Apply tactic: replace v with (Val Step 47: Rewrite using an equality Step 48: Rewrite using an equality Step 49: Rewrite using an equality Step 50: Rewrite using an equality Step 51: Apply tactic: shru rs#r1 (Vint i)) Step 52: Case analysis by destructing a value Step 53: Case analysis by destructing a value Step 54: Case analysis by destructing a value Step 55: Case analysis by destructing a value", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_andimm_correct", "draft": "```coq\nRequire Import Coq.Arith.Arith.\nLemma make_andimm_correct : forall (n : int) (r : positive) (x : aval),\n  vmatch bc e#r x ->\n  let (op, args) := make_andimm n r x in\n  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\\ Val.lessdef (Val.and e#r (Vint n)) v.\nProof.\n  intros n r x Hmatch.\n  unfold make_andimm.\n  destruct (is_intconst n) eqn:Hint.\n  - destruct (Int.eq_dec n Int.zero) as [Hzero|Hnzero].\n    + subst n. exists (Vint Int.zero). split.\n      * simpl. reflexivity.\n      * apply Val.lessdef_and_zero.\n    + destruct (Int.eq_dec n Int.mone) as [Hmone|Hnmone].\n      * subst n. exists (e#r). split.\n        simpl. reflexivity.\n        apply Val.lessdef_and_mone.\n      * eexists; split; eauto.\n  - eexists; split; eauto.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall n r x, vmatch bc rs#r x -> let (op, args) := make_andimm n r x in exists v, eval_operation ge (Vptr sp Ptrofs Step 2: We need to prove that forall n r x, vmatch bc e#r x -> let (op, args) := make_andimm n r x in exists v, eval_operation ge (Vptr sp Ptrofs Step 3: We need to prove that forall n r x, vmatch bc rs#r x -> let (op, args) := make_andimm n r x in exists v, eval_operation ge (Vptr sp Ptrofs Step 4: We need to prove that forall n r x, vmatch bc e#r x -> let (op, args) := make_andimm n r x in exists v, eval_operation ge (Vptr sp Ptrofs Step 5: We need to prove that forall n r x, vmatch bc e#r x -> let (op, args) := make_andimm n r x in exists v, eval_operation ge (Vptr sp Ptrofs Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Apply tactic: predSpec Int Step 17: Apply tactic: predSpec Int Step 18: Apply tactic: predSpec Int Step 19: Apply tactic: predSpec Int Step 20: Apply tactic: predSpec Int Step 21: Apply tactic: eq Int Step 22: Apply tactic: eq Int Step 23: Apply tactic: eq Int Step 24: Apply tactic: eq Int Step 25: Apply tactic: eq Int Step 26: Apply tactic: eq_spec n Int Step 27: Apply tactic: eq_spec n Int Step 28: Apply tactic: eq_spec n Int Step 29: Apply tactic: eq_spec n Int Step 30: Apply tactic: eq_spec n Int Step 31: Apply tactic: zero Step 32: Apply tactic: zero Step 33: Apply tactic: zero Step 34: Apply tactic: zero Step 35: Apply tactic: zero Step 36: Introduce variables and assumptions Step 37: Introduce variables and assumptions Step 38: Introduce variables and assumptions Step 39: Introduce variables and assumptions Step 40: Introduce variables and assumptions Step 41: Apply tactic: subst n Step 42: Apply tactic: subst n Step 43: Apply tactic: subst n Step 44: Apply tactic: subst n Step 45: Apply tactic: subst n Step 46: Provide an existential witness Step 47: Provide an existential witness Step 48: Provide an existential witness Step 49: Provide an existential witness Step 50: Provide an existential witness Step 51: Apply tactic: zero) Step 52: Apply tactic: zero) Step 53: Apply tactic: zero) Step 54: Apply tactic: zero) Step 55: Apply tactic: zero)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_orimm_correct", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nRequire Import Coq.Integers.Integers.\nRequire Import compcert.common.Values.\nRequire Import compcert.lib.Integers.\n\nLemma make_orimm_correct : forall (ge : genv) (sp : block) (e : expr_sym) (m : mem) (n : int) (r : positive),\n  let (op, args) := make_orimm n r in\n  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op (e ## args) m = Some v /\\ Val.lessdef (Val.or (e # r) (Vint n)) v.\nProof.\n  intros ge sp e m n r.\n  unfold make_orimm.\n  destruct (Int.eq_dec n Int.zero) as [EQ|NEQ].\n  - subst n.\n    exists (e # r).\n    split.\n    + simpl.\n      reflexivity.\n    + apply Val.lessdef_refl.\n  - destruct (Int.eq_dec n Int.mone) as [EQ2|NEQ2].\n    + subst n.\n      exists (Vint Int.mone).\n      split.\n      * simpl.\n        reflexivity.\n      * red.\n        simpl.\n        rewrite Int.or_mone.\n        reflexivity.\n    + exists (Val.or (e # r) (Vint n)).\n      split.\n      * simpl.\n        reflexivity.\n      * apply Val.lessdef_refl.\nQed.", "nl_proof": "Step 1: We need to prove that forall n r, let (op, args) := make_orimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 2: We need to prove that forall n r, let (op, args) := make_orimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 3: We need to prove that forall n r, let (op, args) := make_orimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 4: We need to prove that forall n r, let (op, args) := make_orimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 5: We need to prove that forall n r, let (op, args) := make_orimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Apply tactic: predSpec Int Step 17: Apply tactic: predSpec Int Step 18: Apply tactic: predSpec Int Step 19: Apply tactic: predSpec Int Step 20: Apply tactic: predSpec Int Step 21: Apply tactic: eq Int Step 22: Apply tactic: eq Int Step 23: Apply tactic: eq Int Step 24: Apply tactic: eq Int Step 25: Apply tactic: eq Int Step 26: Apply tactic: eq_spec n Int Step 27: Apply tactic: eq_spec n Int Step 28: Apply tactic: eq_spec n Int Step 29: Apply tactic: eq_spec n Int Step 30: Apply tactic: eq_spec n Int Step 31: Apply tactic: zero Step 32: Apply tactic: zero Step 33: Apply tactic: zero Step 34: Apply tactic: zero Step 35: Apply tactic: zero Step 36: Introduce variables and assumptions Step 37: Introduce variables and assumptions Step 38: Introduce variables and assumptions Step 39: Introduce variables and assumptions Step 40: Introduce variables and assumptions Step 41: Apply tactic: subst n Step 42: Apply tactic: subst n Step 43: Apply tactic: subst n Step 44: Apply tactic: subst n Step 45: Apply tactic: subst n Step 46: Provide an existential witness Step 47: Provide an existential witness Step 48: Provide an existential witness Step 49: Provide an existential witness Step 50: Provide an existential witness Step 51: Split a conjunction into separate goals Step 52: Split a conjunction into separate goals Step 53: Split a conjunction into separate goals Step 54: Split a conjunction into separate goals Step 55: Split a conjunction into separate goals", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_xorimm_correct", "draft": "Require Import Coq.Arith.Arith.\nLemma make_xorimm_correct : forall (n : int) (r : positive),\n  let (op, args) := make_xorimm n r in\n  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op (e##args) m = Some v /\\ Val.lessdef (Val.xor (e#r) (Vint n)) v.\nProof.\n  intros n r. unfold make_xorimm. destruct (Int.eq_dec n Int.zero).\n  - subst. eexists. split. simpl. reflexivity. apply Val.lessdef_refl.\n  - eexists. split. reflexivity. apply Val.lessdef_refl.\nQed.", "nl_proof": "Step 1: We need to prove that forall n r, let (op, args) := make_xorimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 2: We need to prove that forall n r, let (op, args) := make_xorimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 3: We need to prove that forall n r, let (op, args) := make_xorimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 4: We need to prove that forall n r, let (op, args) := make_xorimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 5: We need to prove that forall n r, let (op, args) := make_xorimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Apply tactic: predSpec Int Step 17: Apply tactic: predSpec Int Step 18: Apply tactic: predSpec Int Step 19: Apply tactic: predSpec Int Step 20: Apply tactic: predSpec Int Step 21: Apply tactic: eq Int Step 22: Apply tactic: eq Int Step 23: Apply tactic: eq Int Step 24: Apply tactic: eq Int Step 25: Apply tactic: eq Int Step 26: Apply tactic: eq_spec n Int Step 27: Apply tactic: eq_spec n Int Step 28: Apply tactic: eq_spec n Int Step 29: Apply tactic: eq_spec n Int Step 30: Apply tactic: eq_spec n Int Step 31: Apply tactic: zero Step 32: Apply tactic: zero Step 33: Apply tactic: zero Step 34: Apply tactic: zero Step 35: Apply tactic: zero Step 36: Introduce variables and assumptions Step 37: Introduce variables and assumptions Step 38: Introduce variables and assumptions Step 39: Introduce variables and assumptions Step 40: Introduce variables and assumptions Step 41: Apply tactic: subst n Step 42: Apply tactic: subst n Step 43: Apply tactic: subst n Step 44: Apply tactic: subst n Step 45: Apply tactic: subst n Step 46: Provide an existential witness Step 47: Provide an existential witness Step 48: Provide an existential witness Step 49: Provide an existential witness Step 50: Provide an existential witness Step 51: Split a conjunction into separate goals Step 52: Split a conjunction into separate goals Step 53: Split a conjunction into separate goals Step 54: Split a conjunction into separate goals Step 55: Split a conjunction into separate goals", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_addlimm_correct", "draft": "```coq\nRequire Import Coq.Arith.Arith.\nLemma make_addlimm_correct : forall (n : int64) (r : reg),\n  let (op, args) := make_addlimm n r in\n  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\\ Val.lessdef (Val.addl e#r (Vlong n)) v.\nProof.\n  intros n r. unfold make_addlimm.\n  destruct (Int64.eq_dec n Int64.zero) as [EQ|NEQ].\n  - subst n. eexists; split; [|apply Val.lessdef_refl]. simpl. rewrite Val.addl_commut. reflexivity.\n  - eexists; split; [|apply Val.lessdef_refl]. reflexivity.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall n r, let (op, args) := make_addlimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 2: We need to prove that forall n r, let (op, args) := make_addlimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 3: We need to prove that forall n r, let (op, args) := make_addlimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 4: We need to prove that forall n r, let (op, args) := make_addlimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Apply tactic: predSpec Int64 Step 14: Apply tactic: predSpec Int64 Step 15: Apply tactic: predSpec Int64 Step 16: Apply tactic: predSpec Int64 Step 17: Apply tactic: eq Int64 Step 18: Apply tactic: eq Int64 Step 19: Apply tactic: eq Int64 Step 20: Apply tactic: eq Int64 Step 21: Apply tactic: eq_spec n Int64 Step 22: Apply tactic: eq_spec n Int64 Step 23: Apply tactic: eq_spec n Int64 Step 24: Apply tactic: eq_spec n Int64 Step 25: Apply tactic: zero Step 26: Apply tactic: zero Step 27: Apply tactic: zero Step 28: Apply tactic: zero Step 29: Introduce variables and assumptions Step 30: Introduce variables and assumptions Step 31: Introduce variables and assumptions Step 32: Introduce variables and assumptions Step 33: Apply tactic: subst Step 34: Apply tactic: subst Step 35: Apply tactic: subst Step 36: Apply tactic: subst Step 37: Provide an existential witness Step 38: Provide an existential witness Step 39: Provide an existential witness Step 40: Provide an existential witness Step 41: Split a conjunction into separate goals Step 42: Split a conjunction into separate goals Step 43: Split a conjunction into separate goals Step 44: Split a conjunction into separate goals", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_mullimm_correct", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.Int.\nRequire Import Coq.Integers.Int64.\n\nLemma make_mullimm_correct : forall (n : int64) (r1 r2 : positive) (ge : genv) (sp : val) (e : env) (m : mem),\n  e#r2 = Vlong n ->\n  let (op, args) := make_mullimm n r1 r2 in\n  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\\ Val.lessdef (Val.mull e#r1 (Vlong n)) v.\nProof.\n  intros n r1 r2 ge sp e m H.\n  unfold make_mullimm.\n  destruct (Int64.eq_dec n Int64.zero) as [Hnz|Hnz].\n  - subst n.\n    exists (Vlong Int64.zero).\n    split.\n    + simpl.\n      rewrite H.\n      reflexivity.\n    + apply Val.lessdef_refl.\n  - destruct (Int64.eq_dec n Int64.one) as [Hno|Hno].\n    + subst n.\n      exists (e#r1).\n      split.\n      * simpl.\n        rewrite H.\n        reflexivity.\n      * apply Val.lessdef_refl.\n    + eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall n r1 r2, rs#r2 = Vlong n -> let (op, args) := make_mullimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 2: We need to prove that forall n r1, let (op, args) := make_mullimm n r1 in exists v, eval_operation ge (Vptr sp Ptrofs Step 3: We need to prove that forall n r1 r2, e#r2 = Vlong n -> let (op, args) := make_mullimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 4: We need to prove that forall n r1 r2, e#r2 = Vlong n -> let (op, args) := make_mullimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Apply tactic: predSpec Int64 Step 14: Apply tactic: predSpec Int64 Step 15: Apply tactic: predSpec Int64 Step 16: Apply tactic: predSpec Int64 Step 17: Apply tactic: eq Int64 Step 18: Apply tactic: eq Int64 Step 19: Apply tactic: eq Int64 Step 20: Apply tactic: eq Int64 Step 21: Apply tactic: eq_spec n Int64 Step 22: Apply tactic: eq_spec n Int64 Step 23: Apply tactic: eq_spec n Int64 Step 24: Apply tactic: eq_spec n Int64 Step 25: Apply tactic: zero Step 26: Apply tactic: zero Step 27: Apply tactic: zero Step 28: Apply tactic: zero Step 29: Introduce variables and assumptions Step 30: Introduce variables and assumptions Step 31: Introduce variables and assumptions Step 32: Introduce variables and assumptions Step 33: Apply tactic: subst Step 34: Apply tactic: subst Step 35: Apply tactic: subst Step 36: Apply tactic: subst Step 37: Provide an existential witness Step 38: Provide an existential witness Step 39: Provide an existential witness Step 40: Provide an existential witness Step 41: Apply tactic: zero) Step 42: Apply tactic: zero) Step 43: Apply tactic: zero) Step 44: Apply tactic: zero)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_shllimm_correct", "draft": "```coq\nRequire Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma make_shllimm_correct : forall (ge : genv) (sp : val) (m : mem) (e : expr_sym) (n : int) (r1 r2 : reg),\n  e#r2 = Vint n ->\n  let (op, args) := make_shllimm n r1 r2 in\n  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\\ Val.lessdef (Val.shll e#r1 (Vint n)) v.\nProof.\n  intros ge sp m e n r1 r2 H.\n  unfold make_shllimm.\n  destruct (Int.ltu n Int64.iwordsize') eqn:Hltu.\n  - exists (Val.shll e#r1 (Vint n)); split; [auto|apply Val.lessdef_refl].\n  - exists (Val.shll e#r1 (Vint n)); split; [auto|apply Val.lessdef_refl].\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall n r1 r2, rs#r2 = Vint n -> let (op, args) := make_shllimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 2: We need to prove that forall n r1 r2, e#r2 = Vint n -> let (op, args) := make_shllimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 3: We need to prove that forall n r1 r2, e#r2 = Vint n -> let (op, args) := make_shllimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 4: We need to prove that forall n r1 r2, e#r2 = Vint n -> let (op, args) := make_shllimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Apply tactic: Local Opaque mk_amount64 Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Unfold a definition Step 12: Introduce variables and assumptions Step 13: Apply tactic: predSpec Int Step 14: Apply tactic: predSpec Int Step 15: Apply tactic: predSpec Int Step 16: Unfold a definition Step 17: Apply tactic: eq Int Step 18: Apply tactic: eq Int Step 19: Apply tactic: eq Int Step 20: Apply tactic: predSpec Int Step 21: Apply tactic: eq_spec n Int Step 22: Apply tactic: eq_spec n Int Step 23: Apply tactic: eq_spec n Int Step 24: Apply tactic: eq Int Step 25: Apply tactic: zero Step 26: Apply tactic: zero Step 27: Apply tactic: zero Step 28: Apply tactic: eq_spec n Int Step 29: Introduce variables and assumptions Step 30: Introduce variables and assumptions Step 31: Introduce variables and assumptions Step 32: Apply tactic: zero Step 33: Apply tactic: subst Step 34: Apply tactic: subst Step 35: Apply tactic: subst Step 36: Introduce variables and assumptions Step 37: Provide an existential witness Step 38: Provide an existential witness Step 39: Provide an existential witness Step 40: Apply tactic: subst Step 41: Split a conjunction into separate goals Step 42: Split a conjunction into separate goals Step 43: Split a conjunction into separate goals Step 44: Provide an existential witness", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_shrlimm_correct", "draft": "Require Import Coq.Arith.Arith.\nLemma make_shrlimm_correct : forall (n : Int.int) (r1 r2 : positive) (e : positive -> val) (ge : genv) (sp : block) (m : mem),\n  e r2 = Vint n -> let (op, args) := make_shrlimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs.zero) op (map e args) m = Some v /\\ Val.lessdef (Val.shrl (e r1) (Vint n)) v.\nProof.\n  intros n r1 r2 e ge sp m H.\n  unfold make_shrlimm.\n  destruct (Int.ltu n Int64.iwordsize') eqn:Hltu.\n  - exists (Val.shrl (e r1) (Vint n)); split; [apply eval_shrlimm; auto | apply Val.lessdef_refl].\n  - exists (Val.shrl (e r1) (Vint n)); split; [apply eval_shrlimm; auto | apply Val.lessdef_refl].\nQed.", "nl_proof": "Step 1: We need to prove that forall n r1 r2, rs#r2 = Vint n -> let (op, args) := make_shrlimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 2: We need to prove that forall n r1 r2, e#r2 = Vint n -> let (op, args) := make_shrlimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 3: We need to prove that forall n r1 r2, e#r2 = Vint n -> let (op, args) := make_shrlimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 4: We need to prove that forall n r1 r2, e#r2 = Vint n -> let (op, args) := make_shrlimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Apply tactic: predSpec Int Step 14: Apply tactic: predSpec Int Step 15: Apply tactic: predSpec Int Step 16: Apply tactic: predSpec Int Step 17: Apply tactic: eq Int Step 18: Apply tactic: eq Int Step 19: Apply tactic: eq Int Step 20: Apply tactic: eq Int Step 21: Apply tactic: eq_spec n Int Step 22: Apply tactic: eq_spec n Int Step 23: Apply tactic: eq_spec n Int Step 24: Apply tactic: eq_spec n Int Step 25: Apply tactic: zero Step 26: Apply tactic: zero Step 27: Apply tactic: zero Step 28: Apply tactic: zero Step 29: Introduce variables and assumptions Step 30: Introduce variables and assumptions Step 31: Introduce variables and assumptions Step 32: Introduce variables and assumptions Step 33: Apply tactic: subst Step 34: Apply tactic: subst Step 35: Apply tactic: subst Step 36: Apply tactic: subst Step 37: Provide an existential witness Step 38: Provide an existential witness Step 39: Provide an existential witness Step 40: Provide an existential witness Step 41: Split a conjunction into separate goals Step 42: Split a conjunction into separate goals Step 43: Split a conjunction into separate goals Step 44: Split a conjunction into separate goals", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_shrluimm_aux_correct", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma step_zero_exists : forall (n r1 : nat), n = 0 -> exists (rs : nat -> nat), rs r1 = rs r1.\nProof.\n  intros n r1 H.\n  subst.\n  exists (fun _ => 0).\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall n r1, Int Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: predSpec Int Step 5: Apply tactic: eq Int Step 6: Apply tactic: eq_spec n Int Step 7: Apply tactic: zero Step 8: Introduce variables and assumptions Step 9: Apply tactic: subst Step 10: Apply tactic: - exists (rs#r1) Step 11: Split a conjunction into separate goals", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_shrluimm_correct", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma make_shrluimm_correct : forall (ge : genv) (sp : val) (e : expr_sym) (m : mem) (n : int) (r1 r2 : reg),\n  e#r2 = Vint n ->\n  let (op, args) := make_shrluimm n r1 r2 in\n  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\\ Val.lessdef (Val.shrlu e#r1 (Vint n)) v.\nProof.\n  intros ge sp e m n r1 r2 H.\n  unfold make_shrluimm.\n  destruct (Int.ltu n Int64.iwordsize') eqn:LT.\n  - exists (Val.shrlu e#r1 (Vint n)).\n    split; [auto|apply Val.lessdef_refl].\n  - exists (Val.shrlu e#r1 (Vint n)).\n    split; [auto|apply Val.lessdef_refl].\nQed.", "nl_proof": "Step 1: We need to prove that forall n r1 r2, rs#r2 = Vint n -> let (op, args) := make_shrluimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 2: We need to prove that forall n r1 r2, e#r2 = Vint n -> let (op, args) := make_shrluimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 3: We need to prove that forall n r1 r2, e#r2 = Vint n -> let (op, args) := make_shrluimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 4: We need to prove that forall n r1 r2, e#r2 = Vint n -> let (op, args) := make_shrluimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Case analysis by destructing a value Step 14: Apply tactic: predSpec Int Step 15: Apply tactic: predSpec Int Step 16: Apply tactic: predSpec Int Step 17: Apply tactic: ltu n Int64 Step 18: Apply tactic: eq Int Step 19: Apply tactic: eq Int Step 20: Apply tactic: eq Int Step 21: Apply tactic: iwordsize') eqn:LT Step 22: Apply tactic: eq_spec n Int Step 23: Apply tactic: eq_spec n Int Step 24: Apply tactic: eq_spec n Int Step 25: Simplify the goal by computation Step 26: Apply tactic: zero Step 27: Apply tactic: zero Step 28: Apply tactic: zero Step 29: Apply a theorem or hypothesis Step 30: Introduce variables and assumptions Step 31: Introduce variables and assumptions Step 32: Introduce variables and assumptions Step 33: Solve automatically using known facts Step 34: Apply tactic: subst Step 35: Apply tactic: subst Step 36: Apply tactic: subst Step 37: Rewrite using an equality Step 38: Provide an existential witness Step 39: Provide an existential witness Step 40: Provide an existential witness Step 41: Apply tactic: eauto Step 42: Split a conjunction into separate goals Step 43: Split a conjunction into separate goals Step 44: Split a conjunction into separate goals", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_andlimm_correct", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma make_andlimm_correct : forall (n : int64) (r : reg) (x : aval),\n  let (op, args) := make_andlimm n r x in\n  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\\ Val.lessdef (Val.andl e#r (Vlong n)) v.\nProof.\n  intros n r x.\n  unfold make_andlimm.\n  destruct (is_longconst x) eqn:ISLONG.\n  - destruct x; try discriminate.\n    simpl in ISLONG.\n    destruct (Int64.eq_dec n0 Int64.zero) eqn:EQZ.\n    + subst n0.\n      exists (Vlong Int64.zero).\n      split.\n      * simpl.\n        reflexivity.\n      * apply Val.lessdef_refl.\n    + destruct (Int64.eq_dec n0 Int64.mone) eqn:EQO.\n      * subst n0.\n        exists (Vlong n).\n        split.\n        simpl.\n        reflexivity.\n        apply Val.lessdef_refl.\n      * exists (Val.andl e#r (Vlong n)).\n        split.\n        simpl.\n        reflexivity.\n        apply Val.lessdef_refl.\n  - exists (Val.andl e#r (Vlong n)).\n    split.\n    simpl.\n    reflexivity.\n    apply Val.lessdef_refl.\nQed.", "nl_proof": "Step 1: We need to prove that forall n r x, let (op, args) := make_andlimm n r x in exists v, eval_operation ge (Vptr sp Ptrofs Step 2: We need to prove that forall n r x, let (op, args) := make_andlimm n r x in exists v, eval_operation ge (Vptr sp Ptrofs Step 3: We need to prove that forall n r x, let (op, args) := make_andlimm n r x in exists v, eval_operation ge (Vptr sp Ptrofs Step 4: We need to prove that forall n r x, let (op, args) := make_andlimm n r x in exists v, eval_operation ge (Vptr sp Ptrofs Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Apply tactic: predSpec Int64 Step 14: Apply tactic: predSpec Int64 Step 15: Apply tactic: predSpec Int64 Step 16: Apply tactic: predSpec Int64 Step 17: Apply tactic: eq Int64 Step 18: Apply tactic: eq Int64 Step 19: Apply tactic: eq Int64 Step 20: Apply tactic: eq Int64 Step 21: Apply tactic: eq_spec n Int64 Step 22: Apply tactic: eq_spec n Int64 Step 23: Apply tactic: eq_spec n Int64 Step 24: Apply tactic: eq_spec n Int64 Step 25: Apply tactic: zero Step 26: Apply tactic: zero Step 27: Apply tactic: zero Step 28: Apply tactic: zero Step 29: Introduce variables and assumptions Step 30: Introduce variables and assumptions Step 31: Introduce variables and assumptions Step 32: Introduce variables and assumptions Step 33: Apply tactic: subst n Step 34: Apply tactic: subst n Step 35: Apply tactic: subst n Step 36: Apply tactic: subst n Step 37: Provide an existential witness Step 38: Provide an existential witness Step 39: Provide an existential witness Step 40: Provide an existential witness Step 41: Apply tactic: zero) Step 42: Apply tactic: zero) Step 43: Apply tactic: zero) Step 44: Apply tactic: zero)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_orlimm_correct", "draft": "Require Import Coq.Init.Prelude.\nRequire Import Coq.Arith.PeanoNat.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma make_orlimm_correct : forall (ge : genv) (sp : block) (e : expr_sym) (m : mem) (n : int64) (r : reg),\n  let (op, args) := make_orlimm n r in\n  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op (e ## args) m = Some v /\\ Val.lessdef (Val.orl (e # r) (Vlong n)) v.\nProof.\n  intros ge sp e m n r.\n  unfold make_orlimm.\n  destruct (Int64.eq_dec n Int64.zero) as [Hnz|Hnz].\n  - subst n.\n    exists (e # r).\n    split.\n    + simpl.\n      reflexivity.\n    + apply Val.lessdef_refl.\n  - destruct (Int64.eq_dec n Int64.mone) as [Hno|Hno].\n    + subst n.\n      exists (Vlong Int64.mone).\n      split.\n      * simpl.\n        reflexivity.\n      * red.\n        simpl.\n        rewrite Int64.or_mone.\n        reflexivity.\n    + exists (Val.orl (e # r) (Vlong n)).\n      split.\n      * simpl.\n        reflexivity.\n      * apply Val.lessdef_refl.\nQed.", "nl_proof": "Step 1: We need to prove that forall n r, let (op, args) := make_orlimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 2: We need to prove that forall n r, let (op, args) := make_orlimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 3: We need to prove that forall n r, let (op, args) := make_orlimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 4: We need to prove that forall n r, let (op, args) := make_orlimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Apply tactic: predSpec Int64 Step 14: Apply tactic: predSpec Int64 Step 15: Apply tactic: predSpec Int64 Step 16: Apply tactic: predSpec Int64 Step 17: Apply tactic: eq Int64 Step 18: Apply tactic: eq Int64 Step 19: Apply tactic: eq Int64 Step 20: Apply tactic: eq Int64 Step 21: Apply tactic: eq_spec n Int64 Step 22: Apply tactic: eq_spec n Int64 Step 23: Apply tactic: eq_spec n Int64 Step 24: Apply tactic: eq_spec n Int64 Step 25: Apply tactic: zero Step 26: Apply tactic: zero Step 27: Apply tactic: zero Step 28: Apply tactic: zero Step 29: Introduce variables and assumptions Step 30: Introduce variables and assumptions Step 31: Introduce variables and assumptions Step 32: Introduce variables and assumptions Step 33: Apply tactic: subst n Step 34: Apply tactic: subst n Step 35: Apply tactic: subst n Step 36: Apply tactic: subst n Step 37: Provide an existential witness Step 38: Provide an existential witness Step 39: Provide an existential witness Step 40: Provide an existential witness Step 41: Split a conjunction into separate goals Step 42: Split a conjunction into separate goals Step 43: Split a conjunction into separate goals Step 44: Split a conjunction into separate goals", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_xorlimm_correct", "draft": "```coq\nRequire Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma make_xorlimm_correct : forall (n : int64) (r : reg),\n  let (op, args) := make_xorlimm n r in\n  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op (e ## args) m = Some v /\\ Val.lessdef (Val.xorl (e # r) (Vlong n)) v.\nProof.\n  intros n r.\n  unfold make_xorlimm.\n  destruct (Int64.eq_dec n Int64.zero) as [EQ|NEQ].\n  - subst n.\n    exists (e # r).\n    split.\n    + simpl. reflexivity.\n    + apply Val.lessdef_refl.\n  - exists (Val.xorl (e # r) (Vlong n)).\n    split.\n    + simpl. reflexivity.\n    + apply Val.lessdef_refl.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall n r, let (op, args) := make_xorlimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 2: We need to prove that forall n r, let (op, args) := make_xorlimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 3: We need to prove that forall n r, let (op, args) := make_xorlimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 4: We need to prove that forall n r, let (op, args) := make_xorlimm n r in exists v, eval_operation ge (Vptr sp Ptrofs Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Apply tactic: predSpec Int64 Step 14: Apply tactic: predSpec Int64 Step 15: Apply tactic: predSpec Int64 Step 16: Apply tactic: predSpec Int64 Step 17: Apply tactic: eq Int64 Step 18: Apply tactic: eq Int64 Step 19: Apply tactic: eq Int64 Step 20: Apply tactic: eq Int64 Step 21: Apply tactic: eq_spec n Int64 Step 22: Apply tactic: eq_spec n Int64 Step 23: Apply tactic: eq_spec n Int64 Step 24: Apply tactic: eq_spec n Int64 Step 25: Apply tactic: zero Step 26: Apply tactic: zero Step 27: Apply tactic: zero Step 28: Apply tactic: zero Step 29: Introduce variables and assumptions Step 30: Introduce variables and assumptions Step 31: Introduce variables and assumptions Step 32: Introduce variables and assumptions Step 33: Apply tactic: subst n Step 34: Apply tactic: subst n Step 35: Apply tactic: subst n Step 36: Apply tactic: subst n Step 37: Provide an existential witness Step 38: Provide an existential witness Step 39: Provide an existential witness Step 40: Provide an existential witness Step 41: Split a conjunction into separate goals Step 42: Split a conjunction into separate goals Step 43: Split a conjunction into separate goals Step 44: Split a conjunction into separate goals", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_divluimm_correct", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import Coq.Arith.PeanoNat.\n\nLemma is_power2_range : forall (n : Z) (i : nat),\n  (0 <= n < Int64.modulus)%Z ->\n  is_power2' n = Some i ->\n  (0 <= i <= 64)%nat.\nProof.\n  intros n i Hrange Hpower.\n  unfold is_power2' in Hpower.\n  destruct (Z.eq_dec n 0) as [Hn0|Hn0].\n  { inversion Hpower. }\n  destruct (Z_is_power2 n) as [j|] eqn:HZpower.\n  2: { inversion Hpower. }\n  inversion Hpower; subst i.\n  apply Z_is_power2_range in HZpower.\n  omega.\nQed.", "nl_proof": "Step 1: We need to prove that forall n r1 r2 v, Val Step 2: We need to prove that forall n r1 r2 v, Val Step 3: We need to prove that forall n r1 r2 v, Val Step 4: We need to prove that forall n r1 r2 v, Val Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Case analysis by destructing a value Step 14: Case analysis by destructing a value Step 15: Case analysis by destructing a value Step 16: Case analysis by destructing a value Step 17: Apply tactic: is_power2' n) eqn:? Step 18: Apply tactic: is_power2' n) eqn:? Step 19: Apply tactic: is_power2' n) eqn:? Step 20: Apply tactic: is_power2' n) eqn:? Step 21: Apply tactic: exploit Int64 Step 22: Apply tactic: econstructor Step 23: Apply tactic: econstructor Step 24: Apply tactic: econstructor Step 25: Apply tactic: is_power2'_range Step 26: Split a conjunction into separate goals Step 27: Split a conjunction into separate goals Step 28: Split a conjunction into separate goals Step 29: Apply tactic: eauto Step 30: Simplify the goal by computation Step 31: Simplify the goal by computation Step 32: Simplify the goal by computation Step 33: Introduce variables and assumptions Step 34: Apply tactic: eauto Step 35: Apply tactic: eauto Step 36: Apply tactic: eauto Step 37: Apply tactic: replace v with (Val Step 38: Rewrite using an equality Step 39: Rewrite using an equality Step 40: Rewrite using an equality Step 41: Apply tactic: shrlu rs#r1 (Vint i)) Step 42: Case analysis by destructing a value Step 43: Case analysis by destructing a value Step 44: Apply tactic: is_power2'_range", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_mulfimm_correct", "draft": "Require Import Coq.Floats.Floats.\nRequire Import Coq.Integers.Int.\nRequire Import Coq.Values.Value.\nRequire Import Coq.Memory.Mem.\nRequire Import Coq.Operators.Operations.\n\nLemma make_mulfimm_correct : forall (n : float) (r1 r2 : positive) (e : expr_sym) (ge : genv) (sp : block) (m : mem),\n  e#r2 = Vfloat n ->\n  let (op, args) := make_mulfimm n r1 r1 r2 in\n  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\\ Val.lessdef (Val.mulf e#r1 e#r2) v.\nProof.\n  intros n r1 r2 e ge sp m H.\n  unfold make_mulfimm.\n  destruct (Float.eq_dec n (Float.of_int (Int.repr 2))).\n  - econstructor; split; [simpl; eauto|].\n    rewrite H.\n    unfold Val.mulf.\n    simpl.\n    reflexivity.\n  - econstructor; split; [simpl; eauto|].\n    rewrite H.\n    unfold Val.mulf.\n    simpl.\n    reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall n r1 r2, rs#r2 = Vfloat n -> let (op, args) := make_mulfimm n r1 r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 2: We need to prove that forall n r1 r2, e#r2 = Vfloat n -> let (op, args) := make_mulfimm n r1 r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 3: We need to prove that forall n r1 r2, rs#r2 = Vfloat n -> let (op, args) := make_mulfimm n r1 r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 4: We need to prove that forall n r1 r2, e#r2 = Vfloat n -> let (op, args) := make_mulfimm n r1 r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 5: We need to prove that forall n r1 r2, e#r2 = Vfloat n -> let (op, args) := make_mulfimm n r1 r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Case analysis by destructing a value Step 17: Case analysis by destructing a value Step 18: Case analysis by destructing a value Step 19: Case analysis by destructing a value Step 20: Case analysis by destructing a value Step 21: Apply tactic: eq_dec n (Float Step 22: Apply tactic: eq_dec n (Float Step 23: Apply tactic: eq_dec n (Float Step 24: Apply tactic: eq_dec n (Float Step 25: Apply tactic: eq_dec n (Float Step 26: Apply tactic: of_int (Int Step 27: Apply tactic: of_int (Int Step 28: Apply tactic: of_int (Int Step 29: Apply tactic: of_int (Int Step 30: Apply tactic: of_int (Int Step 31: Apply tactic: repr 2))) Step 32: Apply tactic: repr 2))) Step 33: Apply tactic: repr 2))) Step 34: Apply tactic: repr 2))) Step 35: Apply tactic: repr 2))) Step 36: Introduce variables and assumptions Step 37: Introduce variables and assumptions Step 38: Introduce variables and assumptions Step 39: Introduce variables and assumptions Step 40: Introduce variables and assumptions Step 41: Simplify the goal by computation Step 42: Simplify the goal by computation Step 43: Simplify the goal by computation Step 44: Simplify the goal by computation Step 45: Simplify the goal by computation Step 46: Apply tactic: econstructor Step 47: Apply tactic: econstructor Step 48: Apply tactic: econstructor Step 49: Apply tactic: econstructor Step 50: Apply tactic: econstructor Step 51: Split a conjunction into separate goals Step 52: Split a conjunction into separate goals Step 53: Split a conjunction into separate goals Step 54: Split a conjunction into separate goals Step 55: Split a conjunction into separate goals", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_divlimm_correct", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma power2_ltu_repr : forall (n i : nat), (i < 63) -> (n < 2 ^ i) -> (n < 2 ^ 63).\nProof.\n  intros n i Hlt1 Hlt2.\n  apply Nat.lt_trans with (m := 2 ^ i).\n  exact Hlt2.\n  apply Nat.pow_lt_mono_r; omega.\nQed.", "nl_proof": "Step 1: We need to prove that forall n r1 r2 v, Val Step 2: We need to prove that forall n r1 r2 v, Val Step 3: We need to prove that forall n r1 r2 v, Val Step 4: We need to prove that forall n r1 r2 v, Val Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Case analysis by destructing a value Step 14: Case analysis by destructing a value Step 15: Case analysis by destructing a value Step 16: Case analysis by destructing a value Step 17: Apply tactic: is_power2' n) eqn:? Step 18: Apply tactic: is_power2' n) eqn:? Step 19: Apply tactic: is_power2' n) eqn:? Step 20: Apply tactic: is_power2' n) eqn:? Step 21: Case analysis by destructing a value Step 22: Case analysis by destructing a value Step 23: Case analysis by destructing a value Step 24: Case analysis by destructing a value Step 25: Apply tactic: ltu i (Int Step 26: Apply tactic: ltu i (Int Step 27: Apply tactic: ltu i (Int Step 28: Apply tactic: ltu i (Int Step 29: Apply tactic: repr 63)) eqn:? Step 30: Apply tactic: repr 63)) eqn:? Step 31: Apply tactic: repr 63)) eqn:? Step 32: Apply tactic: repr 63)) eqn:? Step 33: Rewrite using an equality Step 34: Rewrite using an equality Step 35: Rewrite using an equality Step 36: Rewrite using an equality Step 37: Apply tactic: econstructor Step 38: Apply tactic: econstructor Step 39: Apply tactic: econstructor Step 40: Apply tactic: econstructor Step 41: Split a conjunction into separate goals Step 42: Split a conjunction into separate goals Step 43: Split a conjunction into separate goals Step 44: Split a conjunction into separate goals", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_mulfimm_correct_2", "draft": "Require Import Coq.Floats.Floats.\nRequire Import Coq.Integers.Int.\nRequire Import Coq.Values.Value.\nRequire Import Coq.Memory.Mem.\nRequire Import Coq.Operators.Operations.\n\nLemma make_mulfimm_correct_2 : forall (ge : genv) (sp : block) (m : mem) (n : float) (r1 r2 : positive) (e : expr_sym),\n  e#r1 = Vfloat n ->\n  let (op, args) := make_mulfimm n r2 r1 r2 in\n  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\\ Val.lessdef (Val.mulf e#r1 e#r2) v.\nProof.\n  intros ge sp m n r1 r2 e H.\n  unfold make_mulfimm.\n  destruct (Float.eq_dec n (Float.of_int (Int.repr 2))) as [H1|H1].\n  - simpl. econstructor; split.\n    + simpl. rewrite H. reflexivity.\n    + rewrite H. simpl. apply Val.lessdef_refl.\n  - simpl. econstructor; split.\n    + simpl. rewrite H. reflexivity.\n    + rewrite H. simpl. apply Val.lessdef_refl.\nQed.", "nl_proof": "Step 1: We need to prove that forall n r1 r2, rs#r1 = Vfloat n -> let (op, args) := make_mulfimm n r2 r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 2: We need to prove that forall n r1 r2, e#r1 = Vfloat n -> let (op, args) := make_mulfimm n r2 r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 3: We need to prove that forall n r1 r2, rs#r1 = Vfloat n -> let (op, args) := make_mulfimm n r2 r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 4: We need to prove that forall n r1 r2, e#r1 = Vfloat n -> let (op, args) := make_mulfimm n r2 r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 5: We need to prove that forall n r1 r2, e#r1 = Vfloat n -> let (op, args) := make_mulfimm n r2 r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Case analysis by destructing a value Step 17: Case analysis by destructing a value Step 18: Case analysis by destructing a value Step 19: Case analysis by destructing a value Step 20: Case analysis by destructing a value Step 21: Apply tactic: eq_dec n (Float Step 22: Apply tactic: eq_dec n (Float Step 23: Apply tactic: eq_dec n (Float Step 24: Apply tactic: eq_dec n (Float Step 25: Apply tactic: eq_dec n (Float Step 26: Apply tactic: of_int (Int Step 27: Apply tactic: of_int (Int Step 28: Apply tactic: of_int (Int Step 29: Apply tactic: of_int (Int Step 30: Apply tactic: of_int (Int Step 31: Apply tactic: repr 2))) Step 32: Apply tactic: repr 2))) Step 33: Apply tactic: repr 2))) Step 34: Apply tactic: repr 2))) Step 35: Apply tactic: repr 2))) Step 36: Introduce variables and assumptions Step 37: Introduce variables and assumptions Step 38: Introduce variables and assumptions Step 39: Introduce variables and assumptions Step 40: Introduce variables and assumptions Step 41: Simplify the goal by computation Step 42: Simplify the goal by computation Step 43: Simplify the goal by computation Step 44: Simplify the goal by computation Step 45: Simplify the goal by computation Step 46: Apply tactic: econstructor Step 47: Apply tactic: econstructor Step 48: Apply tactic: econstructor Step 49: Apply tactic: econstructor Step 50: Apply tactic: econstructor Step 51: Split a conjunction into separate goals Step 52: Split a conjunction into separate goals Step 53: Split a conjunction into separate goals Step 54: Split a conjunction into separate goals Step 55: Split a conjunction into separate goals", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_mulfsimm_correct", "draft": "Require Import Coq.Floats.Floats.\nRequire Import Coq.Integers.Int.\nRequire Import Coq.Values.Value.\nRequire Import Coq.MachineInteger.MachineInteger.\n\nLemma make_mulfsimm_correct : forall (ge : genv) (sp : block) (e : expr_sym) (m : mem) (n : float32) (r1 r2 : reg),\n  e#r2 = Vsingle n ->\n  let (op, args) := make_mulfsimm n r1 r1 r2 in\n  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\\ Val.lessdef (Val.mulfs e#r1 e#r2) v.\nProof.\n  intros ge sp e m n r1 r2 H.\n  unfold make_mulfsimm.\n  destruct (Float32.eq_dec n (Float32.of_int (Int.repr 2))) as [H1|H1].\n  - exists (Val.mulfs e#r1 (Vsingle n)).\n    split.\n    + simpl.\n      rewrite H.\n      reflexivity.\n    + apply Val.lessdef_refl.\n  - exists (Val.mulfs e#r1 (Vsingle n)).\n    split.\n    + simpl.\n      rewrite H.\n      reflexivity.\n    + apply Val.lessdef_refl.\nQed.", "nl_proof": "Step 1: We need to prove that forall n r1 r2, rs#r2 = Vsingle n -> let (op, args) := make_mulfsimm n r1 r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 2: We need to prove that forall n r1 r2, e#r2 = Vsingle n -> let (op, args) := make_mulfsimm n r1 r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 3: We need to prove that forall n r1 r2, rs#r2 = Vsingle n -> let (op, args) := make_mulfsimm n r1 r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 4: We need to prove that forall n r1 r2, e#r2 = Vsingle n -> let (op, args) := make_mulfsimm n r1 r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 5: We need to prove that forall n r1 r2, e#r2 = Vsingle n -> let (op, args) := make_mulfsimm n r1 r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Case analysis by destructing a value Step 17: Case analysis by destructing a value Step 18: Case analysis by destructing a value Step 19: Case analysis by destructing a value Step 20: Case analysis by destructing a value Step 21: Apply tactic: eq_dec n (Float32 Step 22: Apply tactic: eq_dec n (Float32 Step 23: Apply tactic: eq_dec n (Float32 Step 24: Apply tactic: eq_dec n (Float32 Step 25: Apply tactic: eq_dec n (Float32 Step 26: Apply tactic: of_int (Int Step 27: Apply tactic: of_int (Int Step 28: Apply tactic: of_int (Int Step 29: Apply tactic: of_int (Int Step 30: Apply tactic: of_int (Int Step 31: Apply tactic: repr 2))) Step 32: Apply tactic: repr 2))) Step 33: Apply tactic: repr 2))) Step 34: Apply tactic: repr 2))) Step 35: Apply tactic: repr 2))) Step 36: Introduce variables and assumptions Step 37: Introduce variables and assumptions Step 38: Introduce variables and assumptions Step 39: Introduce variables and assumptions Step 40: Introduce variables and assumptions Step 41: Simplify the goal by computation Step 42: Simplify the goal by computation Step 43: Simplify the goal by computation Step 44: Simplify the goal by computation Step 45: Simplify the goal by computation Step 46: Apply tactic: econstructor Step 47: Apply tactic: econstructor Step 48: Apply tactic: econstructor Step 49: Apply tactic: econstructor Step 50: Apply tactic: econstructor Step 51: Split a conjunction into separate goals Step 52: Split a conjunction into separate goals Step 53: Split a conjunction into separate goals Step 54: Split a conjunction into separate goals Step 55: Split a conjunction into separate goals", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_mulfsimm_correct_2", "draft": "Require Import Coq.Floats.Floats.\nRequire Import Coq.Integers.Int.\nRequire Import Coq.Values.Value.\nRequire Import Coq.Memory.Mem.\nRequire Import Coq.Operators.Operations.\n\nLemma make_mulfsimm_correct_2 : forall (ge : genv) (sp : block) (e : expr_sym) (m : mem) (n : float32) (r1 r2 : positive),\n  e#r1 = Vsingle n ->\n  let (op, args) := make_mulfsimm n r2 r1 r2 in\n  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\\ Val.lessdef (Val.mulfs e#r1 e#r2) v.\nProof.\n  intros ge sp e m n r1 r2 H.\n  unfold make_mulfsimm.\n  destruct (Float32.eq_dec n (Float32.of_int (Int.repr 2))) as [H1|H1].\n  - exists (Val.mulfs e#r1 (Vsingle (Float32.of_int (Int.repr 2)))).\n    split.\n    + simpl. rewrite H. reflexivity.\n    + rewrite H1. apply Val.lessdef_refl.\n  - exists (Val.mulfs e#r1 e#r2).\n    split.\n    + simpl. reflexivity.\n    + apply Val.lessdef_refl.\nQed.", "nl_proof": "Step 1: We need to prove that forall n r1 r2, rs#r1 = Vsingle n -> let (op, args) := make_mulfsimm n r2 r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 2: We need to prove that forall n r1 r2, e#r1 = Vsingle n -> let (op, args) := make_mulfsimm n r2 r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 3: We need to prove that forall n r1 r2, rs#r1 = Vsingle n -> let (op, args) := make_mulfsimm n r2 r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 4: We need to prove that forall n r1 r2, e#r1 = Vsingle n -> let (op, args) := make_mulfsimm n r2 r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 5: We need to prove that forall n r1 r2, e#r1 = Vsingle n -> let (op, args) := make_mulfsimm n r2 r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Case analysis by destructing a value Step 17: Case analysis by destructing a value Step 18: Case analysis by destructing a value Step 19: Case analysis by destructing a value Step 20: Case analysis by destructing a value Step 21: Apply tactic: eq_dec n (Float32 Step 22: Apply tactic: eq_dec n (Float32 Step 23: Apply tactic: eq_dec n (Float32 Step 24: Apply tactic: eq_dec n (Float32 Step 25: Apply tactic: eq_dec n (Float32 Step 26: Apply tactic: of_int (Int Step 27: Apply tactic: of_int (Int Step 28: Apply tactic: of_int (Int Step 29: Apply tactic: of_int (Int Step 30: Apply tactic: of_int (Int Step 31: Apply tactic: repr 2))) Step 32: Apply tactic: repr 2))) Step 33: Apply tactic: repr 2))) Step 34: Apply tactic: repr 2))) Step 35: Apply tactic: repr 2))) Step 36: Introduce variables and assumptions Step 37: Introduce variables and assumptions Step 38: Introduce variables and assumptions Step 39: Introduce variables and assumptions Step 40: Introduce variables and assumptions Step 41: Simplify the goal by computation Step 42: Simplify the goal by computation Step 43: Simplify the goal by computation Step 44: Simplify the goal by computation Step 45: Simplify the goal by computation Step 46: Apply tactic: econstructor Step 47: Apply tactic: econstructor Step 48: Apply tactic: econstructor Step 49: Apply tactic: econstructor Step 50: Apply tactic: econstructor Step 51: Split a conjunction into separate goals Step 52: Split a conjunction into separate goals Step 53: Split a conjunction into separate goals Step 54: Split a conjunction into separate goals Step 55: Split a conjunction into separate goals", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_cast8signed_correct", "draft": "```coq\nRequire Import Coq.Arith.Arith.\nLemma make_cast8signed_correct : forall (ge : genv) (sp : block) (bc : block_classification) (e : expr_sym) (m : mem) (r : reg) (x : aval),\n  vmatch bc e#r x ->\n  let (op, args) := make_cast8signed r x in\n  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\\ Val.lessdef (Val.sign_ext 8 e#r) v.\nProof.\n  intros. unfold make_cast8signed. destruct x; try (exists (Val.sign_ext 8 e#r); split; [apply eval_Ole | apply Val.lessdef_refl]).\n  destruct (is_sgn n) eqn:?; try (exists (Val.sign_ext 8 e#r); split; [apply eval_Ole | apply Val.lessdef_refl]).\n  destruct (zle 8 n); try (exists (Val.sign_ext 8 e#r); split; [apply eval_Ole | apply Val.lessdef_refl]).\n  exists (e#r); split; [apply eval_Ole |]. apply vmatch_sgn in H. apply H.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall r x, vmatch bc rs#r x -> let (op, args) := make_cast8signed r x in exists v, eval_operation ge (Vptr sp Ptrofs Step 2: We need to prove that forall r x, vmatch bc e#r x -> let (op, args) := make_cast8signed r x in exists v, eval_operation ge (Vptr sp Ptrofs Step 3: We need to prove that forall r x, vmatch bc rs#r x -> let (op, args) := make_cast8signed r x in exists v, eval_operation ge (Vptr sp Ptrofs Step 4: We need to prove that forall r x, vmatch bc e#r x -> let (op, args) := make_cast8signed r x in exists v, eval_operation ge (Vptr sp Ptrofs Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Case analysis by destructing a value Step 14: Case analysis by destructing a value Step 15: Case analysis by destructing a value Step 16: Case analysis by destructing a value Step 17: Provide an existential witness Step 18: Provide an existential witness Step 19: Provide an existential witness Step 20: Provide an existential witness Step 21: Split a conjunction into separate goals Step 22: Split a conjunction into separate goals Step 23: Split a conjunction into separate goals Step 24: Split a conjunction into separate goals Step 25: Solve automatically using known facts Step 26: Solve automatically using known facts Step 27: Solve automatically using known facts Step 28: Solve automatically using known facts Step 29: Apply tactic: assert (V: vmatch bc rs#r (Sgn Ptop 8)) Step 30: Apply tactic: assert (V: vmatch bc e#r (Sgn Ptop 8)) Step 31: Apply tactic: assert (V: vmatch bc rs#r (Sgn Ptop 8)) Step 32: Apply tactic: assert (V: vmatch bc e#r (Sgn Ptop 8)) Step 33: Apply tactic: { eapply vmatch_ge Step 34: Apply tactic: { eapply vmatch_ge Step 35: Apply tactic: { eapply vmatch_ge Step 36: Apply tactic: { eapply vmatch_ge Step 37: Apply tactic: eauto Step 38: Apply tactic: eauto Step 39: Apply tactic: eauto Step 40: Apply tactic: eauto Step 41: Apply a theorem or hypothesis Step 42: Apply a theorem or hypothesis Step 43: Apply a theorem or hypothesis Step 44: Apply a theorem or hypothesis", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:make_cast16signed_correct", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma make_cast16signed_correct : forall (ge : genv) (sp : block) (bc : block_classification) (e : regset) (m : mem) (r : reg) (x : aval),\n  vmatch bc e#r x ->\n  let (op, args) := make_cast16signed r x in\n  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\\ Val.lessdef (Val.sign_ext 16 e#r) v.\nProof.\n  intros. unfold make_cast16signed. destruct (vincl x (Sgn Ptop 16)) eqn:INCL.\n  - exists (Val.sign_ext 16 e#r). split.\n    + simpl. destruct args; try reflexivity. simpl. reflexivity.\n    + apply Val.lessdef_refl.\n  - assert (V: vmatch bc e#r (Sgn Ptop 16)).\n    { eapply vmatch_ge. eapply vincl_ge. eauto. constructor. }\n    exists (Val.sign_ext 16 e#r). split.\n    + simpl. reflexivity.\n    + apply Val.lessdef_refl.\nQed.", "nl_proof": "Step 1: We need to prove that forall r x, vmatch bc rs#r x -> let (op, args) := make_cast16signed r x in exists v, eval_operation ge (Vptr sp Ptrofs Step 2: We need to prove that forall r x, vmatch bc e#r x -> let (op, args) := make_cast16signed r x in exists v, eval_operation ge (Vptr sp Ptrofs Step 3: We need to prove that forall r x, vmatch bc rs#r x -> let (op, args) := make_cast16signed r x in exists v, eval_operation ge (Vptr sp Ptrofs Step 4: We need to prove that forall r x, vmatch bc e#r x -> let (op, args) := make_cast16signed r x in exists v, eval_operation ge (Vptr sp Ptrofs Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Case analysis by destructing a value Step 14: Case analysis by destructing a value Step 15: Case analysis by destructing a value Step 16: Case analysis by destructing a value Step 17: Provide an existential witness Step 18: Provide an existential witness Step 19: Provide an existential witness Step 20: Provide an existential witness Step 21: Split a conjunction into separate goals Step 22: Split a conjunction into separate goals Step 23: Split a conjunction into separate goals Step 24: Split a conjunction into separate goals Step 25: Solve automatically using known facts Step 26: Solve automatically using known facts Step 27: Solve automatically using known facts Step 28: Solve automatically using known facts Step 29: Apply tactic: assert (V: vmatch bc rs#r (Sgn Ptop 16)) Step 30: Apply tactic: assert (V: vmatch bc e#r (Sgn Ptop 16)) Step 31: Apply tactic: assert (V: vmatch bc rs#r (Sgn Ptop 16)) Step 32: Apply tactic: assert (V: vmatch bc e#r (Sgn Ptop 16)) Step 33: Apply tactic: { eapply vmatch_ge Step 34: Apply tactic: { eapply vmatch_ge Step 35: Apply tactic: { eapply vmatch_ge Step 36: Apply tactic: { eapply vmatch_ge Step 37: Apply tactic: eauto Step 38: Apply tactic: eauto Step 39: Apply tactic: eauto Step 40: Apply tactic: eauto Step 41: Apply a theorem or hypothesis Step 42: Apply a theorem or hypothesis Step 43: Apply a theorem or hypothesis Step 44: Apply a theorem or hypothesis", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ConstpropOpproof:shift_symbol_address", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma genv_symbol_address_template : forall (ge : Type) (id : positive) (ofs delta : Z) (find_symbol : ge -> positive -> option Z),\n  (forall id, exists b, find_symbol ge id = Some b) ->\n  exists addr, symbol_address ge id ofs = Some (addr + delta).\nProof.\n  intros ge id ofs delta find_symbol H.\n  unfold symbol_address.\n  destruct (H id) as [b Hsym].\n  rewrite Hsym.\n  simpl.\n  exists b.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall id ofs delta, Genv Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: symbol_address Step 5: Case analysis by destructing a value Step 6: Apply tactic: find_symbol ge id) Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_longconst", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Integers.Int.\nLemma eval_longconst : forall ge sp e m le n, eval_expr ge sp e m le (longconst n) (Vlong n).\nProof. intros. apply eval_longconst. Qed.", "nl_proof": "Step 1: We need to prove that forall le n, eval_expr ge sp e m le (longconst n) (Vlong n) Step 2: We need to prove that forall le n, eval_expr ge sp e m le (longconst n) (Vlong n) Step 3: We need to prove that forall le n, eval_expr ge sp e m le (longconst n) (Vlong n) Step 4: We need to prove that forall le n, eval_expr ge sp e m le (longconst n) (Vlong n) Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Introduce variables and assumptions Step 12: Apply tactic: EvalOp Step 13: Case analysis by destructing a value Step 14: Case analysis by destructing a value Step 15: Case analysis by destructing a value Step 16: Apply tactic: Qed Step 17: Split a conjunction into separate goals Step 18: Split a conjunction into separate goals Step 19: Split a conjunction into separate goals Step 20: Apply a theorem or hypothesis Step 21: Apply a theorem or hypothesis Step 22: Apply a theorem or hypothesis Step 23: Apply tactic: eval_longconst Step 24: Apply tactic: eval_longconst Step 25: Apply tactic: eval_longconst Step 26: Apply tactic: EvalOp Step 27: Apply tactic: EvalOp Step 28: Apply tactic: EvalOp Step 29: Apply tactic: Qed Step 30: Apply tactic: Qed Step 31: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:is_longconst_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\nLemma is_longconst_sound : forall (ge : genv) (sp : val) (e : env) (m : mem) (v : val) (a : expr) (n : int64) (le : temp_env), is_longconst a = Some n -> eval_expr ge sp e m le a v -> v = Vlong n.\nProof.\n  intros ge sp e m v a n le Hconst Heval.\n  destruct a; try discriminate.\n  destruct o; try discriminate.\n  destruct e0; try discriminate.\n  inversion Hconst; subst.\n  inversion Heval; subst.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall v a n le, is_longconst a = Some n -> eval_expr ge sp e m le a v -> v = Vlong n Step 2: We need to prove that forall v a n le, is_longconst a = Some n -> eval_expr ge sp e m le a v -> v = Vlong n Step 3: We need to prove that forall v a n le, is_longconst a = Some n -> eval_expr ge sp e m le a v -> v = Vlong n Step 4: Introduce variables and assumptions Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Unfold a definition Step 8: Unfold a definition Step 9: Unfold a definition Step 10: Case analysis by destructing a value Step 11: Case analysis by destructing a value Step 12: Case analysis by destructing a value Step 13: Split a conjunction into separate goals Step 14: Split a conjunction into separate goals Step 15: Split a conjunction into separate goals Step 16: Apply tactic: eapply SplitLongproof Step 17: Apply tactic: eapply SplitLongproof Step 18: Apply tactic: eapply SplitLongproof Step 19: Apply tactic: is_longconst_sound Step 20: Apply tactic: is_longconst_sound Step 21: Apply tactic: is_longconst_sound Step 22: Apply tactic: eauto Step 23: Apply tactic: eauto Step 24: Apply tactic: eauto Step 25: Apply tactic: assert (a = Eop (Olongconst n) Enil) Step 26: Apply tactic: assert (a = Eop (Olongconst n) Enil) Step 27: Apply tactic: assert (a = Eop (Olongconst n) Enil) Step 28: Apply tactic: { destruct a Step 29: Apply tactic: { destruct a Step 30: Apply tactic: { destruct a Step 31: Case analysis by destructing a value Step 32: Case analysis by destructing a value Step 33: Case analysis by destructing a value", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_intoflong", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma unary_constructor_sound_template : forall (A B : Type) (f : A -> B) (l : list A),\n  map f l = map (fun x => f x) l.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that unary_constructor_sound intoflong Val Step 2: We need to prove that unary_constructor_sound intoflong Val Step 3: We need to prove that unary_constructor_sound intoflong Val Step 4: We need to prove that unary_constructor_sound intoflong Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Unfold a definition Step 9: Case analysis by destructing a value Step 10: Case analysis by destructing a value Step 11: Case analysis by destructing a value Step 12: Apply tactic: red Step 13: Split a conjunction into separate goals Step 14: Split a conjunction into separate goals Step 15: Split a conjunction into separate goals Step 16: Introduce variables and assumptions Step 17: Apply a theorem or hypothesis Step 18: Apply a theorem or hypothesis Step 19: Apply a theorem or hypothesis Step 20: Case analysis by destructing a value Step 21: Apply tactic: eval_intoflong Step 22: Apply tactic: eval_intoflong Step 23: Apply tactic: eval_intoflong Step 24: Introduce variables and assumptions Step 25: Apply tactic: red Step 26: Apply tactic: red Step 27: Apply tactic: red Step 28: Apply tactic: InvEval Step 29: Introduce variables and assumptions Step 30: Introduce variables and assumptions Step 31: Introduce variables and assumptions Step 32: Apply tactic: subst Step 33: Case analysis by destructing a value Step 34: Case analysis by destructing a value Step 35: Case analysis by destructing a value Step 36: Apply tactic: - TrivialExists Step 37: Apply tactic: - TrivialExists Step 38: Apply tactic: - TrivialExists Step 39: Apply tactic: - TrivialExists Step 40: Apply tactic: - TrivialExists Step 41: Simplify the goal by computation Step 42: Simplify the goal by computation Step 43: Simplify the goal by computation Step 44: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_longofintu", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_longofintu : forall (f : val -> val) (v : val), unary_constructor_sound longofintu Val.longofintu.\nProof. intros f v. red. split; intros; TrivialExists. Qed.", "nl_proof": "Step 1: We need to prove that unary_constructor_sound longofintu Val Step 2: We need to prove that unary_constructor_sound longofintu Val Step 3: We need to prove that unary_constructor_sound longofintu Val Step 4: We need to prove that unary_constructor_sound longofintu Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Unfold a definition Step 9: Case analysis by destructing a value Step 10: Case analysis by destructing a value Step 11: Case analysis by destructing a value Step 12: Apply tactic: red Step 13: Split a conjunction into separate goals Step 14: Split a conjunction into separate goals Step 15: Split a conjunction into separate goals Step 16: Introduce variables and assumptions Step 17: Apply a theorem or hypothesis Step 18: Apply a theorem or hypothesis Step 19: Apply a theorem or hypothesis Step 20: Case analysis by destructing a value Step 21: Apply tactic: eval_longofintu Step 22: Apply tactic: eval_longofintu Step 23: Apply tactic: eval_longofintu Step 24: Introduce variables and assumptions Step 25: Apply tactic: red Step 26: Apply tactic: red Step 27: Apply tactic: red Step 28: Apply tactic: InvEval Step 29: Introduce variables and assumptions Step 30: Introduce variables and assumptions Step 31: Introduce variables and assumptions Step 32: Apply tactic: subst Step 33: Case analysis by destructing a value Step 34: Case analysis by destructing a value Step 35: Case analysis by destructing a value Step 36: Apply tactic: - TrivialExists Step 37: Apply tactic: - econstructor Step 38: Apply tactic: - econstructor Step 39: Apply tactic: - econstructor Step 40: Apply tactic: - TrivialExists Step 41: Split a conjunction into separate goals Step 42: Split a conjunction into separate goals Step 43: Split a conjunction into separate goals Step 44: Simplify the goal by computation", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_longofint", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that unary_constructor_sound longofint Val Step 2: We need to prove that unary_constructor_sound longofint Val Step 3: We need to prove that unary_constructor_sound longofint Val Step 4: We need to prove that unary_constructor_sound longofint Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Unfold a definition Step 9: Case analysis by destructing a value Step 10: Case analysis by destructing a value Step 11: Case analysis by destructing a value Step 12: Apply tactic: red Step 13: Split a conjunction into separate goals Step 14: Split a conjunction into separate goals Step 15: Split a conjunction into separate goals Step 16: Introduce variables and assumptions Step 17: Apply a theorem or hypothesis Step 18: Apply a theorem or hypothesis Step 19: Apply a theorem or hypothesis Step 20: Case analysis by destructing a value Step 21: Apply tactic: eval_longofint Step 22: Apply tactic: eval_longofint Step 23: Apply tactic: eval_longofint Step 24: Introduce variables and assumptions Step 25: Apply tactic: red Step 26: Apply tactic: red Step 27: Apply tactic: red Step 28: Apply tactic: InvEval Step 29: Introduce variables and assumptions Step 30: Introduce variables and assumptions Step 31: Introduce variables and assumptions Step 32: Apply tactic: subst Step 33: Case analysis by destructing a value Step 34: Case analysis by destructing a value Step 35: Case analysis by destructing a value Step 36: Apply tactic: - TrivialExists Step 37: Apply tactic: - econstructor Step 38: Apply tactic: - econstructor Step 39: Apply tactic: - econstructor Step 40: Apply tactic: - TrivialExists Step 41: Split a conjunction into separate goals Step 42: Split a conjunction into separate goals Step 43: Split a conjunction into separate goals Step 44: Simplify the goal by computation", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_notl", "draft": "Require Import Coq.Integers.Int.\nLemma eval_notl : forall (v : val), unary_constructor_sound notl Val.notl v.\nProof.\n  intros v. red. split.\n  - intros. InvEval. econstructor; eauto.\n  - intros. InvEval. rewrite not_involutive. auto.\nQed.", "nl_proof": "Step 1: We need to prove that unary_constructor_sound notl Val Step 2: We need to prove that unary_constructor_sound notl Val Step 3: We need to prove that unary_constructor_sound notl Val Step 4: We need to prove that unary_constructor_sound notl Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Apply tactic: assert (INV: forall v, Val Step 9: Case analysis by destructing a value Step 10: Case analysis by destructing a value Step 11: Case analysis by destructing a value Step 12: Apply tactic: lessdef (Val Step 13: Split a conjunction into separate goals Step 14: Split a conjunction into separate goals Step 15: Split a conjunction into separate goals Step 16: Apply tactic: notl (Val Step 17: Apply a theorem or hypothesis Step 18: Apply a theorem or hypothesis Step 19: Apply a theorem or hypothesis Step 20: Apply tactic: notl v)) v) Step 21: Apply tactic: eval_notl Step 22: Apply tactic: eval_notl Step 23: Apply tactic: eval_notl Step 24: Apply tactic: { destruct v Step 25: Apply tactic: red Step 26: Apply tactic: red Step 27: Apply tactic: red Step 28: Solve automatically using known facts Step 29: Introduce variables and assumptions Step 30: Introduce variables and assumptions Step 31: Introduce variables and assumptions Step 32: Simplify the goal by computation Step 33: Case analysis by destructing a value Step 34: Case analysis by destructing a value Step 35: Rewrite using an equality Step 36: Rewrite using an equality Step 37: Apply tactic: - InvEval Step 38: Apply tactic: - InvEval Step 39: Apply tactic: notl_xorl Step 40: Apply tactic: not_involutive Step 41: Apply tactic: econstructor Step 42: Apply tactic: econstructor Step 43: Apply a theorem or hypothesis Step 44: Solve automatically using known facts", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_andlimm", "draft": "Require Import Coq.Integers.Int.\nRequire Import compcert.backend.SelectLong.\nRequire Import compcert.lib.Integers.\n\nLemma eval_andlimm : forall (n : int64), unary_constructor_sound (andlimm n) (fun (x : val) => Val.andl x (Vlong n)).\nProof.\n  intros n. red. intros le a b x H. \n  unfold andlimm in H. \n  case (andlimm_match a) in H; intros; InvEval.\n  - exists (Val.andl v (Vlong n)); split; trivial.\n    apply eval_andlimm_base; auto.\n  - subst x. rewrite Int64.and_commut. simpl.\n    exists (Vlong (Int64.and n n0)); split; auto.\n    constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, unary_constructor_sound (andlimm n) (fun v => Val Step 2: We need to prove that forall n, unary_constructor_sound (andlimm n) (fun v => Val Step 3: We need to prove that forall n, unary_constructor_sound (andlimm n) (fun v => Val Step 4: We need to prove that forall n, unary_constructor_sound (andlimm n) (fun x => Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Introduce variables and assumptions Step 12: Apply tactic: red Step 13: Apply tactic: red Step 14: Apply tactic: red Step 15: Apply tactic: red Step 16: Introduce variables and assumptions Step 17: Introduce variables and assumptions Step 18: Introduce variables and assumptions Step 19: Introduce variables and assumptions Step 20: Unfold a definition Step 21: Apply tactic: predSpec Int64 Step 22: Apply tactic: predSpec Int64 Step 23: Apply tactic: predSpec Int64 Step 24: Apply tactic: case (andlimm_match a) Step 25: Apply tactic: eq Int64 Step 26: Apply tactic: eq Int64 Step 27: Apply tactic: eq Int64 Step 28: Introduce variables and assumptions Step 29: Apply tactic: eq_spec n Int64 Step 30: Apply tactic: eq_spec n Int64 Step 31: Apply tactic: eq_spec n Int64 Step 32: Apply tactic: InvEval Step 33: Apply tactic: zero Step 34: Apply tactic: zero Step 35: Apply tactic: zero Step 36: Apply tactic: subst Step 37: Provide an existential witness Step 38: Provide an existential witness Step 39: Provide an existential witness Step 40: Apply tactic: - rewrite Int64 Step 41: Apply tactic: zero) Step 42: Apply tactic: zero) Step 43: Apply tactic: zero) Step 44: Apply tactic: and_commut", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_andl", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma eval_andl : forall (x y : nat), binary_constructor_sound andl Val.andl.\nProof.\n  red; intros.\n  destruct x; destruct y; simpl; try reflexivity.\n  destruct (andl_match n n0); simpl; reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound andl Val Step 2: We need to prove that binary_constructor_sound andl Val Step 3: We need to prove that binary_constructor_sound andl Val Step 4: We need to prove that binary_constructor_sound andl Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Apply tactic: red Step 9: Case analysis by destructing a value Step 10: Case analysis by destructing a value Step 11: Case analysis by destructing a value Step 12: Introduce variables and assumptions Step 13: Split a conjunction into separate goals Step 14: Split a conjunction into separate goals Step 15: Split a conjunction into separate goals Step 16: Unfold a definition Step 17: Apply a theorem or hypothesis Step 18: Apply a theorem or hypothesis Step 19: Apply a theorem or hypothesis Step 20: Apply tactic: case (andl_match a b) Step 21: Apply tactic: eval_andl Step 22: Apply tactic: eval_andl Step 23: Apply tactic: eval_andl Step 24: Introduce variables and assumptions Step 25: Apply tactic: red Step 26: Apply tactic: red Step 27: Apply tactic: red Step 28: Apply tactic: InvEval Step 29: Introduce variables and assumptions Step 30: Introduce variables and assumptions Step 31: Introduce variables and assumptions Step 32: Apply tactic: subst Step 33: Case analysis by destructing a value Step 34: Case analysis by destructing a value Step 35: Case analysis by destructing a value Step 36: Apply tactic: - rewrite Val Step 37: Apply tactic: - InvEval Step 38: Apply tactic: - InvEval Step 39: Apply tactic: - InvEval Step 40: Apply tactic: andl_commut Step 41: Rewrite using an equality Step 42: Rewrite using an equality Step 43: Rewrite using an equality Step 44: Apply a theorem or hypothesis", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_orlimm", "draft": "```coq\nRequire Import Coq.Integers.Int.\nLemma eval_orlimm : forall (A : Type) (n : A), unary_constructor_sound (orlimm n) (fun x => Val.orl x (Vlong n)).\nProof.\n  intros n. red. intros until x. unfold orlimm.\n  predSpec Int64.eq Int64.eq_spec n Int64.zero.\n  - subst n. intros. exists x; split; auto. destruct x; auto. simpl. rewrite Int64.or_zero; auto.\n  - predSpec Int64.eq Int64.eq_spec n Int64.mone.\n    + subst n. intros. exists (Vlong Int64.mone); split; auto. destruct x; auto. simpl. rewrite Int64.or_mone; auto.\n    + intros. eexists; split; eauto.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, unary_constructor_sound (orlimm n) (fun v => Val Step 2: We need to prove that forall n, unary_constructor_sound (orlimm n) (fun v => Val Step 3: We need to prove that forall n, unary_constructor_sound (orlimm n) (fun v => Val Step 4: We need to prove that forall n, unary_constructor_sound (orlimm n) (fun x => Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Introduce variables and assumptions Step 12: Apply tactic: red Step 13: Apply tactic: red Step 14: Apply tactic: red Step 15: Apply tactic: red Step 16: Introduce variables and assumptions Step 17: Introduce variables and assumptions Step 18: Introduce variables and assumptions Step 19: Introduce variables and assumptions Step 20: Unfold a definition Step 21: Apply tactic: predSpec Int64 Step 22: Apply tactic: predSpec Int64 Step 23: Apply tactic: predSpec Int64 Step 24: Apply tactic: predSpec Int64 Step 25: Apply tactic: eq Int64 Step 26: Apply tactic: eq Int64 Step 27: Apply tactic: eq Int64 Step 28: Apply tactic: eq Int64 Step 29: Apply tactic: eq_spec n Int64 Step 30: Apply tactic: eq_spec n Int64 Step 31: Apply tactic: eq_spec n Int64 Step 32: Apply tactic: eq_spec n Int64 Step 33: Apply tactic: zero Step 34: Apply tactic: zero Step 35: Apply tactic: zero Step 36: Apply tactic: zero Step 37: Provide an existential witness Step 38: Provide an existential witness Step 39: Provide an existential witness Step 40: Introduce variables and assumptions Step 41: Split a conjunction into separate goals Step 42: Split a conjunction into separate goals Step 43: Split a conjunction into separate goals Step 44: Apply tactic: subst", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_orl", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Arith.PeanoNat.\nLemma eval_orl : binary_constructor_sound orl Val.orl.\nProof. apply eval_orlimm_base. Qed.", "nl_proof": "Step 1: shl - shru Step 2: shru - shl Step 3: We need to prove that binary_constructor_sound orl Val Step 4: We need to prove that binary_constructor_sound orl Val Step 5: We need to prove that binary_constructor_sound orl Val Step 6: We need to prove that binary_constructor_sound orl Val Step 7: Unfold a definition Step 8: Unfold a definition Step 9: Unfold a definition Step 10: Apply tactic: red Step 11: Case analysis by destructing a value Step 12: Case analysis by destructing a value Step 13: Case analysis by destructing a value Step 14: Introduce variables and assumptions Step 15: Split a conjunction into separate goals Step 16: Split a conjunction into separate goals Step 17: Split a conjunction into separate goals Step 18: Unfold a definition Step 19: Apply a theorem or hypothesis Step 20: Apply a theorem or hypothesis Step 21: Apply a theorem or hypothesis Step 22: Apply tactic: case (orl_match a b) Step 23: Apply tactic: eval_orl Step 24: Apply tactic: eval_orl Step 25: Apply tactic: eval_orl Step 26: Introduce variables and assumptions Step 27: Apply tactic: red Step 28: Apply tactic: red Step 29: Apply tactic: red Step 30: Apply tactic: InvEval Step 31: Introduce variables and assumptions Step 32: Introduce variables and assumptions Step 33: Introduce variables and assumptions Step 34: Apply tactic: subst Step 35: Apply tactic: assert (DEFAULT: exists v, eval_expr ge sp e m le Step 36: Apply tactic: assert (DEFAULT: exists v, eval_expr ge sp e m le Step 37: Case analysis by destructing a value Step 38: Apply tactic: - rewrite Val Step 39: Apply tactic: lessdef (Val Step 40: Apply tactic: lessdef (Val Step 41: Apply tactic: - InvEval Step 42: Apply tactic: orl_commut Step 43: Apply tactic: orl x y) v) by TrivialExists Step 44: Apply tactic: orl x y) v) by TrivialExists Step 45: Rewrite using an equality Step 46: Apply a theorem or hypothesis", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_xorlimm", "draft": "Require Import Coq.Integers.Int.\nRequire Import compcert.backend.SelectLong.\nRequire Import compcert.common.Values.\n\nLemma eval_xorlimm : forall (A : Type) (n : A), unary_constructor_sound (xorlimm n) (fun v => Val.xorl v (Vlong n)).\nProof.\n  red; intros.\n  unfold xorlimm.\n  predSpec Int64.eq Int64.eq_spec n Int64.zero.\n  - subst.\n    exists v; split; auto.\n    destruct v; simpl; try constructor.\n    rewrite Int64.xor_zero; constructor.\n  - InvEval.\n    + exists (Val.xorl v1 (Vlong n)); split.\n      constructor; auto.\n      simpl. rewrite Int64.xor_commut. auto.\n    + exists (Val.xorl v1 (Vlong n)); split.\n      constructor; auto.\n      simpl. rewrite Int64.xor_commut. auto.\n    + exists (Val.xorl v1 (Vlong n)); split.\n      constructor; auto.\n      simpl. rewrite Int64.xor_commut. auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, unary_constructor_sound (xorlimm n) (fun v => Val Step 2: We need to prove that forall n, unary_constructor_sound (xorlimm n) (fun v => Val Step 3: We need to prove that forall n, unary_constructor_sound (xorlimm n) (fun v => Val Step 4: We need to prove that forall n, unary_constructor_sound (xorlimm n) (fun x => Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Introduce variables and assumptions Step 12: Apply tactic: red Step 13: Apply tactic: red Step 14: Apply tactic: red Step 15: Apply tactic: red Step 16: Introduce variables and assumptions Step 17: Introduce variables and assumptions Step 18: Introduce variables and assumptions Step 19: Introduce variables and assumptions Step 20: Unfold a definition Step 21: Apply tactic: predSpec Int64 Step 22: Apply tactic: predSpec Int64 Step 23: Apply tactic: predSpec Int64 Step 24: Case analysis by destructing a value Step 25: Apply tactic: eq Int64 Step 26: Apply tactic: eq Int64 Step 27: Apply tactic: eq Int64 Step 28: Introduce variables and assumptions Step 29: Apply tactic: eq_spec n Int64 Step 30: Apply tactic: eq_spec n Int64 Step 31: Apply tactic: eq_spec n Int64 Step 32: Apply tactic: InvEval Step 33: Apply tactic: zero Step 34: Apply tactic: zero Step 35: Apply tactic: zero Step 36: Apply tactic: subst Step 37: Provide an existential witness Step 38: Provide an existential witness Step 39: Provide an existential witness Step 40: Apply tactic: - rewrite Int64 Step 41: Split a conjunction into separate goals Step 42: Split a conjunction into separate goals Step 43: Split a conjunction into separate goals Step 44: Apply tactic: xor_commut", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_xorl", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Arith.PeanoNat.\nLemma eval_xorl : binary_constructor_sound xorl Val.xorl.\nProof.\n  red; intros.\n  unfold binary_constructor_sound in *.\n  destruct a; destruct b; simpl; try discriminate.\n  - InvEval.\n    rewrite Val.xorl_commut.\n    apply Val.xorl_assoc.\n  - InvEval.\n    rewrite Val.xorl_commut.\n    apply Val.xorl_assoc.\n  - InvEval.\n    rewrite Val.xorl_commut.\n    apply Val.xorl_assoc.\nQed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound xorl Val Step 2: We need to prove that binary_constructor_sound xorl Val Step 3: We need to prove that binary_constructor_sound xorl Val Step 4: We need to prove that binary_constructor_sound xorl Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Apply tactic: red Step 9: Case analysis by destructing a value Step 10: Case analysis by destructing a value Step 11: Case analysis by destructing a value Step 12: Introduce variables and assumptions Step 13: Split a conjunction into separate goals Step 14: Split a conjunction into separate goals Step 15: Split a conjunction into separate goals Step 16: Unfold a definition Step 17: Apply a theorem or hypothesis Step 18: Apply a theorem or hypothesis Step 19: Apply a theorem or hypothesis Step 20: Apply tactic: case (xorl_match a b) Step 21: Apply tactic: eval_xorl Step 22: Apply tactic: eval_xorl Step 23: Apply tactic: eval_xorl Step 24: Introduce variables and assumptions Step 25: Apply tactic: red Step 26: Apply tactic: red Step 27: Apply tactic: red Step 28: Apply tactic: InvEval Step 29: Introduce variables and assumptions Step 30: Introduce variables and assumptions Step 31: Introduce variables and assumptions Step 32: Apply tactic: subst Step 33: Case analysis by destructing a value Step 34: Case analysis by destructing a value Step 35: Case analysis by destructing a value Step 36: Apply tactic: - rewrite Val Step 37: Apply tactic: - InvEval Step 38: Apply tactic: - InvEval Step 39: Apply tactic: - InvEval Step 40: Apply tactic: xorl_commut Step 41: Rewrite using an equality Step 42: Rewrite using an equality Step 43: Rewrite using an equality Step 44: Apply a theorem or hypothesis", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_rolml", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nRequire Import compcert.lib.Integers.\nRequire Import compcert.common.Values.\n\nLemma eval_rolml : forall amount mask, unary_constructor_sound (fun v => rolml v amount mask) (fun v => Val.rolml v amount mask).\nProof.\n  intros amount mask.\n  red.\n  intros until a.\n  intros EVAL.\n  inv EVAL.\n  - simpl.\n    rewrite Val.rolml_zero.\n    auto.\n  - exploit eval_andlimm; eauto.\n    intros (v' & EVAL' & AGREE).\n    simpl.\n    rewrite EVAL'.\n    auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall amount mask, unary_constructor_sound (fun v => rolml v amount mask) (fun v => Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: red Step 5: Introduce variables and assumptions Step 6: Apply tactic: predSpec Int Step 7: Apply tactic: eq Int Step 8: Apply tactic: eq_spec amount Int Step 9: Apply tactic: zero Step 10: Rewrite using an equality Step 11: Apply tactic: exploit (eval_andlimm)", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_shllimm", "draft": "Require Import Coq.Integers.Int.\nLemma eval_shllimm : forall (A : Type) (n : A), unary_constructor_sound (fun e => shllimm e n) (fun v => Val.shll v (Vint n)).\nProof.\n  red.\n  unfold shllimm.\n  unfold unary_constructor_sound.\n  intros.\n  destruct (Int.ltu n Int64.iwordsize') eqn:L.\n  - apply eval_shllimm_base; auto.\n  - apply eval_shllimm_base; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, unary_constructor_sound (fun e => shllimm e n) (fun v => Val Step 2: We need to prove that forall n, unary_constructor_sound (fun e => shllimm e n) (fun v => Val Step 3: We need to prove that forall n, unary_constructor_sound (fun e => shllimm e n) (fun v => Val Step 4: We need to prove that forall n, unary_constructor_sound (fun a => shllimm a n) (fun x => Val Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Apply tactic: red Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Unfold a definition Step 12: Introduce variables and assumptions Step 13: Case analysis by destructing a value Step 14: Case analysis by destructing a value Step 15: Case analysis by destructing a value Step 16: Unfold a definition Step 17: Split a conjunction into separate goals Step 18: Split a conjunction into separate goals Step 19: Split a conjunction into separate goals Step 20: Apply tactic: predSpec Int Step 21: Apply a theorem or hypothesis Step 22: Apply a theorem or hypothesis Step 23: Apply a theorem or hypothesis Step 24: Apply tactic: eq Int Step 25: Apply tactic: eval_shllimm Step 26: Apply tactic: eval_shllimm Step 27: Apply tactic: eval_shllimm Step 28: Apply tactic: eq_spec n Int Step 29: Solve automatically using known facts Step 30: Solve automatically using known facts Step 31: Solve automatically using known facts Step 32: Apply tactic: zero Step 33: Apply tactic: red Step 34: Apply tactic: red Step 35: Apply tactic: red Step 36: Apply tactic: [| destruct (Int Step 37: Introduce variables and assumptions Step 38: Introduce variables and assumptions Step 39: Introduce variables and assumptions Step 40: Apply tactic: ltu n Int64 Step 41: Apply tactic: predSpec Int Step 42: Apply tactic: predSpec Int Step 43: Apply tactic: predSpec Int Step 44: Apply tactic: iwordsize') eqn:L]", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_shrluimm", "draft": "```coq\nRequire Import Coq.Integers.Int.\nLemma eval_shrluimm : forall (A : Type) (n : A), unary_constructor_sound (fun a => shrluimm a n) (fun x => Val.shrlu x (Vint n)).\nProof. intros; red; intros; unfold shrluimm; eauto with evalexpr. Qed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, unary_constructor_sound (fun e => shrluimm e n) (fun v => Val Step 2: We need to prove that forall n, unary_constructor_sound (fun e => shrluimm e n) (fun v => Val Step 3: We need to prove that forall n, unary_constructor_sound (fun e => shrluimm e n) (fun v => Val Step 4: We need to prove that forall n, unary_constructor_sound (fun a => shrluimm a n) (fun x => Val Step 5: Unfold a definition Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Apply tactic: Local Opaque Int64 Step 9: Case analysis by destructing a value Step 10: Unfold a definition Step 11: Unfold a definition Step 12: Apply tactic: zwordsize Step 13: Split a conjunction into separate goals Step 14: Case analysis by destructing a value Step 15: Case analysis by destructing a value Step 16: Apply tactic: red Step 17: Apply a theorem or hypothesis Step 18: Split a conjunction into separate goals Step 19: Split a conjunction into separate goals Step 20: Introduce variables and assumptions Step 21: Apply tactic: eval_shrluimm Step 22: Apply a theorem or hypothesis Step 23: Apply a theorem or hypothesis Step 24: Unfold a definition Step 25: Solve automatically using known facts Step 26: Apply tactic: eval_shrluimm Step 27: Apply tactic: eval_shrluimm Step 28: Apply tactic: predSpec Int Step 29: Apply tactic: red Step 30: Solve automatically using known facts Step 31: Solve automatically using known facts Step 32: Apply tactic: eq Int Step 33: Introduce variables and assumptions Step 34: Apply tactic: red Step 35: Apply tactic: red Step 36: Apply tactic: eq_spec n Int Step 37: Apply tactic: predSpec Int Step 38: Introduce variables and assumptions Step 39: Introduce variables and assumptions Step 40: Apply tactic: zero Step 41: Apply tactic: eq Int Step 42: Apply tactic: predSpec Int Step 43: Apply tactic: predSpec Int Step 44: Apply tactic: [| destruct (Int", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_shrlimm", "draft": "Require Import Coq.Integers.Int.\nLemma eval_shrlimm : forall (A : Type) (n : A), unary_constructor_sound (fun e => shrlimm e n) (fun v => Val.shrl v (Vint n)).\nProof. apply eval_shrlimm. Qed.", "nl_proof": "Step 1: We need to prove that forall n, unary_constructor_sound (fun e => shrlimm e n) (fun v => Val Step 2: We need to prove that forall n, unary_constructor_sound (fun e => shrlimm e n) (fun v => Val Step 3: We need to prove that forall n, unary_constructor_sound (fun e => shrlimm e n) (fun v => Val Step 4: We need to prove that forall n, unary_constructor_sound (fun a => shrlimm a n) (fun x => Val Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Apply tactic: red Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Unfold a definition Step 12: Introduce variables and assumptions Step 13: Case analysis by destructing a value Step 14: Case analysis by destructing a value Step 15: Case analysis by destructing a value Step 16: Unfold a definition Step 17: Split a conjunction into separate goals Step 18: Split a conjunction into separate goals Step 19: Split a conjunction into separate goals Step 20: Apply tactic: predSpec Int Step 21: Apply a theorem or hypothesis Step 22: Apply a theorem or hypothesis Step 23: Apply a theorem or hypothesis Step 24: Apply tactic: eq Int Step 25: Apply tactic: eval_shrlimm Step 26: Apply tactic: eval_shrlimm Step 27: Apply tactic: eval_shrlimm Step 28: Apply tactic: eq_spec n Int Step 29: Solve automatically using known facts Step 30: Solve automatically using known facts Step 31: Solve automatically using known facts Step 32: Apply tactic: zero Step 33: Apply tactic: red Step 34: Apply tactic: red Step 35: Apply tactic: red Step 36: Apply tactic: [| destruct (Int Step 37: Introduce variables and assumptions Step 38: Introduce variables and assumptions Step 39: Introduce variables and assumptions Step 40: Apply tactic: ltu n Int64 Step 41: Apply tactic: predSpec Int Step 42: Apply tactic: predSpec Int Step 43: Apply tactic: predSpec Int Step 44: Apply tactic: iwordsize') eqn:L]", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_shll", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_shll : forall (x y : nat), binary_constructor_sound shll Val.shll.\nProof.\n  red; intros.\n  destruct x; destruct y; simpl; auto.\nQed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound shll Val Step 2: We need to prove that binary_constructor_sound shll Val Step 3: We need to prove that binary_constructor_sound shll Val Step 4: We need to prove that binary_constructor_sound shll Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Apply tactic: red Step 9: Case analysis by destructing a value Step 10: Case analysis by destructing a value Step 11: Case analysis by destructing a value Step 12: Introduce variables and assumptions Step 13: Split a conjunction into separate goals Step 14: Split a conjunction into separate goals Step 15: Split a conjunction into separate goals Step 16: Unfold a definition Step 17: Apply a theorem or hypothesis Step 18: Apply a theorem or hypothesis Step 19: Apply a theorem or hypothesis Step 20: Apply tactic: case (shll_match b) Step 21: Apply tactic: eval_shll Step 22: Apply tactic: eval_shll Step 23: Apply tactic: eval_shll Step 24: Introduce variables and assumptions Step 25: Solve automatically using known facts Step 26: Solve automatically using known facts Step 27: Solve automatically using known facts Step 28: Apply tactic: InvEval Step 29: Apply tactic: red Step 30: Apply tactic: red Step 31: Apply tactic: red Step 32: Apply a theorem or hypothesis Step 33: Introduce variables and assumptions Step 34: Introduce variables and assumptions Step 35: Introduce variables and assumptions Step 36: Solve automatically using known facts Step 37: Case analysis by destructing a value Step 38: Case analysis by destructing a value Step 39: Case analysis by destructing a value Step 40: Solve automatically using known facts Step 41: Apply tactic: - exploit is_intconst_sound Step 42: Apply tactic: - exploit is_intconst_sound Step 43: Apply tactic: - exploit is_intconst_sound Step 44: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_shrlu", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_shrlu : forall (x y : nat), binary_constructor_sound shrlu Val.shrlu x y.\nProof. red; intros; destruct x, y; simpl; auto. Qed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound shrlu Val Step 2: We need to prove that binary_constructor_sound shrlu Val Step 3: We need to prove that binary_constructor_sound shrlu Val Step 4: We need to prove that binary_constructor_sound shrlu Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Apply tactic: red Step 9: Case analysis by destructing a value Step 10: Case analysis by destructing a value Step 11: Case analysis by destructing a value Step 12: Introduce variables and assumptions Step 13: Split a conjunction into separate goals Step 14: Split a conjunction into separate goals Step 15: Split a conjunction into separate goals Step 16: Unfold a definition Step 17: Apply a theorem or hypothesis Step 18: Apply a theorem or hypothesis Step 19: Apply a theorem or hypothesis Step 20: Apply tactic: case (shrlu_match b) Step 21: Apply tactic: eval_shrlu Step 22: Apply tactic: eval_shrlu Step 23: Apply tactic: eval_shrlu Step 24: Introduce variables and assumptions Step 25: Solve automatically using known facts Step 26: Solve automatically using known facts Step 27: Solve automatically using known facts Step 28: Apply tactic: InvEval Step 29: Apply tactic: red Step 30: Apply tactic: red Step 31: Apply tactic: red Step 32: Apply a theorem or hypothesis Step 33: Introduce variables and assumptions Step 34: Introduce variables and assumptions Step 35: Introduce variables and assumptions Step 36: Solve automatically using known facts Step 37: Case analysis by destructing a value Step 38: Case analysis by destructing a value Step 39: Case analysis by destructing a value Step 40: Solve automatically using known facts Step 41: Apply tactic: - exploit is_intconst_sound Step 42: Apply tactic: - exploit is_intconst_sound Step 43: Apply tactic: - exploit is_intconst_sound Step 44: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_shrl", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_shrl : forall (x y : nat), binary_constructor_sound shrl Val.shrl.\nProof. apply eval_shrl. Qed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound shrl Val Step 2: We need to prove that binary_constructor_sound shrl Val Step 3: We need to prove that binary_constructor_sound shrl Val Step 4: We need to prove that binary_constructor_sound shrl Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Apply tactic: red Step 9: Case analysis by destructing a value Step 10: Case analysis by destructing a value Step 11: Case analysis by destructing a value Step 12: Introduce variables and assumptions Step 13: Split a conjunction into separate goals Step 14: Split a conjunction into separate goals Step 15: Split a conjunction into separate goals Step 16: Unfold a definition Step 17: Apply a theorem or hypothesis Step 18: Apply a theorem or hypothesis Step 19: Apply a theorem or hypothesis Step 20: Apply tactic: case (shrl_match b) Step 21: Apply tactic: eval_shrl Step 22: Apply tactic: eval_shrl Step 23: Apply tactic: eval_shrl Step 24: Introduce variables and assumptions Step 25: Solve automatically using known facts Step 26: Solve automatically using known facts Step 27: Solve automatically using known facts Step 28: Apply tactic: InvEval Step 29: Apply tactic: red Step 30: Apply tactic: red Step 31: Apply tactic: red Step 32: Apply a theorem or hypothesis Step 33: Introduce variables and assumptions Step 34: Introduce variables and assumptions Step 35: Introduce variables and assumptions Step 36: Solve automatically using known facts Step 37: Case analysis by destructing a value Step 38: Case analysis by destructing a value Step 39: Case analysis by destructing a value Step 40: Solve automatically using known facts Step 41: Apply tactic: - exploit is_intconst_sound Step 42: Apply tactic: - exploit is_intconst_sound Step 43: Apply tactic: - exploit is_intconst_sound Step 44: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_negl", "draft": "Require Import Coq.Integers.Int.\nRequire Import compcert.lib.Integers.\nRequire Import compcert.common.Values.\n\nLemma eval_negl_sound : forall (v : val), unary_constructor_sound negl (fun v => Val.subl (Vlong Int64.zero) v).\nProof.\n  red. intros v. destruct v; try (split; intro H; inversion H).\n  split; intro H.\n  - inversion H; subst. simpl. TrivialExists.\n  - inversion H; subst. simpl. TrivialExists.\nQed.", "nl_proof": "Step 1: We need to prove that unary_constructor_sound negl Val Step 2: We need to prove that unary_constructor_sound negl Val Step 3: We need to prove that unary_constructor_sound negl Val Step 4: We need to prove that unary_constructor_sound negl (fun v => Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Apply tactic: red Step 9: Case analysis by destructing a value Step 10: Case analysis by destructing a value Step 11: Case analysis by destructing a value Step 12: Introduce variables and assumptions Step 13: Split a conjunction into separate goals Step 14: Split a conjunction into separate goals Step 15: Split a conjunction into separate goals Step 16: Unfold a definition Step 17: Apply a theorem or hypothesis Step 18: Apply a theorem or hypothesis Step 19: Apply a theorem or hypothesis Step 20: Apply tactic: case (negl_match a) Step 21: Apply tactic: eval_negl Step 22: Apply tactic: eval_negl Step 23: Apply tactic: eval_negl Step 24: Introduce variables and assumptions Step 25: Solve automatically using known facts Step 26: Solve automatically using known facts Step 27: Solve automatically using known facts Step 28: Apply tactic: InvEval Step 29: Apply tactic: red Step 30: Apply tactic: red Step 31: Apply tactic: red Step 32: Apply tactic: subst Step 33: Introduce variables and assumptions Step 34: Introduce variables and assumptions Step 35: Introduce variables and assumptions Step 36: Apply tactic: - TrivialExists Step 37: Case analysis by destructing a value Step 38: Case analysis by destructing a value Step 39: Case analysis by destructing a value Step 40: Apply tactic: - TrivialExists Step 41: Apply tactic: - exploit is_longconst_sound Step 42: Apply tactic: - exploit is_longconst_sound Step 43: Apply tactic: - exploit is_longconst_sound Step 44: Apply tactic: - TrivialExists", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_addlimm", "draft": "Require Import Coq.Lists.List.\nLemma eval_addlimm : forall (A : Type) (n : A), unary_constructor_sound (addlimm n) (fun x => Val.addl x (Vlong n)).\nProof.\n  red; intros.\n  unfold addlimm.\n  predSpec Int64.eq Int64.eq_spec n Int64.zero.\n  - subst.\n    exists (Val.addl x (Vlong Int64.zero)); split; auto.\n  - exists (Val.addl x (Vlong n)); split; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, unary_constructor_sound (addlimm n) (fun v => Val Step 2: We need to prove that forall n, unary_constructor_sound (addlimm n) (fun v => Val Step 3: We need to prove that forall n, unary_constructor_sound (addlimm n) (fun v => Val Step 4: We need to prove that forall n, unary_constructor_sound (addlimm n) (fun x => Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Introduce variables and assumptions Step 11: Introduce variables and assumptions Step 12: Unfold a definition Step 13: Introduce variables and assumptions Step 14: Apply tactic: red Step 15: Apply tactic: red Step 16: Introduce variables and assumptions Step 17: Apply tactic: predSpec Int64 Step 18: Introduce variables and assumptions Step 19: Introduce variables and assumptions Step 20: Apply tactic: predSpec Int64 Step 21: Apply tactic: eq Int64 Step 22: Apply tactic: predSpec Int64 Step 23: Apply tactic: predSpec Int64 Step 24: Apply tactic: eq Int64 Step 25: Apply tactic: eq_spec n Int64 Step 26: Apply tactic: eq Int64 Step 27: Apply tactic: eq Int64 Step 28: Apply tactic: eq_spec n Int64 Step 29: Apply tactic: zero Step 30: Apply tactic: eq_spec n Int64 Step 31: Apply tactic: eq_spec n Int64 Step 32: Apply tactic: zero Step 33: Provide an existential witness Step 34: Apply tactic: zero Step 35: Apply tactic: zero Step 36: Apply tactic: - subst n Step 37: Split a conjunction into separate goals Step 38: Apply tactic: subst Step 39: Apply tactic: subst Step 40: Introduce variables and assumptions Step 41: Solve automatically using known facts Step 42: Provide an existential witness Step 43: Provide an existential witness Step 44: Provide an existential witness", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_addl", "draft": "Require Import Coq.Arith.PeanoNat.\nRequire Import Coq.Lists.List.\nRequire Import Coq.ZArith.Int.\nRequire Import Coq.Ptr.Ptrofs.\n\nLemma shift_symbol_address_64_generalized : forall (ge : Genv.t (list byte) unit) (id : ident) (ofs : Ptrofs.int) (n : int64),\n  Archi.ptr64 = true ->\n  Genv.symbol_address ge id (Ptrofs.add ofs (Ptrofs.of_int64 n)) = Val.addl (Genv.symbol_address ge id ofs) (Vlong n).\nProof.\n  intros ge id ofs n Hptr64.\n  unfold Genv.symbol_address.\n  destruct (Genv.find_symbol ge id) eqn:?; auto.\n  simpl. rewrite Hptr64. reflexivity.\nQed.", "nl_proof": "Step 1: assert (SF: Archi.ptr64 = true). { Local Transparent Archi.splitlong. unfold Archi.splitlong in SL. destruct Archi.ptr64; simpl in *; congruence. } Step 2: assert (B: forall id ofs n, Genv.symbol_address ge id (Ptrofs.add ofs (Ptrofs.repr n)) = Val.addl (Genv.symbol_address ge id ofs) (Vlong (Int64.repr n))). { intros. replace (Ptrofs.repr n) with (Ptrofs.of_int64 (Int64.repr n)) by auto with ptrofs. apply Genv.shift_symbol_address_64; auto. } Step 3: We need to prove that binary_constructor_sound addl Val Step 4: We need to prove that binary_constructor_sound addl Val Step 5: We need to prove that binary_constructor_sound addl Val Step 6: We need to prove that binary_constructor_sound addl Val Step 7: Unfold a definition Step 8: Apply tactic: assert (A: forall x y, Int64 Step 9: Unfold a definition Step 10: Apply tactic: red Step 11: Case analysis by destructing a value Step 12: Apply tactic: repr (x + y) = Int64 Step 13: Case analysis by destructing a value Step 14: Introduce variables and assumptions Step 15: Split a conjunction into separate goals Step 16: Apply tactic: add (Int64 Step 17: Split a conjunction into separate goals Step 18: Unfold a definition Step 19: Apply a theorem or hypothesis Step 20: Apply tactic: repr x) (Int64 Step 21: Apply a theorem or hypothesis Step 22: Apply tactic: case (addl_match a b) Step 23: Apply tactic: eval_addl Step 24: Apply tactic: repr y)) Step 25: Apply tactic: eval_addl Step 26: Introduce variables and assumptions Step 27: Solve automatically using known facts Step 28: Apply tactic: { intros Step 29: Apply a theorem or hypothesis Step 30: Apply tactic: InvEval Step 31: Apply tactic: red Step 32: Apply a theorem or hypothesis Step 33: Split a conjunction into separate goals Step 34: Apply tactic: subst Step 35: Introduce variables and assumptions Step 36: Apply tactic: eqm_samerepr Step 37: Solve automatically using known facts Step 38: Apply tactic: - rewrite Val Step 39: Case analysis by destructing a value Step 40: Solve automatically using known facts Step 41: Apply tactic: red Step 42: Apply tactic: addl_commut Step 43: Apply tactic: InvEval Step 44: Apply tactic: assert (B: forall id ofs n, Archi Step 45: Introduce variables and assumptions Step 46: Apply a theorem or hypothesis", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_subl", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_subl : forall (a b : nat), binary_constructor_sound subl Val.subl a b.\nProof.\n  red; intros.\n  destruct a; destruct b; simpl; auto.\n  split; auto.\n  apply subl_addl_opp.\nQed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound subl Val Step 2: We need to prove that binary_constructor_sound subl Val Step 3: We need to prove that binary_constructor_sound subl Val Step 4: We need to prove that binary_constructor_sound subl Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Apply tactic: red Step 9: Case analysis by destructing a value Step 10: Case analysis by destructing a value Step 11: Case analysis by destructing a value Step 12: Introduce variables and assumptions Step 13: Split a conjunction into separate goals Step 14: Split a conjunction into separate goals Step 15: Split a conjunction into separate goals Step 16: Unfold a definition Step 17: Apply a theorem or hypothesis Step 18: Apply a theorem or hypothesis Step 19: Apply a theorem or hypothesis Step 20: Apply tactic: case (subl_match a b) Step 21: Apply tactic: eval_subl Step 22: Apply tactic: eval_subl Step 23: Apply tactic: eval_subl Step 24: Introduce variables and assumptions Step 25: Apply a theorem or hypothesis Step 26: Apply a theorem or hypothesis Step 27: Apply a theorem or hypothesis Step 28: Apply tactic: InvEval Step 29: Split a conjunction into separate goals Step 30: Split a conjunction into separate goals Step 31: Split a conjunction into separate goals Step 32: Apply tactic: subst Step 33: Solve automatically using known facts Step 34: Solve automatically using known facts Step 35: Solve automatically using known facts Step 36: Apply tactic: - rewrite Val Step 37: Apply tactic: red Step 38: Apply tactic: red Step 39: Apply tactic: red Step 40: Apply tactic: subl_addl_opp Step 41: Introduce variables and assumptions Step 42: Introduce variables and assumptions Step 43: Introduce variables and assumptions Step 44: Apply a theorem or hypothesis", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_mullimm_base", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma eval_mullimm_base : forall (A : Type) (n : A), unary_constructor_sound (mullimm_base n) (fun x => Val.mull x (Vlong n)).\nProof.\n  intros n. red. intros until x. unfold mullimm_base.\n  case (Int64.is_power2' n) eqn:P2.\n  - intros. TrivialExists.\n  - case (Int64.is_power2' (Int64.neg n)) eqn:N2.\n    + intros. TrivialExists.\n    + intros. TrivialExists.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, unary_constructor_sound (mullimm_base n) (fun v => Val Step 2: We need to prove that forall n, unary_constructor_sound (mullimm_base n) (fun v => Val Step 3: We need to prove that forall n, unary_constructor_sound (mullimm_base n) (fun v => Val Step 4: We need to prove that forall n, unary_constructor_sound (mullimm_base n) (fun x => Val Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Unfold a definition Step 12: Apply tactic: red Step 13: Apply tactic: red Step 14: Apply tactic: red Step 15: Apply tactic: red Step 16: Introduce variables and assumptions Step 17: Introduce variables and assumptions Step 18: Introduce variables and assumptions Step 19: Introduce variables and assumptions Step 20: Unfold a definition Step 21: Apply tactic: assert (DEFAULT: exists v : val, eval_expr ge sp e Step 22: Apply tactic: generalize (Int64 Step 23: Apply tactic: assert (DEFAULT: exists v, Step 24: Apply tactic: assert (DFL: exists v, eval_expr ge sp e m le (Eop Step 25: Apply tactic: /\\ Val Step 26: Apply tactic: one_bits'_decomp n) Step 27: Apply tactic: eval_expr ge sp e m le (Eop Omull (a ::: longconst Step 28: Apply tactic: lessdef (Val Step 29: Apply tactic: lessdef (Val Step 30: Introduce variables and assumptions Step 31: Apply tactic: /\\ Val Step 32: Apply tactic: mull x (Vlong n)) v) Step 33: Apply tactic: mull x (Vlong n)) v) Step 34: Case analysis by destructing a value Step 35: Apply tactic: lessdef (Val Step 36: Apply tactic: { rewrite Val Step 37: Apply tactic: { TrivialExists Step 38: Apply tactic: one_bits' n) as [ | i [ | j [ | ? ? ]]] eqn:B Step 39: Apply tactic: mull x (Vlong n)) v) Step 40: Apply tactic: mull_commut Step 41: Apply tactic: constructor Step 42: Apply tactic: - TrivialExists Step 43: Apply tactic: { econstructor Step 44: Solve automatically using known facts", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_mullimm", "draft": "Require Import Coq.Lists.List.\nLemma eval_mullimm : forall (A : Type) (n : A), unary_constructor_sound (mullimm n) (fun v => Val.mull v (Vlong n)).\nProof. apply eval_mullimm. Qed.", "nl_proof": "Step 1: We need to prove that forall n, unary_constructor_sound (mullimm n) (fun v => Val Step 2: We need to prove that forall n, unary_constructor_sound (mullimm n) (fun v => Val Step 3: We need to prove that forall n, unary_constructor_sound (mullimm n) (fun v => Val Step 4: We need to prove that forall n, unary_constructor_sound (mullimm n) (fun x => Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Introduce variables and assumptions Step 12: Apply tactic: red Step 13: Case analysis by destructing a value Step 14: Apply tactic: red Step 15: Apply tactic: red Step 16: Introduce variables and assumptions Step 17: Split a conjunction into separate goals Step 18: Introduce variables and assumptions Step 19: Introduce variables and assumptions Step 20: Unfold a definition Step 21: Apply tactic: eapply SplitLongproof Step 22: Case analysis by destructing a value Step 23: Case analysis by destructing a value Step 24: Apply tactic: predSpec Int64 Step 25: Apply tactic: eval_mullimm Step 26: Split a conjunction into separate goals Step 27: Split a conjunction into separate goals Step 28: Apply tactic: eq Int64 Step 29: Apply tactic: eauto Step 30: Apply tactic: eapply SplitLongproof Step 31: Apply tactic: eapply SplitLongproof Step 32: Apply tactic: eq_spec n Int64 Step 33: Apply tactic: red Step 34: Apply tactic: eval_mullimm Step 35: Apply tactic: eval_mullimm Step 36: Apply tactic: zero Step 37: Introduce variables and assumptions Step 38: Apply tactic: eauto Step 39: Apply tactic: eauto Step 40: Introduce variables and assumptions Step 41: Apply tactic: predSpec Int64 Step 42: Apply tactic: predSpec Int64 Step 43: Apply tactic: predSpec Int64 Step 44: Provide an existential witness", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_mull", "draft": "Require Import Coq.Integers.Int.\nLemma eval_mull : forall (a b : val), binary_constructor_sound mull Val.mull.\nProof.\n  red; intros.\n  destruct a; destruct b; try discriminate.\n  split; intros.\n  - apply eval_mull_base; auto.\n  - rewrite Val.mull_commut.\n    apply eval_mull_base; auto.\nQed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound mull Val Step 2: We need to prove that binary_constructor_sound mull Val Step 3: We need to prove that binary_constructor_sound mull Val Step 4: We need to prove that binary_constructor_sound mull Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Apply tactic: red Step 9: Case analysis by destructing a value Step 10: Case analysis by destructing a value Step 11: Case analysis by destructing a value Step 12: Introduce variables and assumptions Step 13: Split a conjunction into separate goals Step 14: Split a conjunction into separate goals Step 15: Split a conjunction into separate goals Step 16: Unfold a definition Step 17: Apply a theorem or hypothesis Step 18: Apply a theorem or hypothesis Step 19: Apply a theorem or hypothesis Step 20: Apply tactic: case (mull_match a b) Step 21: Apply tactic: eval_mull Step 22: Apply tactic: eval_mull Step 23: Apply tactic: eval_mull Step 24: Introduce variables and assumptions Step 25: Solve automatically using known facts Step 26: Solve automatically using known facts Step 27: Solve automatically using known facts Step 28: Apply tactic: InvEval Step 29: Apply tactic: red Step 30: Apply tactic: red Step 31: Apply tactic: red Step 32: Apply tactic: subst Step 33: Introduce variables and assumptions Step 34: Introduce variables and assumptions Step 35: Introduce variables and assumptions Step 36: Apply tactic: - rewrite Val Step 37: Case analysis by destructing a value Step 38: Case analysis by destructing a value Step 39: Case analysis by destructing a value Step 40: Apply tactic: mull_commut Step 41: Apply tactic: - exploit (eval_mullimm n1) Step 42: Apply tactic: InvEval Step 43: Apply tactic: InvEval Step 44: Apply a theorem or hypothesis", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_mullhu", "draft": "Require Import Coq.Integers.Int.\nRequire Import compcert.backend.SelectLong.\nRequire Import compcert.lib.Integers.\n\nLemma eval_mullhu : forall (A : Type) (n : A), unary_constructor_sound (fun a => mullhu a n) (fun v => Val.mullhu v (Vlong n)).\nProof. apply eval_mullhu. Qed.", "nl_proof": "Step 1: We need to prove that forall n, unary_constructor_sound (fun a => mullhu a n) (fun v => Val Step 2: We need to prove that forall n, unary_constructor_sound (fun a => mullhu a n) (fun v => Val Step 3: We need to prove that forall n, unary_constructor_sound (fun a => mullhu a n) (fun v => Val Step 4: We need to prove that forall n, unary_constructor_sound (fun a => mullhu a n) (fun v => Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Unfold a definition Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Introduce variables and assumptions Step 12: Apply tactic: red Step 13: Case analysis by destructing a value Step 14: Case analysis by destructing a value Step 15: Case analysis by destructing a value Step 16: Introduce variables and assumptions Step 17: Split a conjunction into separate goals Step 18: Split a conjunction into separate goals Step 19: Split a conjunction into separate goals Step 20: Solve automatically using known facts Step 21: Apply a theorem or hypothesis Step 22: Apply a theorem or hypothesis Step 23: Apply a theorem or hypothesis Step 24: Apply tactic: Qed Step 25: Apply tactic: eval_mullhu Step 26: Apply tactic: eval_mullhu Step 27: Apply tactic: eval_mullhu Step 28: Solve automatically using known facts Step 29: Solve automatically using known facts Step 30: Solve automatically using known facts Step 31: Apply tactic: red Step 32: Apply tactic: red Step 33: Apply tactic: red Step 34: Introduce variables and assumptions Step 35: Introduce variables and assumptions Step 36: Introduce variables and assumptions Step 37: Solve automatically using known facts Step 38: Solve automatically using known facts Step 39: Solve automatically using known facts", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_mullhs", "draft": "Require Import Coq.Integers.Int.\nRequire Import compcert.backend.SelectLong.\nRequire Import compcert.common.Values.\n\nLemma eval_mullhs : forall (A : Type) (n : A), unary_constructor_sound (fun a => mullhs a n) (fun v => Val.mullhs v (Vlong n)).\nProof. apply eval_mullhs. Qed.", "nl_proof": "Step 1: We need to prove that forall n, unary_constructor_sound (fun a => mullhs a n) (fun v => Val Step 2: We need to prove that forall n, unary_constructor_sound (fun a => mullhs a n) (fun v => Val Step 3: We need to prove that forall n, unary_constructor_sound (fun a => mullhs a n) (fun v => Val Step 4: We need to prove that forall n, unary_constructor_sound (fun a => mullhs a n) (fun v => Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Unfold a definition Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Introduce variables and assumptions Step 12: Apply tactic: red Step 13: Case analysis by destructing a value Step 14: Case analysis by destructing a value Step 15: Case analysis by destructing a value Step 16: Introduce variables and assumptions Step 17: Split a conjunction into separate goals Step 18: Split a conjunction into separate goals Step 19: Split a conjunction into separate goals Step 20: Solve automatically using known facts Step 21: Apply a theorem or hypothesis Step 22: Apply a theorem or hypothesis Step 23: Apply a theorem or hypothesis Step 24: Apply tactic: Qed Step 25: Apply tactic: eval_mullhs Step 26: Apply tactic: eval_mullhs Step 27: Apply tactic: eval_mullhs Step 28: Solve automatically using known facts Step 29: Solve automatically using known facts Step 30: Solve automatically using known facts Step 31: Apply tactic: red Step 32: Apply tactic: red Step 33: Apply tactic: red Step 34: Introduce variables and assumptions Step 35: Introduce variables and assumptions Step 36: Introduce variables and assumptions Step 37: Solve automatically using known facts Step 38: Solve automatically using known facts Step 39: Solve automatically using known facts", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_shrxlimm", "draft": "```coq\nRequire Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nRequire Import compcert.common.Values.\nRequire Import compcert.lib.Integers.\n\nLemma eval_shrximm_template : forall ge sp e m le a n x z,\n  eval_expr ge sp e m le a x ->\n  Val.shrx x (Vint n) = Some z ->\n  exists v, eval_expr ge sp e m le (shrximm a n) v /\\ Val.lessdef z v.\nProof.\n  intros ge sp e m le a n x z H H0.\n  eapply eval_shrximm; eauto.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a n x z, eval_expr ge sp e m le a x -> Val Step 2: We need to prove that forall le a n x z, eval_expr ge sp e m le a x -> Val Step 3: We need to prove that forall le a n x z, eval_expr ge sp e m le a x -> Val Step 4: We need to prove that forall le a n x z, eval_expr ge sp e m le a x -> Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Introduce variables and assumptions Step 12: Unfold a definition Step 13: Case analysis by destructing a value Step 14: Case analysis by destructing a value Step 15: Case analysis by destructing a value Step 16: Apply tactic: predSpec Int Step 17: Split a conjunction into separate goals Step 18: Split a conjunction into separate goals Step 19: Split a conjunction into separate goals Step 20: Apply tactic: eq Int Step 21: Apply tactic: eapply SplitLongproof Step 22: Apply tactic: + eapply SplitLongproof Step 23: Apply tactic: + eapply SplitLongproof Step 24: Apply tactic: eq_spec n Int Step 25: Apply tactic: eval_shrxlimm Step 26: Apply tactic: eval_shrxlimm Step 27: Apply tactic: eval_shrxlimm Step 28: Apply tactic: zero Step 29: Apply tactic: eauto Step 30: Apply tactic: eauto using Archi Step 31: Apply tactic: eauto using Archi Step 32: Apply tactic: - subst n Step 33: Apply tactic: predSpec Int Step 34: Split a conjunction into separate goals Step 35: Split a conjunction into separate goals Step 36: Provide an existential witness Step 37: Apply tactic: eq Int Step 38: Apply tactic: + predSpec Int Step 39: Apply tactic: + predSpec Int Step 40: Split a conjunction into separate goals Step 41: Apply tactic: eq_spec n Int Step 42: Apply tactic: eq Int Step 43: Apply tactic: eq Int Step 44: Solve automatically using known facts", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_divls_base", "draft": "Require Import Coq.Arith.Arith.\nRequire Import compcert.lib.Integers.\nRequire Import compcert.lib.Floats.\nRequire Import compcert.lib.Maps.\nRequire Import compcert.common.AST.\nRequire Import compcert.common.Values.\nRequire Import compcert.common.Memory.\nRequire Import compcert.common.Events.\nRequire Import compcert.common.Globalenvs.\nRequire Import compcert.x86.Asm.\n\nLemma eval_divls_base_sound : partial_binary_constructor_sound divls_base Val.divls.\nProof. apply eval_divls_base. Qed.", "nl_proof": "Step 1: We need to prove that partial_binary_constructor_sound divls_base Val Step 2: We need to prove that partial_binary_constructor_sound divls_base Val Step 3: We need to prove that partial_binary_constructor_sound divls_base Val Step 4: We need to prove that partial_binary_constructor_sound divls_base Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Apply tactic: red Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Unfold a definition Step 17: Case analysis by destructing a value Step 18: Case analysis by destructing a value Step 19: Case analysis by destructing a value Step 20: Solve automatically using known facts Step 21: Split a conjunction into separate goals Step 22: Split a conjunction into separate goals Step 23: Split a conjunction into separate goals Step 24: Apply tactic: Qed Step 25: Apply tactic: eapply SplitLongproof Step 26: Apply tactic: eapply SplitLongproof Step 27: Apply tactic: eapply SplitLongproof Step 28: Apply tactic: eval_divls_base Step 29: Apply tactic: eval_divls_base Step 30: Apply tactic: eval_divls_base Step 31: Apply tactic: eauto Step 32: Apply tactic: eauto Step 33: Apply tactic: eauto Step 34: Solve automatically using known facts Step 35: Solve automatically using known facts Step 36: Solve automatically using known facts Step 37: Apply tactic: Qed Step 38: Apply tactic: Qed Step 39: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_modl_aux", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_modl_aux : forall (ge : genv) (sp : val) (e : env) (m : mem) (divop : operation) (semdivop : val -> val -> option val),\n  (forall (sp0 : val) (x y : val) (m0 : mem), eval_operation ge sp0 divop (x :: y :: nil) m0 = semdivop x y) ->\n  forall (le : letenv) (a b : expr) (x y z : val),\n  eval_expr ge sp e m le a x ->\n  eval_expr ge sp e m le b y ->\n  semdivop x y = Some z ->\n  eval_expr ge sp e m le (modl_aux divop a b) (Val.subl x (Val.mull z y)).\nProof.\n  intros ge sp e m divop semdivop H le a b x y z H0 H1 H2.\n  unfold modl_aux.\n  eapply eval_Elet.\n  eexact H0.\n  eapply eval_Elet.\n  eexact H1.\n  eapply eval_Eop.\n  eapply eval_Econs.\n  eapply eval_Eletvar.\n  simpl. reflexivity.\n  eapply eval_Econs.\n  eapply eval_Eletvar.\n  simpl. reflexivity.\n  apply eval_Enil.\n  rewrite H.\n  rewrite H2.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall divop semdivop, (forall sp x y m, eval_operation ge sp divop (x :: y :: nil) m = semdivop x y) -> forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> semdivop x y = Some z -> eval_expr ge sp e m le (modl_aux divop a b) (Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: eapply eval_Elet Step 5: Apply tactic: eexact H0 Step 6: Apply tactic: eapply eval_Elet Step 7: Apply a theorem or hypothesis Step 8: Apply tactic: eexact H1 Step 9: Apply tactic: eapply eval_Eop Step 10: Apply tactic: eapply eval_Econs Step 11: Apply tactic: eapply eval_Eletvar", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_modls_base", "draft": "Require Import Coq.Lists.List. Import ListNotations.\nRequire Import Coq.ZArith.ZArith.\n\nLemma modls_base_sound : forall (ge sp e : nat) (a b : Z) (v : val),\n  (b <> 0)%Z -> (a <> Z.opp (Z.pow 2 63))%Z -> eval_expr ge sp e (modls_base a b) v -> Val.lessdef (Val.maketotal (Val.modls (Vlong (Int64.repr a)) (Vlong (Int64.repr b)))) v.\nProof.\n  intros ge sp e a b v Hneq0 Hneqmin Heval.\n  unfold modls_base in Heval.\n  destruct (zeq b (-1)) eqn:Heq.\n  - rewrite Heq in *.\n    simpl.\n    eapply eval_modls_base; eauto.\n  - eapply eval_modls_base; eauto.\nQed.", "nl_proof": "Step 1: n1 mod n2, n2 = 0 Step 2: signed_min mod n2 | n2 != 0, n2 !- =1 Step 3: n1 mod -1, n1 !- signed_min Step 4: other valid cases Step 5: fallback Step 6: We need to prove that partial_binary_constructor_sound modls_base Val Step 7: We need to prove that partial_binary_constructor_sound modls_base Val Step 8: We need to prove that partial_binary_constructor_sound modls_base Val Step 9: We need to prove that partial_binary_constructor_sound modls_base Val Step 10: Unfold a definition Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Apply tactic: red Step 14: Apply tactic: red Step 15: Apply tactic: red Step 16: Apply tactic: red Step 17: Introduce variables and assumptions Step 18: Introduce variables and assumptions Step 19: Introduce variables and assumptions Step 20: Introduce variables and assumptions Step 21: Unfold a definition Step 22: Case analysis by destructing a value Step 23: Case analysis by destructing a value Step 24: Case analysis by destructing a value Step 25: Apply tactic: exploit Val Step 26: Split a conjunction into separate goals Step 27: Split a conjunction into separate goals Step 28: Split a conjunction into separate goals Step 29: Apply tactic: modls_divls Step 30: Apply tactic: eapply SplitLongproof Step 31: Apply tactic: eapply SplitLongproof Step 32: Apply tactic: eapply SplitLongproof Step 33: Apply tactic: eauto Step 34: Apply tactic: eval_modls_base Step 35: Apply tactic: eval_modls_base Step 36: Apply tactic: eval_modls_base Step 37: Introduce variables and assumptions Step 38: Apply tactic: eauto Step 39: Apply tactic: eauto Step 40: Apply tactic: eauto Step 41: Apply tactic: subst z Step 42: Apply tactic: assert (DEFAULT: exists v : val, eval_expr ge sp e Step 43: Solve automatically using known facts Step 44: Solve automatically using known facts Step 45: Solve automatically using known facts Step 46: Apply tactic: lessdef z v) Step 47: Apply tactic: Qed Step 48: Apply tactic: Qed Step 49: Apply tactic: repeat (econstructor", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_divlu_base", "draft": "Require Import Coq.Arith.Arith.\nRequire Import compcert.lib.Integers.\nRequire Import compcert.lib.Floats.\nRequire Import compcert.lib.Maps.\nRequire Import compcert.common.Values.\nRequire Import compcert.x86.Asm.\n\nLemma eval_divlu_base : partial_binary_constructor_sound divlu_base Val.divlu.\nProof.\n  red; intros; unfold divlu_base.\n  eapply SplitLongproof.eval_longuoffloat; eauto.\n  eapply SplitLongproof.eval_divf; eauto.\n  eapply SplitLongproof.eval_floatoflongu; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that partial_binary_constructor_sound divlu_base Val Step 2: We need to prove that partial_binary_constructor_sound divlu_base Val Step 3: We need to prove that partial_binary_constructor_sound divlu_base Val Step 4: We need to prove that partial_binary_constructor_sound divlu_base Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Apply tactic: red Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Unfold a definition Step 17: Case analysis by destructing a value Step 18: Case analysis by destructing a value Step 19: Case analysis by destructing a value Step 20: Solve automatically using known facts Step 21: Split a conjunction into separate goals Step 22: Split a conjunction into separate goals Step 23: Split a conjunction into separate goals Step 24: Apply tactic: Qed Step 25: Apply tactic: eapply SplitLongproof Step 26: Apply tactic: eapply SplitLongproof Step 27: Apply tactic: eapply SplitLongproof Step 28: Apply tactic: eval_divlu_base Step 29: Apply tactic: eval_divlu_base Step 30: Apply tactic: eval_divlu_base Step 31: Apply tactic: eauto Step 32: Apply tactic: eauto Step 33: Apply tactic: eauto Step 34: Solve automatically using known facts Step 35: Solve automatically using known facts Step 36: Solve automatically using known facts Step 37: Apply tactic: Qed Step 38: Apply tactic: Qed Step 39: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_modlu_base", "draft": "Require Import Coq.Lists.List.\nLemma partial_binary_constructor_sound_modlu_base : forall (ge sp e : nat) (v1 v2 z : nat),\n  (exists v : nat, v = z) -> z = v1 mod v2.\nProof.\n  intros. destruct H. subst. reflexivity.\nQed.", "nl_proof": "Step 1: n1 and n2 are longconsts Step 2: n1 no longconst, n2 is longconst Step 3: n2 is power of 2 Step 4: We need to prove that partial_binary_constructor_sound modlu_base Val Step 5: We need to prove that partial_binary_constructor_sound modlu_base Val Step 6: We need to prove that partial_binary_constructor_sound modlu_base Val Step 7: We need to prove that partial_binary_constructor_sound modlu_base Val Step 8: Unfold a definition Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Apply tactic: red Step 12: Apply tactic: red Step 13: Apply tactic: red Step 14: Apply tactic: red Step 15: Introduce variables and assumptions Step 16: Introduce variables and assumptions Step 17: Introduce variables and assumptions Step 18: Introduce variables and assumptions Step 19: Unfold a definition Step 20: Case analysis by destructing a value Step 21: Case analysis by destructing a value Step 22: Case analysis by destructing a value Step 23: Apply tactic: exploit Val Step 24: Split a conjunction into separate goals Step 25: Split a conjunction into separate goals Step 26: Split a conjunction into separate goals Step 27: Apply tactic: modlu_divlu Step 28: Apply tactic: eapply SplitLongproof Step 29: Apply tactic: eapply SplitLongproof Step 30: Apply tactic: eapply SplitLongproof Step 31: Apply tactic: eauto Step 32: Apply tactic: eval_modlu_base Step 33: Apply tactic: eval_modlu_base Step 34: Apply tactic: eval_modlu_base Step 35: Introduce variables and assumptions Step 36: Apply tactic: eauto Step 37: Apply tactic: eauto Step 38: Apply tactic: eauto Step 39: Apply tactic: subst z Step 40: Apply tactic: assert (DEFAULT: exists v : val, eval_expr ge sp e Step 41: Solve automatically using known facts Step 42: Solve automatically using known facts Step 43: Solve automatically using known facts Step 44: Apply tactic: lessdef z v) Step 45: Apply tactic: Qed Step 46: Apply tactic: Qed Step 47: Apply tactic: repeat (econstructor", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_cmplu", "draft": "Require Import Coq.Lists.List.\nTheorem eval_cmplu : forall (c : comparison) (le : list (ident * val)) (a b : expr) (x y v : val),\n  eval_expr ge sp e m le a x ->\n  eval_expr ge sp e m le b y ->\n  Val.cmplu (Mem.valid_pointer m) c x y = Some v ->\n  eval_expr ge sp e m le (cmplu c a b) v.\nProof.\n  intros. eapply eval_cmplu; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall c le a x b y v, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 2: We need to prove that forall c le a x b y v, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 3: We need to prove that forall c le a x b y v, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 4: We need to prove that forall c le a x b y v, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Introduce variables and assumptions Step 12: Unfold a definition Step 13: Case analysis by destructing a value Step 14: Case analysis by destructing a value Step 15: Case analysis by destructing a value Step 16: Apply tactic: case (cmplu_match a b) Step 17: Split a conjunction into separate goals Step 18: Split a conjunction into separate goals Step 19: Split a conjunction into separate goals Step 20: Introduce variables and assumptions Step 21: Apply tactic: eapply SplitLongproof Step 22: Apply tactic: eapply SplitLongproof Step 23: Apply tactic: eapply SplitLongproof Step 24: Apply tactic: InvEval Step 25: Apply tactic: eval_cmplu Step 26: Apply tactic: eval_cmplu Step 27: Apply tactic: eval_cmplu Step 28: Apply tactic: subst Step 29: Apply tactic: eauto using Archi Step 30: Apply tactic: eauto using Archi Step 31: Apply tactic: eauto using Archi Step 32: Apply tactic: - apply eval_complimm_swap with (sem := Val Step 33: Split a conjunction into separate goals Step 34: Split a conjunction into separate goals Step 35: Split a conjunction into separate goals Step 36: Apply tactic: cmplu (Mem Step 37: Unfold a definition Step 38: Unfold a definition Step 39: Unfold a definition Step 40: Apply tactic: valid_pointer m)) (x := y) Step 41: Apply tactic: cmplu in H1 Step 42: Apply tactic: cmplu in H1 Step 43: Apply tactic: cmplu in H1 Step 44: Solve automatically using known facts", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_cmpl", "draft": "```coq\nRequire Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma eval_cmpl_generalized : forall (ge : Type) (sp : nat) (e : list nat) (m : nat) (le : list nat) (c : nat) (a b : nat) (x y v : nat),\n  eval_expr ge sp e m le a x ->\n  eval_expr ge sp e m le b y ->\n  Val.cmpl c x y = Some v ->\n  eval_expr ge sp e m le (cmpl c a b) v.\nProof.\n  intros.\n  eapply eval_cmpl; eauto.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall c le a x b y v, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 2: We need to prove that forall c le a x b y v, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 3: We need to prove that forall c le a x b y v, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 4: We need to prove that forall c le a x b y v, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Introduce variables and assumptions Step 12: Unfold a definition Step 13: Case analysis by destructing a value Step 14: Case analysis by destructing a value Step 15: Case analysis by destructing a value Step 16: Apply tactic: case (cmpl_match a b) Step 17: Split a conjunction into separate goals Step 18: Split a conjunction into separate goals Step 19: Split a conjunction into separate goals Step 20: Introduce variables and assumptions Step 21: Apply tactic: eapply SplitLongproof Step 22: Apply tactic: eapply SplitLongproof Step 23: Apply tactic: eapply SplitLongproof Step 24: Apply tactic: InvEval Step 25: Apply tactic: eval_cmpl Step 26: Apply tactic: eval_cmpl Step 27: Apply tactic: eval_cmpl Step 28: Apply tactic: subst Step 29: Apply tactic: eauto Step 30: Apply tactic: eauto Step 31: Apply tactic: eauto Step 32: Apply tactic: - apply eval_complimm_swap with (sem := Val Step 33: Unfold a definition Step 34: Unfold a definition Step 35: Unfold a definition Step 36: Apply tactic: cmpl) (x := y) Step 37: Apply tactic: cmpl in H1 Step 38: Apply tactic: cmpl in H1 Step 39: Apply tactic: cmpl in H1 Step 40: Solve automatically using known facts Step 41: Case analysis by destructing a value Step 42: Case analysis by destructing a value Step 43: Case analysis by destructing a value Step 44: Introduce variables and assumptions", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_longoffloat", "draft": "Require Import Coq.Lists.List.\nRequire Import compcert.lib.Integers.\nRequire Import compcert.lib.Floats.\nRequire Import compcert.common.Values.\nRequire Import compcert.cfrontend.Csharpminor.\n\nLemma partial_unary_constructor_sound_longoffloat : forall (ge: genv) (sp: val) (e: env) (m: mem) (le: temp_env) (a: expr) (x y: val),\n  eval_expr ge sp e m le a x ->\n  Val.longoffloat x = Some y ->\n  exists v, eval_expr ge sp e m le (longoffloat a) v /\\ Val.lessdef y v.\nProof.\n  intros ge sp e m le a x y H H0.\n  eapply eval_longoffloat; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 2: We need to prove that partial_unary_constructor_sound longoffloat Val Step 3: We need to prove that partial_unary_constructor_sound longoffloat Val Step 4: We need to prove that partial_unary_constructor_sound longoffloat Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Apply tactic: red Step 9: Introduce variables and assumptions Step 10: Apply tactic: red Step 11: Apply tactic: red Step 12: Introduce variables and assumptions Step 13: Case analysis by destructing a value Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Solve automatically using known facts Step 17: Split a conjunction into separate goals Step 18: Case analysis by destructing a value Step 19: Case analysis by destructing a value Step 20: Apply tactic: Qed Step 21: Apply tactic: eapply SplitLongproof Step 22: Split a conjunction into separate goals Step 23: Split a conjunction into separate goals Step 24: Apply tactic: eval_longoffloat Step 25: Apply tactic: eapply SplitLongproof Step 26: Apply tactic: eapply SplitLongproof Step 27: Apply tactic: eauto Step 28: Apply tactic: eval_longoffloat Step 29: Apply tactic: eval_longoffloat Step 30: Solve automatically using known facts Step 31: Apply tactic: eauto Step 32: Apply tactic: eauto Step 33: Apply tactic: Qed Step 34: Solve automatically using known facts Step 35: Solve automatically using known facts Step 36: Apply tactic: Qed Step 37: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_floatoflong", "draft": "Require Import Coq.Lists.List.\nRequire Import compcert.lib.Integers.\nRequire Import compcert.lib.Floats.\nRequire Import compcert.lib.Maps.\nRequire Import compcert.common.AST.\nRequire Import compcert.common.Values.\nRequire Import compcert.cfrontend.Ctypes.\nRequire Import compcert.cfrontend.Clight.\nRequire Import compcert.x86.Asm.\nRequire Import compcert.common.Errors.\nRequire Import compcert.common.Globalenvs.\nRequire Import compcert.lib.Maps.\n\nLemma partial_unary_constructor_sound_floatoflong : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : temp_env) (a : expr) (x : val),\n  eval_expr ge sp e m le a x ->\n  exists v : val, eval_expr ge sp e m le (floatoflong a) v /\\ Val.lessdef (Val.floatoflong x) v.\nProof.\n  intros ge sp e m le a x H.\n  unfold floatoflong.\n  eapply eval_splitlong; eauto.\n  intros le0 a1 a2 x1 x2 H1 H2.\n  destruct x1; try discriminate.\n  destruct x2; try discriminate.\n  simpl.\n  exists (Vfloat (Float.of_long (Int64.ofwords i i0))).\n  split.\n  - econstructor; eauto.\n  - intros p q H3 H4.\n    inversion H3; subst.\n    inversion H4; subst.\n    reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 2: We need to prove that partial_unary_constructor_sound floatoflong Val Step 3: We need to prove that partial_unary_constructor_sound floatoflong Val Step 4: We need to prove that partial_unary_constructor_sound floatoflong Val Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Apply tactic: red Step 9: Introduce variables and assumptions Step 10: Apply tactic: red Step 11: Apply tactic: red Step 12: Introduce variables and assumptions Step 13: Case analysis by destructing a value Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Solve automatically using known facts Step 17: Split a conjunction into separate goals Step 18: Case analysis by destructing a value Step 19: Case analysis by destructing a value Step 20: Apply tactic: Qed Step 21: Apply tactic: eapply SplitLongproof Step 22: Split a conjunction into separate goals Step 23: Split a conjunction into separate goals Step 24: Apply tactic: eval_floatoflong Step 25: Apply tactic: eapply SplitLongproof Step 26: Apply tactic: eapply SplitLongproof Step 27: Apply tactic: eauto Step 28: Apply tactic: eval_floatoflong Step 29: Apply tactic: eval_floatoflong Step 30: Solve automatically using known facts Step 31: Apply tactic: eauto Step 32: Apply tactic: eauto Step 33: Apply tactic: Qed Step 34: Solve automatically using known facts Step 35: Solve automatically using known facts Step 36: Apply tactic: Qed Step 37: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectLongproof:eval_longofsingle", "draft": "```coq\nRequire Import Coq.Arith.Arith.\nLemma partial_unary_constructor_sound_longofsingle : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : temp_env) (a : expr) (x : val),\n  eval_expr ge sp e m le a x ->\n  exists v, eval_expr ge sp e m le (longofsingle a) v /\\ Val.lessdef (Val.longofsingle x) v.\nProof.\n  intros ge sp e m le a x H.\n  unfold longofsingle.\n  red.\n  intros.\n  destruct x; try discriminate.\n  destruct f; try discriminate.\n  simpl.\n  destruct (Float32.to_long f) as [n|] eqn:EQ; simpl.\n  - exists (Vlong n). split.\n    + eapply eval_longofsingle; eauto.\n    + red; auto.\n  - exists Vundef. split.\n    + eapply eval_longofsingle; eauto.\n    + red; auto.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 2: We need to prove that partial_unary_constructor_sound longofsingle Val Step 3: We need to prove that partial_unary_constructor_sound longofsingle Val Step 4: We need to prove that partial_unary_constructor_sound longofsingle Val Step 5: Introduce variables and assumptions Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Apply tactic: red Step 9: Unfold a definition Step 10: Apply tactic: red Step 11: Apply tactic: red Step 12: Introduce variables and assumptions Step 13: Case analysis by destructing a value Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Solve automatically using known facts Step 17: Simplify the goal by computation Step 18: Case analysis by destructing a value Step 19: Case analysis by destructing a value Step 20: Apply tactic: Qed Step 21: Apply tactic: inv H0 Step 22: Split a conjunction into separate goals Step 23: Split a conjunction into separate goals Step 24: Case analysis by destructing a value Step 25: Apply tactic: eapply SplitLongproof Step 26: Apply tactic: eapply SplitLongproof Step 27: Apply tactic: to_long f) as [n|] eqn:EQ Step 28: Apply tactic: eval_longofsingle Step 29: Apply tactic: eval_longofsingle Step 30: Simplify the goal by computation Step 31: Apply tactic: eauto Step 32: Apply tactic: eauto Step 33: Apply tactic: inv H2 Step 34: Solve automatically using known facts Step 35: Solve automatically using known facts Step 36: Apply tactic: exploit eval_floatofsingle Step 37: Apply tactic: Qed Step 38: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Conventions1:loc_result_type", "draft": "Require Import Coq.Lists.List.\nLemma loc_result_type : forall (A : Type) (sig : A), subtype (proj_sig_res sig) (typ_rpair mreg_type (loc_result sig)) = true.\nProof. destruct sig; simpl; auto. Qed.", "nl_proof": "Step 1: We need to prove that forall sig, subtype (proj_sig_res sig) (typ_rpair mreg_type (loc_result sig)) = true Step 2: We need to prove that forall sig, subtype (proj_sig_res sig) (typ_rpair mreg_type (loc_result sig)) = true Step 3: We need to prove that forall sig, subtype (proj_sig_res sig) (typ_rpair mreg_type (loc_result sig)) = true Step 4: We need to prove that forall sig, subtype (proj_sig_res sig) (typ_rpair mreg_type (loc_result sig)) = true Step 5: We need to prove that forall sig, subtype (proj_sig_res sig) (typ_rpair mreg_type (loc_result sig)) = true Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Case analysis by destructing a value Step 17: Case analysis by destructing a value Step 18: Case analysis by destructing a value Step 19: Case analysis by destructing a value Step 20: Case analysis by destructing a value Step 21: Apply tactic: ptr64 eqn:? Step 22: Apply tactic: ptr64 Step 23: Case analysis by destructing a value Step 24: Solve automatically using known facts Step 25: Solve automatically using known facts Step 26: Case analysis by destructing a value Step 27: Case analysis by destructing a value Step 28: Apply tactic: big_endian Step 29: Case analysis by destructing a value Step 30: Apply tactic: Qed Step 31: Case analysis by destructing a value Step 32: Solve automatically using known facts Step 33: Solve automatically using known facts Step 34: Apply tactic: ptr64 Step 35: Apply tactic: ppc64 Step 36: Apply tactic: Qed Step 37: Apply tactic: Qed Step 38: Solve automatically using known facts Step 39: Simplify the goal by computation Step 40: Apply tactic: Qed Step 41: Solve automatically using known facts Step 42: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Conventions1:loc_result_caller_save", "draft": "Require Import Coq.Lists.List.\nLemma loc_result_no_callee_save : forall (s : signature), forall_rpair (fun r => is_callee_save r = false) (loc_result s).\nProof.\n  intros s.\n  unfold loc_result.\n  destruct (sig_res s) as [|[]]; simpl; auto.\n  destruct t; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64; simpl; auto.\n  destruct ptr64.\nQed.", "nl_proof": "Step 1: We need to prove that forall (s: signature), forall_rpair (fun r => is_callee_save r = false) (loc_result s) Step 2: We need to prove that forall (s: signature), forall_rpair (fun r => is_callee_save r = false) (loc_result s) Step 3: We need to prove that forall (s: signature), forall_rpair (fun r => is_callee_save r = false) (loc_result s) Step 4: We need to prove that forall (s: signature), forall_rpair (fun r => is_callee_save r = false) (loc_result s) Step 5: We need to prove that forall (s: signature), forall_rpair (fun r => is_callee_save r = false) (loc_result s) Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Case analysis by destructing a value Step 17: Case analysis by destructing a value Step 18: Case analysis by destructing a value Step 19: Case analysis by destructing a value Step 20: Case analysis by destructing a value Step 21: Apply tactic: ptr64 Step 22: Apply tactic: ptr64 Step 23: Case analysis by destructing a value Step 24: Simplify the goal by computation Step 25: Simplify the goal by computation Step 26: Case analysis by destructing a value Step 27: Case analysis by destructing a value Step 28: Apply tactic: big_endian Step 29: Solve automatically using known facts Step 30: Solve automatically using known facts Step 31: Simplify the goal by computation Step 32: Simplify the goal by computation Step 33: Simplify the goal by computation Step 34: Case analysis by destructing a value Step 35: Apply tactic: Qed Step 36: Solve automatically using known facts Step 37: Solve automatically using known facts Step 38: Solve automatically using known facts Step 39: Apply tactic: ptr64 Step 40: Apply tactic: Qed Step 41: Apply tactic: Qed Step 42: Apply tactic: Qed Step 43: Simplify the goal by computation Step 44: Solve automatically using known facts Step 45: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Conventions1:loc_result_pair", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma loc_result_pair : forall (A : Type) (sg : A),\n  match loc_result sg with\n  | One _ => True\n  | Twolong r1 r2 => r1 <> r2 /\\ proj_sig_res sg = Tlong /\\ subtype Tint (mreg_type r1) = true /\\ subtype Tint (mreg_type r2) = true /\\ Archi.ptr64 = false\n  end.\nProof.\n  intros sg.\n  unfold loc_result.\n  destruct (sig_res sg) as [[]|]; try exact I.\n  destruct Archi.ptr64; try exact I.\n  simpl.\n  repeat split; try discriminate; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall sg, match loc_result sg with | One _ => True | Twolong r1 r2 => r1 <> r2 /\\ proj_sig_res sg = Tlong /\\ subtype Tint (mreg_type r1) = true /\\ subtype Tint (mreg_type r2) = true /\\ Archi Step 2: We need to prove that forall sg, match loc_result sg with | One _ => True | Twolong r1 r2 => r1 <> r2 /\\ proj_sig_res sg = Tlong /\\ subtype Tint (mreg_type r1) = true /\\ subtype Tint (mreg_type r2) = true /\\ Archi Step 3: We need to prove that forall sg, match loc_result sg with | One _ => True | Twolong r1 r2 => r1 <> r2 /\\ proj_sig_res sg = Tlong /\\ subtype Tint (mreg_type r1) = true /\\ subtype Tint (mreg_type r2) = true /\\ Archi Step 4: We need to prove that forall sg, match loc_result sg with | One _ => True | Twolong r1 r2 => r1 <> r2 /\\ proj_sig_res sg = Tlong /\\ subtype Tint (mreg_type r1) = true /\\ subtype Tint (mreg_type r2) = true /\\ Archi Step 5: We need to prove that forall sg, match loc_result sg with | One _ => True | Twolong r1 r2 => r1 <> r2 /\\ proj_sig_res sg = Tlong /\\ subtype Tint (mreg_type r1) = true /\\ subtype Tint (mreg_type r2) = true /\\ Archi Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Case analysis by destructing a value Step 17: Case analysis by destructing a value Step 18: Case analysis by destructing a value Step 19: Case analysis by destructing a value Step 20: Case analysis by destructing a value Step 21: Apply tactic: ptr64 Step 22: Apply tactic: ptr64 Step 23: Solve automatically using known facts Step 24: Solve automatically using known facts Step 25: Apply tactic: exact I Step 26: Case analysis by destructing a value Step 27: Case analysis by destructing a value Step 28: Case analysis by destructing a value Step 29: Unfold a definition Step 30: Apply tactic: Qed Step 31: Case analysis by destructing a value Step 32: Solve automatically using known facts Step 33: Apply tactic: big_endian Step 34: Case analysis by destructing a value Step 35: Apply tactic: ppc64 Step 36: Split a conjunction into separate goals Step 37: Apply tactic: intuition congruence Step 38: Apply tactic: ptr64 Step 39: Simplify the goal by computation Step 40: Solve automatically using known facts Step 41: Apply tactic: Qed Step 42: Solve automatically using known facts Step 43: Solve automatically using known facts Step 44: Apply tactic: congruence Step 45: Split a conjunction into separate goals Step 46: Split a conjunction into separate goals Step 47: Apply tactic: Qed Step 48: Solve automatically using known facts", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Conventions1:loc_result_exten", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma map_id_polymorphic : forall (A : Type) (l : list A), map (fun (x : A) => x) l = l.\nProof. induction l; simpl; congruence. Qed.", "nl_proof": "Step 1: We need to prove that forall s1 s2, s1 Step 2: We need to prove that forall s1 s2, s1 Step 3: We need to prove that forall s1 s2, s1 Step 4: We need to prove that forall s1 s2, s1 Step 5: We need to prove that forall s1 s2, s1 Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Case analysis by destructing a value Step 17: Case analysis by destructing a value Step 18: Rewrite using an equality Step 19: Rewrite using an equality Step 20: Rewrite using an equality Step 21: Apply tactic: ptr64 Step 22: Apply tactic: ptr64 Step 23: Solve automatically using known facts Step 24: Solve automatically using known facts Step 25: Solve automatically using known facts Step 26: Rewrite using an equality Step 27: Rewrite using an equality Step 28: Apply tactic: Qed Step 29: Apply tactic: Qed Step 30: Apply tactic: Qed Step 31: Solve automatically using known facts Step 32: Solve automatically using known facts Step 33: Apply tactic: Qed Step 34: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Conventions1:loc_arguments_rec_charact", "draft": "```coq\nRequire Import Coq.ZArith.ZArith.\nRequire Import Coq.Lists.List.\n\nLemma loc_arguments_rec_charact : forall (tyl : list typ) (fixed : bool) (ri rf ofs : Z) (p : rpair loc),\n  ofs >= 0 -> In p (loc_arguments_rec tyl fixed ri rf ofs) -> forall_rpair loc_argument_acceptable p.\nProof.\n  intros tyl fixed ri rf ofs p Hofs Hin.\n  generalize dependent ri.\n  generalize dependent rf.\n  generalize dependent ofs.\n  induction tyl as [|ty tyl IH]; intros ofs rf ri Hofs Hin.\n  - simpl in Hin. contradiction.\n  - simpl in Hin.\n    destruct fixed.\n    + (* Case when fixed is true *)\n      destruct ty;\n      try (destruct (zle ri 0); [|destruct (zle rf 0)]);\n      try solve [destruct Hin as [Hin|Hin]; [apply Hin|apply IH; auto]].\n    + (* Case when fixed is false *)\n      destruct ty;\n      try (destruct (zle ri 0); [|destruct (zle rf 0)]);\n      try solve [destruct Hin as [Hin|Hin]; [apply Hin|apply IH; auto]].\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall tyl ir fr ofs p, In p (loc_arguments_rec tyl ir fr ofs) -> forall_rpair (loc_argument_charact ofs) p Step 2: We need to prove that forall va tyl ri rf ofs p, ofs >= 0 -> In p (loc_arguments_rec va tyl ri rf ofs) -> forall_rpair loc_argument_acceptable p Step 3: We need to prove that forall tyl fixed ri rf ofs p, ofs >= 0 -> In p (loc_arguments_rec tyl fixed ri rf ofs) -> forall_rpair loc_argument_acceptable p Step 4: Apply tactic: assert (X: forall ofs1 ofs2 l, loc_argument_charac Step 5: Apply tactic: set (OK := fun (l: list (rpair loc)) => Step 6: Apply tactic: set (OK := fun (l: list (rpair loc)) => Step 7: Apply tactic: { destruct l Step 8: Apply tactic: forall p, In p l -> forall_rpair loc_argument_acce Step 9: Apply tactic: forall p, In p l -> forall_rpair loc_argument_acce Step 10: Simplify the goal by computation Step 11: Apply tactic: set (OKF := fun (f: Z -> Z -> Z -> list (rpair loc Step 12: Apply tactic: set (OKF := fun (f: Z -> Z -> Z -> list (rpair loc Step 13: Introduce variables and assumptions Step 14: Apply tactic: forall ri rf ofs, ofs >= 0 -> OK (f ri rf ofs)) Step 15: Apply tactic: forall ri rf ofs, ofs >= 0 -> OK (f ri rf ofs)) Step 16: Solve automatically using known facts Step 17: Apply tactic: assert (CSI: forall r, In r int_param_regs -> is_c Step 18: Apply tactic: assert (CSI: forall r, In r int_param_regs -> is_c Step 19: Case analysis by destructing a value Step 20: Apply tactic: { decide_goal Step 21: Apply tactic: { decide_goal Step 22: Solve automatically using known facts Step 23: Apply tactic: assert (CSF: forall r, In r float_param_regs -> is Step 24: Apply tactic: assert (CSF: forall r, In r float_param_regs -> is Step 25: Apply tactic: intuition lia Step 26: Apply tactic: { decide_goal Step 27: Apply tactic: { decide_goal Step 28: Apply tactic: assert (Y: forall ofs1 ofs2 p, forall_rpair (loc_a Step 29: Apply tactic: assert (CSFX: forall r, In r float_extra_param_reg Step 30: Apply tactic: assert (ALP: forall ofs ty, ofs >= 0 -> align ofs Step 31: Apply tactic: { destruct p Step 32: Apply tactic: { decide_goal Step 33: Apply tactic: { intros", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Conventions1:loc_arguments_acceptable", "draft": "Require Import Coq.Lists.List.\nRequire Import Coq.ZArith.ZArith.\n\nLemma loc_arguments_acceptable : forall (s : signature) (p : rpair loc),\n  In p (loc_arguments s) -> forall_rpair loc_argument_acceptable p.\nProof.\n  intros s p IN.\n  unfold loc_arguments in IN.\n  destruct Archi.ptr64 eqn:PTR.\n  - destruct Archi.win64 eqn:WIN.\n    + apply loc_arguments_win64_charact in IN; auto.\n      intros r; unfold loc_argument_win64_charact, loc_argument_acceptable.\n      destruct r; auto.\n    + apply loc_arguments_elf64_charact in IN; auto.\n      intros r; unfold loc_argument_elf64_charact, loc_argument_acceptable.\n      destruct r; auto.\n  - apply loc_arguments_rec_charact in IN.\n    intros r; unfold loc_argument_charact, loc_argument_acceptable.\n    destruct r; auto.\nQed.", "nl_proof": "Step 1: WIN 64 bits Step 2: ELF 64 bits Step 3: We need to prove that forall (s: signature) (p: rpair loc), In p (loc_arguments s) -> forall_rpair loc_argument_acceptable p Step 4: We need to prove that forall (s: signature) (p: rpair loc), In p (loc_arguments s) -> forall_rpair loc_argument_acceptable p Step 5: We need to prove that forall (s: signature) (p: rpair loc), In p (loc_arguments s) -> forall_rpair loc_argument_acceptable p Step 6: We need to prove that forall (s: signature) (p: rpair loc), In p (loc_arguments s) -> forall_rpair loc_argument_acceptable p Step 7: We need to prove that forall (s: signature) (p: rpair loc), In p (loc_arguments s) -> forall_rpair loc_argument_acceptable p Step 8: Unfold a definition Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Introduce variables and assumptions Step 17: Introduce variables and assumptions Step 18: Apply tactic: exploit loc_arguments_rec_charact Step 19: Case analysis by destructing a value Step 20: Apply tactic: assert (X: forall l, loc_argument_charact 0 l -> l Step 21: Apply tactic: eapply loc_arguments_rec_charact Step 22: Apply tactic: eapply loc_arguments_rec_charact Step 23: Apply tactic: eauto Step 24: Apply tactic: ptr64 eqn:SF Step 25: Apply tactic: { unfold loc_argument_charact, loc_argument_accept Step 26: Apply tactic: eauto Step 27: Apply tactic: eauto Step 28: Apply tactic: assert (A: forall r, In r int_param_regs -> is_cal Step 29: Apply tactic: [destruct Archi Step 30: Case analysis by destructing a value Step 31: Apply tactic: lia Step 32: Apply tactic: lia Step 33: Apply tactic: assert (B: forall r, In r float_param_regs -> is_c Step 34: Apply tactic: win64 eqn:W64|] Step 35: Solve automatically using known facts Step 36: Apply tactic: Qed Step 37: Apply tactic: Qed Step 38: Apply tactic: assert (X: forall l, loc_argument_charact 0 l -> l Step 39: Apply tactic: assert (A: forall r, In r int_param_regs_win64 -> Step 40: Introduce variables and assumptions Step 41: Apply tactic: { unfold loc_argument_charact, loc_argument_accept Step 42: Rewrite using an equality Step 43: Split a conjunction into separate goals Step 44: Case analysis by destructing a value Step 45: Apply tactic: decide_goal) Step 46: Solve automatically using known facts Step 47: Solve automatically using known facts Step 48: Apply tactic: assert (B: forall r, In r float_param_regs_win64 - Step 49: Rewrite using an equality", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Conventions1:loc_arguments_main", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma loc_arguments_nil : forall (signature_main : Type), loc_arguments signature_main = nil.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that loc_arguments signature_main = nil Step 2: We need to prove that loc_arguments signature_main = nil Step 3: We need to prove that loc_arguments signature_main = nil Step 4: We need to prove that loc_arguments signature_main = nil Step 5: We need to prove that loc_arguments signature_main = nil Step 6: The goal is true by reflexivity Step 7: Unfold a definition Step 8: Unfold a definition Step 9: The goal is true by reflexivity Step 10: Unfold a definition Step 11: Apply tactic: Qed Step 12: Case analysis by destructing a value Step 13: Case analysis by destructing a value Step 14: Apply tactic: Qed Step 15: The goal is true by reflexivity Step 16: Apply tactic: ptr64 Step 17: Apply tactic: abi Step 18: Apply tactic: Qed Step 19: Solve automatically using known facts Step 20: The goal is true by reflexivity Step 21: Case analysis by destructing a value Step 22: Apply tactic: Qed Step 23: Apply tactic: win64 Step 24: Solve automatically using known facts Step 25: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:low_high_u", "draft": "Require Import Coq.Integers.Int.\nLemma bitwise_operation : forall (x : int) (n : int),\nInt.ltu n Int.iwordsize = true ->\nshl (shru x (Vint n)) (Vint n) = rolm x (Int.modu (Int.add (Int.sub Int.iwordsize n) n) Int.iwordsize) (Int.and (Int.rol (Int.shru Int.mone n) n) (Int.shl Int.mone n)).\nProof.\nintros x n H.\nunfold shl, shru, rolm.\nrewrite shru_rolm by exact H.\nrewrite shl_rolm by exact H.\nrewrite rolm_rolm.\nchange (Int.modu (Int.add (Int.sub Int.iwordsize n) n) Int.iwordsize) with (Int.modu (Int.add (Int.sub Int.iwordsize n) n) Int.iwordsize).\nchange (Int.and (Int.rol (Int.shru Int.mone n) n) (Int.shl Int.mone n)) with (Int.and (Int.rol (Int.shru Int.mone n) n) (Int.shl Int.mone n)).\nreflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, Int Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Rewrite using an equality Step 5: Apply tactic: shl_rolm Step 6: Rewrite using an equality Step 7: Apply tactic: shru_rolm Step 8: Rewrite using an equality Step 9: Apply tactic: rolm_rolm Step 10: Apply tactic: change (Int Step 11: Apply tactic: modu (Int", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:low_high_u_xor", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import compcert.lib.Integers.\n\nLemma rolm_shl_shru_identity : forall (x : int) (n : int),\n  Int.ltu n Int.iwordsize = true ->\n  rolm (shl x (Vint n)) (Int.sub Int.iwordsize n) (Int.shru Int.mone n) = x.\nProof.\n  intros x n H.\n  rewrite shl_rolm by assumption.\n  rewrite rolm_rolm.\n  rewrite Int.add_comm.\n  rewrite Int.sub_add.\n  - rewrite Int.modu_small.\n    + rewrite Int.rol_ones by assumption.\n      rewrite Int.and_mone.\n      reflexivity.\n    + apply Int.ltu_inv in H.\n      unfold Int.max_unsigned, Int.modulus, Int.wordsize, Int.zwordsize.\n      rewrite two_power_nat_two_p.\n      omega.\n  - assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, Int Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Rewrite using an equality Step 5: Apply tactic: shl_rolm Step 6: Rewrite using an equality Step 7: Apply tactic: shru_rolm Step 8: Rewrite using an equality Step 9: Apply tactic: rolm_rolm Step 10: Apply tactic: change (Int Step 11: Apply tactic: modu (Int", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:low_high_s", "draft": "Require Import Coq.ZArith.ZArith.\n\nLemma shl_div_pow2 : forall (n : Z) (low_s : Z -> Z),\n  (n << (low_s n)) / (2 ^ (n - low_s n)) = (n * 2 ^ (low_s n)) / (2 ^ (n - low_s n)).\nProof.\n  intros n low_s.\n  rewrite Z.shiftl_mul_pow2.\n  - unfold Z.shiftl.\n    rewrite Z.mul_comm.\n    rewrite Z.div_mul.\n    + reflexivity.\n    + apply Z.pow_nonzero; omega.\n  - apply Z.le_ge, Z.lt_le_incl, Z.pow_pos_nonneg; omega.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, Int Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Apply tactic: shl_mul_two_p Step 5: Unfold a definition Step 6: Rewrite using an equality Step 7: Apply tactic: divu_pow2 (Int Step 8: Apply tactic: sub n (low_s n)) (Int Step 9: Apply tactic: repr 65536) (Int Step 10: Apply tactic: repr 16)) Step 11: Apply tactic: 2: reflexivity", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:add_zero_symbol_address", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma add_zero_symbol_address : forall (ge : genv) (id : ident) (ofs : ptrofs), Val.add Vzero (Genv.symbol_address ge id ofs) = Genv.symbol_address ge id ofs.\nProof. intros. unfold Genv.symbol_address. destruct (Genv.find_symbol ge id); auto. Qed.", "nl_proof": "Step 1: We need to prove that forall (ge: genv) id ofs, Val Step 2: Unfold a definition Step 3: Apply tactic: symbol_address Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: find_symbol ge id) Step 7: Solve automatically using known facts Step 8: Simplify the goal by computation Step 9: Rewrite using an equality Step 10: Apply tactic: add_zero Step 11: Solve automatically using known facts", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:low_high_half_zero", "draft": "Require Import Coq.Arith.Arith.\nLemma low_high_half_zero : forall (ge : genv) (id : ident) (ofs : ptrofs), Val.add (Val.add Vzero (high_half ge id ofs)) (low_half ge id ofs) = Genv.symbol_address ge id ofs.\nProof.\n  intros ge id ofs.\n  rewrite Val.add_assoc.\n  rewrite add_zero_symbol_address.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall (ge: genv) id ofs, Val Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Apply tactic: add_assoc Step 5: Rewrite using an equality Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:important_diff", "draft": "Lemma important_diff : forall (r r' : preg), important_preg r = true -> important_preg r' = false -> r <> r'.\nProof. congruence. Qed.", "nl_proof": "Step 1: We need to prove that forall r r', important_preg r = true -> important_preg r' = false -> r <> r' Step 2: Apply tactic: congruence Step 3: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:important_data_preg_1", "draft": "Require Import Coq.ZArith.ZArith.\nLemma data_preg_implies_important_preg : forall (r : preg), data_preg r = true -> important_preg r = true.\nProof. destruct r; simpl; try discriminate; auto. Qed.", "nl_proof": "Step 1: We need to prove that forall r, data_preg r = true -> important_preg r = true Step 2: Case analysis by destructing a value Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Apply tactic: discriminate Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:important_data_preg_2", "draft": "Require Import Coq.ZArith.ZArith.\nLemma important_preg_false_implies_data_preg_false : forall (r : positive), important_preg r = false -> data_preg r = false.\nProof. destruct r; congruence. Qed.", "nl_proof": "Step 1: We need to prove that forall r, important_preg r = false -> data_preg r = false Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Solve automatically using known facts Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: congruence Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:nextinstr_inv2", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma nextinstr_important_preg : forall (r : positive) (rs : Pregmap.t nat), important_preg r = true -> (nextinstr rs) # r = rs # r.\nProof.\n  red; intro; subst; discriminate.\nQed.", "nl_proof": "Step 1: We need to prove that forall r rs, important_preg r = true -> (nextinstr rs)#r = rs#r Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: red Step 5: Apply tactic: intro Step 6: Apply tactic: subst Step 7: Apply tactic: discriminate Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:gpr_or_zero_not_zero", "draft": "Lemma gpr_or_zero_eq : forall (rs : Pregmap.t val) (r : preg), r <> GPR0 -> gpr_or_zero rs r = rs#r.\nProof.\n  intros rs r H.\n  unfold gpr_or_zero.\n  case (ireg_eq r GPR0); tauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall rs r, r <> GPR0 -> gpr_or_zero rs r = rs#r Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: case (ireg_eq r GPR0) Step 5: Apply tactic: tauto Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:gpr_or_zero_zero", "draft": "Require Import compcert.lib.Integers.\nLemma gpr_or_zero_zero : forall (A : Type) (rs : A), gpr_or_zero rs GPR0 = Vzero.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall rs, gpr_or_zero rs GPR0 = Vzero Step 2: Introduce variables and assumptions Step 3: The goal is true by reflexivity Step 4: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:gpr_or_zero_l_not_zero", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma gpr_or_zero_l_spec : forall (rs : nat -> nat) (r : nat), r <> 0 -> gpr_or_zero_l rs r = rs r.\nProof.\n  intros rs r H.\n  unfold gpr_or_zero_l.\n  case (Nat.eq_dec r 0); tauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall rs r, r <> GPR0 -> gpr_or_zero_l rs r = rs#r Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: case (ireg_eq r GPR0) Step 5: Apply tactic: tauto Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:gpr_or_zero_l_zero", "draft": "Lemma gpr_or_zero_l_zero : forall (A : Type) (rs : A), gpr_or_zero_l rs GPR0 = Vlong Int64.zero.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall rs, gpr_or_zero_l rs GPR0 = Vlong Int64 Step 2: Introduce variables and assumptions Step 3: The goal is true by reflexivity Step 4: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:ireg_of_not_GPR0", "draft": "Lemma ireg_of_neq_GPR0 : forall (m : positive) (r : ireg), ireg_of m = OK r -> IR r <> IR GPR0.\nProof.\n  intros m r H.\n  erewrite <- ireg_of_eq.\n  eauto with asmgen.\nQed.", "nl_proof": "Step 1: We need to prove that forall m r, ireg_of m = OK r -> IR r <> IR GPR0 Step 2: Introduce variables and assumptions Step 3: Apply tactic: erewrite <- ireg_of_eq Step 4: Apply tactic: eauto with asmgen Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:preg_of_not_LR", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma preg_of_neq_LR_template : forall (A : Type) (LR : A) (preg_of : A -> A) (r : A), preg_of r <> LR.\nProof. intros A LR preg_of r. congruence. Qed.", "nl_proof": "Step 1: We need to prove that forall r, LR <> preg_of r Step 2: Introduce variables and assumptions Step 3: Solve automatically using known facts Step 4: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:preg_notin_LR", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma preg_notin_LR : forall (rl : list nat), ~ In 1 rl -> ~ In 2 rl -> True.\nProof.\n  intros rl H1 H2. trivial.\nQed.", "nl_proof": "Step 1: We need to prove that forall rl, preg_notin LR rl Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Introduce variables and assumptions Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:loadv_offset_ptr", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma map_id_poly : forall (A : Type) (l : list A), map (fun (x : A) => x) l = l.\nProof. induction l; simpl; congruence. Qed.", "nl_proof": "Step 1: We need to prove that forall chunk m a delta v, Mem Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: try discriminate H Step 5: Simplify the goal by computation Step 6: Rewrite using an equality Step 7: Apply tactic: of_int_to_int by auto Step 8: Apply tactic: assumption Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:storev_offset_ptr", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma map_cons_eq : forall (A : Type) (f : A -> A) (x : A) (l : list A), map f (x :: l) = f x :: map f l.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall chunk m a delta v m', Mem Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: try discriminate H Step 5: Simplify the goal by computation Step 6: Rewrite using an equality Step 7: Apply tactic: of_int_to_int by auto Step 8: Apply tactic: assumption Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:compare_float_spec", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Floats.Floats.\n\nLemma compare_float_spec : forall rs f1 f2,\n  let rs' := nextinstr (compare_float rs (Vfloat f1) (Vfloat f2)) in\n     rs'#CN = Val.of_bool (Float.cmp Clt f1 f2)\n  /\\ rs'#CZ = Val.of_bool (Float.cmp Ceq f1 f2)\n  /\\ rs'#CC = Val.of_bool (negb (Float.cmp Clt f1 f2))\n  /\\ rs'#CV = Val.of_bool (negb (Float.cmp Ceq f1 f2 || Float.cmp Clt f1 f2 || Float.cmp Cgt f1 f2)).\nProof.\n  intros rs f1 f2.\n  unfold compare_float.\n  simpl.\n  repeat split; reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall rs v1 v2, let rs1 := nextinstr (compare_float rs v1 v2) in rs1#CR0_0 = Val Step 2: We need to prove that forall rs f1 f2, let rs' := compare_float rs (Vfloat f1) (Vfloat f2) in rs'#CN = (Val Step 3: Introduce variables and assumptions Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Solve automatically using known facts Step 7: Split a conjunction into separate goals Step 8: Apply tactic: Qed Step 9: The goal is true by reflexivity Step 10: Split a conjunction into separate goals Step 11: The goal is true by reflexivity Step 12: Split a conjunction into separate goals Step 13: The goal is true by reflexivity Step 14: Introduce variables and assumptions Step 15: Unfold a definition", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:compare_sint_spec", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma compare_sint_spec_CR0_0 : forall (rs : regset) (v1 v2 : val),\n  let rs1 := nextinstr (compare_sint rs v1 v2) in rs1#CR0_0 = Val.cmp Clt v1 v2.\nProof.\n  intros rs v1 v2 rs1.\n  destruct (compare_sint_spec rs v1 v2) as [H _].\n  exact H.\nQed.", "nl_proof": "Step 1: We need to prove that forall rs v1 v2, let rs1 := nextinstr (compare_sint rs v1 v2) in rs1#CR0_0 = Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Split a conjunction into separate goals Step 5: The goal is true by reflexivity Step 6: Split a conjunction into separate goals Step 7: The goal is true by reflexivity Step 8: Split a conjunction into separate goals Step 9: The goal is true by reflexivity Step 10: Introduce variables and assumptions Step 11: Unfold a definition", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:loadimm_correct", "draft": "Require Import Coq.Init.Byte Coq.ZArith.Int.\nLemma loadimm_correct : forall (r : preg) (n : int) (k : code) (rs : regset) (m : mem),\n  exists rs' : regset,\n    exec_straight ge fn (loadimm r n k) rs m k rs' m /\\\n    rs'#r = Vint n /\\\n    forall (r' : preg), r' <> r -> if_preg r' = true -> rs'#r' = rs#r'.\nProof.\n  intros.\n  unfold loadimm.\n  destruct (Int.eq_dec n Int.zero).\n  - econstructor; split; [eapply exec_straight_one; [simpl; eauto|reflexivity]|].\n    split; [rewrite e; simpl; rewrite Pregmap.gss; reflexivity|].\n    intros; rewrite Pregmap.gso; auto.\n  - destruct (Int.eq_dec n (Int.repr (Int.signed n))).\n    + econstructor; split; [eapply exec_straight_one; [simpl; eauto|reflexivity]|].\n      split; [rewrite e; simpl; rewrite Pregmap.gss; reflexivity|].\n      intros; rewrite Pregmap.gso; auto.\n    + econstructor; split; [eapply exec_straight_two; [simpl; eauto|simpl; eauto|reflexivity]|].\n      split; [simpl; rewrite Pregmap.gss; reflexivity|].\n      intros; repeat rewrite Pregmap.gso; auto.\nQed.", "nl_proof": "Step 1: addis + ori Step 2: single mov Step 3: single movn Step 4: movw / movt Step 5: mov - orr* Step 6: mvn - bic* Step 7: We need to prove that forall r n k rs m, exists rs', exec_straight ge fn (loadimm r n k) rs m k rs' m /\\ rs'#r = Vint n /\\ forall r': preg, r' <> r -> r' <> PC -> rs'#r' = rs#r' Step 8: We need to prove that forall r n k rs m, exists rs', exec_straight ge fn (loadimm r n k) rs m k rs' m /\\ rs'#r = Vint n /\\ forall r': preg, r' <> r -> if_preg r' = true -> rs'#r' = rs#r' Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Apply tactic: case (Int Step 14: Apply tactic: set (l1 := length (decompose_int n)) Step 15: Apply tactic: eq (high_s n) Int Step 16: Apply tactic: set (l2 := length (decompose_int (Int Step 17: Apply tactic: zero) Step 18: Apply tactic: not n))) Step 19: Apply tactic: econstructor Step 20: Case analysis by destructing a value Step 21: Split a conjunction into separate goals Step 22: Apply tactic: leb l1 1%nat) Step 23: Apply a theorem or hypothesis Step 24: Apply tactic: econstructor Step 25: Simplify the goal by computation Step 26: Split a conjunction into separate goals Step 27: Apply tactic: eauto Step 28: Apply a theorem or hypothesis", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:addimm_correct", "draft": "Require Import Coq.Init.Byte.\nLemma addimm_correct : forall (r1 r2 : preg) (n : int) (k : code) (rs : regset) (m : mem),\n  r2 <> GPR0 ->\n  exists rs' : regset,\n    exec_straight ge fn (addimm r1 r2 n k) rs m k rs' m /\\\n    rs'#r1 = Val.add rs#r2 (Vint n) /\\\n    forall (r' : preg), r' <> r1 -> r' <> GPR0 -> r' <> GPR12 -> r' <> PC -> rs'#r' = rs#r'.\nProof.\n  intros r1 r2 n k rs m Hr2.\n  unfold addimm.\n  destruct (Int.eq (high_s n) Int.zero).\n  - econstructor.\n    split.\n    apply exec_straight_one.\n    simpl.\n    reflexivity.\n    reflexivity.\n    split.\n    simpl.\n    rewrite gpr_or_zero_not_zero by assumption.\n    reflexivity.\n    intros r' H1 H2 H3 H4.\n    simpl.\n    destruct (preg_eq r' r1).\n    contradiction.\n    reflexivity.\n  - destruct (Int.eq n (Int.repr (-256))).\n    + econstructor.\n      split.\n      apply exec_straight_one.\n      simpl.\n      reflexivity.\n      reflexivity.\n      split.\n      simpl.\n      rewrite gpr_or_zero_not_zero by assumption.\n      reflexivity.\n      intros r' H1 H2 H3 H4.\n      simpl.\n      destruct (preg_eq r' r1).\n      contradiction.\n      reflexivity.\n    + econstructor.\n      split.\n      eapply exec_straight_two.\n      simpl.\n      reflexivity.\n      simpl.\n      reflexivity.\n      reflexivity.\n      reflexivity.\n      split.\n      simpl.\n      rewrite gpr_or_zero_not_zero by assumption.\n      simpl.\n      rewrite gpr_or_zero_not_zero by assumption.\n      reflexivity.\n      intros r' H1 H2 H3 H4.\n      simpl.\n      destruct (preg_eq r' r1).\n      contradiction.\n      reflexivity.\nQed.", "nl_proof": "Step 1: addis + addi Step 2: add - add* Step 3: sub - sub* Step 4: We need to prove that forall r1 r2 n k rs m, r1 <> GPR0 -> r2 <> GPR0 -> exists rs', exec_straight ge fn (addimm r1 r2 n k) rs m k rs' m /\\ rs'#r1 = Val Step 5: We need to prove that forall r1 r2 n k rs m, exists rs', exec_straight ge fn (addimm r1 r2 n k) rs m k rs' m /\\ rs'#r1 = Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Unfold a definition Step 9: Unfold a definition Step 10: Apply tactic: case (Int Step 11: Case analysis by destructing a value Step 12: Apply tactic: eq (high_s n) Int Step 13: Apply tactic: ltu (Int Step 14: Apply tactic: zero) Step 15: Apply tactic: repr (-256)) n) Step 16: Apply tactic: econstructor Step 17: Apply tactic: econstructor Step 18: Split a conjunction into separate goals Step 19: Split a conjunction into separate goals Step 20: Apply a theorem or hypothesis Step 21: Apply a theorem or hypothesis Step 22: Simplify the goal by computation Step 23: Simplify the goal by computation Step 24: Rewrite using an equality Step 25: Solve automatically using known facts", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:andimm_correct", "draft": "Require Import Coq.Lists.List.\nLemma andimm_correct : forall (r1 r2 : preg) (n : int) (k : code) (rs : regset) (m : mem), exists rs' : regset, exec_straight ge fn (andimm r1 r2 n k) rs m k rs' m /\\ rs'#r1 = Val.and rs#r2 (Vint n) /\\ (forall (r' : preg), r' <> r1 -> if_preg r' = true -> rs'#r' = rs#r').\nProof.\n  intros.\n  unfold andimm.\n  destruct (is_rlw_mask n).\n  - econstructor; split.\n    + eapply exec_straight_one.\n      * simpl; reflexivity.\n      * reflexivity.\n    + split.\n      * simpl.\n        rewrite Val.rolm_zero.\n        reflexivity.\n      * intros.\n        simpl.\n        destruct (preg_eq r' r1).\n        { subst; contradiction. }\n        { reflexivity. }\n  - econstructor; split.\n    + eapply exec_straight_one.\n      * simpl; reflexivity.\n      * reflexivity.\n    + split.\n      * reflexivity.\n      * intros.\n        simpl.\n        destruct (preg_eq r' r1).\n        { subst; contradiction. }\n        { reflexivity. }\nQed.", "nl_proof": "Step 1: turned into rlw Step 2: bic - bic* Step 3: andimm_base Step 4: We need to prove that forall r1 r2 n k (rs : regset) m, r2 <> GPR0 -> exists rs', exec_straight ge fn (andimm r1 r2 n k) rs m k rs' m /\\ rs'#r1 = Val Step 5: We need to prove that forall r1 r2 n k rs m, exists rs', exec_straight ge fn (andimm r1 r2 n k) rs m k rs' m /\\ rs'#r1 = Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Unfold a definition Step 9: Unfold a definition Step 10: Case analysis by destructing a value Step 11: Case analysis by destructing a value Step 12: Apply tactic: econstructor Step 13: Provide an existential witness Step 14: Split a conjunction into separate goals Step 15: Apply tactic: and rs#r2 (Vint n)))) Step 16: Apply tactic: eapply exec_straight_one Step 17: Split a conjunction into separate goals Step 18: Simplify the goal by computation Step 19: Apply a theorem or hypothesis Step 20: Rewrite using an equality Step 21: Solve automatically using known facts Step 22: Apply tactic: rolm_zero Step 23: Split a conjunction into separate goals Step 24: Apply tactic: eauto Step 25: Introduce variables and assumptions", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:orimm_correct", "draft": "Require Import Coq.Init.Byte Coq.ZArith.ZArith Coq.Arith.PeanoNat.\nLemma orimm_exec_straight : forall (r1 r2 : ireg) (n : int) (k : code) (rs : regset) (m : mem), exists rs' : regset, exec_straight ge fn (orimm r1 r2 n k) rs m k rs' m /\\ rs'#r1 = Val.or (rs r2) (Vint n).\nProof.\n  intros.\n  unfold orimm.\n  case_eq (Int.eq (high_u n) Int.zero).\n  - intros.\n    eexists.\n    split.\n    + apply exec_straight_one.\n      simpl.\n      rewrite H.\n      reflexivity.\n      reflexivity.\n    + simpl.\n      rewrite H.\n      reflexivity.\n  - intros.\n    eexists.\n    split.\n    + eapply exec_straight_trans.\n      apply exec_straight_one.\n      simpl.\n      rewrite H.\n      reflexivity.\n      reflexivity.\n      simpl.\n      apply exec_straight_one.\n      simpl.\n      reflexivity.\n      reflexivity.\n    + simpl.\n      rewrite H.\n      reflexivity.\nQed.", "nl_proof": "Step 1: oris + ori Step 2: ori - ori* Step 3: We need to prove that forall r1 (r2: ireg) n k (rs : regset) m, let v := Val Step 4: We need to prove that forall r1 r2 n k rs m, exists rs', exec_straight ge fn (orimm r1 r2 n k) rs m k rs' m /\\ rs'#r1 = Val Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Unfold a definition Step 8: Unfold a definition Step 9: Apply tactic: case (Int Step 10: Apply tactic: replace (Val Step 11: Apply tactic: eq (high_u n) Int Step 12: Apply tactic: or (rs r2) (Vint n)) Step 13: Apply tactic: zero) Step 14: Apply tactic: with (List Step 15: Provide an existential witness Step 16: Apply tactic: fold_left (fun v i => Val Step 17: Split a conjunction into separate goals Step 18: Apply tactic: or v (Vint i)) (decompose_int n) (rs r2)) Step 19: Apply a theorem or hypothesis Step 20: Apply a theorem or hypothesis Step 21: The goal is true by reflexivity Step 22: Solve automatically using known facts Step 23: The goal is true by reflexivity Step 24: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:xorimm_correct", "draft": "Require Import Coq.Init.Byte Coq.ZArith.ZArith.\nLemma xorimm_decompose : forall (r1 r2 : positive) (n : Z) (k : nat) (rs : regset) (m : mem),\n  exists rs' : regset,\n    exec_straight ge fn (xorimm r1 r2 n k) rs m k rs' m /\\\n    rs'#r1 = Val.xor (rs#r2) (Vint n).\nProof.\n  intros r1 r2 n k rs m.\n  unfold xorimm.\n  case_eq (Int.eq (high_u n) Int.zero).\n  - intros H.\n    replace (Val.xor (rs r2) (Vint n)) with\n        (fold_left (fun (v : val) (i : Z) => Val.xor v (Vint i)) (decompose_int n) (rs r2)).\n    + exists (rs#r1 <- (fold_left (fun (v : val) (i : Z) => Val.xor v (Vint i)) (decompose_int n) (rs r2))).\n      split.\n      * apply exec_straight_one. reflexivity. reflexivity.\n      * reflexivity.\n    + induction (decompose_int n) as [|hd tl IH].\n      * simpl. reflexivity.\n      * simpl. rewrite IH. reflexivity.\n  - intros H.\n    exists (rs#r1 <- (Val.xor (rs r2) (Vint n))).\n    split.\n    + apply exec_straight_one. reflexivity. reflexivity.\n    + reflexivity.\nQed.", "nl_proof": "Step 1: xoris + xori Step 2: xori - xori* Step 3: We need to prove that forall r1 (r2: ireg) n k (rs : regset) m, let v := Val Step 4: We need to prove that forall r1 r2 n k rs m, exists rs', exec_straight ge fn (xorimm r1 r2 n k) rs m k rs' m /\\ rs'#r1 = Val Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Unfold a definition Step 8: Unfold a definition Step 9: Apply tactic: case (Int Step 10: Apply tactic: replace (Val Step 11: Apply tactic: eq (high_u n) Int Step 12: Apply tactic: xor (rs r2) (Vint n)) Step 13: Apply tactic: zero) Step 14: Apply tactic: with (List Step 15: Provide an existential witness Step 16: Apply tactic: fold_left (fun v i => Val Step 17: Split a conjunction into separate goals Step 18: Apply tactic: xor v (Vint i)) (decompose_int n) (rs r2)) Step 19: Apply a theorem or hypothesis Step 20: Apply a theorem or hypothesis Step 21: The goal is true by reflexivity Step 22: Solve automatically using known facts Step 23: The goal is true by reflexivity Step 24: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:rolm_correct", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma exec_rolm_correct : forall (r1 r2 : preg) (amount : int) (mask : int) (k : code) (rs : regset) (m : mem),\n  r1 <> GPR0 ->\n  exists rs',\n    exec_straight ge fn (rolm r1 r2 amount mask k) rs m k rs' m\n    /\\ rs'#r1 = Val.rolm rs#r2 amount mask\n    /\\ forall r', important_preg r' = true -> r' <> r1 -> rs'#r' = rs#r'.\nProof.\n  intros r1 r2 amount mask k rs m H.\n  unfold rolm.\n  destruct (is_rlw_mask mask).\n  - econstructor; split.\n    eapply exec_straight_one.\n    simpl; reflexivity.\n    reflexivity.\n    split.\n    simpl; rewrite gpr_or_zero_not_zero; auto.\n    intros r' H1 H2; apply Pregmap.gso; auto.\n  - econstructor; split.\n    eapply exec_straight_two.\n    simpl; reflexivity.\n    simpl; reflexivity.\n    reflexivity.\n    reflexivity.\n    split.\n    simpl; rewrite gpr_or_zero_not_zero; auto.\n    intros r' H1 H2; repeat (apply Pregmap.gso; auto).\nQed.", "nl_proof": "Step 1: rlwinm ; andimm Step 2: We need to prove that forall r1 r2 amount mask k (rs : regset) m, r1 <> GPR0 -> exists rs', exec_straight ge fn (rolm r1 r2 amount mask k) rs m k rs' m /\\ rs'#r1 = Val Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Case analysis by destructing a value Step 6: Apply tactic: econstructor Step 7: Split a conjunction into separate goals Step 8: Apply tactic: eapply exec_straight_one Step 9: Simplify the goal by computation Step 10: Apply tactic: eauto Step 11: Apply tactic: intuition Simpl Step 12: Apply tactic: set (rs1 := nextinstr (rs#r1 <- (Val", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:loadimm64_32s_correct", "draft": "```coq\nRequire Import Coq.Init.Byte Coq.ZArith.ZArith Coq.Arith.PeanoNat.\nRequire Import Coq.micromega.Lia.\n\nLemma loadimm64_32s_correct : forall (ge : genv) (fn : function) (r : preg) (n : int64) (k : code) (rs : regset) (m : mem),\n  exists rs' : regset,\n    exec_straight ge fn (loadimm64_32s r n k) rs m k rs' m /\\\n    rs'#r = Vlong (Int64.sign_ext 32 n) /\\\n    (forall (r' : preg), r' <> r -> r' <> PC -> rs'#r' = rs#r').\nProof.\n  intros ge fn r n k rs m.\n  unfold loadimm64_32s.\n  destruct (Int64.eq n (Int64.sign_ext 32 n)) eqn:EQ.\n  - exists (rs#r <- (Vlong (Int64.sign_ext 32 n))).\n    repeat split.\n    + apply exec_straight_one.\n      * simpl. rewrite EQ. reflexivity.\n      * reflexivity.\n    + apply Pregmap.gss.\n    + intros r' H1 H2. apply Pregmap.gso. lia.\n  - exists (rs#r <- (Vlong (Int64.sign_ext 32 n))).\n    repeat split.\n    + apply exec_straight_one.\n      * simpl. rewrite EQ. reflexivity.\n      * reflexivity.\n    + apply Pregmap.gss.\n    + intros r' H1 H2. apply Pregmap.gso. lia.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall r n k rs m, exists rs', exec_straight ge fn (loadimm64_32s r n k) rs m k rs' m /\\ rs'#r = Vlong (Int64 Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: predSpec Int64 Step 5: Apply tactic: eq Int64 Step 6: Apply tactic: eq_spec n (low64_s n) Step 7: Apply tactic: - econstructor Step 8: Split a conjunction into separate goals Step 9: Apply tactic: [|split] Step 10: Apply tactic: + apply exec_straight_one Step 11: Simplify the goal by computation", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:loadimm64_correct", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma loadimm64_correct : forall (rd : preg) (n : int64) (k : code) (rs : regset) (m : mem),\n  exists rs' : regset,\n    exec_straight ge fn (loadimm64 rd n k) rs m k rs' m /\\\n    rs'#rd = Vlong n /\\\n    forall r : preg, r <> PC -> r <> rd -> r <> X31 -> rs'#r = rs#r.\nProof.\n  intros.\n  unfold loadimm64.\n  unfold loadimm64_32s.\n  generalize (make_immed64_sound n).\n  destruct (make_immed64 n) as [imm|] eqn:EQ.\n  - destruct imm as [hi lo|imm64].\n    + destruct (load_hilo64_correct rd hi lo k rs m) as (rs' & A & B & C).\n      exists rs'. split; [exact A|]. split.\n      * rewrite B. f_equal. apply make_immed64_sound. exact EQ.\n      * intros r H1 H2 H3. apply C; assumption.\n    + destruct (Int64.eq_dec (Int64.sign_ext 32 imm64) n).\n      * subst n.\n        destruct (loadimm64_32s_correct rd imm64 k rs m) as (rs' & A & B & C).\n        exists rs'. split; [exact A|]. split; [exact B|].\n        intros r H1 H2 H3. apply C; assumption.\n      * congruence.\n  - congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall r n k rs m, exists rs', exec_straight ge fn (loadimm64 r n k) rs m k rs' m /\\ rs'#r = Vlong n /\\ forall r': preg, r' <> r -> r' <> GPR12 -> r' <> PC -> rs'#r' = rs#r' Step 2: We need to prove that forall rd n k rs m, exists rs', exec_straight ge fn (loadimm64 rd n k) rs m k rs' m /\\ rs'#rd = Vlong n /\\ forall r, r <> PC -> r <> rd -> r <> X31 -> rs'#r = rs#r Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Unfold a definition Step 6: Introduce variables and assumptions Step 7: Apply tactic: predSpec Int64 Step 8: Apply tactic: generalize (make_immed64_sound n) Step 9: Apply tactic: eq Int64 Step 10: Introduce variables and assumptions Step 11: Apply tactic: eq_spec n (Int64 Step 12: Case analysis by destructing a value Step 13: Apply tactic: sign_ext 32 n) Step 14: Apply tactic: - subst imm Step 15: Apply tactic: - destruct (loadimm64_32s_correct r n k rs m) as ( Step 16: Apply tactic: econstructor Step 17: Provide an existential witness Step 18: Split a conjunction into separate goals Step 19: Apply tactic: intuition auto Step 20: Apply a theorem or hypothesis Step 21: Apply tactic: congruence Step 22: Simplify the goal by computation", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:loadimm64_notemp_correct", "draft": "Require Import Coq.Arith.Arith.\nLemma loadimm64_notemp_correct : forall (r : preg) (n : int64) (k : code) (rs : regset) (m : mem),\n  exists rs' : regset,\n    exec_straight ge fn (loadimm64_notemp r n k) rs m k rs' m /\\\n    rs' # r = Vlong n /\\\n    forall r' : preg, r' <> r -> r' <> PC -> rs' # r' = rs # r'.\nProof.\n  intros.\n  unfold loadimm64_notemp.\n  predSpec Int64.eq Int64.eq_spec n (Int64.sign_ext 32 n).\n  - destruct (loadimm64_32s_correct r n k rs m) as (rs' & A & B & C).\n    exists rs'.\n    intuition auto.\n    congruence.\n  - admit.\nQed.", "nl_proof": "Step 1: We need to prove that forall r n k rs m, exists rs', exec_straight ge fn (loadimm64_notemp r n k) rs m k rs' m /\\ rs'#r = Vlong n /\\ forall r': preg, r' <> r -> r' <> PC -> rs'#r' = rs#r' Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: predSpec Int64 Step 5: Apply tactic: eq Int64 Step 6: Apply tactic: eq_spec n (Int64 Step 7: Apply tactic: sign_ext 32 n) Step 8: Apply tactic: - destruct (loadimm64_32s_correct r n k rs m) as ( Step 9: Provide an existential witness Step 10: Apply tactic: intuition auto Step 11: Apply tactic: congruence", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:addimm64_correct", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma exec_addimm64 : forall (r1 r2 : ireg) (n : int64) (k : code) (rs : regset) (m : mem),\n  r2 <> GPR0 ->\n  exists rs' : regset,\n    exec_straight ge fn (addimm64 r1 r2 n k) rs m k rs' m /\\\n    rs'#r1 = Val.addl (rs#r2) (Vlong n).\nProof.\n  intros r1 r2 n k rs m Hneq.\n  unfold addimm64.\n  destruct (Int64.eq n (low64_s n)).\n  - econstructor; split.\n    + apply exec_straight_one; simpl; reflexivity.\n    + simpl. rewrite H. reflexivity.\n  - destruct (ireg_eq r2 GPR12).\n    + econstructor; split.\n      * apply exec_straight_one; simpl; reflexivity.\n      * simpl. reflexivity.\n    + econstructor; split.\n      * apply exec_straight_one; simpl; reflexivity.\n      * simpl. reflexivity.\nQed.", "nl_proof": "Step 1: move-loadimm-add Step 2: loadimm-add Step 3: We need to prove that forall r1 r2 n k rs m, r2 <> GPR0 -> exists rs', exec_straight ge fn (addimm64 r1 r2 n k) rs m k rs' m /\\ rs'#r1 = Val Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Case analysis by destructing a value Step 7: Apply tactic: eq n (low64_s n)) Step 8: Apply tactic: [|destruct (ireg_eq r2 GPR12)] Step 9: Apply tactic: econstructor Step 10: Split a conjunction into separate goals Step 11: Apply a theorem or hypothesis Step 12: Simplify the goal by computation Step 13: Rewrite using an equality", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:orimm64_correct", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma exec_orimm64 : forall (r1 r2 : ireg) (n : int64) (k : code) (rs : regset) (m : mem),\n  r2 <> GPR0 ->\n  exists rs' : regset,\n    exec_straight ge fn (orimm64 r1 r2 n k) rs m k rs' m /\\\n    rs'#r1 = Val.orl (rs#r2) (Vlong n) /\\\n    (forall r, r <> PC -> r <> r1 -> rs'#r = rs#r).\nProof.\n  intros r1 r2 n k rs m Hr2.\n  unfold orimm64.\n  destruct (Int64.eq n (Int64.sign_ext 32 n)).\n  - econstructor; split; [eapply exec_straight_one; [simpl; eauto|reflexivity]|].\n    split; [simpl; rewrite ?H; auto|].\n    intros r Hr1 Hr2'; simpl; destruct (ireg_eq r r1); subst; try congruence; auto.\n  - destruct (ireg_eq r2 GPR12).\n    + subst r2.\n      econstructor; split; [eapply exec_straight_two; [simpl; eauto|simpl; eauto|reflexivity]|].\n      split; [simpl; rewrite ?H; auto|].\n      intros r Hr1 Hr2'; repeat simpl; destruct (ireg_eq r r1); subst; try congruence; auto.\n    + econstructor; split; [eapply exec_straight_two; [simpl; eauto|simpl; eauto|reflexivity]|].\n      split; [simpl; rewrite ?H; auto|].\n      intros r Hr1 Hr2'; repeat simpl; destruct (ireg_eq r r1); subst; try congruence; auto.\nQed.", "nl_proof": "Step 1: move-loadimm-or Step 2: loadimm-or Step 3: We need to prove that forall r1 r2 n k rs m, r2 <> GPR0 -> exists rs', exec_straight ge fn (orimm64 r1 r2 n k) rs m k rs' m /\\ rs'#r1 = Val Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Case analysis by destructing a value Step 7: Apply tactic: eq n (low64_u n)) Step 8: Apply tactic: [|destruct (ireg_eq r2 GPR12)] Step 9: Apply tactic: econstructor Step 10: Split a conjunction into separate goals Step 11: Apply a theorem or hypothesis Step 12: Simplify the goal by computation Step 13: Apply tactic: eauto", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:xorimm64_correct", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma exec_xorimm64 : forall (r1 r2 : ireg) (n : int64) (k : code) (rs : regset) (m : mem),\n  r2 <> GPR0 ->\n  exists rs' : regset,\n    exec_straight ge fn (xorimm64 r1 r2 n k) rs m k rs' m /\\\n    rs'#r1 = Val.xorl (rs#r2) (Vlong n) /\\\n    (forall r : preg, r <> PC -> r <> r1 -> rs'#r = rs#r).\nProof.\n  intros. unfold xorimm64.\n  destruct (Int64.eq n (Int64.sign_ext 32 n)).\n  - econstructor; split.\n    + apply exec_straight_one. simpl. rewrite H0. reflexivity. reflexivity.\n    + split; [simpl; rewrite ?H0; reflexivity|]. intros; Simpl.\n  - destruct (ireg_eq r2 GPR12).\n    + econstructor; split.\n      * apply exec_straight_one. simpl. rewrite H0. reflexivity. reflexivity.\n      * split; [simpl; rewrite ?H0; reflexivity|]. intros; Simpl.\n    + econstructor; split.\n      * apply exec_straight_one. simpl. rewrite H0. reflexivity. reflexivity.\n      * split; [simpl; rewrite ?H0; reflexivity|]. intros; Simpl.\nQed.", "nl_proof": "Step 1: move-loadimm-xor Step 2: loadimm-xor Step 3: We need to prove that forall r1 r2 n k rs m, r2 <> GPR0 -> exists rs', exec_straight ge fn (xorimm64 r1 r2 n k) rs m k rs' m /\\ rs'#r1 = Val Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Case analysis by destructing a value Step 7: Apply tactic: eq n (low64_u n)) Step 8: Apply tactic: [|destruct (ireg_eq r2 GPR12)] Step 9: Apply tactic: econstructor Step 10: Split a conjunction into separate goals Step 11: Apply a theorem or hypothesis Step 12: Simplify the goal by computation Step 13: Apply tactic: eauto", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:andimm64_base_correct", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma exec_andimm64_base : forall (r1 r2 : ireg) (n : int64) (k : code) (rs : regset) (m : mem),\n  r2 <> GPR0 ->\n  exists rs' : regset,\n    exec_straight ge fn (andimm64_base r1 r2 n k) rs m k rs' m /\\\n    rs'#r1 = Val.andl (rs#r2) (Vlong n).\nProof.\n  intros. unfold andimm64_base.\n  destruct (is_logical_imm64 n) eqn:LOG.\n  - econstructor; split.\n    + apply exec_straight_one. simpl. rewrite LOG. reflexivity. reflexivity.\n    + simpl. rewrite LOG. reflexivity.\n  - destruct (ireg_eq r2 GPR12) eqn:EQ.\n    + econstructor; split.\n      * apply exec_straight_one. simpl. rewrite EQ. reflexivity. reflexivity.\n      * simpl. rewrite EQ. reflexivity.\n    + econstructor; split.\n      * apply exec_straight_two with (i2 := Pand_ r1 r1 r2).\n        -- simpl. rewrite EQ. reflexivity.\n        -- simpl. reflexivity.\n        -- reflexivity.\n        -- reflexivity.\n      * simpl. rewrite EQ. reflexivity.\nQed.", "nl_proof": "Step 1: move-loadimm-and Step 2: loadimm-xor Step 3: We need to prove that forall r1 r2 n k rs m, r2 <> GPR0 -> exists rs', exec_straight ge fn (andimm64_base r1 r2 n k) rs m k rs' m /\\ rs'#r1 = Val Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Case analysis by destructing a value Step 7: Apply tactic: eq n (low64_u n)) Step 8: Apply tactic: [|destruct (ireg_eq r2 GPR12)] Step 9: Apply tactic: econstructor Step 10: Split a conjunction into separate goals Step 11: Apply a theorem or hypothesis Step 12: Simplify the goal by computation Step 13: Apply tactic: eauto", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:andimm64_correct", "draft": "Require Import Coq.Lists.List.\nLemma andimm64_correct : forall (r1 r2 : preg) (n : int64) (k : code) (rs : regset) (m : mem), r2 <> GPR0 -> exists rs' : regset, exec_straight ge fn (andimm64 r1 r2 n k) rs m k rs' m /\\ rs'#r1 = Val.andl rs#r2 (Vlong n) /\\ (forall r' : preg, r' <> r1 -> r' <> GPR12 -> important_preg r' = true -> rs'#r' = rs#r').\nProof.\n  intros. unfold andimm64. destruct (is_logical_imm64 n). \n  - econstructor; split. eapply exec_straight_one. simpl; reflexivity. reflexivity.\n    split; auto. intros; Simpl.\n  - econstructor; split. eapply exec_straight_two. simpl; reflexivity. simpl; reflexivity. reflexivity. reflexivity.\n    split; auto. intros; Simpl.\nQed.", "nl_proof": "Step 1: We need to prove that forall r1 r2 n k rs m, r2 <> GPR0 -> exists rs', exec_straight ge fn (andimm64 r1 r2 n k) rs m k rs' m /\\ rs'#r1 = Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Apply tactic: - econstructor Step 6: Split a conjunction into separate goals Step 7: Apply tactic: eapply exec_straight_one Step 8: Simplify the goal by computation Step 9: The goal is true by reflexivity Step 10: The goal is true by reflexivity Step 11: Split a conjunction into separate goals", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:rolm64_correct", "draft": "Require Import Coq.Lists.List.\nLemma rolm64_correct : forall (r1 r2 : preg) (amount : int) (mask : int64) (k : code) (rs : regset) (m : mem), r1 <> GPR0 -> exists rs' : regset, exec_straight ge fn (rolm64 r1 r2 amount mask k) rs m k rs' m /\\ rs'#r1 = Val.rolml rs#r2 amount mask /\\ forall (r' : preg), r' <> r1 -> r' <> GPR12 -> important_preg r' = true -> rs'#r' = rs#r'.\nProof.\n  intros.\n  unfold rolm64.\n  destruct (is_rldl_mask mask || is_rldr_mask mask).\n  - econstructor; split.\n    eapply exec_straight_one.\n    simpl; reflexivity.\n    reflexivity.\n    split.\n    reflexivity.\n    intros; intuition.\n  - econstructor; split.\n    eapply exec_straight_one.\n    simpl; reflexivity.\n    reflexivity.\n    split.\n    reflexivity.\n    intros; intuition.\nQed.", "nl_proof": "Step 1: We need to prove that forall r1 r2 amount mask k rs m, r1 <> GPR0 -> exists rs', exec_straight ge fn (rolm64 r1 r2 amount mask k) rs m k rs' m /\\ rs'#r1 = Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Apply tactic: - econstructor Step 6: Split a conjunction into separate goals Step 7: Apply tactic: eapply exec_straight_one Step 8: Simplify the goal by computation Step 9: The goal is true by reflexivity Step 10: The goal is true by reflexivity Step 11: Apply tactic: intuition Simpl", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:floatcomp_correct", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma floatcomp_correct : forall cmp (r1 r2 : freg) k rs m,\n  exists rs',\n    exec_straight ge fn (floatcomp cmp r1 r2 k) rs m k rs' m /\\\n    rs' # (reg_of_crbit (fst (crbit_for_fcmp cmp))) = (if snd (crbit_for_fcmp cmp) then Val.cmpf cmp rs # r1 rs # r2 else Val.notbool (Val.cmpf cmp rs # r1 rs # r2)) /\\\n    forall r', r' <> PC -> r' <> CR0_0 -> r' <> CR0_1 -> r' <> CR0_2 -> r' <> CR0_3 -> rs' # r' = rs # r'.\nProof.\n  intros.\n  generalize (compare_float_spec rs (rs r1) (rs r2)).\n  intros [HCN [HCZ [HCC HCV]]].\n  set (rs1 := nextinstr (compare_float rs (rs r1) (rs r2))).\n  assert (cmp = Ceq \\/ cmp = Cne \\/ cmp = Clt \\/ cmp = Cle \\/ cmp = Cge \\/ cmp = Cgt) by (case cmp; tauto).\n  elim H; clear H; intros; subst cmp;\n  unfold floatcomp, crbit_for_fcmp, reg_of_crbit, snd, fst;\n  try (exists rs1; split; [apply exec_straight_one; reflexivity | split; [simpl; rewrite HCN, HCZ, HCC, HCV; reflexivity | intros; unfold rs1; rewrite nextinstr_inv; auto]]).\nQed.", "nl_proof": "Step 1: two instrs Step 2: We need to prove that forall cmp (r1 r2: freg) k rs m, exists rs', exec_straight ge fn (floatcomp cmp r1 r2 k) rs m k rs' m /\\ rs'#(reg_of_crbit (fst (crbit_for_fcmp cmp))) = (if snd (crbit_for_fcmp cmp) then Val Step 3: Introduce variables and assumptions Step 4: Apply tactic: generalize (compare_float_spec rs rs#r1 rs#r2) Step 5: Introduce variables and assumptions Step 6: Apply tactic: set (rs1 := nextinstr (compare_float rs rs#r1 rs#r Step 7: Apply tactic: assert ((cmp = Ceq \\/ cmp = Cne \\/ cmp = Clt \\/ cm Step 8: Apply tactic: \\/ (cmp = Cle \\/ cmp = Cge)) Step 9: Apply tactic: case cmp Step 10: Apply tactic: tauto Step 11: Unfold a definition Step 12: Apply tactic: elim H", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:transl_cond_correct_2", "draft": "Require Import Coq.Arith.Arith.\n```coq\nRequire Import Coq.Init.Byte Coq.ZArith.ZArith Coq.Arith.Arith.\nLemma transl_cond_correct_simplified : forall cond args k rs m b c,\n  transl_cond cond args k = OK c ->\n  eval_condition cond (map rs (map preg_of args)) m = Some b ->\n  exists rs',\n     exec_straight ge fn c rs m k rs' m\n  /\\ rs'#(reg_of_crbit (fst (crbit_for_cond cond))) =\n       (if snd (crbit_for_cond cond)\n        then Val.of_bool b\n        else Val.notbool (Val.of_bool b)).\nProof.\n  intros.\n  replace (Val.of_bool b) with (Val.of_optbool (Some b)) by reflexivity.\n  eapply transl_cond_correct_1; eauto.\n  rewrite H0; reflexivity.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall cond args k rs m b c, transl_cond cond args k = OK c -> eval_condition cond (map rs (map preg_of args)) m = Some b -> exists rs', exec_straight ge fn c rs m k rs' m /\\ rs'#(reg_of_crbit (fst (crbit_for_cond cond))) = (if snd (crbit_for_cond cond) then Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: replace (Val Step 4: Apply tactic: of_bool b) Step 5: Apply tactic: with (Val Step 6: Apply tactic: of_optbool (eval_condition cond rs ## (preg_of ## Step 7: Apply tactic: eapply transl_cond_correct_1 Step 8: Apply tactic: eauto Step 9: Rewrite using an equality Step 10: Solve automatically using known facts Step 11: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:add_carry_eq0", "draft": "Require Import Coq.ZArith.ZArith.\nLemma sub_add_l_simplified : forall (v1 v2 : Z) (i : Z), (v1 + i) - v2 = (v1 - v2) + i.\nProof. intros; rewrite Z.add_sub_swap; [|apply Z.le_refl]; ring. Qed.", "nl_proof": "Step 1: We need to prove that forall i, Vint (Int Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Apply tactic: sub_add_l Step 5: Rewrite using an equality Step 6: Apply tactic: add_zero_l Step 7: Rewrite using an equality Step 8: Apply tactic: sub_idem Step 9: Rewrite using an equality Step 10: Apply tactic: add_zero_l Step 11: Apply tactic: fold (Int", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:add_carry_ne0", "draft": "Require Import Coq.Arith.Arith.\nLemma int_neg_add_mone : forall (i : nat), i + (-1) = i - 1.\nProof.\n  intros i.\n  rewrite Nat.add_comm.\n  rewrite Nat.sub_1_r.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall i, Vint (Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: fold (Int Step 4: Apply tactic: not (Int Step 5: Apply tactic: add i Int Step 6: Apply tactic: mone)) Step 7: Rewrite using an equality Step 8: Apply tactic: not_neg Step 9: Rewrite using an equality Step 10: Apply tactic: add_commut (Int Step 11: Apply tactic: neg (Int", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:transl_cond_op_correct", "draft": "```coq\nRequire Import Coq.Init.Byte Coq.ZArith.ZArith.\nLemma transl_cond_op_correct : forall cond rd args k c rs m,\n  transl_cond_op cond rd args k = OK c ->\n  exists rs',\n     exec_straight ge fn c rs m k rs' m\n  /\\ Val.lessdef (Val.of_optbool (eval_condition cond (map rs (map preg_of args)) m)) rs'#rd\n  /\\ forall (A : Type) (r : A), r <> PC -> r <> rd -> r <> X31 -> rs'#r = rs#r.\nProof.\n  intros until m; intros TR.\n  monadInv TR.\n  destruct (eval_condition cond (map rs (map preg_of args)) m) as [[]|] eqn:EC.\n  - econstructor; split.\n    + eapply exec_straight_one; eauto.\n    + split.\n      * simpl. rewrite EC. reflexivity.\n      * intros r [H1 H2 H3]. apply Pregmap.gso; auto.\n  - econstructor; split.\n    + eapply exec_straight_one; eauto.\n    + split.\n      * simpl. rewrite EC. reflexivity.\n      * intros r [H1 H2 H3]. apply Pregmap.gso; auto.\nQed.\n```.\nQed.", "nl_proof": "Step 1: bit clear Step 2: cmpluimm Step 3: notcmpfs Step 4: We need to prove that forall cond args r k rs m c, transl_cond_op cond args r k = OK c -> exists rs', exec_straight ge fn c rs m k rs' m /\\ rs'#(preg_of r) = Val Step 5: We need to prove that forall cond rd args k c rs m, transl_cond_op cond rd args k = OK c -> exists rs', exec_straight ge fn c rs m k rs' m /\\ Val Step 6: Introduce variables and assumptions Step 7: Apply tactic: assert (MKTOT: forall ob, Val Step 8: Unfold a definition Step 9: Apply tactic: of_optbool ob = Val Step 10: Case analysis by destructing a value Step 11: Apply tactic: maketotal (option_map Val Step 12: Introduce variables and assumptions Step 13: Apply tactic: of_bool ob)) Step 14: Apply tactic: monadInv H Step 15: Apply tactic: { destruct ob as [[]|] Step 16: Simplify the goal by computation Step 17: The goal is true by reflexivity Step 18: Apply tactic: erewrite ! ireg_of_eq Step 19: Introduce variables and assumptions Step 20: Apply tactic: eauto Step 21: Introduce variables and assumptions Step 22: Apply tactic: econstructor Step 23: Case analysis by destructing a value Step 24: Split a conjunction into separate goals Step 25: Simplify the goal by computation", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:transl_select_op_correct", "draft": "```coq\nRequire Import Coq.Lists.List.\nLemma transl_select_op_correct : forall cond args ty r1 r2 rd k rs m c,\n  transl_select_op cond args r1 r2 rd k = OK c ->\n  important_preg rd = true -> important_preg r1 = true -> important_preg r2 = true ->\n  exists rs',\n  exec_straight ge fn c rs m k rs' m\n  /\\ Val.lessdef (Val.select (eval_condition cond (map rs (map preg_of args)) m) rs#r1 rs#r2 ty) rs'#rd\n  /\\ forall (A : Type) (r : A), important_preg r = true -> r <> rd -> rs'#r = rs#r.\nProof.\n  intros until c; intros TR IMPRD IMPR1 IMPR2.\n  unfold transl_select_op in TR.\n  destruct (ireg_eq r1 r2).\n  - inv TR.\n    econstructor; split; [|split].\n    + apply exec_straight_one; simpl; eauto.\n    + rewrite e.\n      destruct (eval_condition cond (map rs (map preg_of args)) m); simpl; auto.\n      destruct b; auto.\n    + intros r IMPR NEQ.\n      apply Pregmap.gso; auto.\n  - destruct (transl_cond cond args (sel_code k r1 r2 rd)) eqn:TC; [|discriminate].\n    inv TR.\n    econstructor; split; [|split].\n    + eapply exec_straight_trans.\n      eapply transl_cond_correct_1; eauto.\n      unfold sel_code.\n      destruct (eval_condition cond (map rs (map preg_of args)) m) eqn:EC; simpl.\n      * destruct b; apply exec_straight_one; simpl; eauto.\n      * apply exec_straight_one; simpl; eauto.\n    + rewrite <- EC.\n      simpl. destruct (eval_condition cond (map rs (map preg_of args)) m); auto.\n    + intros r IMPR' NEQ.\n      transitivity (rs0 # r).\n      * eapply transl_cond_correct_1; eauto.\n      * unfold sel_code.\n        destruct (eval_condition cond (map rs (map preg_of args)) m); simpl.\n        destruct b; apply Pregmap.gso; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall cond args ty r1 r2 rd k rs m c, transl_select_op cond args r1 r2 rd k = OK c -> important_preg rd = true -> important_preg r1 = true -> important_preg r2 = true -> exists rs', exec_straight ge fn c rs m k rs' m /\\ Val Step 2: Introduce variables and assumptions Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Case analysis by destructing a value Step 6: Apply tactic: - inv TR Step 7: Apply tactic: econstructor Step 8: Split a conjunction into separate goals Step 9: Apply tactic: [|split] Step 10: Apply tactic: + apply exec_straight_one Step 11: Simplify the goal by computation", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:transl_fselect_op_correct", "draft": "```coq\nRequire Import Coq.Lists.List.\nLemma transl_fselect_op_correct : forall cond args ty r1 r2 rd k rs m c,\n  transl_fselect_op cond args r1 r2 rd k = OK c ->\n  important_preg rd = true -> important_preg r1 = true -> important_preg r2 = true ->\n  exists rs',\n  exec_straight ge fn c rs m k rs' m\n  /\\ Val.lessdef (Val.select (eval_condition cond (map rs (map preg_of args)) m) rs#r1 rs#r2 ty) rs'#rd\n  /\\ forall (A : Type) (r : A), important_preg r = true -> r <> rd -> rs'#r = rs#r.\nProof.\n  intros cond args ty r1 r2 rd k rs m c TR Hrd Hr1 Hr2.\n  unfold transl_fselect_op in TR.\n  destruct (transl_cond cond args) as [c1|] eqn:TC; try discriminate.\n  inv TR.\n  econstructor; split; [|split].\n  + eapply exec_straight_trans.\n    eapply transl_cond_correct_1; eauto.\n    apply exec_straight_one.\n    simpl. rewrite H. reflexivity.\n    reflexivity.\n  + simpl. rewrite H0. apply Val.lessdef_refl.\n  + intros r Himp Hneq.\n    rewrite H1; auto.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall cond args ty r1 r2 rd k rs m c, transl_fselect_op cond args r1 r2 rd k = OK c -> important_preg rd = true -> important_preg r1 = true -> important_preg r2 = true -> exists rs', exec_straight ge fn c rs m k rs' m /\\ Val Step 2: Introduce variables and assumptions Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Case analysis by destructing a value Step 6: Apply tactic: - inv TR Step 7: Apply tactic: econstructor Step 8: Split a conjunction into separate goals Step 9: Apply tactic: [|split] Step 10: Apply tactic: + apply exec_straight_one Step 11: Simplify the goal by computation", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:transl_op_correct_aux", "draft": "Require Import Coq.Init.Byte Coq.ZArith.ZArith Coq.Arith.PeanoNat.\nLemma transl_op_correct_gpr1 : forall (op : operation) (args : list reg) (res : preg) (k : code) (rs : regset) (m : mem) (v : val) (c : code),\n  transl_op op args res k = OK c ->\n  eval_operation ge (rs#GPR1) op (map rs (map preg_of args)) m = Some v ->\n  exists rs' : regset,\n    exec_straight ge fn c rs m k rs' m /\\\n    Val.lessdef v (rs'#(preg_of res)) /\\\n    (forall r : preg, important_preg r = true -> r <> preg_of res -> preg_notin r (destroyed_by_op op) -> rs'#r = rs#r).\nProof.\n  intros op args res k rs m v c TR EV.\n  destruct op; try discriminate; monadInv TR; ArgsInv; try (eexists; split; [eapply exec_straight_one; [simpl; eauto|reflexivity]|split; [simpl; rewrite EV; auto|intros; Simpl]).\n  all: try (eexists; split; [eapply exec_straight_two; [simpl; eauto|simpl; eauto|reflexivity]|split; [simpl; rewrite EV; auto|intros; Simpl]).\n  all: try (eexists; split; [eapply exec_straight_three; [simpl; eauto|simpl; eauto|simpl; eauto|reflexivity]|split; [simpl; rewrite EV; auto|intros; Simpl]).\n  all: try (eexists; split; [eapply exec_straight_four; [simpl; eauto|simpl; eauto|simpl; eauto|simpl; eauto|reflexivity]|split; [simpl; rewrite EV; auto|intros; Simpl]).\nQed.", "nl_proof": "Step 1: Ointconst Step 2: Oaddrsymbol Step 3: Oshrximm Step 4: Olongconst Step 5: Oaddlimm Step 6: Oandlimm Step 7: Oxorlimm Step 8: Oshrxlimm Step 9: Olongoffloat Step 10: Ofloatoflong Step 11: Ointoffloat Step 12: small data Step 13: relative data Step 14: absolute data Step 15: Oaddrstack Step 16: Oaddsymbol Step 17: small data Step 18: relative data Step 19: absolute data Step 20: We need to prove that forall op args res k (rs: regset) m v c, transl_op op args res k = OK c -> eval_operation ge (rs#GPR1) op (map rs (map preg_of args)) m = Some v -> exists rs', exec_straight ge fn c rs m k rs' m /\\ Val Step 21: Apply tactic: assert (SAME: forall v1 v2, v1 = v2 -> Val Step 22: Apply tactic: lessdef v2 v1) Step 23: Apply tactic: { intros Step 24: Apply tactic: subst Step 25: Solve automatically using known facts Step 26: Apply tactic: Opaque Int Step 27: Introduce variables and assumptions Step 28: Unfold a definition Step 29: Case analysis by destructing a value Step 30: Apply tactic: ArgsInv", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof1:transl_load_correct", "draft": "```coq\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma transl_load_correct : forall chunk addr args dst k c (rs: regset) m vaddr v,\n  transl_load chunk addr args dst k = OK c ->\n  Op.eval_addressing ge (rs#SP) addr (map rs (map preg_of args)) = Some vaddr ->\n  Mem.loadv chunk m vaddr = Some v ->\n  exists rs',\n     exec_straight ge fn c rs m k rs' m\n  /\\ rs'#(preg_of dst) = v\n  /\\ forall (A : Type) (r : A), data_preg r = true -> r <> preg_of dst -> rs' r = rs r.\nProof.\n  intros until v; intros TR EA LD.\n  unfold transl_load in TR.\n  destruct (transl_memory_access (mk_load_instr chunk) addr args k) as [c'|] eqn:TR';\n  try discriminate.\n  inv TR.\n  exploit transl_memory_access_correct; eauto.\n  intros (base & ofs & rs' & A & B & C).\n  exists rs'; split; [eauto|split; [|eauto]].\n  rewrite B; auto.\nQed.\n```.\nQed.", "nl_proof": "Step 1: Mint8signed Step 2: Mint8unsigned Step 3: Mint816signed Step 4: Mint16unsigned Step 5: Mfloat32 Step 6: Mfloat64 Step 7: We need to prove that forall chunk addr args dst k c (rs: regset) m a v, transl_load chunk addr args dst k = OK c -> eval_addressing ge (rs#GPR1) addr (map rs (map preg_of args)) = Some a -> Mem Step 8: We need to prove that forall chunk addr args dest k c (rs: regset) m a v, transl_load chunk addr args dest k = OK c -> eval_addressing ge (rs#RSP) addr (map rs (map preg_of args)) = Some a -> Mem Step 9: We need to prove that forall chunk addr args dst k c (rs: regset) a m v, transl_load chunk addr args dst k = OK c -> eval_addressing ge (rs#SP) addr (map rs (map preg_of args)) = Some a -> Mem Step 10: We need to prove that forall chunk addr args dst k c (rs: regset) m a v, transl_load chunk addr args dst k = OK c -> eval_addressing ge rs#SP addr (map rs (map preg_of args)) = Some a -> Mem Step 11: Introduce variables and assumptions Step 12: Unfold a definition Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Apply tactic: assert (LD: forall v, Val Step 16: Introduce variables and assumptions Step 17: Case analysis by destructing a value Step 18: Introduce variables and assumptions Step 19: Apply tactic: lessdef a v -> v = a) Step 20: Apply tactic: monadInv H Step 21: Simplify the goal by computation Step 22: Apply tactic: assert (A: exists mk_instr, Step 23: Apply tactic: { intros Step 24: Apply tactic: exploit transl_addressing_mode_correct Step 25: Apply tactic: try discriminate Step 26: Apply tactic: transl_memory_access mk_instr addr args k = OK c Step 27: Apply tactic: inv H2 Step 28: Apply tactic: eauto Step 29: Apply tactic: eauto using transl_load_int_correct, transl_load_f Step 30: Apply tactic: /\\ forall base ofs rs, Step 31: Solve automatically using known facts Step 32: Apply tactic: intro EA Step 33: Apply tactic: Qed Step 34: Apply tactic: exec_instr ge fn (mk_instr base ofs) rs m = exec_l Step 35: Apply tactic: discriminate H1 Step 36: Apply tactic: assert (EA': eval_addrmode ge x rs = a) Step 37: Apply tactic: { unfold transl_load in TR Step 38: Apply tactic: assert (BASE: forall mk1 mk2 unaligned k' chunk' v Step 39: Case analysis by destructing a value Step 40: Case analysis by destructing a value Step 41: Apply tactic: transl_memory_access mk1 mk2 unaligned addr args G Step 42: Simplify the goal by computation Step 43: Apply tactic: ArgsInv Step 44: Apply tactic: Mem Step 45: Apply tactic: try discriminate Step 46: Apply tactic: econstructor", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:transf_program_match", "draft": "Require Import Coq.Arith.Arith.\nLemma transf_program_match : forall p tp, transf_program p = OK tp -> match_prog p tp.\nProof. eapply match_transform_partial_program; eauto. Qed.", "nl_proof": "Step 1: We need to prove that forall p tp, transf_program p = OK tp -> match_prog p tp Step 2: We need to prove that forall p tp, transf_program p = OK tp -> match_prog p tp Step 3: We need to prove that forall p tp, transf_program p = OK tp -> match_prog p tp Step 4: We need to prove that forall p tp, transf_program p = OK tp -> match_prog p tp Step 5: We need to prove that forall p tp, transf_program p = OK tp -> match_prog p tp Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: eapply match_transform_partial_program Step 12: Apply tactic: eapply match_transform_partial_program Step 13: Apply tactic: eapply match_transform_partial_program Step 14: Apply tactic: eapply match_transform_partial_program Step 15: Apply tactic: eapply match_transform_partial_program Step 16: Apply tactic: eauto Step 17: Apply tactic: eauto Step 18: Apply tactic: eauto Step 19: Apply tactic: eauto Step 20: Apply tactic: eauto Step 21: Apply tactic: Qed Step 22: Apply tactic: Qed Step 23: Apply tactic: Qed Step 24: Apply tactic: Qed Step 25: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:symbols_preserved", "draft": "Require Import Coq.Program.Basics.\nRequire Import Coq.Lists.List.\n\nLemma function_ptr_translated_template : forall (ge tge : Genv.t fundef unit) (transf_fundef : fundef -> fundef) (b : block) (f : fundef),\n  Genv.find_funct_ptr ge b = Some f ->\n  exists tf : fundef, Genv.find_funct_ptr tge b = Some tf /\\ transf_fundef f = tf.\nProof.\n  intros ge tge transf_fundef b f H.\n  exists (transf_fundef f).\n  split; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall (s: ident), Genv Step 2: We need to prove that forall (s: ident), Genv Step 3: We need to prove that forall (s: ident), Genv Step 4: We need to prove that forall (s: ident), Genv Step 5: We need to prove that forall (s: ident), Genv Step 6: Apply tactic: Lemma senv_preserved: Step 7: Apply tactic: Lemma senv_preserved: Step 8: Apply tactic: Lemma senv_preserved: Step 9: Apply tactic: Lemma senv_preserved: Step 10: Apply tactic: Lemma senv_preserved: Step 11: Apply tactic: Senv Step 12: Apply tactic: Senv Step 13: Apply tactic: Senv Step 14: Apply tactic: Senv Step 15: Apply tactic: Senv Step 16: Apply tactic: equiv ge tge Step 17: Apply tactic: equiv ge tge Step 18: Apply tactic: equiv ge tge Step 19: Apply tactic: equiv ge tge Step 20: Apply tactic: equiv ge tge Step 21: Apply tactic: Lemma functions_translated: Step 22: Apply tactic: Lemma functions_translated: Step 23: Apply tactic: Lemma functions_translated: Step 24: Apply tactic: Lemma functions_translated: Step 25: Apply tactic: Lemma functions_translated: Step 26: Apply tactic: forall b f, Step 27: Apply tactic: forall b f, Step 28: Apply tactic: forall b f, Step 29: Apply tactic: forall b f, Step 30: Apply tactic: forall b f, Step 31: Apply tactic: Genv Step 32: Apply tactic: Genv Step 33: Apply tactic: Genv Step 34: Apply tactic: Genv Step 35: Apply tactic: Genv Step 36: Apply tactic: find_funct_ptr ge b = Some f -> Step 37: Apply tactic: find_funct_ptr ge b = Some f -> Step 38: Apply tactic: find_funct_ptr ge b = Some f -> Step 39: Apply tactic: find_funct_ptr ge b = Some f -> Step 40: Apply tactic: find_funct_ptr ge b = Some f -> Step 41: Provide an existential witness Step 42: Provide an existential witness Step 43: Provide an existential witness Step 44: Provide an existential witness Step 45: Provide an existential witness Step 46: Apply tactic: Genv Step 47: Apply tactic: Genv Step 48: Apply tactic: Genv Step 49: Apply tactic: Genv Step 50: Apply tactic: Genv Step 51: Apply tactic: find_funct_ptr tge b = Some tf /\\ transf_fundef f Step 52: Apply tactic: find_funct_ptr tge b = Some tf /\\ transf_fundef f Step 53: Apply tactic: find_funct_ptr tge b = Some tf /\\ transf_fundef f Step 54: Apply tactic: find_funct_ptr tge b = Some tf /\\ transf_fundef f Step 55: Apply tactic: find_funct_ptr tge b = Some tf /\\ transf_fundef f", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:senv_preserved", "draft": "Require Import Coq.Lists.List.\n\nLemma functions_translated : forall (ge tge : Genv.t fundef unit) (transf_fundef : fundef -> fundef) (b : block) (f : fundef),\n  Genv.find_funct_ptr ge b = Some f ->\n  exists tf : fundef, Genv.find_funct_ptr tge b = Some tf /\\ transf_fundef f = tf.\nProof.\n  intros ge tge transf_fundef b f H.\n  exists (transf_fundef f).\n  split.\n  - apply Genv.find_funct_ptr_transf.\n    exact H.\n  - reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that Senv Step 2: We need to prove that Senv Step 3: We need to prove that Senv Step 4: We need to prove that Senv Step 5: We need to prove that Senv Step 6: Apply tactic: Lemma functions_translated: Step 7: Apply tactic: Lemma functions_translated: Step 8: Apply tactic: Lemma functions_translated: Step 9: Apply tactic: Lemma functions_translated: Step 10: Apply tactic: Lemma functions_translated: Step 11: Apply tactic: forall b f, Step 12: Apply tactic: forall b f, Step 13: Apply tactic: forall b f, Step 14: Apply tactic: forall b f, Step 15: Apply tactic: forall b f, Step 16: Apply tactic: Genv Step 17: Apply tactic: Genv Step 18: Apply tactic: Genv Step 19: Apply tactic: Genv Step 20: Apply tactic: Genv Step 21: Apply tactic: find_funct_ptr ge b = Some f -> Step 22: Apply tactic: find_funct_ptr ge b = Some f -> Step 23: Apply tactic: find_funct_ptr ge b = Some f -> Step 24: Apply tactic: find_funct_ptr ge b = Some f -> Step 25: Apply tactic: find_funct_ptr ge b = Some f -> Step 26: Provide an existential witness Step 27: Provide an existential witness Step 28: Provide an existential witness Step 29: Provide an existential witness Step 30: Provide an existential witness Step 31: Apply tactic: Genv Step 32: Apply tactic: Genv Step 33: Apply tactic: Genv Step 34: Apply tactic: Genv Step 35: Apply tactic: Genv Step 36: Apply tactic: find_funct_ptr tge b = Some tf /\\ transf_fundef f Step 37: Apply tactic: find_funct_ptr tge b = Some tf /\\ transf_fundef f Step 38: Apply tactic: find_funct_ptr tge b = Some tf /\\ transf_fundef f Step 39: Apply tactic: find_funct_ptr tge b = Some tf /\\ transf_fundef f Step 40: Apply tactic: find_funct_ptr tge b = Some tf /\\ transf_fundef f Step 41: Apply tactic: Lemma functions_transl: Step 42: Apply tactic: Lemma functions_transl: Step 43: Apply tactic: Lemma functions_transl: Step 44: Apply tactic: Lemma functions_transl: Step 45: Apply tactic: Lemma functions_transl: Step 46: Apply tactic: forall fb f tf, Step 47: Apply tactic: forall fb f tf, Step 48: Apply tactic: forall fb f tf, Step 49: Apply tactic: forall fb f tf, Step 50: Apply tactic: forall fb f tf, Step 51: Apply tactic: Genv Step 52: Apply tactic: Genv Step 53: Apply tactic: Genv Step 54: Apply tactic: Genv Step 55: Apply tactic: Genv", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:functions_translated", "draft": "```coq\nRequire Import Coq.Program.Equality.\nLemma functions_translated : forall (ge tge : Genv.t) (fb : block) (f : function) (tf : function),\n  Genv.find_funct_ptr ge fb = Some (Internal f) ->\n  transf_function f = OK tf ->\n  Genv.find_funct_ptr tge fb = Some (Internal tf).\nProof.\n  intros ge tge fb f tf H1 H2.\n  exploit (find_funct_ptr_transf_partial (transf_function) (fun _ => tt) ge tge).\n  - apply transform_partial_program_identity.\n  - exact H1.\n  - intros [tf' [H3 H4]].\n    rewrite H2 in H4.\n    inversion H4; subst.\n    exact H3.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall b f, Genv Step 2: We need to prove that forall b f, Genv Step 3: We need to prove that forall b f, Genv Step 4: We need to prove that forall b f, Genv Step 5: We need to prove that forall b f, Genv Step 6: Apply tactic: Lemma functions_transl: Step 7: Apply tactic: Lemma functions_transl: Step 8: Apply tactic: Lemma functions_transl: Step 9: Apply tactic: Lemma functions_transl: Step 10: Apply tactic: Lemma functions_transl: Step 11: Apply tactic: forall fb f tf, Step 12: Apply tactic: forall fb f tf, Step 13: Apply tactic: forall fb f tf, Step 14: Apply tactic: forall fb f tf, Step 15: Apply tactic: forall fb f tf, Step 16: Apply tactic: Genv Step 17: Apply tactic: Genv Step 18: Apply tactic: Genv Step 19: Apply tactic: Genv Step 20: Apply tactic: Genv Step 21: Apply tactic: find_funct_ptr ge fb = Some (Internal f) -> Step 22: Apply tactic: find_funct_ptr ge fb = Some (Internal f) -> Step 23: Apply tactic: find_funct_ptr ge fb = Some (Internal f) -> Step 24: Apply tactic: find_funct_ptr ge fb = Some (Internal f) -> Step 25: Apply tactic: find_funct_ptr ge fb = Some (Internal f) -> Step 26: Apply tactic: transf_function f = OK tf -> Step 27: Apply tactic: transf_function f = OK tf -> Step 28: Apply tactic: transf_function f = OK tf -> Step 29: Apply tactic: transf_function f = OK tf -> Step 30: Apply tactic: transf_function f = OK tf -> Step 31: Apply tactic: Genv Step 32: Apply tactic: Genv Step 33: Apply tactic: Genv Step 34: Apply tactic: Genv Step 35: Apply tactic: Genv Step 36: Apply tactic: find_funct_ptr tge fb = Some (Internal tf) Step 37: Apply tactic: find_funct_ptr tge fb = Some (Internal tf) Step 38: Apply tactic: find_funct_ptr tge fb = Some (Internal tf) Step 39: Apply tactic: find_funct_ptr tge fb = Some (Internal tf) Step 40: Apply tactic: find_funct_ptr tge fb = Some (Internal tf) Step 41: Introduce variables and assumptions Step 42: Introduce variables and assumptions Step 43: Introduce variables and assumptions Step 44: Introduce variables and assumptions Step 45: Introduce variables and assumptions Step 46: Apply tactic: exploit functions_translated Step 47: Apply tactic: exploit functions_translated Step 48: Apply tactic: exploit functions_translated Step 49: Apply tactic: exploit functions_translated Step 50: Apply tactic: exploit functions_translated Step 51: Apply tactic: eauto Step 52: Apply tactic: eauto Step 53: Apply tactic: eauto Step 54: Apply tactic: eauto Step 55: Apply tactic: eauto", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:functions_transl", "draft": "Require Import Coq.Lists.List.\nLemma functions_translated_inv : forall (fb f tf : nat) (B : option nat) (EQ : B = Some tf), exists x, Genv.find_funct_ptr fb f = Some x.\nProof.\n  intros. monadInv B. rewrite EQ. inv EQ. eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall fb f tf, Genv Step 2: We need to prove that forall fb f tf, Genv Step 3: We need to prove that forall fb f tf, Genv Step 4: We need to prove that forall fb f tf, Genv Step 5: We need to prove that forall fb f tf, Genv Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: exploit functions_translated Step 12: Apply tactic: exploit functions_translated Step 13: Apply tactic: exploit functions_translated Step 14: Apply tactic: exploit functions_translated Step 15: Apply tactic: exploit functions_translated Step 16: Apply tactic: eauto Step 17: Apply tactic: eauto Step 18: Apply tactic: eauto Step 19: Apply tactic: eauto Step 20: Apply tactic: eauto Step 21: Introduce variables and assumptions Step 22: Introduce variables and assumptions Step 23: Introduce variables and assumptions Step 24: Introduce variables and assumptions Step 25: Introduce variables and assumptions Step 26: Apply tactic: monadInv B Step 27: Apply tactic: monadInv B Step 28: Apply tactic: monadInv B Step 29: Apply tactic: monadInv B Step 30: Apply tactic: monadInv B Step 31: Rewrite using an equality Step 32: Rewrite using an equality Step 33: Rewrite using an equality Step 34: Rewrite using an equality Step 35: Rewrite using an equality Step 36: Apply tactic: inv EQ Step 37: Apply tactic: inv EQ Step 38: Apply tactic: inv EQ Step 39: Apply tactic: inv EQ Step 40: Apply tactic: inv EQ Step 41: Solve automatically using known facts Step 42: Solve automatically using known facts Step 43: Solve automatically using known facts Step 44: Solve automatically using known facts Step 45: Solve automatically using known facts Step 46: Apply tactic: Qed Step 47: Apply tactic: Qed Step 48: Apply tactic: Qed Step 49: Apply tactic: Qed Step 50: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:transf_function_no_overflow", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nRequire Import compcert.common.Values.\nRequire Import compcert.lib.Integers.\n\nLemma transf_function_no_overflow : forall f tf,\n  transf_function f = OK tf -> list_length_z (fn_code tf) <= Ptrofs.max_unsigned.\nProof.\n  intros f tf H. monadInv H. destruct x. inv EQ0. lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall f tf, transf_function f = OK tf -> list_length_z tf Step 2: We need to prove that forall f tf, transf_function f = OK tf -> list_length_z (fn_code tf) <= Ptrofs Step 3: We need to prove that forall f tf, transf_function f = OK tf -> list_length_z (fn_code tf) <= Ptrofs Step 4: We need to prove that forall f tf, transf_function f = OK tf -> list_length_z tf Step 5: We need to prove that forall f tf, transf_function f = OK tf -> list_length_z tf Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: monadInv H Step 12: Apply tactic: monadInv H Step 13: Apply tactic: monadInv H Step 14: Apply tactic: monadInv H Step 15: Apply tactic: monadInv H Step 16: Case analysis by destructing a value Step 17: Case analysis by destructing a value Step 18: Case analysis by destructing a value Step 19: Case analysis by destructing a value Step 20: Case analysis by destructing a value Step 21: Apply tactic: max_unsigned (list_length_z x Step 22: Apply tactic: max_unsigned (list_length_z (fn_code x))) Step 23: Apply tactic: max_unsigned (list_length_z (fn_code x))) Step 24: Apply tactic: max_unsigned (list_length_z x Step 25: Apply tactic: max_unsigned (list_length_z x Step 26: Apply tactic: (fn_code))) Step 27: Apply tactic: monadInv EQ0 Step 28: Apply tactic: inv EQ0 Step 29: Apply tactic: (fn_code))) Step 30: Apply tactic: (fn_code))) Step 31: Apply tactic: inv EQ0 Step 32: Apply tactic: lia Step 33: Apply tactic: lia Step 34: Apply tactic: inv EQ0 Step 35: Apply tactic: inv EQ0 Step 36: Apply tactic: lia Step 37: Apply tactic: Qed Step 38: Apply tactic: Qed Step 39: Apply tactic: lia Step 40: Apply tactic: lia Step 41: Apply tactic: Qed Step 42: Apply tactic: Qed Step 43: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:exec_straight_exec", "draft": "```coq\nRequire Import Coq.Init.Datatypes.\nLemma exec_straight_exec : forall (ge : Genv.t fundef unit) (tge : Genv.t fundef unit) (fb : block) (f : function) (c : list instruction) (ep : bool) (tf : function) (tc : list instruction) (c' : list instruction) (rs : regset) (m : mem) (rs' : regset) (m' : mem),\n  transl_code_at_pc ge (rs PC) fb f c ep tf tc ->\n  exec_straight tge tf tc rs m c' rs' m' ->\n  plus step tge (State rs m) E0 (State rs' m').\nProof.\n  intros. inv H. eapply exec_straight_steps_1; eauto. eapply transf_function_no_overflow; eauto. eapply functions_transl; eauto.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall fb f c ep tf tc c' rs m rs' m', transl_code_at_pc ge (rs PC) fb f c ep tf tc -> exec_straight tge tf tc rs m c' rs' m' -> plus step tge (State rs m) E0 (State rs' m') Step 2: We need to prove that forall fb f c ep tf tc c' rs m rs' m', transl_code_at_pc ge (rs PC) fb f c ep tf tc -> exec_straight tge tf tc rs m c' rs' m' -> plus step tge (State rs m) E0 (State rs' m') Step 3: We need to prove that forall fb f c ep tf tc c' rs m rs' m', transl_code_at_pc ge (rs PC) fb f c ep tf tc -> exec_straight tge tf tc rs m c' rs' m' -> plus step tge (State rs m) E0 (State rs' m') Step 4: We need to prove that forall fb f c ep tf tc c' rs m rs' m', transl_code_at_pc ge (rs PC) fb f c ep tf tc -> exec_straight tge tf tc rs m c' rs' m' -> plus step tge (State rs m) E0 (State rs' m') Step 5: We need to prove that forall fb f c ep tf tc c' rs m rs' m', transl_code_at_pc ge (rs PC) fb f c ep tf tc -> exec_straight tge tf tc rs m c' rs' m' -> plus step tge (State rs m) E0 (State rs' m') Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: inv H Step 12: Apply tactic: inv H Step 13: Apply tactic: inv H Step 14: Apply tactic: inv H Step 15: Apply tactic: inv H Step 16: Apply tactic: eapply exec_straight_steps_1 Step 17: Apply tactic: eapply exec_straight_steps_1 Step 18: Apply tactic: eapply exec_straight_steps_1 Step 19: Apply tactic: eapply exec_straight_steps_1 Step 20: Apply tactic: eapply exec_straight_steps_1 Step 21: Apply tactic: eauto Step 22: Apply tactic: eauto Step 23: Apply tactic: eauto Step 24: Apply tactic: eauto Step 25: Apply tactic: eauto Step 26: Apply tactic: eapply transf_function_no_overflow Step 27: Apply tactic: eapply transf_function_no_overflow Step 28: Apply tactic: eapply transf_function_no_overflow Step 29: Apply tactic: eapply transf_function_no_overflow Step 30: Apply tactic: eapply transf_function_no_overflow Step 31: Apply tactic: eauto Step 32: Apply tactic: eauto Step 33: Apply tactic: eauto Step 34: Apply tactic: eauto Step 35: Apply tactic: eauto Step 36: Apply tactic: eapply functions_transl Step 37: Apply tactic: eapply functions_transl Step 38: Apply tactic: eapply functions_transl Step 39: Apply tactic: eapply functions_transl Step 40: Apply tactic: eapply functions_transl Step 41: Apply tactic: eauto Step 42: Apply tactic: eauto Step 43: Apply tactic: eauto Step 44: Apply tactic: eauto Step 45: Apply tactic: eauto Step 46: Apply tactic: Qed Step 47: Apply tactic: Qed Step 48: Apply tactic: Qed Step 49: Apply tactic: Qed Step 50: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:exec_straight_at", "draft": "Require Import Coq.Arith.Arith.\n```coq\nRequire Import Coq.Init.Byte Coq.Lists.List.\nLemma exec_straight_at : forall ge tge fb f c ep tf tc c' ep' tc' rs m rs' m',\n  transl_code_at_pc ge (rs PC) fb f c ep tf tc ->\n  transl_code f c' ep' = OK tc' ->\n  exec_straight tge tf tc rs m tc' rs' m' ->\n  transl_code_at_pc ge (rs' PC) fb f c' ep' tf tc'.\nProof.\n  intros ge tge fb f c ep tf tc c' ep' tc' rs m rs' m' H H0 H1.\n  inv H.\n  exploit exec_straight_steps_2; eauto.\n  eapply transf_function_no_overflow; eauto.\n  eapply functions_transl; eauto.\n  intros [ofs' [H2 H3]].\n  rewrite H2.\n  constructor; auto.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall fb f c ep tf tc c' ep' tc' rs m rs' m', transl_code_at_pc ge (rs PC) fb f c ep tf tc -> transl_code f c' ep' = OK tc' -> exec_straight tge tf tc rs m tc' rs' m' -> transl_code_at_pc ge (rs' PC) fb f c' ep' tf tc' Step 2: We need to prove that forall fb f c ep tf tc c' ep' tc' rs m rs' m', transl_code_at_pc ge (rs PC) fb f c ep tf tc -> transl_code f c' ep' = OK tc' -> exec_straight tge tf tc rs m tc' rs' m' -> transl_code_at_pc ge (rs' PC) fb f c' ep' tf tc' Step 3: We need to prove that forall fb f c ep tf tc c' ep' tc' rs m rs' m', transl_code_at_pc ge (rs PC) fb f c ep tf tc -> transl_code f c' ep' = OK tc' -> exec_straight tge tf tc rs m tc' rs' m' -> transl_code_at_pc ge (rs' PC) fb f c' ep' tf tc' Step 4: We need to prove that forall fb f c ep tf tc c' ep' tc' rs m rs' m', transl_code_at_pc ge (rs PC) fb f c ep tf tc -> transl_code f c' ep' = OK tc' -> exec_straight tge tf tc rs m tc' rs' m' -> transl_code_at_pc ge (rs' PC) fb f c' ep' tf tc' Step 5: We need to prove that forall fb f c ep tf tc c' ep' tc' rs m rs' m', transl_code_at_pc ge (rs PC) fb f c ep tf tc -> transl_code f c' ep' = OK tc' -> exec_straight tge tf tc rs m tc' rs' m' -> transl_code_at_pc ge (rs' PC) fb f c' ep' tf tc' Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: inv H Step 12: Apply tactic: inv H Step 13: Apply tactic: inv H Step 14: Apply tactic: inv H Step 15: Apply tactic: inv H Step 16: Apply tactic: exploit exec_straight_steps_2 Step 17: Apply tactic: exploit exec_straight_steps_2 Step 18: Apply tactic: exploit exec_straight_steps_2 Step 19: Apply tactic: exploit exec_straight_steps_2 Step 20: Apply tactic: exploit exec_straight_steps_2 Step 21: Apply tactic: eauto Step 22: Apply tactic: eauto Step 23: Apply tactic: eauto Step 24: Apply tactic: eauto Step 25: Apply tactic: eauto Step 26: Apply tactic: eapply transf_function_no_overflow Step 27: Apply tactic: eapply transf_function_no_overflow Step 28: Apply tactic: eapply transf_function_no_overflow Step 29: Apply tactic: eapply transf_function_no_overflow Step 30: Apply tactic: eapply transf_function_no_overflow Step 31: Apply tactic: eauto Step 32: Apply tactic: eauto Step 33: Apply tactic: eauto Step 34: Apply tactic: eauto Step 35: Apply tactic: eauto Step 36: Apply tactic: eapply functions_transl Step 37: Apply tactic: eapply functions_transl Step 38: Apply tactic: eapply functions_transl Step 39: Apply tactic: eapply functions_transl Step 40: Apply tactic: eapply functions_transl Step 41: Apply tactic: eauto Step 42: Apply tactic: eauto Step 43: Apply tactic: eauto Step 44: Apply tactic: eauto Step 45: Apply tactic: eauto Step 46: Introduce variables and assumptions Step 47: Introduce variables and assumptions Step 48: Introduce variables and assumptions Step 49: Introduce variables and assumptions Step 50: Introduce variables and assumptions Step 51: Rewrite using an equality Step 52: Rewrite using an equality Step 53: Rewrite using an equality Step 54: Rewrite using an equality Step 55: Rewrite using an equality", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:loadimm_label", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import Coq.Lists.List.\n\nLemma loadimm_tail_nolabel : forall (sz rd n k : nat), tail_nolabel k (loadimm sz rd n k).\nProof.\n  intros sz rd n k.\n  unfold loadimm.\n  case (Int.eq (high_s n) Int.zero).\n  - case (leb (length (decompose_int n)) 1%nat).\n    + apply loadimm_z_label.\n    + apply loadimm_n_label.\n  - case (Int.eq (low_s n) Int.zero).\n    + set (l2 := length (decompose_int (Int.not n))).\n      case (leb l2 1%nat).\n      * apply TailNoLabel.\n      * apply TailNoLabel.\n    + apply TailNoLabel.\nQed.", "nl_proof": "Step 1: We need to prove that forall r n k, tail_nolabel k (loadimm r n k) Step 2: We need to prove that forall r n k, tail_nolabel k (loadimm r n k) Step 3: We need to prove that forall sz rd n k, tail_nolabel k (loadimm sz rd n k) Step 4: Introduce variables and assumptions Step 5: Introduce variables and assumptions Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Unfold a definition Step 9: Introduce variables and assumptions Step 10: Apply tactic: case (Int Step 11: Apply tactic: set (l1 := length (decompose_int n)) Step 12: Case analysis by destructing a value Step 13: Apply tactic: eq (high_s n) Int Step 14: Apply tactic: set (l2 := length (decompose_int (Int Step 15: Apply tactic: leb Step 16: Apply tactic: zero) Step 17: Apply tactic: not n))) Step 18: Apply tactic: [apply loadimm_z_label|apply loadimm_n_label] Step 19: Apply tactic: TailNoLabel Step 20: Case analysis by destructing a value Step 21: Apply tactic: Qed Step 22: Apply tactic: case (Int Step 23: Apply tactic: leb l1 1%nat) Step 24: Apply tactic: eq (low_s n) Int Step 25: Apply tactic: TailNoLabel Step 26: Apply tactic: zero) Step 27: Case analysis by destructing a value Step 28: Apply tactic: TailNoLabel Step 29: Apply tactic: leb l2 1%nat)", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:addimm_label", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma tail_nolabel_addimm : forall (r1 r2 n k : nat), tail_nolabel k (addimm r1 r2 n k).\nProof.\n  intros r1 r2 n k.\n  unfold addimm.\n  destruct (Int.eq (high_s n) Int.zero) eqn:H1.\n  - apply TailNoLabel.\n  - destruct (Int.ltu (Int.repr (-256)) n) eqn:H2.\n    + apply TailNoLabel.\n    + destruct (Int.eq (low_s n) Int.zero) eqn:H3.\n      * apply TailNoLabel.\n      * destruct (Nat.leb (length (decompose_int n)) (length (decompose_int (Int.neg n)))) eqn:H4.\n        { apply TailNoLabel. }\n        { apply TailNoLabel. }\nQed.", "nl_proof": "Step 1: We need to prove that forall r1 r2 n k, tail_nolabel k (addimm r1 r2 n k) Step 2: We need to prove that forall r1 r2 n k, tail_nolabel k (addimm r1 r2 n k) Step 3: Introduce variables and assumptions Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Apply tactic: case (Int Step 8: Case analysis by destructing a value Step 9: Apply tactic: eq (high_s n) Int Step 10: Apply tactic: ltu (Int Step 11: Apply tactic: zero) Step 12: Apply tactic: repr (-256)) n) Step 13: Apply tactic: TailNoLabel Step 14: Apply tactic: TailNoLabel Step 15: Apply tactic: case (Int Step 16: Case analysis by destructing a value Step 17: Apply tactic: eq (low_s n) Int Step 18: Apply tactic: leb (length (decompose_int n)) (length (decompose_ Step 19: Apply tactic: zero) Step 20: Apply tactic: neg n)))) Step 21: Apply tactic: TailNoLabel Step 22: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:andimm_base_label", "draft": "Require Import Coq.Arith.Arith.\nLemma andimm_base_label : forall (r1 r2 n k : nat), tail_nolabel k (andimm_base r1 r2 n k).\nProof.\n  intros r1 r2 n k.\n  unfold andimm_base.\n  case (Int.eq (high_u n) Int.zero).\n  TailNoLabel.\n  case (Int.eq (low_u n) Int.zero).\n  TailNoLabel.\nQed.", "nl_proof": "Step 1: We need to prove that forall r1 r2 n k, tail_nolabel k (andimm_base r1 r2 n k) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: case (Int Step 5: Apply tactic: eq (high_u n) Int Step 6: Apply tactic: zero) Step 7: Apply tactic: TailNoLabel Step 8: Apply tactic: case (Int Step 9: Apply tactic: eq (low_u n) Int Step 10: Apply tactic: zero) Step 11: Apply tactic: TailNoLabel", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:andimm_label", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma tail_nolabel_andimm : forall (r1 r2 n k : nat), tail_nolabel k (andimm r1 r2 n k).\nProof.\n  intros r1 r2 n k.\n  unfold andimm.\n  destruct (is_rlw_mask n).\n  - apply TailNoLabel.\n  - apply TailNoLabel.\nQed.", "nl_proof": "Step 1: We need to prove that forall r1 r2 n k, tail_nolabel k (andimm r1 r2 n k) Step 2: We need to prove that forall r1 r2 n k, tail_nolabel k (andimm r1 r2 n k) Step 3: Introduce variables and assumptions Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Apply tactic: case (is_rlw_mask n) Step 8: Case analysis by destructing a value Step 9: Apply tactic: TailNoLabel Step 10: Apply tactic: TailNoLabel Step 11: Apply tactic: Qed Step 12: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:orimm_label", "draft": "Require Import Coq.Arith.Arith.\nLemma orimm_tail_nolabel : forall (r1 r2 n k : nat), tail_nolabel k (orimm r1 r2 n k).\nProof.\n  intros r1 r2 n k.\n  unfold orimm.\n  case (Int.eq (high_u n) Int.zero).\n  - apply TailNoLabel.\n  - case (Int.eq (low_u n) Int.zero).\n    + apply TailNoLabel.\n    + apply TailNoLabel.\nQed.", "nl_proof": "Step 1: We need to prove that forall r1 r2 n k, tail_nolabel k (orimm r1 r2 n k) Step 2: We need to prove that forall r1 r2 n k, tail_nolabel k (orimm r1 r2 n k) Step 3: Introduce variables and assumptions Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Apply tactic: case (Int Step 8: Solve automatically using known facts Step 9: Apply tactic: eq (high_u n) Int Step 10: Apply tactic: Qed Step 11: Apply tactic: zero) Step 12: Apply tactic: TailNoLabel Step 13: Apply tactic: case (Int Step 14: Apply tactic: eq (low_u n) Int Step 15: Apply tactic: zero) Step 16: Apply tactic: TailNoLabel", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:xorimm_label", "draft": "Require Import Coq.Arith.Arith.\nLemma xorimm_tail_nolabel : forall (r1 r2 n k : nat), tail_nolabel k (xorimm r1 r2 n k).\nProof.\n  intros r1 r2 n k.\n  unfold xorimm.\n  case (Int.eq (high_u n) Int.zero).\n  - apply TailNoLabel.\n  - case (Int.eq (low_u n) Int.zero).\n    + apply TailNoLabel.\n    + apply TailNoLabel.\nQed.", "nl_proof": "Step 1: We need to prove that forall r1 r2 n k, tail_nolabel k (xorimm r1 r2 n k) Step 2: We need to prove that forall r1 r2 n k, tail_nolabel k (xorimm r1 r2 n k) Step 3: Introduce variables and assumptions Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Apply tactic: case (Int Step 8: Solve automatically using known facts Step 9: Apply tactic: eq (high_u n) Int Step 10: Apply tactic: Qed Step 11: Apply tactic: zero) Step 12: Apply tactic: TailNoLabel Step 13: Apply tactic: case (Int Step 14: Apply tactic: eq (low_u n) Int Step 15: Apply tactic: zero) Step 16: Apply tactic: TailNoLabel", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:rolm_label", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma rolm_label : forall (r1 r2 amount mask k : nat), tail_nolabel k (rolm r1 r2 amount mask k).\nProof.\n  intros r1 r2 amount mask k.\n  unfold rolm.\n  case (is_rlw_mask mask).\n  - apply TailNoLabel.\n  - apply TailNoLabel.\nQed.", "nl_proof": "Step 1: We need to prove that forall r1 r2 amount mask k, tail_nolabel k (rolm r1 r2 amount mask k) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: case (is_rlw_mask mask) Step 5: Apply tactic: TailNoLabel Step 6: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:loadimm64_32s_label", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma tail_nolabel_loadimm64_32s : forall (r n k : nat), tail_nolabel k (loadimm64_32s r n k).\nProof.\n  intros r n k.\n  unfold loadimm64_32s.\n  destruct n.\n  - apply TailNoLabel.\n  - apply TailNoLabel.\nQed.", "nl_proof": "Step 1: We need to prove that forall r n k, tail_nolabel k (loadimm64_32s r n k) Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: TailNoLabel Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:loadimm64_label", "draft": "Require Import Coq.Init.Byte Coq.ZArith.Int.\nLemma loadimm64_tail_nolabel : forall (r : reg) (n : int64) (k : code), tail_nolabel k (loadimm64 r n k).\nProof.\n  intros r n k.\n  unfold loadimm64.\n  destruct (Int64.eq n (Int64.zero)) eqn:EQ.\n  - apply TailNoLabel.\n  - apply TailNoLabel.\nQed.", "nl_proof": "Step 1: We need to prove that forall r n k, tail_nolabel k (loadimm64 r n k) Step 2: We need to prove that forall r n k, tail_nolabel k (loadimm64 r n k) Step 3: We need to prove that forall r n k, tail_nolabel k (loadimm64 r n k) Step 4: Unfold a definition Step 5: Introduce variables and assumptions Step 6: Unfold a definition Step 7: Introduce variables and assumptions Step 8: Unfold a definition Step 9: Introduce variables and assumptions Step 10: Case analysis by destructing a value Step 11: Case analysis by destructing a value Step 12: Case analysis by destructing a value Step 13: Apply tactic: TailNoLabel Step 14: Apply tactic: TailNoLabel Step 15: Apply tactic: TailNoLabel Step 16: Apply tactic: Qed Step 17: Unfold a definition Step 18: Apply tactic: Qed Step 19: Case analysis by destructing a value Step 20: Apply tactic: eq lo Int64 Step 21: Apply tactic: zero) Step 22: Apply tactic: TailNoLabel Step 23: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:loadimm64_notemp_label", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma loadimm64_notemp_label : forall (r n k : nat), tail_nolabel k (loadimm64_notemp r n k).\nProof.\n  intros r n k.\n  unfold loadimm64_notemp.\n  destruct _.\n  - apply TailNoLabel.\n  - eapply tail_nolabel_trans.\n    + apply TailNoLabel.\n    + apply TailNoLabel.\nQed.", "nl_proof": "Step 1: We need to prove that forall r n k, tail_nolabel k (loadimm64_notemp r n k) Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: TailNoLabel Step 6: Apply tactic: eapply tail_nolabel_trans Step 7: Apply tactic: TailNoLabel Step 8: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:loadind_label", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma loadind_tail_nolabel : forall (base ofs ty dst k c : Type), loadind base ofs ty dst k = OK c -> tail_nolabel k c.\nProof.\n  intros base ofs ty dst k c H.\n  set (ofs' := Ptrofs) in *.\n  destruct ofs.\n  destruct ty.\n  destruct dst.\n  destruct k.\n  set (ofs_mod := Int) in *.\n  destruct ofs_mod.\n  try discriminate.\n  inv H.\n  apply TailNoLabel.\n  exact I.\nQed.", "nl_proof": "Step 1: We need to prove that forall base ofs ty dst k c, loadind base ofs ty dst k = OK c -> tail_nolabel k c Step 2: We need to prove that forall base ofs ty dst k c, loadind base ofs ty dst k = OK c -> tail_nolabel k c Step 3: We need to prove that forall base ofs ty dst k c, loadind base ofs ty dst k = OK c -> tail_nolabel k c Step 4: We need to prove that forall base ofs ty dst k c, loadind base ofs ty dst k = OK c -> tail_nolabel k c Step 5: We need to prove that forall base ofs ty dst k c, loadind base ofs ty dst k = OK c -> tail_nolabel k c Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Unfold a definition Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Apply tactic: set (ofs' := Ptrofs Step 17: Case analysis by destructing a value Step 18: Case analysis by destructing a value Step 19: Case analysis by destructing a value Step 20: Case analysis by destructing a value Step 21: Apply tactic: to_int ofs) in * Step 22: Apply tactic: try discriminate Step 23: Apply tactic: inv H Step 24: Apply tactic: inv H Step 25: Apply tactic: inv H Step 26: Apply tactic: set (ofs_mod := Int Step 27: Case analysis by destructing a value Step 28: Apply tactic: TailNoLabel Step 29: Apply a theorem or hypothesis Step 30: Apply a theorem or hypothesis Step 31: Apply tactic: eq (Int Step 32: Apply tactic: TailNoLabel Step 33: Apply tactic: Qed Step 34: Introduce variables and assumptions Step 35: Introduce variables and assumptions Step 36: Apply tactic: mods ofs' (Int Step 37: Apply tactic: Qed Step 38: Apply tactic: exact I Step 39: Apply tactic: exact I Step 40: Apply tactic: repr 4)) Int Step 41: Apply tactic: Qed Step 42: Apply tactic: Qed Step 43: Apply tactic: zero) in * Step 44: Case analysis by destructing a value", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:storeind_label", "draft": "Require Import Coq.Lists.List.\nLemma storeind_tail_nolabel : forall (src base ofs ty k c : Type), storeind src base ofs ty k = OK c -> tail_nolabel k c.\nProof.\n  intros src base ofs ty k c H.\n  set (ofs' := Ptrofs.to_int ofs) in *.\n  destruct ofs' as [ofs_mod|] eqn:E.\n  - set (ofs_mod_eq := Int.eq ofs_mod (Int.repr 4)) in *.\n    destruct ofs_mod_eq eqn:F.\n    + inv H. apply TailNoLabel.\n    + inv H. apply TailNoLabel.\n  - inv H. apply TailNoLabel.\nQed.", "nl_proof": "Step 1: We need to prove that forall base ofs ty src k c, storeind src base ofs ty k = OK c -> tail_nolabel k c Step 2: We need to prove that forall base ofs ty src k c, storeind src base ofs ty k = OK c -> tail_nolabel k c Step 3: We need to prove that forall base ofs ty src k c, storeind src base ofs ty k = OK c -> tail_nolabel k c Step 4: We need to prove that forall src base ofs ty k c, storeind src base ofs ty k = OK c -> tail_nolabel k c Step 5: We need to prove that forall src base ofs ty k c, storeind src base ofs ty k = OK c -> tail_nolabel k c Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Unfold a definition Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Apply tactic: set (ofs' := Ptrofs Step 17: Case analysis by destructing a value Step 18: Case analysis by destructing a value Step 19: Case analysis by destructing a value Step 20: Case analysis by destructing a value Step 21: Apply tactic: to_int ofs) in * Step 22: Apply tactic: try discriminate Step 23: Apply tactic: inv H Step 24: Apply tactic: inv H Step 25: Apply tactic: inv H Step 26: Apply tactic: set (ofs_mod := Int Step 27: Case analysis by destructing a value Step 28: Apply tactic: TailNoLabel Step 29: Apply a theorem or hypothesis Step 30: Apply a theorem or hypothesis Step 31: Apply tactic: eq (Int Step 32: Apply tactic: TailNoLabel Step 33: Apply tactic: Qed Step 34: Introduce variables and assumptions Step 35: Introduce variables and assumptions Step 36: Apply tactic: mods ofs' (Int Step 37: Apply tactic: Qed Step 38: Apply tactic: exact I Step 39: Apply tactic: exact I Step 40: Apply tactic: repr 4)) Int Step 41: Apply tactic: Qed Step 42: Apply tactic: Qed Step 43: Apply tactic: zero) in * Step 44: Case analysis by destructing a value", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:floatcomp_label", "draft": "Require Import Coq.Lists.List.\nLemma floatcomp_label : forall cmp r1 r2 k, tail_nolabel k (floatcomp cmp r1 r2 k).\nProof. intros; unfold floatcomp; destruct cmp; apply TailNoLabel. Qed.", "nl_proof": "Step 1: We need to prove that forall cmp r1 r2 k, tail_nolabel k (floatcomp cmp r1 r2 k) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Apply tactic: TailNoLabel Step 6: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:transl_cond_label", "draft": "Require Import Coq.Lists.List.\nLemma transl_cond_tail_nolabel : forall (cond : Type) (args : list Type) (k c : Type), transl_cond cond args k = OK c -> tail_nolabel k c.\nProof.\n  intros cond args k c H.\n  unfold transl_cond in H.\n  destruct cond; try discriminate.\n  all: repeat (destruct args; try discriminate).\n  all: try (apply TailNoLabel; auto).\n  all: try (eapply tail_nolabel_trans; eauto).\n  all: try (destruct is_arith_imm32; eauto).\n  all: try (destruct (eq_dec n Int); eauto).\n  all: try (destruct (eq_dec n Int64); eauto).\n  all: try (destruct i; eauto).\nQed.", "nl_proof": "Step 1: We need to prove that forall cond args k c, transl_cond cond args k = OK c -> tail_nolabel k c Step 2: We need to prove that forall cond args k c, transl_cond cond args k = OK c -> tail_nolabel k c Step 3: We need to prove that forall cond args k c, transl_cond cond args k = OK c -> tail_nolabel k c Step 4: We need to prove that forall cond args k c, transl_cond cond args k = OK c -> tail_nolabel k c Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Unfold a definition Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Case analysis by destructing a value Step 14: Case analysis by destructing a value Step 15: Case analysis by destructing a value Step 16: Case analysis by destructing a value Step 17: Apply tactic: TailNoLabel Step 18: Apply tactic: TailNoLabel Step 19: Apply tactic: TailNoLabel Step 20: Apply tactic: TailNoLabel Step 21: Apply tactic: eapply tail_nolabel_trans Step 22: Case analysis by destructing a value Step 23: Case analysis by destructing a value Step 24: Apply tactic: - destruct is_arith_imm32 Step 25: Apply tactic: TailNoLabel Step 26: Apply tactic: eq_dec n Int Step 27: Apply tactic: TailNoLabel Step 28: Apply tactic: TailNoLabel Step 29: Apply tactic: Qed Step 30: Apply tactic: zero) Step 31: Apply tactic: eapply tail_nolabel_trans Step 32: Case analysis by destructing a value Step 33: Apply tactic: TailNoLabel Step 34: Apply tactic: TailNoLabel Step 35: Apply tactic: TailNoLabel Step 36: Case analysis by destructing a value Step 37: Case analysis by destructing a value Step 38: Apply tactic: eapply tail_nolabel_trans Step 39: Apply tactic: eq_dec n Int64 Step 40: Apply tactic: neg i)) Step 41: Apply tactic: TailNoLabel", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:transl_cond_op_label", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma transl_cond_op_tail_nolabel : forall cond args r k c, transl_cond_op cond args r k = OK c -> tail_nolabel k c.\nProof.\n  intros cond args r k c H.\n  unfold transl_cond_op in H.\n  destruct cond;\n  destruct args;\n  try discriminate;\n  try (destruct args; try discriminate);\n  try (destruct args; try discriminate);\n  try (inversion H; subst; apply TailNoLabel);\n  try (simpl in H; destruct (transl_cond _ _ _); try discriminate; inversion H; subst; eapply tail_nolabel_trans; [eapply transl_cond_label|apply TailNoLabel]).\nQed.", "nl_proof": "Step 1: We need to prove that forall cond args r k c, transl_cond_op cond args r k = OK c -> tail_nolabel k c Step 2: We need to prove that forall cond args r k c, transl_cond_op cond r args k = OK c -> tail_nolabel k c Step 3: Unfold a definition Step 4: Introduce variables and assumptions Step 5: Introduce variables and assumptions Step 6: Unfold a definition Step 7: Case analysis by destructing a value Step 8: Case analysis by destructing a value Step 9: Apply tactic: TailNoLabel Step 10: Apply tactic: TailNoLabel Step 11: Apply tactic: eapply tail_nolabel_trans Step 12: Apply tactic: - destruct c0 Step 13: Apply tactic: eapply transl_cond_label Step 14: Simplify the goal by computation Step 15: Apply tactic: eauto Step 16: Apply tactic: TailNoLabel Step 17: Case analysis by destructing a value Step 18: Apply tactic: - destruct c0 Step 19: Apply tactic: TailNoLabel Step 20: Simplify the goal by computation Step 21: Apply tactic: Qed Step 22: Apply tactic: TailNoLabel", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:transl_select_op_label", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma transl_select_op_label : forall cond args r1 r2 rd k c, transl_select_op cond args r1 r2 rd k = OK c -> tail_nolabel k c.\nProof.\n  intros. unfold transl_select_op in H. destruct (transl_cond cond args _); try discriminate. inv H. eapply tail_nolabel_trans. eapply transl_cond_label; eauto. TailNoLabel.\nQed.", "nl_proof": "Step 1: We need to prove that forall cond args r1 r2 rd k c, transl_select_op cond args r1 r2 rd k = OK c -> tail_nolabel k c Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: TailNoLabel Step 6: Apply tactic: eapply tail_nolabel_trans Step 7: Apply tactic: eapply transl_cond_label Step 8: Apply tactic: eauto Step 9: Apply tactic: TailNoLabel Step 10: Apply tactic: Qed", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:transl_fselect_op_label", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma transl_fselect_op_label : forall cond args r1 r2 rd k c, transl_fselect_op cond args r1 r2 rd k = OK c -> tail_nolabel k c.\nProof.\n  unfold transl_fselect_op.\n  intros cond args r1 r2 rd k c H.\n  destruct (transl_cond cond args); simpl in H; try discriminate.\n  eapply tail_nolabel_trans.\n  eapply transl_cond_label; eauto.\n  TailNoLabel.\nQed.", "nl_proof": "Step 1: We need to prove that forall cond args r1 r2 rd k c, transl_fselect_op cond args r1 r2 rd k = OK c -> tail_nolabel k c Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: TailNoLabel Step 6: Apply tactic: eapply tail_nolabel_trans Step 7: Apply tactic: eapply transl_cond_label Step 8: Apply tactic: eauto Step 9: Apply tactic: TailNoLabel Step 10: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:transl_op_label", "draft": "Require Import Coq.Lists.List.\nLemma transl_op_tail_nolabel : forall (op : operation) (args : list mreg) (r : mreg) (k : code) (c : code), transl_op op args r k = OK c -> tail_nolabel k c.\nProof.\n  intros op args r k c H.\n  unfold transl_op in H.\n  destruct op; try discriminate;\n  try (destruct args; try discriminate);\n  try (destruct args; try discriminate);\n  try (destruct args; try discriminate);\n  try (destruct args; try discriminate);\n  try (destruct preg_of; try discriminate);\n  try (destruct Int.eq; try discriminate);\n  try (destruct Int64.eq; try discriminate);\n  try (destruct Float.eq; try discriminate);\n  try (inv H; apply tail_nolabel_cons; auto);\n  try (inv H; apply tail_nolabel_cons; auto);\n  try (inv H; apply tail_nolabel_cons; auto).\nQed.", "nl_proof": "Step 1: We need to prove that forall op args r k c, transl_op op args r k = OK c -> tail_nolabel k c Step 2: We need to prove that forall op args r k c, transl_op op args r k = OK c -> tail_nolabel k c Step 3: We need to prove that forall op args r k c, transl_op op args r k = OK c -> tail_nolabel k c Step 4: We need to prove that forall op args r k c, transl_op op args r k = OK c -> tail_nolabel k c Step 5: We need to prove that forall op args r k c, transl_op op args r k = OK c -> tail_nolabel k c Step 6: Apply tactic: Opaque Int Step 7: Unfold a definition Step 8: Apply tactic: Opaque Int Step 9: Apply tactic: Opaque Int Step 10: Unfold a definition Step 11: Unfold a definition Step 12: Introduce variables and assumptions Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Introduce variables and assumptions Step 16: Introduce variables and assumptions Step 17: Case analysis by destructing a value Step 18: Introduce variables and assumptions Step 19: Introduce variables and assumptions Step 20: Case analysis by destructing a value Step 21: Case analysis by destructing a value Step 22: Apply tactic: TailNoLabel Step 23: Case analysis by destructing a value Step 24: Case analysis by destructing a value Step 25: Apply tactic: TailNoLabel Step 26: Apply tactic: TailNoLabel Step 27: Case analysis by destructing a value Step 28: Apply tactic: TailNoLabel Step 29: Apply tactic: TailNoLabel Step 30: Apply tactic: - destruct (preg_of r) Step 31: Apply tactic: - destruct (preg_of r) Step 32: Apply tactic: eq_dec n Int Step 33: Case analysis by destructing a value Step 34: Apply tactic: - destruct (preg_of r) Step 35: Apply tactic: try discriminate Step 36: Apply tactic: try discriminate Step 37: Apply tactic: zero) Step 38: Apply tactic: try discriminate Step 39: Apply tactic: try discriminate Step 40: Case analysis by destructing a value Step 41: Case analysis by destructing a value Step 42: Apply tactic: TailNoLabel Step 43: Case analysis by destructing a value Step 44: Case analysis by destructing a value Step 45: Apply tactic: inv H Step 46: Apply tactic: inv H Step 47: Case analysis by destructing a value Step 48: Apply tactic: inv H Step 49: Apply tactic: inv H Step 50: Apply tactic: TailNoLabel Step 51: Apply tactic: TailNoLabel Step 52: Apply tactic: eq_dec n Int64 Step 53: Apply tactic: TailNoLabel Step 54: Apply tactic: TailNoLabel Step 55: Apply tactic: - destruct (Float", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:transl_memory_access_label", "draft": "Require Import Coq.Lists.List.\nLemma transl_memory_access_label : forall (mk_instr: ireg -> offset -> instruction) (addr: addressing) (args: list mreg) (k: code) (c: code),\n  (forall (r : ireg) (o : offset), nolabel (mk_instr r o)) ->\n  transl_memory_access mk_instr addr args k = OK c -> tail_nolabel k c.\nProof.\n  intros mk_instr addr args k c Hnolabel Htransl.\n  unfold transl_memory_access in Htransl.\n  destruct addr; try destruct args; try discriminate;\n  repeat match goal with\n  | H: context[match ?x with _ => _ end = OK _] |- _ => destruct x eqn:?; try discriminate\n  | H: OK _ = OK _ |- _ => inversion H; clear H; subst\n  end;\n  apply tail_nolabel_cons; [apply Hnolabel | assumption].\nQed.", "nl_proof": "Step 1: We need to prove that forall (mk1: constant -> ireg -> instruction) (mk2: ireg -> ireg -> instruction) unaligned addr args temp k c, transl_memory_access mk1 mk2 unaligned addr args temp k = OK c -> (forall c r, nolabel (mk1 c r)) -> (forall r1 r2, nolabel (mk2 r1 r2)) -> tail_nolabel k c Step 2: We need to prove that forall (mk_instr_imm: ireg -> int -> instruction) (mk_instr_gen: option (ireg -> shift_op -> instruction)) (mk_immed: int -> int) (addr: addressing) (args: list mreg) c k, transl_memory_access mk_instr_imm mk_instr_gen mk_immed addr args k = OK c -> (forall r n, nolabel (mk_instr_imm r n)) -> (match mk_instr_gen with | None => True | Some f => forall r sa, nolabel (f r sa) end) -> tail_nolabel k c Step 3: We need to prove that forall (mk_instr: ireg -> offset -> instruction) addr args k c, (forall r o, nolabel (mk_instr r o)) -> transl_memory_access mk_instr addr args k = OK c -> tail_nolabel k c Step 4: Unfold a definition Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Case analysis by destructing a value Step 11: Case analysis by destructing a value Step 12: Case analysis by destructing a value Step 13: Apply tactic: TailNoLabel Step 14: Apply tactic: TailNoLabel Step 15: Apply tactic: TailNoLabel Step 16: Case analysis by destructing a value Step 17: Case analysis by destructing a value Step 18: Apply a theorem or hypothesis Step 19: Apply tactic: eq (Int Step 20: Apply tactic: TailNoLabel Step 21: Solve automatically using known facts Step 22: Apply tactic: mods i (Int Step 23: Case analysis by destructing a value Step 24: Apply tactic: Qed Step 25: Apply tactic: repr 4)) Int Step 26: Apply tactic: TailNoLabel Step 27: Apply tactic: zero) Step 28: Apply tactic: Qed Step 29: Case analysis by destructing a value", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:transl_epilogue_label", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma transl_epilogue_tail_nolabel : forall (f k : nat), tail_nolabel k (transl_epilogue f k).\nProof.\n  intros f k.\n  unfold transl_epilogue.\n  destruct f.\n  - apply TailNoLabel.\n  - apply TailNoLabel.\nQed.", "nl_proof": "Step 1: We need to prove that forall f k, tail_nolabel k (transl_epilogue f k) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Apply tactic: TailNoLabel Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:transl_instr_label", "draft": "Require Import Coq.Arith.Arith.\n```coq\nRequire Import Coq.Lists.List.\nLemma transl_instr_label : forall f i ep k c,\n  transl_instr f i ep k = OK c ->\n  match i with Mlabel lbl => c = Plabel lbl :: k | _ => tail_nolabel k c end.\nProof.\n  intros f i ep k c H.\n  destruct i; simpl in H; try monadInv H;\n  try (apply tail_nolabel_cons; auto);\n  try (eapply loadind_label; eauto);\n  try (eapply storeind_label; eauto);\n  try (destruct ep; monadInv H; apply tail_nolabel_cons; auto;\n       eapply loadind_label; eauto).\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall f i ep k c, transl_instr f i ep k = OK c -> match i with Mlabel lbl => c = Plabel lbl :: k | _ => tail_nolabel k c end Step 2: We need to prove that forall f i ep k c, transl_instr f i ep k = OK c -> match i with Mlabel lbl => c = Plabel lbl :: k | _ => tail_nolabel k c end Step 3: We need to prove that forall f i ep k c, transl_instr f i ep k = OK c -> match i with Mlabel lbl => c = Plabel lbl :: k | _ => tail_nolabel k c end Step 4: We need to prove that forall f i ep k c, transl_instr f i ep k = OK c -> match i with Mlabel lbl => c = Plabel lbl :: k | _ => tail_nolabel k c end Step 5: We need to prove that forall f i ep k c, transl_instr f i ep k = OK c -> match i with Mlabel lbl => c = Plabel lbl :: k | _ => tail_nolabel k c end Step 6: Unfold a definition Step 7: Apply tactic: Opaque loadind Step 8: Unfold a definition Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Introduce variables and assumptions Step 12: Unfold a definition Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Case analysis by destructing a value Step 17: Introduce variables and assumptions Step 18: Case analysis by destructing a value Step 19: Case analysis by destructing a value Step 20: Case analysis by destructing a value Step 21: Apply tactic: TailNoLabel Step 22: Case analysis by destructing a value Step 23: Apply tactic: TailNoLabel Step 24: Apply tactic: TailNoLabel Step 25: Apply tactic: TailNoLabel Step 26: Apply tactic: eapply loadind_label Step 27: Apply tactic: TailNoLabel Step 28: Apply tactic: eapply loadind_label Step 29: Apply tactic: - eapply loadind_label Step 30: Apply tactic: - eapply loadind_label Step 31: Apply tactic: eauto Step 32: Apply tactic: eapply loadind_label Step 33: Apply tactic: eauto Step 34: Apply tactic: eauto Step 35: Apply tactic: eauto Step 36: Apply tactic: eapply storeind_label Step 37: Apply tactic: eauto Step 38: Apply tactic: eapply storeind_label Step 39: Apply tactic: - eapply storeind_label Step 40: Apply tactic: - eapply storeind_label Step 41: Apply tactic: eauto Step 42: Apply tactic: eapply storeind_label Step 43: Apply tactic: eauto Step 44: Apply tactic: eauto Step 45: Apply tactic: eauto Step 46: Apply tactic: eapply loadind_label Step 47: Apply tactic: eauto Step 48: Case analysis by destructing a value Step 49: Apply tactic: - destruct ep Step 50: Apply tactic: - destruct ep Step 51: Apply tactic: eauto Step 52: Apply tactic: eapply loadind_label Step 53: Apply tactic: eapply loadind_label Step 54: Apply tactic: eapply loadind_label Step 55: Apply tactic: eapply loadind_label", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:transl_code_label", "draft": "Require Import Coq.Lists.List.\nLemma transl_code_label : forall (lbl : Mach.label) (f : Mach.function) (c : Mach.code) (ep : bool) (tc : list Asm.instruction),\n  transl_code f c ep = OK tc ->\n  match Mach.find_label lbl c with\n  | None => Asm.find_label lbl tc = None\n  | Some c' => exists tc', Asm.find_label lbl tc = Some tc' /\\ transl_code f c' false = OK tc'\n  end.\nProof.\n  induction c; intros ep tc H; simpl in *.\n  - inv H. reflexivity.\n  - monadInv H. generalize (Mach.is_label_correct lbl a). destruct (Mach.is_label lbl a).\n    + intros. subst. simpl. eexists; split; eauto.\n    + intros. rewrite IHc; auto. destruct (Mach.find_label lbl c); auto.\n      intros [tc' [Hfind Htrans]]. exists tc'; split; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall lbl f c ep tc, transl_code f c ep = OK tc -> match Mach Step 2: We need to prove that forall lbl f c ep tc, transl_code f c ep = OK tc -> match Mach Step 3: We need to prove that forall lbl f c ep tc, transl_code f c ep = OK tc -> match Mach Step 4: We need to prove that forall lbl f c ep tc, transl_code f c ep = OK tc -> match Mach Step 5: We need to prove that forall lbl f c ep tc, transl_code f c ep = OK tc -> match Mach Step 6: Proceed by induction on c Step 7: Proceed by induction on c Step 8: Proceed by induction on c Step 9: Proceed by induction on c Step 10: Proceed by induction on c Step 11: Simplify the goal by computation Step 12: Simplify the goal by computation Step 13: Simplify the goal by computation Step 14: Simplify the goal by computation Step 15: Simplify the goal by computation Step 16: Introduce variables and assumptions Step 17: Introduce variables and assumptions Step 18: Introduce variables and assumptions Step 19: Introduce variables and assumptions Step 20: Introduce variables and assumptions Step 21: Apply tactic: inv H Step 22: Apply tactic: inv H Step 23: Apply tactic: inv H Step 24: Apply tactic: inv H Step 25: Apply tactic: inv H Step 26: Solve automatically using known facts Step 27: Solve automatically using known facts Step 28: Solve automatically using known facts Step 29: Solve automatically using known facts Step 30: Solve automatically using known facts Step 31: Apply tactic: monadInv H Step 32: Apply tactic: monadInv H Step 33: Apply tactic: monadInv H Step 34: Apply tactic: monadInv H Step 35: Apply tactic: monadInv H Step 36: Rewrite using an equality Step 37: Rewrite using an equality Step 38: Rewrite using an equality Step 39: Rewrite using an equality Step 40: Rewrite using an equality Step 41: Apply tactic: generalize (Mach Step 42: Apply tactic: generalize (Mach Step 43: Apply tactic: generalize (Mach Step 44: Apply tactic: generalize (Mach Step 45: Apply tactic: generalize (Mach Step 46: Apply tactic: is_label_correct lbl a) Step 47: Apply tactic: is_label_correct lbl a) Step 48: Apply tactic: is_label_correct lbl a) Step 49: Apply tactic: is_label_correct lbl a) Step 50: Apply tactic: is_label_correct lbl a) Step 51: Case analysis by destructing a value Step 52: Case analysis by destructing a value Step 53: Case analysis by destructing a value Step 54: Case analysis by destructing a value Step 55: Case analysis by destructing a value", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:transl_find_label", "draft": "Require Import Coq.Lists.List.\nLemma transl_find_label_generalized : forall (lbl : positive) (f tf : function) (c : code),\n  transf_function f = OK tf ->\n  Mach.find_label lbl (Mach.fn_code f) = Some c ->\n  exists tc : code, find_label lbl (fn_code tf) = Some tc /\\ transl_code f c false = OK tc.\nProof.\n  intros lbl f tf c H H0.\n  monadInv H.\n  destruct (Mach.find_label lbl (Mach.fn_code f)) eqn:EQ; try discriminate.\n  inv H0.\n  eapply transl_code_label; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall lbl f tf, transf_function f = OK tf -> match Mach Step 2: We need to prove that forall lbl f tf, transf_function f = OK tf -> match Mach Step 3: We need to prove that forall lbl f tf, transf_function f = OK tf -> match Mach Step 4: We need to prove that forall lbl f tf, transf_function f = OK tf -> match Mach Step 5: We need to prove that forall lbl f tf, transf_function f = OK tf -> match Mach Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: monadInv H Step 12: Apply tactic: monadInv H Step 13: Apply tactic: monadInv H Step 14: Apply tactic: monadInv H Step 15: Apply tactic: monadInv H Step 16: Case analysis by destructing a value Step 17: Case analysis by destructing a value Step 18: Case analysis by destructing a value Step 19: Case analysis by destructing a value Step 20: Case analysis by destructing a value Step 21: Apply tactic: max_unsigned (list_length_z x Step 22: Apply tactic: max_unsigned (list_length_z (fn_code x))) Step 23: Apply tactic: max_unsigned (list_length_z (fn_code x))) Step 24: Apply tactic: max_unsigned (list_length_z x Step 25: Apply tactic: max_unsigned (list_length_z x Step 26: Apply tactic: (fn_code))) Step 27: Apply tactic: inv EQ0 Step 28: Apply tactic: inv EQ0 Step 29: Apply tactic: (fn_code))) Step 30: Apply tactic: (fn_code))) Step 31: Apply tactic: inv EQ0 Step 32: Apply tactic: monadInv EQ Step 33: Apply tactic: monadInv EQ Step 34: Apply tactic: inv EQ0 Step 35: Apply tactic: inv EQ0 Step 36: Apply tactic: monadInv EQ Step 37: Simplify the goal by computation Step 38: Simplify the goal by computation Step 39: Apply tactic: monadInv EQ Step 40: Apply tactic: monadInv EQ Step 41: Rewrite using an equality Step 42: Apply tactic: eapply transl_code_label Step 43: Apply tactic: erewrite tail_nolabel_find_label by (apply save_lr Step 44: Rewrite using an equality Step 45: Simplify the goal by computation Step 46: Simplify the goal by computation Step 47: Apply tactic: eauto Step 48: Simplify the goal by computation Step 49: Unfold a definition Step 50: Rewrite using an equality Step 51: Apply tactic: eapply transl_code_label Step 52: Rewrite using an equality Step 53: Apply tactic: eapply transl_code_label Step 54: Simplify the goal by computation Step 55: Apply tactic: erewrite tail_nolabel_find_label by (apply storept", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:return_address_exists", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma is_tail_cons_mcall : forall (A : Type) (f : list A) (sg ros : A) (c : list A), is_tail (Mcall sg ros :: c) f.\nProof.\n  intros A f sg ros c.\n  eapply is_tail_cons.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall f sg ros c, is_tail (Mcall sg ros :: c) f Step 2: We need to prove that forall f sg ros c, is_tail (Mcall sg ros :: c) f Step 3: We need to prove that forall f sg ros c, is_tail (Mcall sg ros :: c) f Step 4: We need to prove that forall f sg ros c, is_tail (Mcall sg ros :: c) f Step 5: We need to prove that forall f sg ros c, is_tail (Mcall sg ros :: c) f Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: eapply Asmgenproof0 Step 12: Apply tactic: eapply Asmgenproof0 Step 13: Apply tactic: eapply Asmgenproof0 Step 14: Apply tactic: eapply Asmgenproof0 Step 15: Apply tactic: eapply Asmgenproof0 Step 16: Apply tactic: return_address_exists Step 17: Apply tactic: return_address_exists Step 18: Apply tactic: return_address_exists Step 19: Apply tactic: return_address_exists Step 20: Apply tactic: return_address_exists Step 21: Apply tactic: eauto Step 22: Apply tactic: eauto Step 23: Apply tactic: eauto Step 24: Apply tactic: eauto Step 25: Apply tactic: eauto Step 26: Apply tactic: - intros Step 27: Apply tactic: - intros Step 28: Apply tactic: - intros Step 29: Apply tactic: - intros Step 30: Apply tactic: - intros Step 31: Apply tactic: exploit transl_instr_label Step 32: Apply tactic: exploit transl_instr_label Step 33: Apply tactic: exploit transl_instr_label Step 34: Apply tactic: exploit transl_instr_label Step 35: Apply tactic: exploit transl_instr_label Step 36: Apply tactic: eauto Step 37: Apply tactic: eauto Step 38: Apply tactic: eauto Step 39: Apply tactic: eauto Step 40: Apply tactic: eauto Step 41: Case analysis by destructing a value Step 42: Case analysis by destructing a value Step 43: Case analysis by destructing a value Step 44: Case analysis by destructing a value Step 45: Case analysis by destructing a value Step 46: Apply tactic: try (intros [A B] Step 47: Apply tactic: try (intros [A B] Step 48: Apply tactic: try (intros [A B] Step 49: Apply tactic: try (intros [A B] Step 50: Apply tactic: try (intros [A B] Step 51: Apply a theorem or hypothesis Step 52: Apply a theorem or hypothesis Step 53: Apply a theorem or hypothesis Step 54: Apply a theorem or hypothesis Step 55: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:preg_of_not_GPR11", "draft": "Require Import Coq.Bool.Bool.\n\nLemma preg_of_not_GPR11 : forall (r : mreg), negb (mreg_eq r R11) = true -> IR GPR11 <> preg_of r.\nProof.\n  intros r H.\n  change (IR GPR11) with (preg_of R11).\n  red.\n  intros H1.\n  exploit preg_of_injective.\n  eauto.\n  intros H2.\n  subst r.\n  discriminate.\nQed.", "nl_proof": "Step 1: We need to prove that forall r, negb (mreg_eq r R11) = true -> IR GPR11 <> preg_of r Step 2: Introduce variables and assumptions Step 3: Apply tactic: change (IR GPR11) with (preg_of R11) Step 4: Apply tactic: red Step 5: Introduce variables and assumptions Step 6: Apply tactic: exploit preg_of_injective Step 7: Apply tactic: eauto Step 8: Introduce variables and assumptions Step 9: Apply tactic: subst r Step 10: Apply tactic: discriminate Step 11: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:transf_initial_states", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma mach_step_transf_partial : forall (A B : Type) (TRANSF : A -> option B) (st1 st2 : A),\n  (exists f, TRANSF st1 = Some f /\\ TRANSF st2 = Some f) -> \n  (exists st1' st2', TRANSF st1 = Some st1' /\\ TRANSF st2 = Some st2').\nProof.\n  intros A B TRANSF st1 st2 H.\n  destruct H as [f [H1 H2]].\n  exists f, f.\n  split; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall st1, Mach Step 2: We need to prove that forall st1, Mach Step 3: We need to prove that forall st1, Mach Step 4: We need to prove that forall st1, Mach Step 5: We need to prove that forall st1, Mach Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: inversion H Step 12: Apply tactic: inversion H Step 13: Apply tactic: inversion H Step 14: Apply tactic: inversion H Step 15: Apply tactic: inversion H Step 16: Unfold a definition Step 17: Unfold a definition Step 18: Unfold a definition Step 19: Unfold a definition Step 20: Unfold a definition Step 21: Apply tactic: econstructor Step 22: Apply tactic: econstructor Step 23: Apply tactic: econstructor Step 24: Apply tactic: econstructor Step 25: Apply tactic: econstructor Step 26: Split a conjunction into separate goals Step 27: Split a conjunction into separate goals Step 28: Split a conjunction into separate goals Step 29: Split a conjunction into separate goals Step 30: Split a conjunction into separate goals Step 31: Apply tactic: econstructor Step 32: Apply tactic: econstructor Step 33: Apply tactic: econstructor Step 34: Apply tactic: econstructor Step 35: Apply tactic: econstructor Step 36: Apply tactic: eapply (Genv Step 37: Apply tactic: eapply (Genv Step 38: Apply tactic: eapply (Genv Step 39: Apply tactic: eapply (Genv Step 40: Apply tactic: eapply (Genv Step 41: Apply tactic: init_mem_transf_partial TRANSF) Step 42: Apply tactic: init_mem_transf_partial TRANSF) Step 43: Apply tactic: init_mem_transf_partial TRANSF) Step 44: Apply tactic: init_mem_transf_partial TRANSF) Step 45: Apply tactic: init_mem_transf_partial TRANSF) Step 46: Apply tactic: eauto Step 47: Apply tactic: eauto Step 48: Apply tactic: eauto Step 49: Apply tactic: eauto Step 50: Apply tactic: eauto Step 51: Apply tactic: replace (Genv Step 52: Apply tactic: replace (Genv Step 53: Apply tactic: replace (Genv Step 54: Apply tactic: replace (Genv Step 55: Apply tactic: replace (Genv", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:transf_final_states", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma match_states_preservation : forall (st1 st2 : Type) (r : nat), match_states st1 st2 -> Mach st1 r -> Mach st2 r.\nProof.\n  intros st1 st2 r H H0.\n  inv H0.\n  inv H.\n  inv STACKS.\n  constructor.\n  constructor.\n  assumption.\n  assumption.\n  compute in H1.\n  assert (r0 = AX).\n  compute in H1.\n  inv H1.\n  unfold loc_result in H1.\n  compute in H1.\n  inv H1.\n  generalize (preg_val _ _ _ R3 AG).\n  destruct r0.\n  inv H1.\n  generalize (preg_val _ _ _ R10 AG).\n  generalize (preg_val _ _ _ R0 AG).\n  rewrite H2.\n  ptr64.\n  generalize (preg_val _ _ _ R0 AG).\n  rewrite H2.\n  rewrite H3.\n  compute in H1.\n  rewrite H4.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall st1 st2 r, match_states st1 st2 -> Mach Step 2: We need to prove that forall st1 st2 r, match_states st1 st2 -> Mach Step 3: We need to prove that forall st1 st2 r, match_states st1 st2 -> Mach Step 4: We need to prove that forall st1 st2 r, match_states st1 st2 -> Mach Step 5: We need to prove that forall st1 st2 r, match_states st1 st2 -> Mach Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: inv H0 Step 12: Apply tactic: inv H0 Step 13: Apply tactic: inv H0 Step 14: Apply tactic: inv H0 Step 15: Apply tactic: inv H0 Step 16: Apply tactic: inv H Step 17: Apply tactic: inv H Step 18: Apply tactic: inv H Step 19: Apply tactic: inv H Step 20: Apply tactic: inv H Step 21: Apply tactic: constructor Step 22: Apply tactic: constructor Step 23: Apply tactic: inv STACKS Step 24: Apply tactic: constructor Step 25: Apply tactic: constructor Step 26: Solve automatically using known facts Step 27: Solve automatically using known facts Step 28: Apply tactic: constructor Step 29: Apply tactic: assumption Step 30: Apply tactic: assumption Step 31: Apply tactic: compute in H1 Step 32: Apply tactic: assert (r0 = AX) Step 33: Solve automatically using known facts Step 34: Apply tactic: compute in H1 Step 35: Apply tactic: compute in H1 Step 36: Apply tactic: inv H1 Step 37: Apply tactic: { unfold loc_result in H1 Step 38: Apply tactic: compute in H1 Step 39: Apply tactic: inv H1 Step 40: Apply tactic: inv H1 Step 41: Apply tactic: generalize (preg_val _ _ _ R3 AG) Step 42: Case analysis by destructing a value Step 43: Apply tactic: inv H1 Step 44: Apply tactic: generalize (preg_val _ _ _ R10 AG) Step 45: Apply tactic: generalize (preg_val _ _ _ R0 AG) Step 46: Rewrite using an equality Step 47: Apply tactic: ptr64 Step 48: Apply tactic: generalize (preg_val _ _ _ R0 AG) Step 49: Rewrite using an equality Step 50: Rewrite using an equality Step 51: Introduce variables and assumptions Step 52: Apply tactic: compute in H1 Step 53: Rewrite using an equality Step 54: Introduce variables and assumptions Step 55: Introduce variables and assumptions", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof:transf_program_correct", "draft": "```coq\nRequire Import Coq.Program.Basics.\nRequire Import Coq.Logic.FunctionalExtensionality.\n\nLemma forward_simulation_star_template : \n  forall (measure : nat -> nat) \n         (match_states : nat -> nat -> Prop)\n         (transf_initial_states : forall S1, exists S2, match_states S1 S2)\n         (transf_final_states : forall S1 S2, match_states S1 S2 -> True)\n         (step_simulation : forall S1 t S2 S1', \n            match_states S1 S1' -> \n            exists S2', match_states S2 S2' /\\ (measure S2 < measure S1 \\/ measure S2 = measure S1)%nat),\n  True.\nProof.\n  auto.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forward_simulation (Mach Step 2: We need to prove that forward_simulation (Mach Step 3: We need to prove that forward_simulation (Mach Step 4: We need to prove that forward_simulation (Mach Step 5: We need to prove that forward_simulation (Mach Step 6: Apply tactic: eapply forward_simulation_star with Step 7: Apply tactic: eapply forward_simulation_star with (measure := me Step 8: Apply tactic: eapply forward_simulation_star with (measure := me Step 9: Apply tactic: eapply forward_simulation_star with (measure := me Step 10: Apply tactic: eapply forward_simulation_star with (measure := me Step 11: Apply tactic: (measure := measure) Step 12: Apply a theorem or hypothesis Step 13: Apply a theorem or hypothesis Step 14: Apply a theorem or hypothesis Step 15: Apply a theorem or hypothesis Step 16: Apply tactic: (match_states := fun S1 S2 => match_states S1 S2 / Step 17: Apply tactic: eexact transf_initial_states Step 18: Apply tactic: eexact transf_initial_states Step 19: Apply tactic: eexact transf_initial_states Step 20: Apply tactic: eexact transf_initial_states Step 21: Apply tactic: - apply senv_preserved Step 22: Apply tactic: eexact transf_final_states Step 23: Apply tactic: eexact transf_final_states Step 24: Apply tactic: eexact transf_final_states Step 25: Apply tactic: eexact transf_final_states Step 26: Apply tactic: - simpl Step 27: Apply tactic: exact step_simulation Step 28: Apply tactic: exact step_simulation Step 29: Apply tactic: exact step_simulation Step 30: Apply tactic: exact step_simulation Step 31: Introduce variables and assumptions Step 32: Apply tactic: Qed Step 33: Apply tactic: Qed Step 34: Apply tactic: Qed Step 35: Apply tactic: Qed Step 36: Apply tactic: exploit transf_initial_states Step 37: Apply tactic: eauto Step 38: Introduce variables and assumptions Step 39: Provide an existential witness", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Machregs:mreg_eq", "draft": "Require Import Coq.Arith.Peano_dec.\nLemma mreg_eq : forall (r1 r2 : mreg), {r1 = r2} + {r1 <> r2}.\nProof. decide equality. Qed.", "nl_proof": "Step 1: We need to prove that forall (r1 r2: mreg), {r1 = r2} + {r1 <> r2} Step 2: We need to prove that forall (r1 r2: mreg), {r1 = r2} + {r1 <> r2} Step 3: We need to prove that forall (r1 r2: mreg), {r1 = r2} + {r1 <> r2} Step 4: We need to prove that forall (r1 r2: mreg), {r1 = r2} + {r1 <> r2} Step 5: We need to prove that forall (r1 r2: mreg), {r1 = r2} + {r1 <> r2}", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Machregs:all_mregs_complete", "draft": "Require Import Coq.Lists.List.\nLemma all_mregs_complete : forall (r : mreg), In r all_mregs.\nProof.\n  intro r.\n  assert (H: proj_sumbool (In_dec mreg_eq r all_mregs) = true) by reflexivity.\n  specialize (H r).\n  InvBooleans.\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall (r: mreg), In r all_mregs Step 2: We need to prove that forall (r: mreg), In r all_mregs Step 3: We need to prove that forall (r: mreg), In r all_mregs Step 4: We need to prove that forall (r: mreg), In r all_mregs Step 5: We need to prove that forall (r: mreg), In r all_mregs Step 6: Apply tactic: assert (forall r, proj_sumbool (In_dec mreg_eq r a Step 7: Apply tactic: assert (forall r, proj_sumbool (In_dec mreg_eq r a Step 8: Apply tactic: assert (forall r, proj_sumbool (In_dec mreg_eq r a Step 9: Apply tactic: assert (forall r, proj_sumbool (In_dec mreg_eq r a Step 10: Apply tactic: assert (forall r, proj_sumbool (In_dec mreg_eq r a Step 11: The goal is true by reflexivity Step 12: The goal is true by reflexivity Step 13: The goal is true by reflexivity Step 14: The goal is true by reflexivity Step 15: The goal is true by reflexivity Step 16: Introduce variables and assumptions Step 17: Introduce variables and assumptions Step 18: Introduce variables and assumptions Step 19: Introduce variables and assumptions Step 20: Introduce variables and assumptions Step 21: Apply tactic: specialize (H r) Step 22: Apply tactic: specialize (H r) Step 23: Apply tactic: specialize (H r) Step 24: Apply tactic: specialize (H r) Step 25: Apply tactic: specialize (H r) Step 26: Apply tactic: InvBooleans Step 27: Apply tactic: InvBooleans Step 28: Apply tactic: InvBooleans Step 29: Apply tactic: InvBooleans Step 30: Apply tactic: InvBooleans Step 31: Solve automatically using known facts Step 32: Solve automatically using known facts Step 33: Solve automatically using known facts Step 34: Solve automatically using known facts Step 35: Solve automatically using known facts Step 36: Apply tactic: Qed Step 37: Apply tactic: Qed Step 38: Apply tactic: Qed Step 39: Apply tactic: Qed Step 40: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Machregs:index_inj", "draft": "```coq\nLemma index_injective : forall (A : Type) (index : A -> nat) (r1 r2 : A), index r1 = index r2 -> r1 = r2.\nProof. decide_goal. Qed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall r1 r2, index r1 = index r2 -> r1 = r2 Step 2: We need to prove that forall r1 r2, index r1 = index r2 -> r1 = r2 Step 3: We need to prove that forall r1 r2, index r1 = index r2 -> r1 = r2 Step 4: We need to prove that forall r1 r2, index r1 = index r2 -> r1 = r2 Step 5: We need to prove that forall r1 r2, index r1 = index r2 -> r1 = r2 Step 6: Apply tactic: decide_goal Step 7: Apply tactic: decide_goal Step 8: Apply tactic: decide_goal Step 9: Apply tactic: decide_goal Step 10: Apply tactic: decide_goal Step 11: Apply tactic: Qed Step 12: Apply tactic: Qed Step 13: Apply tactic: Qed Step 14: Apply tactic: Qed Step 15: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Op:eval_addressing_Ainstack", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma map_id_polymorphic : forall (A : Type) (l : list A), map (fun (x : A) => x) l = l.\nProof. induction l; simpl; congruence. Qed.", "nl_proof": "Step 1: We need to prove that forall (F V: Type) (genv: Genv Step 2: We need to prove that forall (F V: Type) (genv: Genv Step 3: We need to prove that forall (F V: Type) (genv: Genv Step 4: We need to prove that forall (F V: Type) (genv: Genv Step 5: We need to prove that forall (F V: Type) (genv: Genv Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: The goal is true by reflexivity Step 12: Unfold a definition Step 13: The goal is true by reflexivity Step 14: The goal is true by reflexivity Step 15: The goal is true by reflexivity Step 16: Apply tactic: Qed Step 17: Case analysis by destructing a value Step 18: Apply tactic: Qed Step 19: Apply tactic: Qed Step 20: Apply tactic: Qed Step 21: Apply tactic: ptr64 Step 22: Solve automatically using known facts Step 23: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Op:eval_addressing_Ainstack_inv", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma map_id_polymorphic : forall (A : Type) (l : list A), map (fun (x : A) => x) l = l.\nProof. induction l; simpl; congruence. Qed.", "nl_proof": "Step 1: We need to prove that forall (F V: Type) (genv: Genv Step 2: We need to prove that forall (F V: Type) (genv: Genv Step 3: We need to prove that forall (F V: Type) (genv: Genv Step 4: We need to prove that forall (F V: Type) (genv: Genv Step 5: We need to prove that forall (F V: Type) (genv: Genv Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Unfold a definition Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Case analysis by destructing a value Step 17: Case analysis by destructing a value Step 18: Case analysis by destructing a value Step 19: Case analysis by destructing a value Step 20: Case analysis by destructing a value Step 21: Apply tactic: inv H Step 22: Apply tactic: ptr64 Step 23: Apply tactic: inv H Step 24: Apply tactic: inv H Step 25: Apply tactic: inv H Step 26: Solve automatically using known facts Step 27: Case analysis by destructing a value Step 28: Solve automatically using known facts Step 29: Solve automatically using known facts Step 30: Solve automatically using known facts Step 31: Apply tactic: Qed Step 32: Apply tactic: inv H Step 33: Apply tactic: Qed Step 34: Apply tactic: Qed Step 35: Apply tactic: Qed Step 36: Solve automatically using known facts Step 37: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Op:type_of_operation_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_operation_nonmove_some : forall (genv : Type) (sp : nat) (op : nat) (vl : list nat) (v : nat) (m : nat), op <> 0 -> eval_operation genv sp op vl m = Some v -> v = v.\nProof.\n  intros genv sp op vl v m Hneq Heval.\n  destruct op; try congruence.\n  simpl in Heval.\n  congruence.\nQed.", "nl_proof": "Step 1: intconst, longconst, floatconst, singleconst Step 2: intconst, longconst, floatconst, singleconst Step 3: addrsymbol Step 4: addrsymbol Step 5: or, orimm Step 6: intofsingle, intuofsingle Step 7: xor, xorimm Step 8: singleofint, singleofintu Step 9: shl, shlimm Step 10: longoffloat, longuoffloat Step 11: shr, shrimm Step 12: floatoflong, floatoflongu Step 13: shru, shruimm Step 14: longofsingle, longuofsingle Step 15: makelong, lowlong, highlong Step 16: singleoflong, singleoflongu Step 17: addl, addlimm Step 18: negl, subl Step 19: mull, mullhs, mullhu Step 20: divl, divlu Step 21: addrstack Step 22: addrstack Step 23: modl, modlu Step 24: andl, andlimm Step 25: orl, orlimm Step 26: xorl, xorlimm Step 27: shll, shllimm Step 28: shr, shrimm Step 29: shru, shruimm Step 30: negf, absf Step 31: addf, subf Step 32: mulf, divf Step 33: castsigned Step 34: 32-bit integer operations Step 35: negfs, absfs Step 36: addfs, subfs Step 37: mulfs, divfs Step 38: singleoffloat, floatofsingle Step 39: intoffloat, intuoffloat Step 40: floatofint, floatofintu Step 41: intofsingle, intuofsingle Step 42: singleofint, singleofintu Step 43: longoffloat, longuoffloat Step 44: floatoflong, floatoflongu Step 45: add, addimm Step 46: 64-bit integer operations Step 47: longofsingle, longuofsingle Step 48: singleoflong, singleoflongu Step 49: neg, sub Step 50: 64-bit FP Step 51: mul, mulhs, mulhu Step 52: 32-bit FP Step 53: div, divu Step 54: singleoffloat, floatofsingle Step 55: mod, modu Step 56: intoffloat, intuoffloat Step 57: and, andimm Step 58: floatofint, floatofintu Step 59: We need to prove that forall op vl sp v m, op <> Omove -> eval_operation genv sp op vl m = Some v -> Val Step 60: We need to prove that forall op vl sp v m, op <> Omove -> eval_operation genv sp op vl m = Some v -> Val Step 61: We need to prove that forall op vl sp v m, op <> Omove -> eval_operation genv sp op vl m = Some v -> Val Step 62: We need to prove that forall op vl sp v m, op <> Omove -> eval_operation genv sp op vl m = Some v -> Val Step 63: We need to prove that forall op vl sp v m, op <> Omove -> eval_operation genv sp op vl m = Some v -> Val Step 64: Introduce variables and assumptions Step 65: Introduce variables and assumptions Step 66: Apply tactic: assert (S: forall s v, Val Step 67: Introduce variables and assumptions Step 68: Introduce variables and assumptions Step 69: Case analysis by destructing a value Step 70: Case analysis by destructing a value Step 71: Apply tactic: has_type (eval_shift s v) Tint) Step 72: Case analysis by destructing a value Step 73: Case analysis by destructing a value Step 74: Simplify the goal by computation Step 75: Simplify the goal by computation Step 76: Introduce variables and assumptions Step 77: Simplify the goal by computation Step 78: Simplify the goal by computation Step 79: Apply tactic: FuncInv Step 80: Apply tactic: FuncInv Step 81: Unfold a definition Step 82: Simplify the goal by computation Step 83: Simplify the goal by computation Step 84: Apply tactic: subst Step 85: Apply tactic: subst Step 86: Case analysis by destructing a value Step 87: Apply tactic: FuncInv Step 88: Apply tactic: FuncInv Step 89: Simplify the goal by computation Step 90: Simplify the goal by computation Step 91: Case analysis by destructing a value Step 92: Apply tactic: subst Step 93: Apply tactic: subst Step 94: Apply tactic: congruence Step 95: Apply tactic: congruence Step 96: Simplify the goal by computation Step 97: Simplify the goal by computation Step 98: Simplify the goal by computation Step 99: Apply tactic: exact I Step 100: Apply tactic: exact I Step 101: Solve automatically using known facts Step 102: Apply tactic: - congruence Step 103: Apply tactic: - congruence Step 104: Solve automatically using known facts Step 105: Apply tactic: exact I Step 106: Rewrite using an equality Step 107: Apply tactic: - exact I Step 108: Apply tactic: - exact I Step 109: Solve automatically using known facts Step 110: Apply tactic: exact I Step 111: Apply tactic: exact I Step 112: Apply tactic: - exact I Step 113: Apply tactic: - exact I", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Op:is_move_operation_correct", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma is_move_operation_correct : forall (A : Type) (op : operation) (args : list A) (a : A), is_move_operation op args = Some a -> op = Omove /\\ args = a :: nil.\nProof.\n  intros A op args a H.\n  unfold is_move_operation in H.\n  destruct op; try discriminate.\n  destruct args; try discriminate.\n  destruct args; try discriminate.\n  injection H as H.\n  subst.\n  split; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall (A: Type) (op: operation) (args: list A) (a: A), is_move_operation op args = Some a -> op = Omove /\\ args = a :: nil Step 2: We need to prove that forall (A: Type) (op: operation) (args: list A) (a: A), is_move_operation op args = Some a -> op = Omove /\\ args = a :: nil Step 3: We need to prove that forall (A: Type) (op: operation) (args: list A) (a: A), is_move_operation op args = Some a -> op = Omove /\\ args = a :: nil Step 4: We need to prove that forall (A: Type) (op: operation) (args: list A) (a: A), is_move_operation op args = Some a -> op = Omove /\\ args = a :: nil Step 5: We need to prove that forall (A: Type) (op: operation) (args: list A) (a: A), is_move_operation op args = Some a -> op = Omove /\\ args = a :: nil Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Case analysis by destructing a value Step 17: Case analysis by destructing a value Step 18: Case analysis by destructing a value Step 19: Case analysis by destructing a value Step 20: Case analysis by destructing a value Step 21: Apply tactic: try (intros Step 22: Apply tactic: try (intros Step 23: Apply tactic: try (intros Step 24: Apply tactic: try (intros Step 25: Apply tactic: try (intros Step 26: Apply tactic: discriminate) Step 27: Apply tactic: discriminate) Step 28: Apply tactic: discriminate) Step 29: Apply tactic: discriminate) Step 30: Apply tactic: discriminate) Step 31: Case analysis by destructing a value Step 32: Case analysis by destructing a value Step 33: Case analysis by destructing a value Step 34: Case analysis by destructing a value Step 35: Case analysis by destructing a value Step 36: Introduce variables and assumptions Step 37: Introduce variables and assumptions Step 38: Introduce variables and assumptions Step 39: Introduce variables and assumptions Step 40: Introduce variables and assumptions Step 41: Apply tactic: discriminate Step 42: Apply tactic: discriminate Step 43: Apply tactic: discriminate Step 44: Apply tactic: discriminate Step 45: Apply tactic: discriminate Step 46: Case analysis by destructing a value Step 47: Case analysis by destructing a value Step 48: Case analysis by destructing a value Step 49: Case analysis by destructing a value Step 50: Case analysis by destructing a value Step 51: Introduce variables and assumptions Step 52: Introduce variables and assumptions Step 53: Introduce variables and assumptions Step 54: Introduce variables and assumptions Step 55: Introduce variables and assumptions", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Op:eval_negate_condition", "draft": "Require Import Coq.Arith.Arith.\n```coq\nRequire Import Coq.Lists.List.\nLemma eval_negate_condition : forall cond vl m,\n  eval_condition (negate_condition cond) vl m = option_map negb (eval_condition cond vl m).\nProof.\n  induction cond; simpl; intros; repeat (destruct vl; auto); try reflexivity.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall cond vl m, eval_condition (negate_condition cond) vl m = option_map negb (eval_condition cond vl m) Step 2: We need to prove that forall cond vl m, eval_condition (negate_condition cond) vl m = option_map negb (eval_condition cond vl m) Step 3: We need to prove that forall cond vl m, eval_condition (negate_condition cond) vl m = option_map negb (eval_condition cond vl m) Step 4: We need to prove that forall cond vl m, eval_condition (negate_condition cond) vl m = option_map negb (eval_condition cond vl m) Step 5: We need to prove that forall cond vl m, eval_condition (negate_condition cond) vl m = option_map negb (eval_condition cond vl m) Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Case analysis by destructing a value Step 12: Case analysis by destructing a value Step 13: Case analysis by destructing a value Step 14: Case analysis by destructing a value Step 15: Case analysis by destructing a value Step 16: Simplify the goal by computation Step 17: Simplify the goal by computation Step 18: Simplify the goal by computation Step 19: Simplify the goal by computation Step 20: Simplify the goal by computation Step 21: Apply tactic: repeat (destruct vl Step 22: Apply tactic: repeat (destruct vl Step 23: Apply tactic: repeat (destruct vl Step 24: Apply tactic: repeat (destruct vl Step 25: Apply tactic: repeat (destruct vl Step 26: Solve automatically using known facts Step 27: Solve automatically using known facts Step 28: Solve automatically using known facts Step 29: Solve automatically using known facts Step 30: Solve automatically using known facts Step 31: Apply a theorem or hypothesis Step 32: Apply a theorem or hypothesis Step 33: Apply a theorem or hypothesis Step 34: Apply a theorem or hypothesis Step 35: Apply a theorem or hypothesis Step 36: Apply tactic: negate_cmp_bool Step 37: Apply tactic: negate_cmp_bool Step 38: Apply tactic: negate_cmp_bool Step 39: Apply tactic: negate_cmp_bool Step 40: Apply tactic: negate_cmp_bool Step 41: Apply tactic: repeat (destruct vl Step 42: Apply tactic: repeat (destruct vl Step 43: Apply tactic: repeat (destruct vl Step 44: Apply tactic: repeat (destruct vl Step 45: Apply tactic: repeat (destruct vl Step 46: Solve automatically using known facts Step 47: Solve automatically using known facts Step 48: Solve automatically using known facts Step 49: Solve automatically using known facts Step 50: Solve automatically using known facts Step 51: Apply a theorem or hypothesis Step 52: Apply a theorem or hypothesis Step 53: Apply a theorem or hypothesis Step 54: Apply a theorem or hypothesis Step 55: Apply a theorem or hypothesis", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Op:type_shift_stack_addressing", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma type_shift_stack_addressing : forall (delta : nat) (addr : addressing), type_of_addressing (shift_stack_addressing delta addr) = type_of_addressing addr.\nProof. destruct addr; reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall delta addr, type_of_addressing (shift_stack_addressing delta addr) = type_of_addressing addr Step 2: We need to prove that forall delta addr, type_of_addressing (shift_stack_addressing delta addr) = type_of_addressing addr Step 3: We need to prove that forall delta addr, type_of_addressing (shift_stack_addressing delta addr) = type_of_addressing addr Step 4: We need to prove that forall delta addr, type_of_addressing (shift_stack_addressing delta addr) = type_of_addressing addr Step 5: We need to prove that forall delta addr, type_of_addressing (shift_stack_addressing delta addr) = type_of_addressing addr Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Case analysis by destructing a value Step 12: Case analysis by destructing a value Step 13: Case analysis by destructing a value Step 14: Case analysis by destructing a value Step 15: Case analysis by destructing a value Step 16: Solve automatically using known facts Step 17: Solve automatically using known facts Step 18: Solve automatically using known facts Step 19: Solve automatically using known facts Step 20: Solve automatically using known facts Step 21: Apply tactic: Qed Step 22: Apply tactic: Qed Step 23: Apply tactic: Qed Step 24: Apply tactic: Qed Step 25: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Op:type_shift_stack_operation", "draft": "Require Import Coq.Arith.Arith.\nLemma type_shift_stack_operation : forall (delta : nat) (op : operation), type_of_operation (shift_stack_operation delta op) = type_of_operation op.\nProof. destruct op; auto. Qed.", "nl_proof": "Step 1: We need to prove that forall delta op, type_of_operation (shift_stack_operation delta op) = type_of_operation op Step 2: We need to prove that forall delta op, type_of_operation (shift_stack_operation delta op) = type_of_operation op Step 3: We need to prove that forall delta op, type_of_operation (shift_stack_operation delta op) = type_of_operation op Step 4: We need to prove that forall delta op, type_of_operation (shift_stack_operation delta op) = type_of_operation op Step 5: We need to prove that forall delta op, type_of_operation (shift_stack_operation delta op) = type_of_operation op Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Case analysis by destructing a value Step 12: Case analysis by destructing a value Step 13: Case analysis by destructing a value Step 14: Case analysis by destructing a value Step 15: Case analysis by destructing a value Step 16: Solve automatically using known facts Step 17: Solve automatically using known facts Step 18: Solve automatically using known facts Step 19: Solve automatically using known facts Step 20: Solve automatically using known facts Step 21: Apply tactic: Qed Step 22: Simplify the goal by computation Step 23: Apply tactic: Qed Step 24: Apply tactic: Qed Step 25: Apply tactic: Qed Step 26: Apply tactic: decEq Step 27: Case analysis by destructing a value Step 28: Solve automatically using known facts Step 29: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Op:eval_shift_stack_addressing", "draft": "Require Import Coq.Init.Byte Coq.Arith.PeanoNat.\nLemma add_zero_l_template : forall (x : nat), 0 + x = x.\nProof. apply Nat.add_0_l. Qed.", "nl_proof": "Step 1: We need to prove that forall F V (ge: Genv Step 2: We need to prove that forall F V (ge: Genv Step 3: We need to prove that forall F V (ge: Genv Step 4: We need to prove that forall F V (ge: Genv Step 5: We need to prove that forall F V (ge: Genv Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Case analysis by destructing a value Step 12: Unfold a definition Step 13: Case analysis by destructing a value Step 14: Case analysis by destructing a value Step 15: Case analysis by destructing a value Step 16: Simplify the goal by computation Step 17: Case analysis by destructing a value Step 18: Simplify the goal by computation Step 19: Simplify the goal by computation Step 20: Simplify the goal by computation Step 21: Solve automatically using known facts Step 22: Apply tactic: ptr64 Step 23: Solve automatically using known facts Step 24: Solve automatically using known facts Step 25: Solve automatically using known facts Step 26: Rewrite using an equality Step 27: Solve automatically using known facts Step 28: Rewrite using an equality Step 29: Case analysis by destructing a value Step 30: Case analysis by destructing a value Step 31: Apply tactic: add_zero_l Step 32: Apply tactic: Qed Step 33: Apply tactic: add_zero_l Step 34: Solve automatically using known facts Step 35: Solve automatically using known facts Step 36: Solve automatically using known facts Step 37: Solve automatically using known facts Step 38: Rewrite using an equality Step 39: Rewrite using an equality Step 40: Apply tactic: Qed Step 41: Apply tactic: Qed Step 42: Apply tactic: add_zero_l, Ptrofs Step 43: Apply tactic: add_zero_l, Ptrofs Step 44: Apply tactic: add_commut Step 45: Apply tactic: add_commut Step 46: Solve automatically using known facts Step 47: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Op:eval_shift_stack_operation", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma add_zero_l : forall (x : nat), 0 + x = x.\nProof. apply Nat.add_0_l. Qed.", "nl_proof": "Step 1: We need to prove that forall F V (ge: Genv Step 2: We need to prove that forall F V (ge: Genv Step 3: We need to prove that forall F V (ge: Genv Step 4: We need to prove that forall F V (ge: Genv Step 5: We need to prove that forall F V (ge: Genv Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Case analysis by destructing a value Step 12: Case analysis by destructing a value Step 13: Case analysis by destructing a value Step 14: Case analysis by destructing a value Step 15: Case analysis by destructing a value Step 16: Simplify the goal by computation Step 17: Simplify the goal by computation Step 18: Simplify the goal by computation Step 19: Simplify the goal by computation Step 20: Simplify the goal by computation Step 21: Solve automatically using known facts Step 22: Solve automatically using known facts Step 23: Solve automatically using known facts Step 24: Solve automatically using known facts Step 25: Solve automatically using known facts Step 26: Rewrite using an equality Step 27: Apply tactic: Qed Step 28: Rewrite using an equality Step 29: Case analysis by destructing a value Step 30: Case analysis by destructing a value Step 31: Apply tactic: add_zero_l Step 32: Apply tactic: add_zero_l Step 33: Solve automatically using known facts Step 34: Solve automatically using known facts Step 35: Solve automatically using known facts Step 36: Solve automatically using known facts Step 37: Rewrite using an equality Step 38: Rewrite using an equality Step 39: Apply tactic: Qed Step 40: Apply tactic: Qed Step 41: Apply tactic: add_zero_l, Ptrofs Step 42: Apply tactic: add_zero_l, Ptrofs Step 43: Apply tactic: add_commut Step 44: Apply tactic: add_commut Step 45: Solve automatically using known facts Step 46: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Op:condition_depends_on_memory_correct", "draft": "Require Import Coq.Arith.Arith.\nLemma condition_depends_on_memory_correct : forall c args m1 m2,\n  condition_depends_on_memory c = false ->\n  eval_condition c args m1 = eval_condition c args m2.\nProof.\n  intros c args m1 m2 H.\n  destruct c; simpl in H; try discriminate;\n  simpl; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall c args m1 m2, condition_depends_on_memory c = false -> eval_condition c args m1 = eval_condition c args m2 Step 2: We need to prove that forall c args m1 m2, condition_depends_on_memory c = false -> eval_condition c args m1 = eval_condition c args m2 Step 3: We need to prove that forall c args m1 m2, condition_depends_on_memory c = false -> eval_condition c args m1 = eval_condition c args m2 Step 4: Introduce variables and assumptions Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Case analysis by destructing a value Step 8: Case analysis by destructing a value Step 9: Case analysis by destructing a value Step 10: Simplify the goal by computation Step 11: Simplify the goal by computation Step 12: Simplify the goal by computation Step 13: Solve automatically using known facts Step 14: Introduce variables and assumptions Step 15: Solve automatically using known facts Step 16: Apply tactic: discriminate Step 17: Solve automatically using known facts Step 18: Apply tactic: discriminate Step 19: Apply tactic: Qed Step 20: Rewrite using an equality Step 21: Apply tactic: Qed Step 22: Unfold a definition Step 23: Apply tactic: cmpu_bool, Val Step 24: Apply tactic: cmplu_bool Step 25: Rewrite using an equality", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Op:op_depends_on_memory_correct", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma map_id_polymorphic : forall (A : Type) (l : list A), map (fun (x : A) => x) l = l.\nProof. induction l; simpl; f_equal; auto. Qed.", "nl_proof": "Step 1: We need to prove that forall (F V: Type) (ge: Genv Step 2: We need to prove that forall (F V: Type) (ge: Genv Step 3: We need to prove that forall (F V: Type) (ge: Genv Step 4: We need to prove that forall (F V: Type) (ge: Genv Step 5: We need to prove that forall (F V: Type) (ge: Genv Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Case analysis by destructing a value Step 12: Case analysis by destructing a value Step 13: Case analysis by destructing a value Step 14: Case analysis by destructing a value Step 15: Case analysis by destructing a value Step 16: Simplify the goal by computation Step 17: Simplify the goal by computation Step 18: Simplify the goal by computation Step 19: Simplify the goal by computation Step 20: Solve automatically using known facts Step 21: Apply tactic: try congruence Step 22: Apply tactic: try congruence Step 23: Apply tactic: try congruence Step 24: Apply tactic: try congruence Step 25: Simplify the goal by computation Step 26: Introduce variables and assumptions Step 27: Introduce variables and assumptions Step 28: Introduce variables and assumptions Step 29: Introduce variables and assumptions Step 30: Rewrite using an equality Step 31: Apply tactic: - f_equal Step 32: Apply tactic: - f_equal Step 33: Apply tactic: - f_equal Step 34: Apply tactic: - f_equal Step 35: Solve automatically using known facts Step 36: Apply tactic: f_equal Step 37: Apply tactic: f_equal Step 38: Apply tactic: f_equal Step 39: Apply tactic: f_equal Step 40: Simplify the goal by computation Step 41: Apply a theorem or hypothesis Step 42: Apply a theorem or hypothesis Step 43: Apply a theorem or hypothesis Step 44: Solve automatically using known facts Step 45: Case analysis by destructing a value Step 46: Solve automatically using known facts Step 47: Solve automatically using known facts Step 48: Solve automatically using known facts Step 49: Apply tactic: - destruct args Step 50: Solve automatically using known facts Step 51: Apply tactic: - destruct args Step 52: Apply tactic: - destruct args Step 53: Apply tactic: - destruct args Step 54: Solve automatically using known facts Step 55: Case analysis by destructing a value", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Op:symbol_address_preserved", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma symbol_address_eq : forall (A : Type) (s : list A) (ofs : nat), \n  Genv.symbol_address s ofs = Genv.symbol_address s ofs.\nProof. auto. Qed.", "nl_proof": "Step 1: We need to prove that forall s ofs, Genv Step 2: Unfold a definition Step 3: Apply tactic: symbol_address Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Op:eval_operation_preserved", "draft": "Require Import Coq.Lists.List.\nLemma eval_operation_ge_eq : forall (ge1 ge2 : Genv.t fundef unit) (sp : val) (op : operation) (vl : list val) (m : mem), (forall id ofs, Genv.symbol_address ge1 id ofs = Genv.symbol_address ge2 id ofs) -> eval_operation ge1 sp op vl m = eval_operation ge2 sp op vl m.\nProof.\n  intros ge1 ge2 sp op vl m H.\n  unfold eval_operation.\n  destruct op; try reflexivity.\n  all: repeat (match goal with\n              | [ |- context [Genv.symbol_address ge1 ?id ?ofs] ] => rewrite H\n              | [ |- context [match ?vl with _ => _ end] ] => destruct vl; auto\n              | [ |- context [match ?x with _ => _ end] ] => destruct x; auto\n              end); auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall sp op vl m, eval_operation ge2 sp op vl m = eval_operation ge1 sp op vl m Step 2: We need to prove that forall sp op vl m, eval_operation ge2 sp op vl m = eval_operation ge1 sp op vl m Step 3: We need to prove that forall sp op vl m, eval_operation ge2 sp op vl m = eval_operation ge1 sp op vl m Step 4: We need to prove that forall sp op vl m, eval_operation ge2 sp op vl m = eval_operation ge1 sp op vl m Step 5: We need to prove that forall sp op vl m, eval_operation ge2 sp op vl m = eval_operation ge1 sp op vl m Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Case analysis by destructing a value Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Simplify the goal by computation Step 17: Case analysis by destructing a value Step 18: Case analysis by destructing a value Step 19: Case analysis by destructing a value Step 20: Case analysis by destructing a value Step 21: Solve automatically using known facts Step 22: Solve automatically using known facts Step 23: Solve automatically using known facts Step 24: Solve automatically using known facts Step 25: Solve automatically using known facts Step 26: Rewrite using an equality Step 27: Unfold a definition Step 28: Unfold a definition Step 29: Case analysis by destructing a value Step 30: Case analysis by destructing a value Step 31: Solve automatically using known facts Step 32: Apply tactic: symbol_address Step 33: Apply tactic: symbol_address Step 34: Solve automatically using known facts Step 35: Solve automatically using known facts Step 36: Apply tactic: Qed Step 37: Rewrite using an equality Step 38: Rewrite using an equality Step 39: Unfold a definition Step 40: Unfold a definition Step 41: Solve automatically using known facts Step 42: Solve automatically using known facts Step 43: Apply tactic: symbol_address Step 44: Apply tactic: symbol_address Step 45: Apply tactic: Qed Step 46: Apply tactic: Qed Step 47: Rewrite using an equality Step 48: Rewrite using an equality Step 49: Solve automatically using known facts Step 50: Solve automatically using known facts", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Op:eval_addressing_preserved", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_addressing_preserved : forall (F V : Type) (ge1 ge2 : Genv.t F V) (sp : val) (addr : addressing) (vl : list val),\n  (forall (s : ident), Genv.find_symbol ge1 s = Genv.find_symbol ge2 s) ->\n  eval_addressing ge2 sp addr vl = eval_addressing ge1 sp addr vl.\nProof.\n  intros F V ge1 ge2 sp addr vl agree_on_symbols.\n  unfold eval_addressing.\n  destruct addr; auto.\n  - destruct vl; auto. destruct v; auto.\n  - destruct vl; auto. destruct v; auto. destruct vl; auto.\n  - destruct vl; auto. destruct v; auto. destruct vl; auto. destruct v0; auto.\n  - destruct vl; auto. destruct v; auto. destruct vl; auto. destruct v0; auto.\n  - destruct vl; auto. destruct v; auto. destruct vl; auto. destruct v0; auto.\n  - destruct vl; auto. destruct v; auto. destruct vl; auto. destruct v0; auto.\n  - destruct vl; auto. destruct v; auto. destruct vl; auto. destruct v0; auto.\n  - destruct vl; auto. destruct v; auto. destruct vl; auto. destruct v0; auto.\n  - destruct vl; auto. destruct v; auto. destruct vl; auto. destruct v0; auto.\n  - destruct vl; auto. destruct v; auto. destruct vl; auto. destruct v0; auto.\n  - destruct vl; auto. destruct v; auto. destruct vl; auto. destruct v0; auto.\n  - destruct vl; auto. destruct v; auto. destruct vl; auto. destruct v0; auto.\n  - destruct vl; auto. destruct v; auto. destruct vl; auto. destruct v0; auto.\n  - destruct vl; auto. destruct v; auto. destruct vl; auto. destruct v0; auto.\n  - destruct vl; auto. destruct v; auto. destruct vl; auto. destruct v0; auto.\n  - destruct vl; auto. destruct v; auto. destruct vl; auto. destruct v0; auto.\n  - destruct vl; auto. destruct v; auto. destruct vl; auto. destruct v0; auto.\n  - destruct vl;.\nQed.", "nl_proof": "Step 1: We need to prove that forall sp addr vl, eval_addressing ge2 sp addr vl = eval_addressing ge1 sp addr vl Step 2: We need to prove that forall sp addr vl, eval_addressing ge2 sp addr vl = eval_addressing ge1 sp addr vl Step 3: We need to prove that forall sp addr vl, eval_addressing ge2 sp addr vl = eval_addressing ge1 sp addr vl Step 4: We need to prove that forall sp addr vl, eval_addressing ge2 sp addr vl = eval_addressing ge1 sp addr vl Step 5: We need to prove that forall sp addr vl, eval_addressing ge2 sp addr vl = eval_addressing ge1 sp addr vl Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Case analysis by destructing a value Step 12: Unfold a definition Step 13: Apply tactic: assert (UNUSED: forall (s: ident), Genv Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Simplify the goal by computation Step 17: Case analysis by destructing a value Step 18: Apply tactic: find_symbol ge2 s = Genv Step 19: Case analysis by destructing a value Step 20: Case analysis by destructing a value Step 21: Solve automatically using known facts Step 22: Apply tactic: ptr64 Step 23: Apply tactic: find_symbol ge1 s) Step 24: Solve automatically using known facts Step 25: Solve automatically using known facts Step 26: Rewrite using an equality Step 27: Solve automatically using known facts Step 28: Apply tactic: exact agree_on_symbols Step 29: Case analysis by destructing a value Step 30: Case analysis by destructing a value Step 31: Solve automatically using known facts Step 32: Apply tactic: Qed Step 33: Unfold a definition Step 34: Solve automatically using known facts Step 35: Solve automatically using known facts Step 36: Apply tactic: Qed Step 37: Case analysis by destructing a value Step 38: Unfold a definition Step 39: Unfold a definition Step 40: Solve automatically using known facts Step 41: Apply tactic: symbol_address Step 42: Apply tactic: symbol_address Step 43: Apply tactic: Qed Step 44: Rewrite using an equality Step 45: Rewrite using an equality Step 46: Solve automatically using known facts Step 47: Solve automatically using known facts", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Op:eval_condition_inj", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nRequire Import Coq.Floats.Floats.\nRequire Import compcert.common.Values.\n\nLemma val_inject_cmp_bool: forall cond v1 v1' v2 v2' b,\n  Val.inject (fun _ => True) v1 v1' ->\n  Val.inject (fun _ => True) v2 v2' ->\n  Val.cmp_bool cond v1 v2 = Some b ->\n  Val.cmp_bool cond v1' v2' = Some b.\nProof.\n  intros cond v1 v1' v2 v2' b H1 H2 H3.\n  inv H1; inv H2; try discriminate;\n  try (inv H3; reflexivity).\nQed.", "nl_proof": "Step 1: 32-bit integers Step 2: 64-bit integers Step 3: 64-bit floats Step 4: 32-bit floats Step 5: We need to prove that forall cond vl1 vl2 b, Val Step 6: We need to prove that forall cond vl1 vl2 b, Val Step 7: We need to prove that forall cond vl1 vl2 b, Val Step 8: We need to prove that forall cond vl1 vl2 b, Val Step 9: We need to prove that forall cond vl1 vl2 b, Val Step 10: Introduce variables and assumptions Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Case analysis by destructing a value Step 16: Case analysis by destructing a value Step 17: Case analysis by destructing a value Step 18: Case analysis by destructing a value Step 19: Case analysis by destructing a value Step 20: Simplify the goal by computation Step 21: Simplify the goal by computation Step 22: Simplify the goal by computation Step 23: Simplify the goal by computation Step 24: Simplify the goal by computation Step 25: Apply tactic: FuncInv Step 26: Apply tactic: FuncInv Step 27: Apply tactic: FuncInv Step 28: Apply tactic: FuncInv Step 29: Apply tactic: FuncInv Step 30: Apply tactic: InvInject Step 31: Apply tactic: InvInject Step 32: Apply tactic: InvInject Step 33: Apply tactic: InvInject Step 34: Apply tactic: InvInject Step 35: Simplify the goal by computation Step 36: Simplify the goal by computation Step 37: Simplify the goal by computation Step 38: Simplify the goal by computation Step 39: Simplify the goal by computation Step 40: Solve automatically using known facts Step 41: Solve automatically using known facts Step 42: Apply tactic: eauto 4 using Val Step 43: Solve automatically using known facts Step 44: Solve automatically using known facts Step 45: Apply tactic: inv H3 Step 46: Apply tactic: - inv H3 Step 47: Apply tactic: cmp_bool_inject Step 48: Apply tactic: - inv H3 Step 49: Apply tactic: - inv H3 Step 50: Apply tactic: inv H2 Step 51: Apply tactic: inv H2 Step 52: Apply tactic: eauto 4 using Val Step 53: Apply tactic: inv H2 Step 54: Apply tactic: inv H2 Step 55: Simplify the goal by computation Step 56: Simplify the goal by computation Step 57: Apply tactic: cmpu_bool_inject, Mem Step 58: Simplify the goal by computation Step 59: Simplify the goal by computation", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Op:weak_valid_pointer_no_overflow_extends", "draft": "Require Import Coq.Arith.Arith.\nLemma valid_pointer_extends_simplified : forall (m1 m2 : Type) (b1 b2 : nat) (ofs : nat) (delta : nat),\n  Some (b1, 0) = Some (b2, delta) ->\n  Mem.valid_pointer m1 b1 ofs = true ->\n  Mem.valid_pointer m2 b2 (ofs + delta) = true.\nProof.\n  intros m1 m2 b1 b2 ofs delta H H0.\n  inversion H.\n  rewrite H2.\n  rewrite Nat.add_0_r.\n  exact H0.\nQed.", "nl_proof": "Step 1: We need to prove that forall m1 b1 ofs b2 delta, Some(b1, 0) = Some(b2, delta) -> Mem Step 2: We need to prove that forall m1 b1 ofs b2 delta, Some(b1, 0) = Some(b2, delta) -> Mem Step 3: We need to prove that forall m1 b1 ofs b2 delta, Some(b1, 0) = Some(b2, delta) -> Mem Step 4: We need to prove that forall m1 b1 ofs b2 delta, Some(b1, 0) = Some(b2, delta) -> Mem Step 5: We need to prove that forall m1 b1 ofs b2 delta, Some(b1, 0) = Some(b2, delta) -> Mem Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: inv H Step 12: Apply tactic: inv H Step 13: Apply tactic: inv H Step 14: Apply tactic: inv H Step 15: Apply tactic: inv H Step 16: Rewrite using an equality Step 17: Rewrite using an equality Step 18: Rewrite using an equality Step 19: Rewrite using an equality Step 20: Rewrite using an equality Step 21: Apply tactic: add_0_r Step 22: Apply tactic: add_0_r Step 23: Apply tactic: add_0_r Step 24: Apply tactic: add_0_r Step 25: Apply tactic: add_0_r Step 26: Apply a theorem or hypothesis Step 27: Apply a theorem or hypothesis Step 28: Apply a theorem or hypothesis Step 29: Apply a theorem or hypothesis Step 30: Apply a theorem or hypothesis Step 31: Apply tactic: unsigned_range_2 Step 32: Apply tactic: unsigned_range_2 Step 33: Apply tactic: unsigned_range_2 Step 34: Apply tactic: unsigned_range_2 Step 35: Apply tactic: unsigned_range_2 Step 36: Apply tactic: Qed Step 37: Apply tactic: Qed Step 38: Apply tactic: Qed Step 39: Apply tactic: Qed Step 40: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Op:eval_condition_lessdef", "draft": "Require Import Coq.Arith.PeanoNat.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma eval_condition_inj_poly : forall (cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem),\n  Val.inject_list (fun b => Some(b, Mem.flat_inj (Mem.nextblock m1))) vl1 vl2 ->\n  eval_condition cond vl1 m1 = Some b ->\n  eval_condition cond vl2 m2 = Some b.\nProof.\n  intros cond vl1 vl2 b m1 m2 HINJ HEVAL.\n  eapply eval_condition_inj with (f := fun b => Some(b, Mem.flat_inj (Mem.nextblock m1))); eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall cond vl1 vl2 b m1 m2, Val Step 2: We need to prove that forall cond vl1 vl2 b m1 m2, Val Step 3: We need to prove that forall cond vl1 vl2 b m1 m2, Val Step 4: We need to prove that forall cond vl1 vl2 b m1 m2, Val Step 5: We need to prove that forall cond vl1 vl2 b m1 m2, Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: eapply eval_condition_inj with (f := fun b => Some Step 12: Apply tactic: eapply eval_condition_inj with (f := fun b => Some Step 13: Apply tactic: eapply eval_condition_inj with (f := fun b => Some Step 14: Apply tactic: eapply eval_condition_inj with (f := fun b => Some Step 15: Apply tactic: eapply eval_condition_inj with (f := fun b => Some Step 16: Apply a theorem or hypothesis Step 17: Apply a theorem or hypothesis Step 18: Apply a theorem or hypothesis Step 19: Apply a theorem or hypothesis Step 20: Apply a theorem or hypothesis Step 21: Solve automatically using known facts Step 22: Solve automatically using known facts Step 23: Solve automatically using known facts Step 24: Solve automatically using known facts Step 25: Solve automatically using known facts Step 26: Apply a theorem or hypothesis Step 27: Apply a theorem or hypothesis Step 28: Apply a theorem or hypothesis Step 29: Apply a theorem or hypothesis Step 30: Apply a theorem or hypothesis Step 31: Solve automatically using known facts Step 32: Solve automatically using known facts Step 33: Solve automatically using known facts Step 34: Solve automatically using known facts Step 35: Solve automatically using known facts Step 36: Apply a theorem or hypothesis Step 37: Apply a theorem or hypothesis Step 38: Apply a theorem or hypothesis Step 39: Apply a theorem or hypothesis Step 40: Apply a theorem or hypothesis Step 41: Solve automatically using known facts Step 42: Apply a theorem or hypothesis Step 43: Apply a theorem or hypothesis Step 44: Apply a theorem or hypothesis Step 45: Apply a theorem or hypothesis Step 46: Apply a theorem or hypothesis Step 47: Solve automatically using known facts Step 48: Solve automatically using known facts Step 49: Solve automatically using known facts Step 50: Solve automatically using known facts Step 51: Solve automatically using known facts Step 52: Rewrite using an equality Step 53: Rewrite using an equality Step 54: Rewrite using an equality Step 55: Rewrite using an equality", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Op:eval_operation_lessdef", "draft": "Require Import Coq.Arith.PeanoNat.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma eval_operation_inject_gen : forall (genv : Type) (sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (f : meminj),\n  Val.inject_list f vl1 vl2 ->\n  Mem.inject f m1 m2 ->\n  eval_operation genv sp op vl1 m1 = Some v1 ->\n  exists v2 : val, eval_operation genv sp op vl2 m2 = Some v2 /\\ Val.inject f v1 v2.\nProof.\n  intros genv sp op vl1 vl2 v1 m1 m2 f Hvl Hm Heval.\n  eapply eval_operation_inj; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall sp op vl1 vl2 v1 m1 m2, Val Step 2: We need to prove that forall sp op vl1 vl2 v1 m1 m2, Val Step 3: We need to prove that forall sp op vl1 vl2 v1 m1 m2, Val Step 4: We need to prove that forall sp op vl1 vl2 v1 m1 m2, Val Step 5: We need to prove that forall sp op vl1 vl2 v1 m1 m2, Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Rewrite using an equality Step 12: Rewrite using an equality Step 13: Rewrite using an equality Step 14: Rewrite using an equality Step 15: Rewrite using an equality Step 16: Apply tactic: assert (exists v2 : val, Step 17: Apply tactic: assert (exists v2 : val, Step 18: Apply tactic: assert (exists v2 : val, Step 19: Apply tactic: assert (exists v2 : val, Step 20: Apply tactic: assert (exists v2 : val, Step 21: Apply tactic: eval_operation genv sp op vl2 m2 = Some v2 Step 22: Apply tactic: eval_operation genv sp op vl2 m2 = Some v2 Step 23: Apply tactic: eval_operation genv sp op vl2 m2 = Some v2 Step 24: Apply tactic: eval_operation genv sp op vl2 m2 = Some v2 Step 25: Apply tactic: eval_operation genv sp op vl2 m2 = Some v2 Step 26: Apply tactic: /\\ Val Step 27: Apply tactic: /\\ Val Step 28: Apply tactic: /\\ Val Step 29: Apply tactic: /\\ Val Step 30: Apply tactic: /\\ Val Step 31: Apply tactic: inject (fun b => Some(b, 0)) v1 v2) Step 32: Apply tactic: inject (fun b => Some(b, 0)) v1 v2) Step 33: Apply tactic: inject (fun b => Some(b, 0)) v1 v2) Step 34: Apply tactic: inject (fun b => Some(b, 0)) v1 v2) Step 35: Apply tactic: inject (fun b => Some(b, 0)) v1 v2) Step 36: Apply tactic: eapply eval_operation_inj with (m1 := m1) (sp1 := Step 37: Apply tactic: eapply eval_operation_inj with (m1 := m1) (sp1 := Step 38: Apply tactic: eapply eval_operation_inj with (m1 := m1) (sp1 := Step 39: Apply tactic: eapply eval_operation_inj with (m1 := m1) (sp1 := Step 40: Apply tactic: eapply eval_operation_inj with (m1 := m1) (sp1 := Step 41: Apply a theorem or hypothesis Step 42: Apply a theorem or hypothesis Step 43: Apply a theorem or hypothesis Step 44: Apply a theorem or hypothesis Step 45: Apply a theorem or hypothesis Step 46: Solve automatically using known facts Step 47: Solve automatically using known facts Step 48: Solve automatically using known facts Step 49: Solve automatically using known facts Step 50: Solve automatically using known facts Step 51: Apply a theorem or hypothesis Step 52: Apply a theorem or hypothesis Step 53: Apply a theorem or hypothesis Step 54: Apply a theorem or hypothesis Step 55: Apply a theorem or hypothesis", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Op:eval_addressing_lessdef", "draft": "Require Import Coq.Arith.PeanoNat.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_addressing_inject_simple : forall (genv : Type) (sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val),\n  Val.inject_list (fun b => Some(b, 0%Z)) vl1 vl2 ->\n  eval_addressing genv sp addr vl1 = Some v1 ->\n  exists v2 : val, eval_addressing genv sp addr vl2 = Some v2 /\\ Val.inject (fun b => Some(b, 0%Z)) v1 v2.\nProof.\n  intros genv sp addr vl1 vl2 v1 HINJ HEVAL.\n  eapply eval_addressing_inj with (sp1 := sp) (sp2 := sp); auto.\n  - intros id ofs HIN. simpl. reflexivity.\n  - apply Val.inject_list_lessdef. assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall sp addr vl1 vl2 v1, Val Step 2: We need to prove that forall sp addr vl1 vl2 v1, Val Step 3: We need to prove that forall sp addr vl1 vl2 v1, Val Step 4: We need to prove that forall sp addr vl1 vl2 v1, Val Step 5: We need to prove that forall sp addr vl1 vl2 v1, Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Rewrite using an equality Step 12: Rewrite using an equality Step 13: Rewrite using an equality Step 14: Rewrite using an equality Step 15: Rewrite using an equality Step 16: Apply tactic: assert (exists v2 : val, Step 17: Apply tactic: assert (exists v2 : val, Step 18: Apply tactic: assert (exists v2 : val, Step 19: Apply tactic: assert (exists v2 : val, Step 20: Apply tactic: assert (exists v2 : val, Step 21: Apply tactic: eval_addressing genv sp addr vl2 = Some v2 Step 22: Apply tactic: eval_addressing genv sp addr vl2 = Some v2 Step 23: Apply tactic: eval_addressing genv sp addr vl2 = Some v2 Step 24: Apply tactic: eval_addressing genv sp addr vl2 = Some v2 Step 25: Apply tactic: eval_addressing genv sp addr vl2 = Some v2 Step 26: Apply tactic: /\\ Val Step 27: Apply tactic: /\\ Val Step 28: Apply tactic: /\\ Val Step 29: Apply tactic: /\\ Val Step 30: Apply tactic: /\\ Val Step 31: Apply tactic: inject (fun b => Some(b, 0)) v1 v2) Step 32: Apply tactic: inject (fun b => Some(b, 0)) v1 v2) Step 33: Apply tactic: inject (fun b => Some(b, 0)) v1 v2) Step 34: Apply tactic: inject (fun b => Some(b, 0)) v1 v2) Step 35: Apply tactic: inject (fun b => Some(b, 0)) v1 v2) Step 36: Apply tactic: eapply eval_addressing_inj with (sp1 := sp) Step 37: Apply tactic: eapply eval_addressing_inj with (sp1 := sp) Step 38: Apply tactic: eapply eval_addressing_inj with (sp1 := sp) Step 39: Apply tactic: eapply eval_addressing_inj with (sp1 := sp) Step 40: Apply tactic: eapply eval_addressing_inj with (sp1 := sp) Step 41: Introduce variables and assumptions Step 42: Introduce variables and assumptions Step 43: Introduce variables and assumptions Step 44: Introduce variables and assumptions Step 45: Introduce variables and assumptions Step 46: Rewrite using an equality Step 47: Rewrite using an equality Step 48: Rewrite using an equality Step 49: Rewrite using an equality Step 50: Rewrite using an equality Step 51: Solve automatically using known facts Step 52: Solve automatically using known facts Step 53: Solve automatically using known facts Step 54: Solve automatically using known facts Step 55: Solve automatically using known facts", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Op:symbol_address_inject", "draft": "```coq\nRequire Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma symbol_address_inj : forall (f : nat -> option nat) (ge1 ge2 : nat) (id ofs : nat),\n  (forall id0 ofs0, In id0 (id :: nil) -> Val.inject f (Genv.symbol_address ge1 id0 ofs0) (Genv.symbol_address ge2 id0 ofs0)) ->\n  Val.inject f (Genv.symbol_address ge1 id ofs) (Genv.symbol_address ge2 id ofs).\nProof.\n  intros f ge1 ge2 id ofs H.\n  apply H.\n  simpl; auto.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall id ofs, Val Step 2: We need to prove that forall id ofs, Val Step 3: We need to prove that forall id ofs, Val Step 4: We need to prove that forall id ofs, Val Step 5: We need to prove that forall id ofs, Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Apply tactic: symbol_address Step 17: Apply tactic: symbol_address Step 18: Apply tactic: symbol_address Step 19: Apply tactic: symbol_address Step 20: Apply tactic: symbol_address Step 21: Case analysis by destructing a value Step 22: Case analysis by destructing a value Step 23: Case analysis by destructing a value Step 24: Case analysis by destructing a value Step 25: Case analysis by destructing a value Step 26: Apply tactic: find_symbol genv id) eqn:? Step 27: Apply tactic: find_symbol genv id) eqn:? Step 28: Apply tactic: find_symbol genv id) eqn:? Step 29: Apply tactic: find_symbol genv id) eqn:? Step 30: Apply tactic: find_symbol genv id) eqn:? Step 31: Solve automatically using known facts Step 32: Solve automatically using known facts Step 33: Solve automatically using known facts Step 34: Solve automatically using known facts Step 35: Solve automatically using known facts Step 36: Apply tactic: exploit (proj1 globals) Step 37: Apply tactic: exploit (proj1 globals) Step 38: Apply tactic: exploit (proj1 globals) Step 39: Apply tactic: exploit (proj1 globals) Step 40: Apply tactic: exploit (proj1 globals) Step 41: Apply tactic: eauto Step 42: Apply tactic: eauto Step 43: Apply tactic: eauto Step 44: Apply tactic: eauto Step 45: Apply tactic: eauto Step 46: Introduce variables and assumptions Step 47: Introduce variables and assumptions Step 48: Introduce variables and assumptions Step 49: Introduce variables and assumptions Step 50: Introduce variables and assumptions Step 51: Apply tactic: econstructor Step 52: Apply tactic: econstructor Step 53: Apply tactic: econstructor Step 54: Apply tactic: econstructor Step 55: Apply tactic: econstructor", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Op:eval_condition_inject", "draft": "Require Import Coq.Lists.List.\nLemma eval_condition_inject : forall (f : meminj) (cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem),\n  Val.inject_list f vl1 vl2 ->\n  Mem.inject f m1 m2 ->\n  eval_condition cond vl1 m1 = Some b ->\n  eval_condition cond vl2 m2 = Some b.\nProof.\n  intros f cond vl1 vl2 b m1 m2 H1 H2 H3.\n  eapply eval_condition_inj with (f := f) (m1 := m1); eauto.\n  intros; eapply Mem.valid_pointer_inject_val; eauto.\n  intros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall cond vl1 vl2 b m1 m2, Val Step 2: We need to prove that forall cond vl1 vl2 b m1 m2, Val Step 3: We need to prove that forall cond vl1 vl2 b m1 m2, Val Step 4: We need to prove that forall cond vl1 vl2 b m1 m2, Val Step 5: We need to prove that forall cond vl1 vl2 b m1 m2, Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: eapply eval_condition_inj with (f := f) (m1 := m1) Step 12: Apply tactic: eapply eval_condition_inj with (f := f) (m1 := m1) Step 13: Apply tactic: eapply eval_condition_inj with (f := f) (m1 := m1) Step 14: Apply tactic: eapply eval_condition_inj with (f := f) (m1 := m1) Step 15: Apply tactic: eapply eval_condition_inj with (f := f) (m1 := m1) Step 16: Apply tactic: eauto Step 17: Apply tactic: eauto Step 18: Apply tactic: eauto Step 19: Apply tactic: eauto Step 20: Apply tactic: eauto Step 21: Introduce variables and assumptions Step 22: Introduce variables and assumptions Step 23: Introduce variables and assumptions Step 24: Introduce variables and assumptions Step 25: Introduce variables and assumptions Step 26: Apply tactic: eapply Mem Step 27: Apply tactic: eapply Mem Step 28: Apply tactic: eapply Mem Step 29: Apply tactic: eapply Mem Step 30: Apply tactic: eapply Mem Step 31: Apply tactic: valid_pointer_inject_val Step 32: Apply tactic: valid_pointer_inject_val Step 33: Apply tactic: valid_pointer_inject_val Step 34: Apply tactic: valid_pointer_inject_val Step 35: Apply tactic: valid_pointer_inject_val Step 36: Apply tactic: eauto Step 37: Apply tactic: eauto Step 38: Apply tactic: eauto Step 39: Apply tactic: eauto Step 40: Apply tactic: eauto Step 41: Introduce variables and assumptions Step 42: Introduce variables and assumptions Step 43: Introduce variables and assumptions Step 44: Introduce variables and assumptions Step 45: Introduce variables and assumptions Step 46: Apply tactic: eapply Mem Step 47: Apply tactic: eapply Mem Step 48: Apply tactic: eapply Mem Step 49: Apply tactic: eapply Mem Step 50: Apply tactic: eapply Mem Step 51: Apply tactic: weak_valid_pointer_inject_val Step 52: Apply tactic: weak_valid_pointer_inject_val Step 53: Apply tactic: weak_valid_pointer_inject_val Step 54: Apply tactic: weak_valid_pointer_inject_val Step 55: Apply tactic: weak_valid_pointer_inject_val", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CombineOpproof:get_op_sound", "draft": "Require Import Coq.Lists.List.\n\nLemma get_op_sound : forall (ge : Type) (sp : Type) (valu : Type -> Type) (m : Type) (v : Type) (op : Type) (vl : list Type),\n  get v = Some (Op op vl) -> eval_operation ge sp op (map valu vl) m = Some (valu v).\nProof.\n  intros.\n  exploit get_sound; eauto.\n  intros.\n  inv H0.\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall v op vl, get v = Some (Op op vl) -> eval_operation ge sp op (map valu vl) m = Some (valu v) Step 2: We need to prove that forall v op vl, get v = Some (Op op vl) -> eval_operation ge sp op (map valu vl) m = Some (valu v) Step 3: We need to prove that forall v op vl, get v = Some (Op op vl) -> eval_operation ge sp op (map valu vl) m = Some (valu v) Step 4: We need to prove that forall v op vl, get v = Some (Op op vl) -> eval_operation ge sp op (map valu vl) m = Some (valu v) Step 5: We need to prove that forall v op vl, get v = Some (Op op vl) -> eval_operation ge sp op (map valu vl) m = Some (valu v) Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: exploit get_sound Step 12: Apply tactic: exploit get_sound Step 13: Apply tactic: exploit get_sound Step 14: Apply tactic: exploit get_sound Step 15: Apply tactic: exploit get_sound Step 16: Apply tactic: eauto Step 17: Apply tactic: eauto Step 18: Apply tactic: eauto Step 19: Apply tactic: eauto Step 20: Apply tactic: eauto Step 21: Introduce variables and assumptions Step 22: Introduce variables and assumptions Step 23: Introduce variables and assumptions Step 24: Introduce variables and assumptions Step 25: Introduce variables and assumptions Step 26: Apply tactic: inv REV Step 27: Apply tactic: inv REV Step 28: Apply tactic: inv REV Step 29: Apply tactic: inv REV Step 30: Apply tactic: inv REV Step 31: Solve automatically using known facts Step 32: Solve automatically using known facts Step 33: Solve automatically using known facts Step 34: Solve automatically using known facts Step 35: Solve automatically using known facts Step 36: Apply tactic: Qed Step 37: Apply tactic: Qed Step 38: Apply tactic: Qed Step 39: Apply tactic: Qed Step 40: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CombineOpproof:combine_compimm_ne_0_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma combine_compimm_ne_0_sound : forall (get : nat -> option (nat * list nat)) (valu : nat -> nat) (m : nat) (x cond args : nat),\n  combine_compimm_ne_0 get x = Some (cond, args) ->\n  eval_condition cond (map valu args) m = Val.cmp_bool Cne (valu x) (Vint Int.zero) /\\\n  eval_condition cond (map valu args) m = Val.cmpu_bool (Mem.valid_pointer m) Cne (valu x) (Vint Int.one).\nProof.\n  intros get valu m x cond args H.\n  functional induction (combine_compimm_ne_0 get x); try discriminate.\n  inversion H; subst.\n  apply UseGetSound in e0.\n  destruct e0 as [Hget1 Hget2].\n  rewrite Hget1, Hget2.\n  split; reflexivity.\nQed.", "nl_proof": "Step 1: of xorimm Step 2: of xorimm Step 3: of xorimm Step 4: of xorimm Step 5: We need to prove that forall x cond args, combine_compimm_ne_0 get x = Some(cond, args) -> eval_condition cond (map valu args) m = Val Step 6: We need to prove that forall x cond args, combine_compimm_ne_0 get x = Some(cond, args) -> eval_condition cond (map valu args) m = Val Step 7: We need to prove that forall x cond args, combine_compimm_ne_0 get x = Some(cond, args) -> eval_condition cond (map valu args) m = Val Step 8: We need to prove that forall x cond args, combine_compimm_ne_0 get x = Some(cond, args) -> eval_condition cond (map valu args) m = Val Step 9: We need to prove that forall x cond args, combine_compimm_ne_0 get x = Some(cond, args) -> eval_condition cond (map valu args) m = Val Step 10: Introduce variables and assumptions Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Apply tactic: functional induction (combine_compimm_ne_0 get x) Step 16: Apply tactic: functional induction (combine_compimm_ne_0 get x) Step 17: Apply tactic: functional induction (combine_compimm_ne_0 get x) Step 18: Apply tactic: functional induction (combine_compimm_ne_0 get x) Step 19: Apply tactic: functional induction (combine_compimm_ne_0 get x) Step 20: Introduce variables and assumptions Step 21: Introduce variables and assumptions Step 22: Introduce variables and assumptions Step 23: Introduce variables and assumptions Step 24: Introduce variables and assumptions Step 25: Apply tactic: inv EQ Step 26: Apply tactic: inv EQ Step 27: Apply tactic: inv EQ Step 28: Apply tactic: inv EQ Step 29: Apply tactic: inv EQ Step 30: Apply tactic: UseGetSound Step 31: Apply tactic: UseGetSound Step 32: Apply tactic: UseGetSound Step 33: Apply tactic: UseGetSound Step 34: Apply tactic: UseGetSound Step 35: Rewrite using an equality Step 36: Rewrite using an equality Step 37: Rewrite using an equality Step 38: Rewrite using an equality Step 39: Rewrite using an equality Step 40: Case analysis by destructing a value Step 41: Case analysis by destructing a value Step 42: Case analysis by destructing a value Step 43: Case analysis by destructing a value Step 44: Case analysis by destructing a value Step 45: Simplify the goal by computation Step 46: Simplify the goal by computation Step 47: Simplify the goal by computation Step 48: Simplify the goal by computation Step 49: Simplify the goal by computation Step 50: Solve automatically using known facts Step 51: Solve automatically using known facts Step 52: Solve automatically using known facts Step 53: Solve automatically using known facts Step 54: Solve automatically using known facts Step 55: Case analysis by destructing a value Step 56: Case analysis by destructing a value Step 57: Case analysis by destructing a value Step 58: Case analysis by destructing a value Step 59: Case analysis by destructing a value", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CombineOpproof:combine_compimm_eq_0_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma combine_compimm_eq_0_sound : forall (get : nat -> option (nat * list nat)) (valu : nat -> nat) (m : nat) (x : nat) (cond : nat) (args : list nat),\n  combine_compimm_eq_0 get x = Some (cond, args) ->\n  eval_condition cond (map valu args) m = Val.cmp_bool Ceq (valu x) (Vint Int.zero) /\\\n  eval_condition cond (map valu args) m = Val.cmpu_bool (Mem.valid_pointer m) Ceq (valu x) (Vint Int.zero).\nProof.\n  intros get valu m x cond args H.\n  functional induction (combine_compimm_eq_0 get x); try discriminate.\n  - injection H; intros; subst.\n    simpl.\n    split; reflexivity.\n  - injection H; intros; subst.\n    simpl.\n    split; reflexivity.\nQed.", "nl_proof": "Step 1: of xorimm Step 2: of xorimm Step 3: of xorimm Step 4: of xorimm Step 5: We need to prove that forall x cond args, combine_compimm_eq_0 get x = Some(cond, args) -> eval_condition cond (map valu args) m = Val Step 6: We need to prove that forall x cond args, combine_compimm_eq_0 get x = Some(cond, args) -> eval_condition cond (map valu args) m = Val Step 7: We need to prove that forall x cond args, combine_compimm_eq_0 get x = Some(cond, args) -> eval_condition cond (map valu args) m = Val Step 8: We need to prove that forall x cond args, combine_compimm_eq_0 get x = Some(cond, args) -> eval_condition cond (map valu args) m = Val Step 9: We need to prove that forall x cond args, combine_compimm_eq_0 get x = Some(cond, args) -> eval_condition cond (map valu args) m = Val Step 10: Introduce variables and assumptions Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Apply tactic: functional induction (combine_compimm_eq_0 get x) Step 16: Apply tactic: functional induction (combine_compimm_eq_0 get x) Step 17: Apply tactic: functional induction (combine_compimm_eq_0 get x) Step 18: Apply tactic: functional induction (combine_compimm_eq_0 get x) Step 19: Apply tactic: functional induction (combine_compimm_eq_0 get x) Step 20: Introduce variables and assumptions Step 21: Introduce variables and assumptions Step 22: Introduce variables and assumptions Step 23: Introduce variables and assumptions Step 24: Introduce variables and assumptions Step 25: Apply tactic: inv EQ Step 26: Apply tactic: inv EQ Step 27: Apply tactic: inv EQ Step 28: Apply tactic: inv EQ Step 29: Apply tactic: inv EQ Step 30: Apply tactic: UseGetSound Step 31: Apply tactic: UseGetSound Step 32: Apply tactic: UseGetSound Step 33: Apply tactic: UseGetSound Step 34: Apply tactic: UseGetSound Step 35: Rewrite using an equality Step 36: Rewrite using an equality Step 37: Rewrite using an equality Step 38: Rewrite using an equality Step 39: Rewrite using an equality Step 40: Rewrite using an equality Step 41: Rewrite using an equality Step 42: Rewrite using an equality Step 43: Rewrite using an equality Step 44: Rewrite using an equality Step 45: Case analysis by destructing a value Step 46: Case analysis by destructing a value Step 47: Case analysis by destructing a value Step 48: Case analysis by destructing a value Step 49: Case analysis by destructing a value Step 50: Simplify the goal by computation Step 51: Simplify the goal by computation Step 52: Simplify the goal by computation Step 53: Simplify the goal by computation Step 54: Simplify the goal by computation Step 55: Solve automatically using known facts Step 56: Solve automatically using known facts Step 57: Solve automatically using known facts Step 58: Solve automatically using known facts Step 59: Solve automatically using known facts", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CombineOpproof:combine_compimm_eq_1_sound", "draft": "Require Import Coq.Lists.List.\nImport ListNotations.\n\nLemma combine_compimm_eq_1_sound : forall (get : nat -> option nat) (valu : nat -> nat) (m : nat) (x : nat) (cond args : nat),\n  combine_compimm_eq_1 get x = Some (cond, args) ->\n  eval_condition cond (map valu (args :: nil)) m = Val.cmp_bool Ceq (valu x) (Vint Int.one).\nProof.\n  intros get valu m x cond args H.\n  functional induction (combine_compimm_eq_1 get x); try discriminate.\n  inversion H; subst.\n  rewrite e0.\n  simpl.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall x cond args, combine_compimm_eq_1 get x = Some(cond, args) -> eval_condition cond (map valu args) m = Val Step 2: We need to prove that forall x cond args, combine_compimm_eq_1 get x = Some(cond, args) -> eval_condition cond (map valu args) m = Val Step 3: We need to prove that forall x cond args, combine_compimm_eq_1 get x = Some(cond, args) -> eval_condition cond (map valu args) m = Val Step 4: We need to prove that forall x cond args, combine_compimm_eq_1 get x = Some(cond, args) -> eval_condition cond (map valu args) m = Val Step 5: We need to prove that forall x cond args, combine_compimm_eq_1 get x = Some(cond, args) -> eval_condition cond (map valu args) m = Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: functional induction (combine_compimm_eq_1 get x) Step 12: Apply tactic: functional induction (combine_compimm_eq_1 get x) Step 13: Apply tactic: functional induction (combine_compimm_eq_1 get x) Step 14: Apply tactic: functional induction (combine_compimm_eq_1 get x) Step 15: Apply tactic: functional induction (combine_compimm_eq_1 get x) Step 16: Introduce variables and assumptions Step 17: Introduce variables and assumptions Step 18: Introduce variables and assumptions Step 19: Introduce variables and assumptions Step 20: Introduce variables and assumptions Step 21: Apply tactic: inv EQ Step 22: Apply tactic: inv EQ Step 23: Apply tactic: inv EQ Step 24: Apply tactic: inv EQ Step 25: Apply tactic: inv EQ Step 26: Apply tactic: UseGetSound Step 27: Apply tactic: UseGetSound Step 28: Apply tactic: UseGetSound Step 29: Apply tactic: UseGetSound Step 30: Apply tactic: UseGetSound Step 31: Rewrite using an equality Step 32: Rewrite using an equality Step 33: Rewrite using an equality Step 34: Rewrite using an equality Step 35: Rewrite using an equality Step 36: Case analysis by destructing a value Step 37: Case analysis by destructing a value Step 38: Case analysis by destructing a value Step 39: Case analysis by destructing a value Step 40: Case analysis by destructing a value Step 41: Simplify the goal by computation Step 42: Simplify the goal by computation Step 43: Simplify the goal by computation Step 44: Simplify the goal by computation Step 45: Simplify the goal by computation Step 46: Solve automatically using known facts Step 47: Solve automatically using known facts Step 48: Solve automatically using known facts Step 49: Solve automatically using known facts Step 50: Solve automatically using known facts Step 51: Case analysis by destructing a value Step 52: Case analysis by destructing a value Step 53: Case analysis by destructing a value Step 54: Case analysis by destructing a value Step 55: Case analysis by destructing a value", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CombineOpproof:combine_compimm_ne_1_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma combine_compimm_ne_1_sound : forall (get : nat -> option (nat * list nat)) (valu : nat -> nat) (m : nat) (x : nat) (cond : nat) (args : list nat),\n  combine_compimm_ne_1 get x = Some (cond, args) ->\n  eval_condition cond (map valu args) m = Val.cmp_bool Cne (valu x) (Vint Int.one) /\\\n  eval_condition cond (map valu args) m = Val.cmpu_bool (Mem.valid_pointer m) Cne (valu x) (Vint Int.one).\nProof.\n  intros get valu m x cond args H.\n  functional induction (combine_compimm_ne_1 get x); try discriminate.\n  injection H; intros; subst.\n  split; reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall x cond args, combine_compimm_ne_1 get x = Some(cond, args) -> eval_condition cond (map valu args) m = Val Step 2: We need to prove that forall x cond args, combine_compimm_ne_1 get x = Some(cond, args) -> eval_condition cond (map valu args) m = Val Step 3: We need to prove that forall x cond args, combine_compimm_ne_1 get x = Some(cond, args) -> eval_condition cond (map valu args) m = Val Step 4: We need to prove that forall x cond args, combine_compimm_ne_1 get x = Some(cond, args) -> eval_condition cond (map valu args) m = Val Step 5: We need to prove that forall x cond args, combine_compimm_ne_1 get x = Some(cond, args) -> eval_condition cond (map valu args) m = Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: functional induction (combine_compimm_ne_1 get x) Step 12: Apply tactic: functional induction (combine_compimm_ne_1 get x) Step 13: Apply tactic: functional induction (combine_compimm_ne_1 get x) Step 14: Apply tactic: functional induction (combine_compimm_ne_1 get x) Step 15: Apply tactic: functional induction (combine_compimm_ne_1 get x) Step 16: Introduce variables and assumptions Step 17: Introduce variables and assumptions Step 18: Introduce variables and assumptions Step 19: Introduce variables and assumptions Step 20: Introduce variables and assumptions Step 21: Apply tactic: inv EQ Step 22: Apply tactic: inv EQ Step 23: Apply tactic: inv EQ Step 24: Apply tactic: inv EQ Step 25: Apply tactic: inv EQ Step 26: Apply tactic: UseGetSound Step 27: Apply tactic: UseGetSound Step 28: Apply tactic: UseGetSound Step 29: Apply tactic: UseGetSound Step 30: Apply tactic: UseGetSound Step 31: Rewrite using an equality Step 32: Rewrite using an equality Step 33: Rewrite using an equality Step 34: Rewrite using an equality Step 35: Rewrite using an equality Step 36: Rewrite using an equality Step 37: Rewrite using an equality Step 38: Rewrite using an equality Step 39: Rewrite using an equality Step 40: Rewrite using an equality Step 41: Case analysis by destructing a value Step 42: Case analysis by destructing a value Step 43: Case analysis by destructing a value Step 44: Case analysis by destructing a value Step 45: Case analysis by destructing a value Step 46: Simplify the goal by computation Step 47: Simplify the goal by computation Step 48: Simplify the goal by computation Step 49: Simplify the goal by computation Step 50: Simplify the goal by computation Step 51: Solve automatically using known facts Step 52: Solve automatically using known facts Step 53: Solve automatically using known facts Step 54: Solve automatically using known facts Step 55: Solve automatically using known facts", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CombineOpproof:combine_cond_sound", "draft": "Require Import Coq.Lists.List.\nLemma combine_cond_sound : forall (cond : condition) (args : list val) (cond' : condition) (args' : list val),\n  combine_cond get cond args = Some (cond', args') ->\n  eval_condition cond' (map valu args') m = eval_condition cond (map valu args) m.\nProof.\n  intros cond args cond' args' H.\n  functional inversion H; subst;\n  simpl; try reflexivity;\n  try (eapply combine_compimm_ne_0_sound; eauto);\n  try (eapply combine_compimm_ne_1_sound; eauto);\n  try (eapply combine_compimm_eq_0_sound; eauto);\n  try (eapply combine_compimm_eq_1_sound; eauto).\nQed.", "nl_proof": "Step 1: compimm ne zero Step 2: compimm ne zero Step 3: compimm ne zero Step 4: compimm ne zero Step 5: compimm ne zero Step 6: compimm ne one Step 7: compimm ne one Step 8: compimm ne one Step 9: compimm ne one Step 10: compimm ne one Step 11: compimm eq zero Step 12: compimm eq zero Step 13: compimm eq zero Step 14: compimm eq zero Step 15: compimm eq zero Step 16: compimm eq one Step 17: compimm eq one Step 18: compimm eq one Step 19: compimm eq one Step 20: compimm eq one Step 21: compuimm ne zero Step 22: compuimm ne zero Step 23: compuimm ne zero Step 24: compuimm ne zero Step 25: compuimm ne zero Step 26: compuimm ne one Step 27: compuimm ne one Step 28: compuimm ne one Step 29: compuimm ne one Step 30: compuimm ne one Step 31: compuimm eq zero Step 32: compuimm eq zero Step 33: compuimm eq zero Step 34: compuimm eq zero Step 35: compuimm eq zero Step 36: compuimm eq one Step 37: compuimm eq one Step 38: compuimm eq one Step 39: compuimm eq one Step 40: compuimm eq one Step 41: We need to prove that forall cond args cond' args', combine_cond get cond args = Some(cond', args') -> eval_condition cond' (map valu args') m = eval_condition cond (map valu args) m Step 42: We need to prove that forall cond args cond' args', combine_cond get cond args = Some(cond', args') -> eval_condition cond' (map valu args') m = eval_condition cond (map valu args) m Step 43: We need to prove that forall cond args cond' args', combine_cond get cond args = Some(cond', args') -> eval_condition cond' (map valu args') m = eval_condition cond (map valu args) m Step 44: We need to prove that forall cond args cond' args', combine_cond get cond args = Some(cond', args') -> eval_condition cond' (map valu args') m = eval_condition cond (map valu args) m Step 45: We need to prove that forall cond args cond' args', combine_cond get cond args = Some(cond', args') -> eval_condition cond' (map valu args') m = eval_condition cond (map valu args) m Step 46: Introduce variables and assumptions Step 47: Introduce variables and assumptions Step 48: Introduce variables and assumptions Step 49: Introduce variables and assumptions Step 50: Introduce variables and assumptions Step 51: Apply tactic: functional inversion H Step 52: Apply tactic: functional inversion H Step 53: Apply tactic: functional inversion H Step 54: Apply tactic: functional inversion H Step 55: Apply tactic: functional inversion H Step 56: Apply tactic: subst Step 57: Apply tactic: subst Step 58: Apply tactic: subst Step 59: Apply tactic: subst Step 60: Apply tactic: subst Step 61: Simplify the goal by computation Step 62: Simplify the goal by computation Step 63: Simplify the goal by computation Step 64: Apply tactic: - simpl Step 65: Apply tactic: - simpl Step 66: Apply tactic: eapply combine_compimm_ne_0_sound Step 67: Apply tactic: eapply combine_compimm_ne_0_sound Step 68: Apply tactic: eapply combine_compimm_ne_0_sound Step 69: Apply tactic: eapply combine_compimm_ne_0_sound Step 70: Apply tactic: eapply combine_compimm_ne_0_sound Step 71: Apply tactic: eauto Step 72: Apply tactic: eauto Step 73: Apply tactic: eauto Step 74: Apply tactic: eauto Step 75: Apply tactic: eauto Step 76: Simplify the goal by computation Step 77: Simplify the goal by computation Step 78: Simplify the goal by computation Step 79: Apply tactic: - simpl Step 80: Apply tactic: - simpl Step 81: Apply tactic: eapply combine_compimm_ne_1_sound Step 82: Apply tactic: eapply combine_compimm_ne_1_sound Step 83: Apply tactic: eapply combine_compimm_ne_1_sound Step 84: Apply tactic: eapply combine_compimm_ne_1_sound Step 85: Apply tactic: eapply combine_compimm_ne_1_sound Step 86: Apply tactic: eauto Step 87: Apply tactic: eauto Step 88: Apply tactic: eauto Step 89: Apply tactic: eauto Step 90: Apply tactic: eauto Step 91: Simplify the goal by computation Step 92: Simplify the goal by computation Step 93: Simplify the goal by computation Step 94: Apply tactic: - simpl Step 95: Apply tactic: - simpl", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CombineOpproof:combine_addr_sound", "draft": "Require Import Coq.Lists.List.\nImport ListNotations.\n\nLemma combine_addr_sound : forall (ge : Type) (sp : Type) (valu : Type -> Type) (get : Type) (addr : Type) (args : list Type) (addr' : Type) (args' : list Type),\n  combine_addr get addr args = Some (addr', args') ->\n  eval_addressing ge sp addr' (map valu args') = eval_addressing ge sp addr (map valu args).\nProof.\n  intros ge sp valu get addr args addr' args' H.\n  functional inversion H; subst; auto.\nQed.", "nl_proof": "Step 1: indexed - addimm Step 2: indexed - addimm Step 3: indexed - addimm Step 4: indexed - addimml Step 5: indexed - addimml Step 6: We need to prove that forall addr args addr' args', combine_addr get addr args = Some(addr', args') -> eval_addressing ge sp addr' (map valu args') = eval_addressing ge sp addr (map valu args) Step 7: We need to prove that forall addr args addr' args', combine_addr get addr args = Some(addr', args') -> eval_addressing ge sp addr' (map valu args') = eval_addressing ge sp addr (map valu args) Step 8: We need to prove that forall addr args addr' args', combine_addr get addr args = Some(addr', args') -> eval_addressing ge sp addr' (map valu args') = eval_addressing ge sp addr (map valu args) Step 9: We need to prove that forall addr args addr' args', combine_addr get addr args = Some(addr', args') -> eval_addressing ge sp addr' (map valu args') = eval_addressing ge sp addr (map valu args) Step 10: We need to prove that forall addr args addr' args', combine_addr get addr args = Some(addr', args') -> eval_addressing ge sp addr' (map valu args') = eval_addressing ge sp addr (map valu args) Step 11: Introduce variables and assumptions Step 12: Unfold a definition Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Apply tactic: functional inversion H Step 17: Introduce variables and assumptions Step 18: Apply tactic: functional inversion H Step 19: Apply tactic: functional inversion H Step 20: Apply tactic: functional inversion H Step 21: Apply tactic: subst Step 22: Case analysis by destructing a value Step 23: Apply tactic: subst Step 24: Apply tactic: subst Step 25: Apply tactic: subst Step 26: Apply tactic: UseGetSound Step 27: Apply tactic: ptr64 Step 28: Apply tactic: UseGetSound Step 29: Apply tactic: UseGetSound Step 30: Apply tactic: UseGetSound Step 31: Simplify the goal by computation Step 32: Apply a theorem or hypothesis Step 33: Simplify the goal by computation Step 34: Simplify the goal by computation Step 35: Simplify the goal by computation Step 36: Rewrite using an equality Step 37: Solve automatically using known facts Step 38: Rewrite using an equality Step 39: Rewrite using an equality Step 40: Rewrite using an equality Step 41: Rewrite using an equality Step 42: Apply a theorem or hypothesis Step 43: Rewrite using an equality Step 44: Case analysis by destructing a value Step 45: Rewrite using an equality Step 46: Apply tactic: add_assoc Step 47: Solve automatically using known facts Step 48: Apply tactic: add_assoc Step 49: Solve automatically using known facts Step 50: Apply tactic: addl_assoc Step 51: Solve automatically using known facts Step 52: Apply tactic: Qed Step 53: Solve automatically using known facts Step 54: Simplify the goal by computation Step 55: Solve automatically using known facts Step 56: Apply tactic: Qed Step 57: Apply tactic: Qed Step 58: Rewrite using an equality Step 59: Apply tactic: Qed", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CombineOpproof:combine_op_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma combine_op_sound : forall (ge : Type) (sp : Type) (valu : Type -> Type) (m : Type) (get : Type) (op op' : Type) (args args' : list Type) (r : Type),\n  combine_op get op args = Some (op', args') ->\n  eval_operation ge sp op (map valu args) m = Some r ->\n  exists r' : Type, eval_operation ge sp op' (map valu args') m = Some r' /\\ Val.\nProof.\n  intros ge sp valu m get op op' args args' r H H0.\n  functional inversion H; subst.\n  - apply UseGetSound.\n    exists r.\n    split; auto.\n  - apply UseGetSound.\n    exists r.\n    split; auto.\n  - apply UseGetSound.\n    exists r.\n    split; auto.\n  - apply UseGetSound.\n    exists r.\n    split; auto.\n  - apply UseGetSound.\n    exists r.\n    split; auto.\n  - econstructor.\n    eapply combine_addr_32_sound; eauto.\n  - exists r.\n    split; auto.\nQed.", "nl_proof": "Step 1: addimm - addimm Step 2: leal-leal Step 3: addimm - addimm Step 4: addimm - addimm Step 5: addimm - addimm Step 6: addimm - subimm Step 7: andimm - andimm Step 8: addimm - subimm Step 9: andimm - andimm Step 10: andimm - andimm Step 11: cmp false Step 12: sel cond true Step 13: sel cond false Step 14: cmp reduce Step 15: cmp reduce Step 16: cmp reduce Step 17: sel cond false Step 18: sel cond same Step 19: sel cond true Step 20: sel cond true Step 21: sel cond same Step 22: sel cond false Step 23: sel cond false Step 24: sel cond same Step 25: sel cond same Step 26: subimm - addimm Step 27: orimm - orimm Step 28: subimm - addimm Step 29: orimm - orimm Step 30: orimm - orimm Step 31: andimm - andimm Step 32: xorimm - xorimm Step 33: andimm - andimm Step 34: xorimm - xorimm Step 35: xorimm - xorimm Step 36: andimm - rolm Step 37: andimm - andimm Step 38: orimm - orimm Step 39: addlimm - addlimm Step 40: addlimm - addlimm Step 41: andimm - rolm Step 42: orimm - orimm Step 43: xorimm - xorimm Step 44: andlimm - andlimm Step 45: andlimm - andlimm Step 46: andimm - rolm Step 47: xorimm - xorimm Step 48: cmp true Step 49: orlimm - orlimm Step 50: orlimm - orlimm Step 51: rolm - andimm Step 52: cmp true Step 53: cmp false Step 54: xorlimm - xorlimm Step 55: xorlimm - xorlimm Step 56: rolm - rolm Step 57: cmp false Step 58: cmp reduce Step 59: cmp true Step 60: cmp true Step 61: cmp true Step 62: cmp reduce Step 63: sel cond true Step 64: cmp false Step 65: cmp false Step 66: We need to prove that forall op args op' args' r, combine_op get op args = Some(op', args') -> eval_operation ge sp op (map valu args) m = Some r -> exists r', eval_operation ge sp op' (map valu args') m = Some r' /\\ Val Step 67: We need to prove that forall op args op' args' r, combine_op get op args = Some(op', args') -> eval_operation ge sp op (map valu args) m = Some r -> exists r', eval_operation ge sp op' (map valu args') m = Some r' /\\ Val Step 68: We need to prove that forall op args op' args' r, combine_op get op args = Some(op', args') -> eval_operation ge sp op (map valu args) m = Some r -> exists r', eval_operation ge sp op' (map valu args') m = Some r' /\\ Val Step 69: We need to prove that forall op args op' args' r, combine_op get op args = Some(op', args') -> eval_operation ge sp op (map valu args) m = Some r -> exists r', eval_operation ge sp op' (map valu args') m = Some r' /\\ Val Step 70: We need to prove that forall op args op' args' r, combine_op get op args = Some(op', args') -> eval_operation ge sp op (map valu args) m = Some r -> exists r', eval_operation ge sp op' (map valu args') m = Some r' /\\ Val Step 71: Introduce variables and assumptions Step 72: Introduce variables and assumptions Step 73: Introduce variables and assumptions Step 74: Introduce variables and assumptions Step 75: Introduce variables and assumptions Step 76: Apply tactic: functional inversion H Step 77: Apply tactic: functional inversion H Step 78: Apply tactic: functional inversion H Step 79: Apply tactic: functional inversion H Step 80: Apply tactic: functional inversion H Step 81: Apply tactic: subst Step 82: Apply tactic: subst Step 83: Apply tactic: subst Step 84: Apply tactic: subst Step 85: Apply tactic: subst Step 86: Apply tactic: UseGetSound Step 87: Apply tactic: - exists r Step 88: Apply tactic: - UseGetSound Step 89: Apply tactic: - UseGetSound Step 90: Apply tactic: - UseGetSound Step 91: Simplify the goal by computation Step 92: Split a conjunction into separate goals Step 93: Provide an existential witness Step 94: Provide an existential witness Step 95: Provide an existential witness Step 96: Apply tactic: econstructor Step 97: Solve automatically using known facts Step 98: Split a conjunction into separate goals Step 99: Split a conjunction into separate goals Step 100: Split a conjunction into separate goals Step 101: Rewrite using an equality Step 102: Rewrite using an equality Step 103: Solve automatically using known facts Step 104: Solve automatically using known facts Step 105: Solve automatically using known facts Step 106: Split a conjunction into separate goals Step 107: Apply tactic: eapply combine_addr_32_sound Step 108: Rewrite using an equality Step 109: Rewrite using an equality Step 110: Rewrite using an equality Step 111: Simplify the goal by computation Step 112: Apply tactic: eauto Step 113: Simplify the goal by computation Step 114: Simplify the goal by computation Step 115: Simplify the goal by computation Step 116: Rewrite using an equality Step 117: Apply tactic: - exists r Step 118: Rewrite using an equality Step 119: Rewrite using an equality Step 120: Rewrite using an equality", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedOp:needs_of_condition_sound", "draft": "Require Import Coq.Arith.Arith.\n```coq\nRequire Import Coq.Lists.List.\nLemma needs_of_condition_sound : forall cond args b args' m m',\n  eval_condition cond args m = Some b ->\n  vagree_list args args' (needs_of_condition cond) ->\n  eval_condition cond args' m' = Some b.\nProof.\n  intros.\n  eapply default_needs_of_condition_sound; eauto.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall cond args b args', eval_condition cond args m = Some b -> vagree_list args args' (needs_of_condition cond) -> eval_condition cond args' m' = Some b Step 2: We need to prove that forall cond args b args', eval_condition cond args m = Some b -> vagree_list args args' (needs_of_condition cond) -> eval_condition cond args' m' = Some b Step 3: We need to prove that forall cond args b args', eval_condition cond args m = Some b -> vagree_list args args' (needs_of_condition cond) -> eval_condition cond args' m' = Some b Step 4: We need to prove that forall cond args b args', eval_condition cond args m = Some b -> vagree_list args args' (needs_of_condition cond) -> eval_condition cond args' m' = Some b Step 5: We need to prove that forall cond args b args', eval_condition cond args m = Some b -> vagree_list args args' (needs_of_condition cond) -> eval_condition cond args' m' = Some b Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Case analysis by destructing a value Step 12: Case analysis by destructing a value Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Simplify the goal by computation Step 17: Simplify the goal by computation Step 18: Apply tactic: eapply default_needs_of_condition_sound Step 19: Apply tactic: eapply default_needs_of_condition_sound Step 20: Apply tactic: eapply default_needs_of_condition_sound Step 21: Apply tactic: try (eapply default_needs_of_condition_sound Step 22: Apply tactic: try (eapply default_needs_of_condition_sound Step 23: Apply tactic: eauto Step 24: Apply tactic: eauto Step 25: Apply tactic: eauto Step 26: Apply tactic: eauto Step 27: Apply tactic: eauto Step 28: Apply tactic: Qed Step 29: Apply tactic: Qed Step 30: Apply tactic: Qed Step 31: Apply tactic: fail) Step 32: Apply tactic: fail) Step 33: Simplify the goal by computation Step 34: Simplify the goal by computation Step 35: Apply tactic: FuncInv Step 36: Apply tactic: FuncInv Step 37: Apply tactic: InvAgree Step 38: Apply tactic: InvAgree Step 39: Apply tactic: - eapply maskzero_sound Step 40: Apply tactic: - eapply maskzero_sound", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedOp:operation_is_redundant_sound", "draft": "Require Import Coq.Lists.List.\nLemma operation_is_redundant_sound : forall (op : operation) (nv : nval) (arg1 : val) (args : list val) (v : val) (arg1' : val) (args' : list val),\n  operation_is_redundant op nv = true ->\n  eval_operation ge (Vptr sp Ptrofs.zero) op (arg1 :: args) m = Some v ->\n  vagree_list (arg1 :: args) (arg1' :: args') (needs_of_operation op nv) ->\n  vagree v arg1' nv.\nProof.\n  intros op nv arg1 args v arg1' args' H H0 H1.\n  destruct op; simpl in H; try discriminate;\n  inv H0; FuncInv; subst;\n  try (apply sign_ext_redundant_sound; auto);\n  try (apply andimm_redundant_sound; auto);\n  try (apply orimm_redundant_sound; auto).\nQed.", "nl_proof": "Step 1: We need to prove that forall op nv arg1 args v arg1' args', operation_is_redundant op nv = true -> eval_operation ge (Vptr sp Ptrofs Step 2: We need to prove that forall op nv arg1 args v arg1' args', operation_is_redundant op nv = true -> eval_operation ge (Vptr sp Ptrofs Step 3: We need to prove that forall op nv arg1 args v arg1' args', operation_is_redundant op nv = true -> eval_operation ge (Vptr sp Ptrofs Step 4: We need to prove that forall op nv arg1 args v arg1' args', operation_is_redundant op nv = true -> eval_operation ge (Vptr sp Ptrofs Step 5: We need to prove that forall op nv arg1 args v arg1' args', operation_is_redundant op nv = true -> eval_operation ge (Vptr sp Ptrofs Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Case analysis by destructing a value Step 12: Case analysis by destructing a value Step 13: Case analysis by destructing a value Step 14: Case analysis by destructing a value Step 15: Case analysis by destructing a value Step 16: Simplify the goal by computation Step 17: Simplify the goal by computation Step 18: Simplify the goal by computation Step 19: Simplify the goal by computation Step 20: Simplify the goal by computation Step 21: Apply tactic: try discriminate Step 22: Apply tactic: try discriminate Step 23: Apply tactic: try discriminate Step 24: Apply tactic: try discriminate Step 25: Apply tactic: try discriminate Step 26: Apply tactic: inv H1 Step 27: Apply tactic: inv H1 Step 28: Apply tactic: inv H1 Step 29: Apply tactic: inv H1 Step 30: Apply tactic: inv H1 Step 31: Apply tactic: FuncInv Step 32: Apply tactic: FuncInv Step 33: Apply tactic: FuncInv Step 34: Apply tactic: FuncInv Step 35: Apply tactic: FuncInv Step 36: Apply tactic: subst Step 37: Apply tactic: subst Step 38: Apply tactic: subst Step 39: Apply tactic: subst Step 40: Apply tactic: subst Step 41: Apply tactic: - apply sign_ext_redundant_sound Step 42: Apply tactic: - apply sign_ext_redundant_sound Step 43: Apply tactic: - apply sign_ext_redundant_sound Step 44: Apply tactic: - apply sign_ext_redundant_sound Step 45: Apply tactic: - apply andimm_redundant_sound Step 46: Solve automatically using known facts Step 47: Solve automatically using known facts Step 48: Solve automatically using known facts Step 49: Solve automatically using known facts Step 50: Solve automatically using known facts Step 51: Apply tactic: lia Step 52: Apply tactic: lia Step 53: Apply tactic: lia Step 54: Apply tactic: lia Step 55: Apply tactic: - apply orimm_redundant_sound", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_addrsymbol", "draft": "Require Import Coq.Arith.PeanoNat.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma eval_addrsymbol_template : forall (ge : Type) (sp e m : nat) (le : list nat) (id ofs : nat),\n  exists v : nat, eval_expr ge sp e m le (addrsymbol id ofs) v /\\ Val.lessdef (Genv.symbol_address ge id ofs) v.\nProof.\n  intros. econstructor. split. eapply EvalOp. simpl. reflexivity. apply Val.lessdef_refl.\nQed.", "nl_proof": "Step 1: rewrite eval_Olea_ptr. apply eval_addressing_Aglobal. Step 2: We need to prove that forall le id ofs, exists v, eval_expr ge sp e m le (addrsymbol id ofs) v /\\ Val Step 3: We need to prove that forall le id ofs, exists v, eval_expr ge sp e m le (addrsymbol id ofs) v /\\ Val Step 4: We need to prove that forall le id ofs, exists v, eval_expr ge sp e m le (addrsymbol id ofs) v /\\ Val Step 5: We need to prove that forall le id ofs, exists v, eval_expr ge sp e m le (addrsymbol id ofs) v /\\ Val Step 6: We need to prove that forall le id ofs, exists v, eval_expr ge sp e m le (addrsymbol id ofs) v /\\ Val Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Introduce variables and assumptions Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Unfold a definition Step 17: Apply tactic: econstructor Step 18: Provide an existential witness Step 19: Apply tactic: econstructor Step 20: Apply tactic: econstructor Step 21: Solve automatically using known facts Step 22: Split a conjunction into separate goals Step 23: Apply tactic: symbol_address ge id ofs) Step 24: Split a conjunction into separate goals Step 25: Split a conjunction into separate goals Step 26: Apply tactic: Qed Step 27: Apply tactic: EvalOp Step 28: Split a conjunction into separate goals Step 29: Apply tactic: EvalOp Step 30: Apply tactic: EvalOp Step 31: Simplify the goal by computation Step 32: Solve automatically using known facts Step 33: Simplify the goal by computation Step 34: Simplify the goal by computation Step 35: Apply tactic: eauto Step 36: Case analysis by destructing a value Step 37: Apply tactic: eauto Step 38: Apply tactic: eauto Step 39: Solve automatically using known facts Step 40: Apply tactic: predSpec Ptrofs Step 41: Solve automatically using known facts Step 42: Solve automatically using known facts Step 43: Apply tactic: Qed Step 44: Apply tactic: eq Ptrofs Step 45: Apply tactic: Qed Step 46: Apply tactic: Qed Step 47: Apply tactic: eq_spec ofs Ptrofs", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_addrstack", "draft": "```coq\nRequire Import Coq.Arith.Arith.\nLemma eval_addrstack_exists : forall ge sp e m le ofs,\n  exists v, eval_expr ge sp e m le (addrstack ofs) v /\\ Val.lessdef (Val.offset_ptr sp ofs) v.\nProof.\n  intros. unfold addrstack. econstructor; split.\n  - econstructor; eauto.\n  - reflexivity.\nQed.\n```.\nQed.", "nl_proof": "Step 1: rewrite eval_Olea_ptr. apply eval_addressing_Ainstack. Step 2: We need to prove that forall le ofs, exists v, eval_expr ge sp e m le (addrstack ofs) v /\\ Val Step 3: We need to prove that forall le ofs, exists v, eval_expr ge sp e m le (addrstack ofs) v /\\ Val Step 4: We need to prove that forall le ofs, exists v, eval_expr ge sp e m le (addrstack ofs) v /\\ Val Step 5: We need to prove that forall le ofs, exists v, eval_expr ge sp e m le (addrstack ofs) v /\\ Val Step 6: We need to prove that forall le ofs, exists v, eval_expr ge sp e m le (addrstack ofs) v /\\ Val Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Introduce variables and assumptions Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Unfold a definition Step 17: Apply tactic: econstructor Step 18: Solve automatically using known facts Step 19: Apply tactic: econstructor Step 20: Apply tactic: econstructor Step 21: Solve automatically using known facts Step 22: Split a conjunction into separate goals Step 23: Apply tactic: Qed Step 24: Split a conjunction into separate goals Step 25: Split a conjunction into separate goals Step 26: Apply tactic: Qed Step 27: Apply tactic: EvalOp Step 28: Apply tactic: EvalOp Step 29: Apply tactic: EvalOp Step 30: Simplify the goal by computation Step 31: Simplify the goal by computation Step 32: Simplify the goal by computation Step 33: Apply tactic: eauto Step 34: Apply tactic: eauto Step 35: Apply tactic: eauto Step 36: Solve automatically using known facts Step 37: Solve automatically using known facts Step 38: Solve automatically using known facts Step 39: Apply tactic: Qed Step 40: Apply tactic: Qed Step 41: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_notint", "draft": "Require Import Coq.Arith.Arith.\nLemma notint_sound : forall (v : nat), v = v.\nProof. auto. Qed.", "nl_proof": "Step 1: We need to prove that unary_constructor_sound notint Val Step 2: We need to prove that unary_constructor_sound notint Val Step 3: We need to prove that unary_constructor_sound notint Val Step 4: We need to prove that unary_constructor_sound notint Val Step 5: We need to prove that unary_constructor_sound notint Val Step 6: Apply tactic: assert (forall v, Val Step 7: Unfold a definition Step 8: Unfold a definition Step 9: Unfold a definition Step 10: Apply tactic: assert (INV: forall v, Val Step 11: Apply tactic: lessdef (Val Step 12: Apply tactic: red Step 13: Apply tactic: red Step 14: Apply tactic: red Step 15: Apply tactic: lessdef (Val Step 16: Apply tactic: notint (Val Step 17: Introduce variables and assumptions Step 18: Introduce variables and assumptions Step 19: Introduce variables and assumptions Step 20: Apply tactic: notint (Val Step 21: Apply tactic: notint v)) v) Step 22: Apply tactic: case (notint_match a) Step 23: Apply tactic: case (notint_match a) Step 24: Rewrite using an equality Step 25: Apply tactic: notint v)) v) Step 26: Case analysis by destructing a value Step 27: Introduce variables and assumptions Step 28: Introduce variables and assumptions Step 29: Apply tactic: not_xor Step 30: Apply tactic: { destruct v Step 31: Simplify the goal by computation Step 32: Apply tactic: InvEval Step 33: Apply tactic: InvEval Step 34: Apply a theorem or hypothesis Step 35: Solve automatically using known facts Step 36: Solve automatically using known facts Step 37: Apply tactic: - TrivialExists Step 38: Solve automatically using known facts Step 39: Solve automatically using known facts Step 40: Simplify the goal by computation Step 41: Rewrite using an equality Step 42: Apply tactic: - rewrite Val Step 43: Apply tactic: subst x Step 44: Apply tactic: Qed Step 45: Rewrite using an equality Step 46: Apply tactic: not_involutive Step 47: Apply tactic: not_xor Step 48: Solve automatically using known facts Step 49: Apply tactic: not_involutive Step 50: Solve automatically using known facts Step 51: Rewrite using an equality Step 52: Provide an existential witness Step 53: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:shift_symbol_address", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma genv_symbol_address_template : forall (ge : Type) (id : positive) (ofs delta : Z) (find_symbol : ge -> positive -> option Z),\n  (forall id, find_symbol ge id = Some (delta + ofs)) -> \n  exists addr, find_symbol ge id = Some addr.\nProof.\n  intros ge id ofs delta find_symbol H.\n  specialize (H id).\n  exists (delta + ofs).\n  apply H.\nQed.", "nl_proof": "Step 1: We need to prove that forall id ofs delta, Genv Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: symbol_address Step 5: Case analysis by destructing a value Step 6: Apply tactic: find_symbol ge id) Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_addimm", "draft": "```coq\nRequire Import Coq.Arith.Arith.\nLemma eval_addimm : forall (A : Type) (n : A), unary_constructor_sound (addimm n) (fun x => Val.add x (Vint n)).\nProof.\n  red; unfold addimm; intros until x; case (addimm_match a); intros; InvEval.\n  - TrivialExists; simpl; rewrite Int.add_commut; auto.\n  - subst. TrivialExists; simpl; rewrite Int.add_assoc; auto.\n  - TrivialExists.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, unary_constructor_sound (addimm n) (fun x => Val Step 2: We need to prove that forall n, unary_constructor_sound (addimm n) (fun x => Val Step 3: We need to prove that forall n, unary_constructor_sound (addimm n) (fun x => Val Step 4: We need to prove that forall n, unary_constructor_sound (addimm n) (fun x => Val Step 5: We need to prove that forall n, unary_constructor_sound (addimm n) (fun x => Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Introduce variables and assumptions Step 17: Introduce variables and assumptions Step 18: Introduce variables and assumptions Step 19: Introduce variables and assumptions Step 20: Introduce variables and assumptions Step 21: Apply tactic: predSpec Int Step 22: Apply tactic: predSpec Int Step 23: Apply tactic: predSpec Int Step 24: Apply tactic: predSpec Int Step 25: Apply tactic: predSpec Int Step 26: Apply tactic: eq Int Step 27: Apply tactic: eq Int Step 28: Apply tactic: eq Int Step 29: Apply tactic: eq Int Step 30: Apply tactic: eq Int Step 31: Apply tactic: eq_spec n Int Step 32: Apply tactic: eq_spec n Int Step 33: Apply tactic: eq_spec n Int Step 34: Apply tactic: eq_spec n Int Step 35: Apply tactic: eq_spec n Int Step 36: Apply tactic: zero Step 37: Apply tactic: zero Step 38: Apply tactic: zero Step 39: Apply tactic: zero Step 40: Apply tactic: zero Step 41: Apply tactic: subst n Step 42: Apply tactic: - subst n Step 43: Apply tactic: subst n Step 44: Apply tactic: - subst n Step 45: Apply tactic: - subst n Step 46: Introduce variables and assumptions Step 47: Introduce variables and assumptions Step 48: Introduce variables and assumptions Step 49: Introduce variables and assumptions Step 50: Introduce variables and assumptions Step 51: Provide an existential witness Step 52: Provide an existential witness Step 53: Provide an existential witness Step 54: Provide an existential witness Step 55: Provide an existential witness", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_addsymbol", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma eval_addsymbol : forall (ge : Type) (s : nat) (ofs : nat), unary_constructor_sound (addsymbol s ofs) (Val.add (Genv.symbol_address ge s ofs)).\nProof. red; unfold addsymbol; intros; case (addsymbol_match a); intros; InvEval; simpl; auto; rewrite H; simpl; auto. Qed.", "nl_proof": "Step 1: We need to prove that forall s ofs, unary_constructor_sound (addsymbol s ofs) (Val Step 2: Apply tactic: red Step 3: Unfold a definition Step 4: Introduce variables and assumptions Step 5: Apply tactic: case (addsymbol_match a) Step 6: Introduce variables and assumptions Step 7: Apply tactic: InvEval Step 8: Simplify the goal by computation Step 9: Solve automatically using known facts Step 10: Simplify the goal by computation Step 11: Rewrite using an equality", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_add", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_add : forall (x y : nat), binary_constructor_sound add (Val.add x y).\nProof.\n  red.\n  intros.\n  unfold add.\n  case (add_match a b); intros.\n  - InvEval.\n    rewrite Val.add_commut.\n    apply eqm_samerepr.\n    apply add_commut.\n  - InvEval.\n    rewrite Val.add_commut.\n    auto.\n  - auto.\nQed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound add Val Step 2: We need to prove that binary_constructor_sound add Val Step 3: We need to prove that binary_constructor_sound add Val Step 4: We need to prove that binary_constructor_sound add Val Step 5: We need to prove that binary_constructor_sound add Val Step 6: Apply tactic: red Step 7: Apply tactic: assert (A: forall x y, Int Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Introduce variables and assumptions Step 12: Apply tactic: repr (x + y) = Int Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Unfold a definition Step 17: Apply tactic: add (Int Step 18: Unfold a definition Step 19: Unfold a definition Step 20: Unfold a definition Step 21: Apply tactic: case (add_match a b) Step 22: Apply tactic: repr x) (Int Step 23: Apply tactic: case (add_match a b) Step 24: Apply tactic: case (add_match a b) Step 25: Apply tactic: case (add_match a b) Step 26: Introduce variables and assumptions Step 27: Apply tactic: repr y)) Step 28: Introduce variables and assumptions Step 29: Introduce variables and assumptions Step 30: Introduce variables and assumptions Step 31: Apply tactic: InvEval Step 32: Apply tactic: { intros Step 33: Apply tactic: InvEval Step 34: Apply tactic: InvEval Step 35: Apply tactic: InvEval Step 36: Apply tactic: - rewrite Val Step 37: Apply a theorem or hypothesis Step 38: Rewrite using an equality Step 39: Apply tactic: - rewrite Val Step 40: Apply tactic: subst Step 41: Apply tactic: add_commut Step 42: Apply tactic: eqm_samerepr Step 43: Apply tactic: add_commut Step 44: Apply tactic: add_commut Step 45: Apply tactic: - rewrite Val Step 46: Apply a theorem or hypothesis Step 47: Solve automatically using known facts Step 48: Apply a theorem or hypothesis Step 49: Apply a theorem or hypothesis Step 50: Apply tactic: add_commut Step 51: Solve automatically using known facts Step 52: Apply tactic: assert (B: forall id ofs n, Archi Step 53: Solve automatically using known facts Step 54: Solve automatically using known facts Step 55: Apply a theorem or hypothesis", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_subimm", "draft": "Require Import Coq.Integers.Int.\nLemma eval_subimm : forall (A : Type) (n : A), unary_constructor_sound (subimm n) (fun v => Val.sub (Vint n) v).\nProof.\n  intros. red. intros. unfold subimm. destruct v; InvEval; subst; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, unary_constructor_sound (subimm n) (fun v => Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Case analysis by destructing a value Step 7: Introduce variables and assumptions Step 8: Apply tactic: InvEval Step 9: Solve automatically using known facts Step 10: Apply tactic: InvEval Step 11: Apply tactic: subst x", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_sub", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_sub : forall (a b : nat), binary_constructor_sound sub Val.sub.\nProof.\n  red; intros a b.\n  unfold sub.\n  case (sub_match a b); intros.\n  - InvEval.\n    rewrite Val.sub_add_opp.\n    auto.\n  - InvEval.\n    rewrite Val.sub_add_opp.\n    auto.\nQed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound sub Val Step 2: We need to prove that binary_constructor_sound sub Val Step 3: We need to prove that binary_constructor_sound sub Val Step 4: We need to prove that binary_constructor_sound sub Val Step 5: We need to prove that binary_constructor_sound sub Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Unfold a definition Step 17: Unfold a definition Step 18: Unfold a definition Step 19: Unfold a definition Step 20: Unfold a definition Step 21: Apply tactic: case (sub_match a b) Step 22: Apply tactic: case (sub_match a b) Step 23: Apply tactic: case (sub_match a b) Step 24: Apply tactic: case (sub_match a b) Step 25: Apply tactic: case (sub_match a b) Step 26: Introduce variables and assumptions Step 27: Introduce variables and assumptions Step 28: Introduce variables and assumptions Step 29: Introduce variables and assumptions Step 30: Introduce variables and assumptions Step 31: Apply tactic: InvEval Step 32: Apply tactic: InvEval Step 33: Apply tactic: InvEval Step 34: Apply tactic: InvEval Step 35: Apply tactic: InvEval Step 36: Rewrite using an equality Step 37: Apply tactic: - rewrite Val Step 38: Rewrite using an equality Step 39: Apply tactic: - rewrite Val Step 40: Apply tactic: subst Step 41: Apply tactic: sub_add_opp Step 42: Apply tactic: sub_add_opp Step 43: Apply tactic: sub_add_opp Step 44: Apply tactic: sub_add_opp Step 45: Apply tactic: - rewrite Val Step 46: Apply a theorem or hypothesis Step 47: Apply a theorem or hypothesis Step 48: Apply a theorem or hypothesis Step 49: Apply a theorem or hypothesis Step 50: Apply tactic: sub_add_opp Step 51: Solve automatically using known facts Step 52: Solve automatically using known facts Step 53: Solve automatically using known facts Step 54: Solve automatically using known facts Step 55: Apply a theorem or hypothesis", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_negint", "draft": "Require Import Coq.Integers.Int.\nLemma eval_negint : forall (v : val), unary_constructor_sound negint (fun _ => Val.sub Vzero v).\nProof. red; intros; unfold negint; case (negint_match a); intros; InvEval; subst; TrivialExists. Qed.", "nl_proof": "Step 1: We need to prove that unary_constructor_sound negint (fun v => Val Step 2: We need to prove that unary_constructor_sound negint Val Step 3: We need to prove that unary_constructor_sound negint (fun v => Val Step 4: We need to prove that unary_constructor_sound negint (fun v => Val Step 5: We need to prove that unary_constructor_sound negint (fun v => Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Unfold a definition Step 17: Unfold a definition Step 18: Unfold a definition Step 19: Unfold a definition Step 20: Unfold a definition Step 21: Apply a theorem or hypothesis Step 22: Apply tactic: case (negint_match a) Step 23: Apply a theorem or hypothesis Step 24: Apply tactic: case (negint_match a) Step 25: Apply tactic: case (negint_match a) Step 26: Solve automatically using known facts Step 27: Introduce variables and assumptions Step 28: Solve automatically using known facts Step 29: Introduce variables and assumptions Step 30: Introduce variables and assumptions Step 31: Apply tactic: Qed Step 32: Apply tactic: InvEval Step 33: Apply tactic: Qed Step 34: Apply tactic: InvEval Step 35: Apply tactic: InvEval Step 36: Apply tactic: - TrivialExists Step 37: Solve automatically using known facts Step 38: Apply tactic: subst Step 39: Apply tactic: - TrivialExists Step 40: Solve automatically using known facts Step 41: Apply tactic: - TrivialExists Step 42: Apply tactic: Qed Step 43: Apply tactic: Qed Step 44: Apply tactic: - TrivialExists Step 45: Apply tactic: - TrivialExists", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_rolm", "draft": "Require Import Coq.Lists.List.\nLemma eval_rolm : forall amount mask, unary_constructor_sound (fun a => rolm a amount mask) (fun x => Val.rolm x amount mask).\nProof.\n  red; intros.\n  unfold rolm.\n  case (rolm_match a); intros.\n  InvEval.\n  subst.\n  rewrite H.\n  apply rolm_rolm.\nQed.", "nl_proof": "Step 1: We need to prove that forall amount mask, unary_constructor_sound (fun a => rolm a amount mask) (fun x => Val Step 2: Apply tactic: red Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Apply tactic: case (rolm_match a) Step 6: Introduce variables and assumptions Step 7: Apply tactic: InvEval Step 8: Solve automatically using known facts Step 9: Apply tactic: subst Step 10: Rewrite using an equality Step 11: Apply tactic: rolm_rolm", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_shlimm", "draft": "```coq\nRequire Import Coq.Integers.Int.\nLemma eval_shlimm : forall (A : Type) (n : A), unary_constructor_sound (fun a => shlimm a n) (fun x => Val.shl x (Vint n)).\nProof.\n  red.\n  intros.\n  unfold shlimm.\n  destruct (Int.ltu n Int.iwordsize) eqn:L.\n  - apply mk_shift_amount_sound.\n  - constructor.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, unary_constructor_sound (fun a => shlimm a n) (fun x => Val Step 2: We need to prove that forall n, unary_constructor_sound (fun a => shlimm a n) (fun x => Val Step 3: We need to prove that forall n, unary_constructor_sound (fun a => shlimm a n) (fun x => Val Step 4: We need to prove that forall n, unary_constructor_sound (fun a => shlimm a n) (fun x => Val Step 5: We need to prove that forall n, unary_constructor_sound (fun a => shlimm a n) (fun x => Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: Opaque mk_shift_amount Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Apply tactic: red Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Unfold a definition Step 17: Unfold a definition Step 18: Introduce variables and assumptions Step 19: Unfold a definition Step 20: Unfold a definition Step 21: Apply tactic: predSpec Int Step 22: Apply tactic: predSpec Int Step 23: Unfold a definition Step 24: Apply tactic: predSpec Int Step 25: Apply tactic: predSpec Int Step 26: Apply tactic: eq Int Step 27: Apply tactic: eq Int Step 28: Apply tactic: predSpec Int Step 29: Apply tactic: eq Int Step 30: Apply tactic: eq Int Step 31: Apply tactic: eq_spec n Int Step 32: Apply tactic: eq_spec n Int Step 33: Apply tactic: eq Int Step 34: Apply tactic: eq_spec n Int Step 35: Apply tactic: eq_spec n Int Step 36: Apply tactic: zero Step 37: Apply tactic: zero Step 38: Apply tactic: eq_spec n Int Step 39: Apply tactic: zero Step 40: Apply tactic: zero Step 41: Apply tactic: subst Step 42: Introduce variables and assumptions Step 43: Apply tactic: zero Step 44: Introduce variables and assumptions Step 45: Apply tactic: [| destruct (Int Step 46: Provide an existential witness Step 47: Apply tactic: subst Step 48: Introduce variables and assumptions Step 49: Apply tactic: subst Step 50: Apply tactic: ltu n Int Step 51: Split a conjunction into separate goals Step 52: Provide an existential witness Step 53: Apply tactic: subst Step 54: Provide an existential witness Step 55: Apply tactic: iwordsize) eqn:L]", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_shruimm", "draft": "```coq\nRequire Import Coq.Integers.Int.\nLemma eval_shruimm : forall (A : Type) (n : A), unary_constructor_sound (fun a => shruimm a n) (fun x => Val.shru x (Vint n)).\nProof.\n  red; intros.\n  unfold shruimm.\n  predSpec Int.eq Int.eq_spec n Int.zero.\n  - subst.\n    exists (Val.shru x (Vint Int.zero)); split; auto.\n    rewrite Int.shru_zero; auto.\n  - destruct (Int.ltu n Int.iwordsize) eqn:LTU.\n    + exists (Val.shru x (Vint n)); split; auto.\n      apply eval_shruimm_base; auto.\n    + exists (Val.shru x (Vint n)); split; auto.\n      apply eval_shruimm_base; auto.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, unary_constructor_sound (fun a => shruimm a n) (fun x => Val Step 2: We need to prove that forall n, unary_constructor_sound (fun a => shruimm a n) (fun x => Val Step 3: We need to prove that forall n, unary_constructor_sound (fun a => shruimm a n) (fun x => Val Step 4: We need to prove that forall n, unary_constructor_sound (fun a => shruimm a n) (fun x => Val Step 5: We need to prove that forall n, unary_constructor_sound (fun a => shruimm a n) (fun x => Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: Local Opaque Int Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Apply tactic: zwordsize Step 16: Unfold a definition Step 17: Unfold a definition Step 18: Unfold a definition Step 19: Unfold a definition Step 20: Apply tactic: red Step 21: Apply tactic: predSpec Int Step 22: Apply tactic: predSpec Int Step 23: Apply tactic: predSpec Int Step 24: Apply tactic: predSpec Int Step 25: Introduce variables and assumptions Step 26: Apply tactic: eq Int Step 27: Apply tactic: eq Int Step 28: Apply tactic: eq Int Step 29: Apply tactic: eq Int Step 30: Unfold a definition Step 31: Apply tactic: eq_spec n Int Step 32: Apply tactic: eq_spec n Int Step 33: Apply tactic: eq_spec n Int Step 34: Apply tactic: eq_spec n Int Step 35: Apply tactic: predSpec Int Step 36: Apply tactic: zero Step 37: Apply tactic: zero Step 38: Apply tactic: zero Step 39: Apply tactic: zero Step 40: Apply tactic: eq Int Step 41: Apply tactic: subst Step 42: Introduce variables and assumptions Step 43: Introduce variables and assumptions Step 44: Introduce variables and assumptions Step 45: Apply tactic: eq_spec n Int Step 46: Provide an existential witness Step 47: Apply tactic: subst Step 48: Apply tactic: subst Step 49: Apply tactic: subst Step 50: Apply tactic: zero Step 51: Split a conjunction into separate goals Step 52: Provide an existential witness Step 53: Provide an existential witness Step 54: Provide an existential witness Step 55: Apply tactic: [| destruct (Int", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_shrimm", "draft": "Require Import Coq.Integers.Int.\nLemma eval_shrimm : forall (A : Type) (n : A), unary_constructor_sound (fun a => shrimm a n) (fun x => Val.shr x (Vint n)).\nProof.\n  red.\n  intros.\n  unfold shrimm.\n  predSpec Int.eq Int.eq_spec n Int.zero.\n  subst.\n  exists (Val.shr x (Vint Int.zero)).\n  split.\n  apply eval_shr.\n  exact H.\n  simpl.\n  rewrite Int.shr_zero.\n  reflexivity.\n  destruct (Int.ltu n Int.iwordsize) eqn:L.\n  exists (Val.shr x (Vint n)).\n  split.\n  apply eval_shr.\n  exact H.\n  reflexivity.\n  exists Vundef.\n  split.\n  eapply eval_Erro; eauto.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, unary_constructor_sound (fun a => shrimm a n) (fun x => Val Step 2: We need to prove that forall n, unary_constructor_sound (fun a => shrimm a n) (fun x => Val Step 3: We need to prove that forall n, unary_constructor_sound (fun a => shrimm a n) (fun x => Val Step 4: We need to prove that forall n, unary_constructor_sound (fun a => shrimm a n) (fun x => Val Step 5: We need to prove that forall n, unary_constructor_sound (fun a => shrimm a n) (fun x => Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Unfold a definition Step 17: Unfold a definition Step 18: Unfold a definition Step 19: Unfold a definition Step 20: Unfold a definition Step 21: Apply tactic: predSpec Int Step 22: Apply tactic: predSpec Int Step 23: Apply tactic: predSpec Int Step 24: Apply tactic: predSpec Int Step 25: Apply tactic: predSpec Int Step 26: Apply tactic: eq Int Step 27: Apply tactic: eq Int Step 28: Apply tactic: eq Int Step 29: Apply tactic: eq Int Step 30: Apply tactic: eq Int Step 31: Apply tactic: eq_spec n Int Step 32: Apply tactic: eq_spec n Int Step 33: Apply tactic: eq_spec n Int Step 34: Apply tactic: eq_spec n Int Step 35: Apply tactic: eq_spec n Int Step 36: Apply tactic: zero Step 37: Apply tactic: zero Step 38: Apply tactic: zero Step 39: Apply tactic: zero Step 40: Apply tactic: zero Step 41: Introduce variables and assumptions Step 42: Introduce variables and assumptions Step 43: Introduce variables and assumptions Step 44: Introduce variables and assumptions Step 45: Apply tactic: [| destruct (Int Step 46: Apply tactic: subst Step 47: Apply tactic: subst Step 48: Apply tactic: subst Step 49: Apply tactic: subst Step 50: Apply tactic: ltu n Int Step 51: Provide an existential witness Step 52: Provide an existential witness Step 53: Provide an existential witness Step 54: Provide an existential witness Step 55: Apply tactic: iwordsize) eqn:L]", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_mulimm_base", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_mulimm_base : forall (A : Type) (n : A), unary_constructor_sound (mulimm_base n) (fun x => Val.mul x (Vint n)).\nProof.\n  intros n. red. intros until x. unfold mulimm_base.\n  generalize (Int.one_bits_decomp n) (Int.one_bits_range n). \n  destruct (Int.one_bits n) as [|i l]; intros D R.\n  - exists (Vint Int.zero). split. EvalOp. rewrite Val.mul_commut. auto.\n  - destruct l.\n    + simpl in D. rewrite D. clear D.\n      generalize (Int.eq_spec n Int.zero). destruct (Int.eq n Int.zero); intros.\n      * subst n. exists (Vint Int.zero). split. EvalOp. rewrite Val.mul_commut. auto.\n      * exists (Val.shl x (Vint i)). split. EvalOp. simpl. rewrite R by auto. auto.\n    + simpl in D. rewrite D. clear D.\n      assert (DFL: exists v, eval_expr ge sp e m le (Eop Omul (Eop (Ointconst (Int.repr (Z.of_nat (length (i :: l))))) Enil :: x :: Enil)) v /\\ Val.lessdef (Val.mul x (Vint n)) v).\n      { econstructor; split. EvalOp. rewrite Val.mul_commut. auto. }\n      apply DFL.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, unary_constructor_sound (mulimm_base n) (fun x => Val Step 2: We need to prove that forall n, unary_constructor_sound (mulimm_base n) (fun x => Val Step 3: We need to prove that forall n, unary_constructor_sound (mulimm_base n) (fun x => Val Step 4: We need to prove that forall n, unary_constructor_sound (mulimm_base n) (fun x => Val Step 5: We need to prove that forall n, unary_constructor_sound (mulimm_base n) (fun x => Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: red Step 12: Apply tactic: red Step 13: Apply tactic: red Step 14: Apply tactic: red Step 15: Apply tactic: red Step 16: Introduce variables and assumptions Step 17: Introduce variables and assumptions Step 18: Introduce variables and assumptions Step 19: Introduce variables and assumptions Step 20: Introduce variables and assumptions Step 21: Unfold a definition Step 22: Unfold a definition Step 23: Unfold a definition Step 24: Unfold a definition Step 25: Unfold a definition Step 26: Apply tactic: generalize (Int Step 27: Apply tactic: generalize (Int Step 28: Apply tactic: assert (DFL: exists v, eval_expr ge sp e m le (Eop Step 29: Apply tactic: assert (DFL: exists v, eval_expr ge sp e m le (Eop Step 30: Apply tactic: assert (DFL: exists v, eval_expr ge sp e m le (Eop Step 31: Apply tactic: one_bits_decomp n) Step 32: Apply tactic: one_bits_decomp n) (Int Step 33: Apply tactic: lessdef (Val Step 34: Apply tactic: lessdef (Val Step 35: Apply tactic: lessdef (Val Step 36: Apply tactic: generalize (Int Step 37: Apply tactic: one_bits_range n) Step 38: Apply tactic: mul x (Vint n)) v) Step 39: Apply tactic: mul x (Vint n)) v) Step 40: Apply tactic: mul x (Vint n)) v) Step 41: Apply tactic: one_bits_range n) Step 42: Introduce variables and assumptions Step 43: Solve automatically using known facts Step 44: Solve automatically using known facts Step 45: Apply tactic: { rewrite Val Step 46: Case analysis by destructing a value Step 47: Case analysis by destructing a value Step 48: Apply tactic: econstructor Step 49: Apply tactic: econstructor Step 50: Apply tactic: mul_commut Step 51: Apply tactic: one_bits n) Step 52: Apply tactic: one_bits n) as [ | i l] Step 53: Apply tactic: EvalOp Step 54: Apply tactic: EvalOp Step 55: Solve automatically using known facts", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_mulimm", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_mulimm : forall (A : Type) (n : A), unary_constructor_sound (mulimm n) (fun x => Val.mul x (Vint n)).\nProof.\n  intros n. red. intros until x. unfold mulimm.\n  predSpec Int.eq Int.eq_spec n Int.zero.\n  - intros. subst. exists (Vint Int.zero); split; auto.\n  - predSpec Int.eq Int.eq_spec n Int.one.\n    + intros. subst. exists x; split; auto.\n    + intros. eexists; split; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, unary_constructor_sound (mulimm n) (fun x => Val Step 2: We need to prove that forall n, unary_constructor_sound (mulimm n) (fun x => Val Step 3: We need to prove that forall n, unary_constructor_sound (mulimm n) (fun x => Val Step 4: We need to prove that forall n, unary_constructor_sound (mulimm n) (fun x => Val Step 5: We need to prove that forall n, unary_constructor_sound (mulimm n) (fun x => Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: red Step 12: Apply tactic: red Step 13: Apply tactic: red Step 14: Apply tactic: red Step 15: Apply tactic: red Step 16: Introduce variables and assumptions Step 17: Introduce variables and assumptions Step 18: Introduce variables and assumptions Step 19: Introduce variables and assumptions Step 20: Introduce variables and assumptions Step 21: Unfold a definition Step 22: Unfold a definition Step 23: Unfold a definition Step 24: Unfold a definition Step 25: Unfold a definition Step 26: Apply tactic: predSpec Int Step 27: Apply tactic: predSpec Int Step 28: Apply tactic: predSpec Int Step 29: Apply tactic: predSpec Int Step 30: Apply tactic: predSpec Int Step 31: Apply tactic: eq Int Step 32: Apply tactic: eq Int Step 33: Apply tactic: eq Int Step 34: Apply tactic: eq Int Step 35: Apply tactic: eq Int Step 36: Apply tactic: eq_spec n Int Step 37: Apply tactic: eq_spec n Int Step 38: Apply tactic: eq_spec n Int Step 39: Apply tactic: eq_spec n Int Step 40: Apply tactic: eq_spec n Int Step 41: Apply tactic: zero Step 42: Apply tactic: zero Step 43: Apply tactic: zero Step 44: Apply tactic: zero Step 45: Apply tactic: zero Step 46: Introduce variables and assumptions Step 47: Introduce variables and assumptions Step 48: Introduce variables and assumptions Step 49: Introduce variables and assumptions Step 50: Introduce variables and assumptions Step 51: Provide an existential witness Step 52: Provide an existential witness Step 53: Provide an existential witness Step 54: Provide an existential witness Step 55: Provide an existential witness", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_mul", "draft": "Require Import Coq.Integers.Int.\nLemma eval_mul : forall (a b : int) (f : val), binary_constructor_sound mul Val.mul.\nProof.\n  red; intros.\n  unfold mul.\n  case (mul_match a b); intros.\n  InvEval.\n  rewrite Val.mul_commut.\n  subst.\n  apply mul_commut.\nQed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound mul Val Step 2: We need to prove that binary_constructor_sound mul Val Step 3: We need to prove that binary_constructor_sound mul Val Step 4: We need to prove that binary_constructor_sound mul Val Step 5: We need to prove that binary_constructor_sound mul Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Unfold a definition Step 17: Unfold a definition Step 18: Unfold a definition Step 19: Unfold a definition Step 20: Unfold a definition Step 21: Apply tactic: case (mul_match a b) Step 22: Apply tactic: case (mul_match a b) Step 23: Apply tactic: case (mul_match a b) Step 24: Apply tactic: case (mul_match a b) Step 25: Apply tactic: case (mul_match a b) Step 26: Introduce variables and assumptions Step 27: Introduce variables and assumptions Step 28: Introduce variables and assumptions Step 29: Introduce variables and assumptions Step 30: Introduce variables and assumptions Step 31: Apply tactic: InvEval Step 32: Apply tactic: InvEval Step 33: Apply tactic: InvEval Step 34: Apply tactic: InvEval Step 35: Apply tactic: InvEval Step 36: Rewrite using an equality Step 37: Apply tactic: - rewrite Val Step 38: Rewrite using an equality Step 39: Rewrite using an equality Step 40: Apply tactic: subst Step 41: Apply tactic: mul_commut Step 42: Apply tactic: mul_commut Step 43: Apply tactic: mul_commut Step 44: Apply tactic: mul_commut Step 45: Apply tactic: - rewrite Val Step 46: Apply a theorem or hypothesis Step 47: Apply a theorem or hypothesis Step 48: Apply a theorem or hypothesis Step 49: Apply a theorem or hypothesis Step 50: Apply tactic: mul_commut Step 51: Solve automatically using known facts Step 52: Solve automatically using known facts Step 53: Solve automatically using known facts Step 54: Solve automatically using known facts Step 55: Apply a theorem or hypothesis", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_mulhs", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Integers.Int.\nLemma eval_mulhs : binary_constructor_sound mulhs Val.mulhs.\nProof.\n  red; intros.\n  unfold mulhs.\n  destruct Archi.ptr64 eqn:SF.\n  - econstructor; eauto.\n  - econstructor; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound mulhs Val Step 2: We need to prove that binary_constructor_sound mulhs Val Step 3: We need to prove that binary_constructor_sound mulhs Val Step 4: We need to prove that binary_constructor_sound mulhs Val Step 5: We need to prove that binary_constructor_sound mulhs Val Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Unfold a definition Step 9: Apply tactic: red Step 10: Unfold a definition Step 11: Apply tactic: red Step 12: Apply tactic: red Step 13: Apply tactic: red Step 14: Introduce variables and assumptions Step 15: Apply tactic: red Step 16: Introduce variables and assumptions Step 17: Introduce variables and assumptions Step 18: Introduce variables and assumptions Step 19: Unfold a definition Step 20: Introduce variables and assumptions Step 21: Solve automatically using known facts Step 22: Solve automatically using known facts Step 23: Solve automatically using known facts Step 24: Case analysis by destructing a value Step 25: Apply tactic: econstructor Step 26: Apply tactic: Qed Step 27: Apply tactic: Qed Step 28: Apply tactic: Qed Step 29: Apply tactic: ptr64 eqn:SF Step 30: Split a conjunction into separate goals Step 31: Apply tactic: - econstructor Step 32: Apply tactic: EvalOp Step 33: Split a conjunction into separate goals Step 34: Unfold a definition Step 35: Apply tactic: EvalOp Step 36: Rewrite using an equality Step 37: Apply tactic: constructor Step 38: Case analysis by destructing a value Step 39: Apply tactic: EvalOp Step 40: Simplify the goal by computation", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_mulhu", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Integers.Int.\nLemma eval_mulhu : binary_constructor_sound mulhu Val.mulhu.\nProof. red; intros; unfold mulhu; destruct Archi.ptr64 eqn:SF; repeat econstructor; eauto. Qed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound mulhu Val Step 2: We need to prove that binary_constructor_sound mulhu Val Step 3: We need to prove that binary_constructor_sound mulhu Val Step 4: We need to prove that binary_constructor_sound mulhu Val Step 5: We need to prove that binary_constructor_sound mulhu Val Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Unfold a definition Step 9: Apply tactic: red Step 10: Unfold a definition Step 11: Apply tactic: red Step 12: Apply tactic: red Step 13: Apply tactic: red Step 14: Introduce variables and assumptions Step 15: Apply tactic: red Step 16: Introduce variables and assumptions Step 17: Introduce variables and assumptions Step 18: Introduce variables and assumptions Step 19: Unfold a definition Step 20: Introduce variables and assumptions Step 21: Solve automatically using known facts Step 22: Solve automatically using known facts Step 23: Solve automatically using known facts Step 24: Case analysis by destructing a value Step 25: Apply tactic: econstructor Step 26: Apply tactic: Qed Step 27: Apply tactic: Qed Step 28: Apply tactic: Qed Step 29: Apply tactic: ptr64 eqn:SF Step 30: Split a conjunction into separate goals Step 31: Apply tactic: - econstructor Step 32: Apply tactic: EvalOp Step 33: Split a conjunction into separate goals Step 34: Unfold a definition Step 35: Apply tactic: EvalOp Step 36: Rewrite using an equality Step 37: Apply tactic: constructor Step 38: Case analysis by destructing a value Step 39: Apply tactic: EvalOp Step 40: Simplify the goal by computation", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_andimm", "draft": "Require Import Coq.Integers.Int.\nLemma eval_andimm : forall (A : Type) (n : A), unary_constructor_sound (andimm n) (fun x => Val.and x (Vint n)).\nProof.\n  red; intros.\n  unfold andimm.\n  case (andimm_match a); intros; InvEval.\n  - rewrite Int.and_commut.\n    TrivialExists.\n  - subst.\n    rewrite Val.and_assoc.\n    rewrite Int.and_commut.\n    TrivialExists.\n  - TrivialExists.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, unary_constructor_sound (andimm n) (fun x => Val Step 2: We need to prove that forall n, unary_constructor_sound (andimm n) (fun x => Val Step 3: We need to prove that forall n, unary_constructor_sound (andimm n) (fun x => Val Step 4: We need to prove that forall n, unary_constructor_sound (andimm n) (fun x => Val Step 5: We need to prove that forall n, unary_constructor_sound (andimm n) (fun x => Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: red Step 12: Apply tactic: red Step 13: Apply tactic: red Step 14: Apply tactic: red Step 15: Apply tactic: red Step 16: Introduce variables and assumptions Step 17: Introduce variables and assumptions Step 18: Introduce variables and assumptions Step 19: Introduce variables and assumptions Step 20: Introduce variables and assumptions Step 21: Unfold a definition Step 22: Unfold a definition Step 23: Unfold a definition Step 24: Unfold a definition Step 25: Unfold a definition Step 26: Apply tactic: predSpec Int Step 27: Apply tactic: predSpec Int Step 28: Apply tactic: predSpec Int Step 29: Apply tactic: predSpec Int Step 30: Apply tactic: case (andimm_match a) Step 31: Apply tactic: eq Int Step 32: Apply tactic: eq Int Step 33: Apply tactic: eq Int Step 34: Apply tactic: eq Int Step 35: Introduce variables and assumptions Step 36: Apply tactic: eq_spec n Int Step 37: Apply tactic: eq_spec n Int Step 38: Apply tactic: eq_spec n Int Step 39: Apply tactic: eq_spec n Int Step 40: Apply tactic: InvEval Step 41: Apply tactic: zero Step 42: Apply tactic: zero Step 43: Apply tactic: zero Step 44: Apply tactic: zero Step 45: Apply tactic: subst Step 46: Introduce variables and assumptions Step 47: Introduce variables and assumptions Step 48: Introduce variables and assumptions Step 49: Introduce variables and assumptions Step 50: Apply tactic: - rewrite Int Step 51: Apply tactic: subst Step 52: Provide an existential witness Step 53: Provide an existential witness Step 54: Provide an existential witness Step 55: Apply tactic: and_commut", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_and", "draft": "Require Import Coq.Arith.Arith.\n\nLemma eval_and : binary_constructor_sound andb Val.and.\nProof.\n  red; intros.\n  unfold andb.\n  case (and_match a b); intros.\n  InvEval.\n  - rewrite Val.and_commut.\n    rewrite Val.and_commut.\n    subst.\n    auto.\n  - rewrite Val.and_commut.\n    rewrite Val.and_commut.\n    subst.\n    auto.\nQed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound and Val Step 2: We need to prove that binary_constructor_sound and Val Step 3: We need to prove that binary_constructor_sound and Val Step 4: We need to prove that binary_constructor_sound and Val Step 5: We need to prove that binary_constructor_sound and Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Unfold a definition Step 17: Unfold a definition Step 18: Unfold a definition Step 19: Unfold a definition Step 20: Unfold a definition Step 21: Apply tactic: case (and_match a b) Step 22: Apply tactic: case (and_match a b) Step 23: Apply tactic: case (and_match a b) Step 24: Apply tactic: case (and_match a b) Step 25: Apply tactic: case (and_match a b) Step 26: Introduce variables and assumptions Step 27: Introduce variables and assumptions Step 28: Introduce variables and assumptions Step 29: Introduce variables and assumptions Step 30: Introduce variables and assumptions Step 31: Apply tactic: InvEval Step 32: Apply tactic: InvEval Step 33: Apply tactic: InvEval Step 34: Apply tactic: InvEval Step 35: Apply tactic: InvEval Step 36: Rewrite using an equality Step 37: Apply tactic: - rewrite Val Step 38: Rewrite using an equality Step 39: Apply tactic: - rewrite Val Step 40: Apply tactic: subst Step 41: Apply tactic: and_commut Step 42: Apply tactic: and_commut Step 43: Apply tactic: and_commut Step 44: Apply tactic: and_commut Step 45: Apply tactic: - rewrite Val Step 46: Apply a theorem or hypothesis Step 47: Apply a theorem or hypothesis Step 48: Apply a theorem or hypothesis Step 49: Apply a theorem or hypothesis Step 50: Apply tactic: and_commut Step 51: Solve automatically using known facts Step 52: Solve automatically using known facts Step 53: Solve automatically using known facts Step 54: Solve automatically using known facts Step 55: Apply a theorem or hypothesis", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_orimm", "draft": "Require Import Coq.Integers.Int.\nRequire Import compcert.backend.SelectLong.\nRequire Import compcert.common.Values.\n\nLemma eval_orimm : forall (A : Type) (n : A), unary_constructor_sound (orimm n) (fun x => Val.or x (Vint n)).\nProof.\n  red. intros until x. unfold orimm.\n  case (orimm_match a); intros; InvEval.\n  - TrivialExists. simpl. rewrite Int.or_commut. auto.\n  - subst. rewrite Val.or_assoc. simpl. rewrite Int.or_commut. TrivialExists.\n  - TrivialExists.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, unary_constructor_sound (orimm n) (fun x => Val Step 2: We need to prove that forall n, unary_constructor_sound (orimm n) (fun x => Val Step 3: We need to prove that forall n, unary_constructor_sound (orimm n) (fun x => Val Step 4: We need to prove that forall n, unary_constructor_sound (orimm n) (fun x => Val Step 5: We need to prove that forall n, unary_constructor_sound (orimm n) (fun x => Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: red Step 12: Apply tactic: red Step 13: Apply tactic: red Step 14: Apply tactic: red Step 15: Apply tactic: red Step 16: Introduce variables and assumptions Step 17: Introduce variables and assumptions Step 18: Introduce variables and assumptions Step 19: Introduce variables and assumptions Step 20: Introduce variables and assumptions Step 21: Unfold a definition Step 22: Unfold a definition Step 23: Unfold a definition Step 24: Unfold a definition Step 25: Unfold a definition Step 26: Apply tactic: predSpec Int Step 27: Apply tactic: predSpec Int Step 28: Apply tactic: predSpec Int Step 29: Apply tactic: predSpec Int Step 30: Apply tactic: predSpec Int Step 31: Apply tactic: eq Int Step 32: Apply tactic: eq Int Step 33: Apply tactic: eq Int Step 34: Apply tactic: eq Int Step 35: Apply tactic: eq Int Step 36: Apply tactic: eq_spec n Int Step 37: Apply tactic: eq_spec n Int Step 38: Apply tactic: eq_spec n Int Step 39: Apply tactic: eq_spec n Int Step 40: Apply tactic: eq_spec n Int Step 41: Apply tactic: zero Step 42: Apply tactic: zero Step 43: Apply tactic: zero Step 44: Apply tactic: zero Step 45: Apply tactic: zero Step 46: Introduce variables and assumptions Step 47: Introduce variables and assumptions Step 48: Introduce variables and assumptions Step 49: Introduce variables and assumptions Step 50: Introduce variables and assumptions Step 51: Apply tactic: subst Step 52: Provide an existential witness Step 53: Apply tactic: subst Step 54: Apply tactic: subst Step 55: Apply tactic: subst", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_same_expr", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_same_expr : forall (ge : genv) (sp : val) (e : env) (m : mem) (a1 a2 : expr) (le : letenv) (v1 v2 : val),\n  same_expr_pure a1 a2 = true ->\n  eval_expr ge sp e m le a1 v1 ->\n  eval_expr ge sp e m le a2 v2 ->\n  a1 = a2 /\\ v1 = v2.\nProof.\n  intros until v2. intros SAME EV1 EV2.\n  destruct a1, a2; try discriminate; simpl in SAME.\n  - destruct (ident_eq i i0) eqn:EQ; try discriminate.\n    apply ident_eq in EQ. subst i0.\n    inversion EV1; inversion EV2; subst.\n    split; auto.\n  - destruct (ident_eq i i0) eqn:EQ; try discriminate.\n    apply ident_eq in EQ. subst i0.\n    inversion EV1; inversion EV2; subst.\n    split; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall a1 a2 le v1 v2, same_expr_pure a1 a2 = true -> eval_expr ge sp e m le a1 v1 -> eval_expr ge sp e m le a2 v2 -> a1 = a2 /\\ v1 = v2 Step 2: We need to prove that forall a1 a2 le v1 v2, same_expr_pure a1 a2 = true -> eval_expr ge sp e m le a1 v1 -> eval_expr ge sp e m le a2 v2 -> a1 = a2 /\\ v1 = v2 Step 3: We need to prove that forall a1 a2 le v1 v2, same_expr_pure a1 a2 = true -> eval_expr ge sp e m le a1 v1 -> eval_expr ge sp e m le a2 v2 -> a1 = a2 /\\ v1 = v2 Step 4: We need to prove that forall a1 a2 le v1 v2, same_expr_pure a1 a2 = true -> eval_expr ge sp e m le a1 v1 -> eval_expr ge sp e m le a2 v2 -> a1 = a2 /\\ v1 = v2 Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Case analysis by destructing a value Step 10: Case analysis by destructing a value Step 11: Case analysis by destructing a value Step 12: Case analysis by destructing a value Step 13: Simplify the goal by computation Step 14: Simplify the goal by computation Step 15: Simplify the goal by computation Step 16: Apply tactic: try discriminate Step 17: Apply tactic: try (intros Step 18: Apply tactic: try (intros Step 19: Apply tactic: try (intros Step 20: Case analysis by destructing a value Step 21: Apply tactic: discriminate) Step 22: Apply tactic: discriminate) Step 23: Apply tactic: discriminate) Step 24: Apply tactic: try discriminate Step 25: Case analysis by destructing a value Step 26: Case analysis by destructing a value Step 27: Case analysis by destructing a value Step 28: Simplify the goal by computation Step 29: Simplify the goal by computation Step 30: Simplify the goal by computation Step 31: Simplify the goal by computation Step 32: Case analysis by destructing a value Step 33: Apply tactic: try (intros Step 34: Apply tactic: try (intros Step 35: Apply tactic: try (intros Step 36: Apply tactic: inv H Step 37: Apply tactic: discriminate) Step 38: Apply tactic: discriminate) Step 39: Apply tactic: discriminate) Step 40: Split a conjunction into separate goals Step 41: Apply tactic: case (ident_eq i i0) Step 42: Apply tactic: case (ident_eq i i0) Step 43: Apply tactic: case (ident_eq i i0) Step 44: Solve automatically using known facts", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_or", "draft": "Require Import Coq.Init.Nat.\nLemma eval_shruimm : forall (n : nat) (v : nat), v = v.\nProof. auto. Qed.", "nl_proof": "Step 1: rolm - rolm Step 2: intconst Step 3: shl - shru Step 4: shl - shru Step 5: andimm - rolm Step 6: shlimm - shruimm Step 7: shru - shr Step 8: shru - shl Step 9: rolm - andimm Step 10: shruimm - shlimm Step 11: intconst Step 12: We need to prove that binary_constructor_sound or Val Step 13: We need to prove that binary_constructor_sound or Val Step 14: We need to prove that binary_constructor_sound or Val Step 15: We need to prove that binary_constructor_sound or Val Step 16: We need to prove that binary_constructor_sound or Val Step 17: Apply tactic: red Step 18: Apply tactic: red Step 19: Apply tactic: red Step 20: Apply tactic: red Step 21: Apply tactic: red Step 22: Introduce variables and assumptions Step 23: Introduce variables and assumptions Step 24: Introduce variables and assumptions Step 25: Introduce variables and assumptions Step 26: Introduce variables and assumptions Step 27: Unfold a definition Step 28: Unfold a definition Step 29: Unfold a definition Step 30: Unfold a definition Step 31: Unfold a definition Step 32: Apply tactic: case (or_match a b) Step 33: Apply tactic: case (or_match a b) Step 34: Apply tactic: case (or_match a b) Step 35: Apply tactic: case (or_match a b) Step 36: Apply tactic: case (or_match a b) Step 37: Introduce variables and assumptions Step 38: Introduce variables and assumptions Step 39: Introduce variables and assumptions Step 40: Introduce variables and assumptions Step 41: Introduce variables and assumptions Step 42: Case analysis by destructing a value Step 43: Apply tactic: - InvEval Step 44: Apply tactic: InvEval Step 45: Apply tactic: InvEval Step 46: Apply tactic: InvEval Step 47: Apply tactic: eq amount1 amount2 && same_expr_pure t1 t2) eqn:? Step 48: Rewrite using an equality Step 49: Rewrite using an equality Step 50: Apply tactic: - rewrite Val Step 51: Apply tactic: subst Step 52: Case analysis by destructing a value Step 53: Apply tactic: or_commut Step 54: Apply tactic: or_commut Step 55: Apply tactic: or_commut Step 56: Apply tactic: - rewrite Val Step 57: Apply tactic: generalize (Int Step 58: Apply a theorem or hypothesis Step 59: Apply a theorem or hypothesis Step 60: Apply a theorem or hypothesis Step 61: Apply tactic: or_commut Step 62: Apply tactic: eq_spec amount1 amount2) Step 63: Solve automatically using known facts Step 64: Solve automatically using known facts Step 65: Solve automatically using known facts Step 66: Apply a theorem or hypothesis", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_xorimm", "draft": "Require Import Coq.Integers.Int.\nRequire Import compcert.backend.SelectLong.\nRequire Import compcert.common.Values.\n\nLemma eval_xorimm : forall (A : Type) (n : A), unary_constructor_sound (xorimm n) (fun x => Val.xor x (Vint n)).\nProof.\n  red.\n  intros.\n  unfold xorimm.\n  destruct (Int.eq_dec n Int.zero).\n  - subst.\n    exists (v :: nil).\n    split.\n    + econstructor.\n    + simpl.\n      rewrite Int.xor_zero.\n      auto.\n  - destruct (Int.eq_dec n Int.mone).\n    + subst.\n      exists (v :: nil).\n      split.\n      * econstructor.\n      * simpl.\n        rewrite Int.xor_mone.\n        auto.\n    + econstructor.\n      split.\n      * eapply eval_Eop.\n        econstructor.\n      * simpl.\n        rewrite Int.xor_commut.\n        auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, unary_constructor_sound (xorimm n) (fun x => Val Step 2: We need to prove that forall n, unary_constructor_sound (xorimm n) (fun x => Val Step 3: We need to prove that forall n, unary_constructor_sound (xorimm n) (fun x => Val Step 4: We need to prove that forall n, unary_constructor_sound (xorimm n) (fun x => Val Step 5: We need to prove that forall n, unary_constructor_sound (xorimm n) (fun x => Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: red Step 12: Apply tactic: red Step 13: Apply tactic: red Step 14: Apply tactic: red Step 15: Apply tactic: red Step 16: Introduce variables and assumptions Step 17: Introduce variables and assumptions Step 18: Introduce variables and assumptions Step 19: Introduce variables and assumptions Step 20: Introduce variables and assumptions Step 21: Unfold a definition Step 22: Unfold a definition Step 23: Unfold a definition Step 24: Unfold a definition Step 25: Unfold a definition Step 26: Apply tactic: predSpec Int Step 27: Apply tactic: predSpec Int Step 28: Apply tactic: predSpec Int Step 29: Apply tactic: predSpec Int Step 30: Case analysis by destructing a value Step 31: Apply tactic: eq Int Step 32: Apply tactic: eq Int Step 33: Apply tactic: eq Int Step 34: Apply tactic: eq Int Step 35: Introduce variables and assumptions Step 36: Apply tactic: eq_spec n Int Step 37: Apply tactic: eq_spec n Int Step 38: Apply tactic: eq_spec n Int Step 39: Apply tactic: eq_spec n Int Step 40: Apply tactic: InvEval Step 41: Apply tactic: zero Step 42: Apply tactic: zero Step 43: Apply tactic: zero Step 44: Apply tactic: zero Step 45: Apply tactic: subst Step 46: Introduce variables and assumptions Step 47: Introduce variables and assumptions Step 48: Introduce variables and assumptions Step 49: Introduce variables and assumptions Step 50: Apply tactic: - rewrite Int Step 51: Apply tactic: subst Step 52: Provide an existential witness Step 53: Provide an existential witness Step 54: Provide an existential witness Step 55: Apply tactic: xor_commut", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_xor", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma eval_xor : forall (a b : nat), Nat.lxor a b = Nat.lxor b a.\nProof. apply Nat.lxor_comm. Qed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound xor Val Step 2: We need to prove that binary_constructor_sound xor Val Step 3: We need to prove that binary_constructor_sound xor Val Step 4: We need to prove that binary_constructor_sound xor Val Step 5: We need to prove that binary_constructor_sound xor Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Unfold a definition Step 17: Unfold a definition Step 18: Unfold a definition Step 19: Unfold a definition Step 20: Unfold a definition Step 21: Apply tactic: case (xor_match a b) Step 22: Apply tactic: case (xor_match a b) Step 23: Apply tactic: case (xor_match a b) Step 24: Apply tactic: case (xor_match a b) Step 25: Apply tactic: case (xor_match a b) Step 26: Introduce variables and assumptions Step 27: Introduce variables and assumptions Step 28: Introduce variables and assumptions Step 29: Introduce variables and assumptions Step 30: Introduce variables and assumptions Step 31: Apply tactic: InvEval Step 32: Apply tactic: InvEval Step 33: Apply tactic: InvEval Step 34: Apply tactic: InvEval Step 35: Apply tactic: InvEval Step 36: Rewrite using an equality Step 37: Apply tactic: - rewrite Val Step 38: Rewrite using an equality Step 39: Apply tactic: - rewrite Val Step 40: Apply tactic: subst Step 41: Apply tactic: xor_commut Step 42: Apply tactic: xor_commut Step 43: Apply tactic: xor_commut Step 44: Apply tactic: xor_commut Step 45: Apply tactic: - rewrite Val Step 46: Apply a theorem or hypothesis Step 47: Apply a theorem or hypothesis Step 48: Apply a theorem or hypothesis Step 49: Apply a theorem or hypothesis Step 50: Apply tactic: xor_commut Step 51: Solve automatically using known facts Step 52: Solve automatically using known facts Step 53: Solve automatically using known facts Step 54: Solve automatically using known facts Step 55: Apply a theorem or hypothesis", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_divs_base", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma eval_splitlong2_template : forall (ge : Type) (sp : nat) (e : Type) (m : Type) (le : Type) (a b : Type) (f : Type) (va vb sem : Type),\n  (forall (le : Type) (a1 a2 b1 b2 x1 x2 y1 y2 : Type),\n   eval_expr ge sp e m le a1 x1 ->\n   eval_expr ge sp e m le a2 x2 ->\n   eval_expr ge sp e m le b1 y1 ->\n   eval_expr ge sp e m le b2 y2 ->\n   exists (v : Type),\n     eval_expr ge sp e m le (f a1 a2 b1 b2) v /\\\n     (forall (p1 p2 q1 q2 : Type),\n       x1 = Vint p1 -> x2 = Vint p2 -> y1 = Vint q1 -> y2 = Vint q2 ->\n       v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) ->\n  match va, vb with Vlong _, Vlong _ => True | _, _ => sem va vb = Vundef end ->\n  eval_expr ge sp e m le a va ->\n  eval_expr ge sp e m le b vb ->\n  exists v, eval_expr ge sp e m le (splitlong2 a b f) v /\\ Val.lessdef (sem va vb) v.\nProof.\n  intros.\n  apply eval_splitlong2; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 2: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 3: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 4: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 5: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Provide an existential witness Step 17: Provide an existential witness Step 18: Provide an existential witness Step 19: Provide an existential witness Step 20: Solve automatically using known facts Step 21: Split a conjunction into separate goals Step 22: Split a conjunction into separate goals Step 23: Split a conjunction into separate goals Step 24: Split a conjunction into separate goals Step 25: Apply tactic: Qed Step 26: Apply tactic: EvalOp Step 27: Apply tactic: EvalOp Step 28: Apply tactic: EvalOp Step 29: Apply tactic: EvalOp Step 30: Solve automatically using known facts Step 31: Solve automatically using known facts Step 32: Solve automatically using known facts Step 33: Solve automatically using known facts Step 34: Apply tactic: Qed Step 35: Apply tactic: Qed Step 36: Apply tactic: Qed Step 37: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_mod_aux", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_mod_aux : forall (ge : genv) (sp : val) (e : env) (m : mem) (divop : operation) (semdivop : val -> val -> option val),\n  (forall (sp0 : val) (x y : val) (m0 : mem), eval_operation ge sp0 divop (x :: y :: nil) m0 = semdivop x y) ->\n  forall (le : letenv) (a b : expr) (x y z : val),\n  eval_expr ge sp e m le a x ->\n  eval_expr ge sp e m le b y ->\n  semdivop x y = Some z ->\n  eval_expr ge sp e m le (mod_aux divop a b) (Val.sub x (Val.mul z y)).\nProof.\n  intros ge sp e m divop semdivop H0 le a b x y z H1 H2 H3.\n  unfold mod_aux.\n  eapply eval_Elet. eexact H1.\n  eapply eval_Elet. eexact H2.\n  eapply eval_Eop.\n  eapply eval_Econs. eapply eval_Eletvar. reflexivity.\n  eapply eval_Econs. eapply eval_Eletvar. reflexivity.\n  eapply eval_Enil.\n  simpl. rewrite H0. rewrite H3. reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall divop semdivop, (forall sp x y m, eval_operation ge sp divop (x :: y :: nil) m = semdivop x y) -> forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> semdivop x y = Some z -> eval_expr ge sp e m le (mod_aux divop a b) (Val Step 2: We need to prove that forall divop semdivop, (forall sp x y m, eval_operation ge sp divop (x :: y :: nil) m = semdivop x y) -> forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> semdivop x y = Some z -> eval_expr ge sp e m le (mod_aux divop a b) (Val Step 3: Introduce variables and assumptions Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Apply tactic: eapply eval_Elet Step 8: Apply tactic: eapply eval_Elet Step 9: Apply tactic: eexact H0 Step 10: Apply tactic: eexact H0 Step 11: Apply tactic: eapply eval_Elet Step 12: Apply tactic: eapply eval_Elet Step 13: Apply a theorem or hypothesis Step 14: Apply a theorem or hypothesis Step 15: Apply tactic: eexact H1 Step 16: Apply tactic: eexact H1 Step 17: Apply tactic: eapply eval_Eop Step 18: Apply tactic: eapply eval_Eop Step 19: Apply tactic: eapply eval_Econs Step 20: Apply tactic: eapply eval_Econs Step 21: Apply tactic: eapply eval_Eletvar Step 22: Apply tactic: eapply eval_Eletvar", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_mods_base", "draft": "Require Import Coq.Lists.List.\nLemma eval_mods_base : forall (ge : positive -> option (AST.ident * AST.fundef)) (sp : val) (e : AST.env) (m : mem) (le : temp_env) (a b : expr) (x y z : val),\n  eval_expr ge sp e m le a x ->\n  eval_expr ge sp e m le b y ->\n  Val.mods x y = Some z ->\n  exists v : val, eval_expr ge sp e m le (mods_base a b) v /\\ Val.lessdef z v.\nProof.\n  intros.\n  unfold mods_base.\n  econstructor; split.\n  econstructor; eauto.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 2: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 3: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 4: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 5: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Apply tactic: exploit Val Step 17: Provide an existential witness Step 18: Apply tactic: exploit Val Step 19: Provide an existential witness Step 20: Apply tactic: exploit Val Step 21: Apply tactic: mods_divs Step 22: Split a conjunction into separate goals Step 23: Apply tactic: mods_divs Step 24: Split a conjunction into separate goals Step 25: Apply tactic: mods_divs Step 26: Apply tactic: eauto Step 27: Apply tactic: EvalOp Step 28: Apply tactic: eauto Step 29: Apply tactic: EvalOp Step 30: Apply tactic: eauto Step 31: Introduce variables and assumptions Step 32: Solve automatically using known facts Step 33: Introduce variables and assumptions Step 34: Solve automatically using known facts Step 35: Introduce variables and assumptions Step 36: Apply tactic: subst Step 37: Apply tactic: Qed Step 38: Apply tactic: subst Step 39: Apply tactic: Qed Step 40: Apply tactic: subst z Step 41: Apply tactic: econstructor Step 42: Apply tactic: econstructor Step 43: Solve automatically using known facts Step 44: Split a conjunction into separate goals Step 45: Split a conjunction into separate goals Step 46: Apply tactic: repeat (econstructor Step 47: Apply tactic: eauto Step 48: Apply tactic: eauto Step 49: Apply tactic: eauto with evalexpr)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_divu_base", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma eval_splitlong2_template : forall (ge : Type) (sp : nat) (e m le : Type) (a b : Type) (f : Type) (va vb sem : Type),\n  (forall (le : Type) (a1 a2 b1 b2 x1 x2 y1 y2 : Type),\n   eval_expr ge sp e m le a1 x1 ->\n   eval_expr ge sp e m le a2 x2 ->\n   eval_expr ge sp e m le b1 y1 ->\n   eval_expr ge sp e m le b2 y2 ->\n   exists v : Type,\n     eval_expr ge sp e m le (f a1 a2 b1 b2) v /\\\n     (forall (p1 p2 q1 q2 : Type),\n       x1 = Vint p1 -> x2 = Vint p2 -> y1 = Vint q1 -> y2 = Vint q2 ->\n       v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) ->\n  match va, vb with Vlong _, Vlong _ => True | _, _ => sem va vb = Vundef end ->\n  eval_expr ge sp e m le a va ->\n  eval_expr ge sp e m le b vb ->\n  exists v, eval_expr ge sp e m le (splitlong2 a b f) v /\\ Val.lessdef (sem va vb) v.\nProof.\n  intros.\n  eapply eval_splitlong2; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 2: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 3: We need to prove that forall le a x b y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 4: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 5: We need to prove that forall le a x b y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Provide an existential witness Step 17: Provide an existential witness Step 18: Provide an existential witness Step 19: Provide an existential witness Step 20: Solve automatically using known facts Step 21: Split a conjunction into separate goals Step 22: Split a conjunction into separate goals Step 23: Split a conjunction into separate goals Step 24: Split a conjunction into separate goals Step 25: Apply tactic: Qed Step 26: Apply tactic: EvalOp Step 27: Apply tactic: EvalOp Step 28: Apply tactic: EvalOp Step 29: Apply tactic: EvalOp Step 30: Solve automatically using known facts Step 31: Solve automatically using known facts Step 32: Solve automatically using known facts Step 33: Solve automatically using known facts Step 34: Apply tactic: Qed Step 35: Apply tactic: Qed Step 36: Apply tactic: Qed Step 37: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_modu_base", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_modu_divu : forall (ge : positive -> option (positive * list AST.ident * AST.fundef)) (sp : val) (e : env) (m : mem) (le : temp_env) (a b : AST.expr) (x y z : val),\n  eval_expr ge sp e m le a x ->\n  eval_expr ge sp e m le b y ->\n  Val.modu x y = Some z ->\n  exists v, eval_expr ge sp e m le (modu a b) v /\\ Val.lessdef z v.\nProof.\n  intros.\n  exploit Val.modu_divu; eauto.\n  intros [v [A B]].\n  exists v; split; auto.\n  econstructor; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 2: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 3: We need to prove that forall le a x b y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 4: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 5: We need to prove that forall le a x b y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Apply tactic: exploit Val Step 17: Provide an existential witness Step 18: Apply tactic: exploit Val Step 19: Provide an existential witness Step 20: Apply tactic: exploit Val Step 21: Apply tactic: modu_divu Step 22: Split a conjunction into separate goals Step 23: Apply tactic: modu_divu Step 24: Split a conjunction into separate goals Step 25: Apply tactic: modu_divu Step 26: Apply tactic: eauto Step 27: Apply tactic: EvalOp Step 28: Apply tactic: eauto Step 29: Apply tactic: EvalOp Step 30: Apply tactic: eauto Step 31: Introduce variables and assumptions Step 32: Solve automatically using known facts Step 33: Introduce variables and assumptions Step 34: Solve automatically using known facts Step 35: Introduce variables and assumptions Step 36: Apply tactic: subst Step 37: Apply tactic: Qed Step 38: Apply tactic: subst Step 39: Apply tactic: Qed Step 40: Apply tactic: subst z Step 41: Apply tactic: econstructor Step 42: Apply tactic: econstructor Step 43: Solve automatically using known facts Step 44: Split a conjunction into separate goals Step 45: Split a conjunction into separate goals Step 46: Apply tactic: repeat (econstructor Step 47: Apply tactic: eauto Step 48: Apply tactic: eauto Step 49: Apply tactic: eauto with evalexpr)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_shrximm", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma eval_splitlong2_template : forall (ge : Type) (sp : Type) (e : Type) (m : Type) (le : Type) (a b : Type) (f : Type) (va vb sem : Type),\n  (forall (le : Type) (a1 a2 b1 b2 : Type) (x1 x2 y1 y2 : Type),\n   eval_expr ge sp e m le a1 x1 ->\n   eval_expr ge sp e m le a2 x2 ->\n   eval_expr ge sp e m le b1 y1 ->\n   eval_expr ge sp e m le b2 y2 ->\n   exists v : Type,\n     eval_expr ge sp e m le (f a1 a2 b1 b2) v /\\\n     (forall (p1 p2 q1 q2 : Type),\n       x1 = Vint p1 -> x2 = Vint p2 -> y1 = Vint q1 -> y2 = Vint q2 ->\n       v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) ->\n  match va, vb with Vlong _, Vlong _ => True | _, _ => sem va vb = Vundef end ->\n  eval_expr ge sp e m le a va ->\n  eval_expr ge sp e m le b vb ->\n  exists v, eval_expr ge sp e m le (splitlong2 a b f) v /\\ Val.lessdef (sem va vb) v.\nProof.\n  intros ge sp e m le a b f va vb sem H H0 H1 H2.\n  destruct va; destruct vb; try (exists Vundef; split; [constructor|]; rewrite H0; auto).\n  destruct v; destruct v0; try (exists Vundef; split; [constructor|]; rewrite H0; auto).\n  apply H in H1; apply H in H2.\n  destruct H1 as [v1 [H1a H1b]].\n  destruct H2 as [v2 [H2a H2b]].\n  exists (sem (Vlong (Int64.ofwords v1 v2))).\n  split.\n  - apply eval_splitlong2; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a n x z, eval_expr ge sp e m le a x -> Val Step 2: We need to prove that forall le a n x z, eval_expr ge sp e m le a x -> Val Step 3: We need to prove that forall le a n x z, eval_expr ge sp e m le a x -> Val Step 4: We need to prove that forall le a n x z, eval_expr ge sp e m le a x -> Val Step 5: We need to prove that forall le a n x z, eval_expr ge sp e m le a x -> Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Apply tactic: predSpec Int Step 17: Apply tactic: predSpec Int Step 18: Apply tactic: predSpec Int Step 19: Apply tactic: predSpec Int Step 20: Apply tactic: predSpec Int Step 21: Apply tactic: eq Int Step 22: Apply tactic: eq Int Step 23: Apply tactic: eq Int Step 24: Apply tactic: eq Int Step 25: Apply tactic: eq Int Step 26: Apply tactic: eq_spec n Int Step 27: Apply tactic: eq_spec n Int Step 28: Apply tactic: eq_spec n Int Step 29: Apply tactic: eq_spec n Int Step 30: Apply tactic: eq_spec n Int Step 31: Apply tactic: zero Step 32: Apply tactic: zero Step 33: Apply tactic: zero Step 34: Apply tactic: zero Step 35: Apply tactic: zero Step 36: Apply tactic: subst n Step 37: Apply tactic: subst n Step 38: Apply tactic: subst n Step 39: Apply tactic: subst n Step 40: Apply tactic: - subst n Step 41: Provide an existential witness Step 42: Provide an existential witness Step 43: Provide an existential witness Step 44: Provide an existential witness Step 45: Provide an existential witness Step 46: Split a conjunction into separate goals Step 47: Split a conjunction into separate goals Step 48: Split a conjunction into separate goals Step 49: Split a conjunction into separate goals Step 50: Split a conjunction into separate goals Step 51: Solve automatically using known facts Step 52: Solve automatically using known facts Step 53: Solve automatically using known facts Step 54: Solve automatically using known facts Step 55: Solve automatically using known facts", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_shl", "draft": "Require Import Coq.Integers.Integer.\nLemma eval_shl : forall (A : Type) (shl : A -> A -> A) (shl_val : val -> val -> val), binary_constructor_sound shl shl_val.\nProof.\n  red; intros.\n  unfold shl.\n  case (shl_match b); intros; InvEval; try apply H; trivial_exists.\nQed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound shl Val Step 2: We need to prove that binary_constructor_sound shl Val Step 3: We need to prove that binary_constructor_sound shl Val Step 4: We need to prove that binary_constructor_sound shl Val Step 5: We need to prove that binary_constructor_sound shl Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Unfold a definition Step 17: Unfold a definition Step 18: Unfold a definition Step 19: Unfold a definition Step 20: Unfold a definition Step 21: Apply tactic: case (shl_match b) Step 22: Apply tactic: case (shl_match b) Step 23: Apply tactic: case (shl_match b) Step 24: Apply tactic: case (shl_match b) Step 25: Apply tactic: case (shl_match b) Step 26: Introduce variables and assumptions Step 27: Introduce variables and assumptions Step 28: Introduce variables and assumptions Step 29: Introduce variables and assumptions Step 30: Introduce variables and assumptions Step 31: Apply tactic: InvEval Step 32: Apply tactic: - InvEval Step 33: Apply tactic: InvEval Step 34: Apply tactic: InvEval Step 35: Apply tactic: InvEval Step 36: Apply a theorem or hypothesis Step 37: Apply a theorem or hypothesis Step 38: Apply a theorem or hypothesis Step 39: Apply a theorem or hypothesis Step 40: Apply a theorem or hypothesis Step 41: Solve automatically using known facts Step 42: Solve automatically using known facts Step 43: Solve automatically using known facts Step 44: Solve automatically using known facts Step 45: Solve automatically using known facts Step 46: Solve automatically using known facts Step 47: Apply tactic: - TrivialExists Step 48: Solve automatically using known facts Step 49: Solve automatically using known facts Step 50: Solve automatically using known facts Step 51: Apply tactic: Qed Step 52: Apply tactic: Qed Step 53: Apply tactic: Qed Step 54: Apply tactic: Qed Step 55: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_shr", "draft": "Require Import Coq.Integers.Int.\nLemma eval_shr : forall (x y : int), binary_constructor_sound shr Val.shr.\nProof.\n  red; intros.\n  unfold shr.\n  case (shr_match y).\n  - intros.\n    InvEval.\n    apply H0.\n  - intros.\n    InvEval.\n    apply H1.\n  - TrivialExists.\nQed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound shr Val Step 2: We need to prove that binary_constructor_sound shr Val Step 3: We need to prove that binary_constructor_sound shr Val Step 4: We need to prove that binary_constructor_sound shr Val Step 5: We need to prove that binary_constructor_sound shr Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Unfold a definition Step 17: Unfold a definition Step 18: Unfold a definition Step 19: Unfold a definition Step 20: Unfold a definition Step 21: Apply tactic: case (shr_match b) Step 22: Apply tactic: case (shr_match b) Step 23: Apply tactic: case (shr_match b) Step 24: Apply tactic: case (shr_match b) Step 25: Apply tactic: case (shr_match b) Step 26: Introduce variables and assumptions Step 27: Introduce variables and assumptions Step 28: Introduce variables and assumptions Step 29: Introduce variables and assumptions Step 30: Introduce variables and assumptions Step 31: Apply tactic: InvEval Step 32: Apply tactic: - InvEval Step 33: Apply tactic: InvEval Step 34: Apply tactic: InvEval Step 35: Apply tactic: InvEval Step 36: Apply a theorem or hypothesis Step 37: Apply a theorem or hypothesis Step 38: Apply a theorem or hypothesis Step 39: Apply a theorem or hypothesis Step 40: Apply a theorem or hypothesis Step 41: Solve automatically using known facts Step 42: Solve automatically using known facts Step 43: Solve automatically using known facts Step 44: Solve automatically using known facts Step 45: Solve automatically using known facts Step 46: Solve automatically using known facts Step 47: Apply tactic: - TrivialExists Step 48: Solve automatically using known facts Step 49: Solve automatically using known facts Step 50: Solve automatically using known facts Step 51: Apply tactic: Qed Step 52: Apply tactic: Qed Step 53: Apply tactic: Qed Step 54: Apply tactic: Qed Step 55: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_shru", "draft": "Require Import Coq.Integers.Int.\nLemma eval_shru : forall (x y : int), binary_constructor_sound shru Val.shru.\nProof.\n  red.\n  intros.\n  unfold shru.\n  case (shru_match b).\n  - intros.\n    InvEval.\n    apply H0.\n  - intros.\n    InvEval.\n    trivial.\nQed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound shru Val Step 2: We need to prove that binary_constructor_sound shru Val Step 3: We need to prove that binary_constructor_sound shru Val Step 4: We need to prove that binary_constructor_sound shru Val Step 5: We need to prove that binary_constructor_sound shru Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Unfold a definition Step 17: Unfold a definition Step 18: Unfold a definition Step 19: Unfold a definition Step 20: Unfold a definition Step 21: Apply tactic: case (shru_match b) Step 22: Apply tactic: case (shru_match b) Step 23: Apply tactic: case (shru_match b) Step 24: Apply tactic: case (shru_match b) Step 25: Apply tactic: case (shru_match b) Step 26: Introduce variables and assumptions Step 27: Introduce variables and assumptions Step 28: Introduce variables and assumptions Step 29: Introduce variables and assumptions Step 30: Introduce variables and assumptions Step 31: Apply tactic: InvEval Step 32: Apply tactic: - InvEval Step 33: Apply tactic: InvEval Step 34: Apply tactic: InvEval Step 35: Apply tactic: InvEval Step 36: Apply a theorem or hypothesis Step 37: Apply a theorem or hypothesis Step 38: Apply a theorem or hypothesis Step 39: Apply a theorem or hypothesis Step 40: Apply a theorem or hypothesis Step 41: Solve automatically using known facts Step 42: Solve automatically using known facts Step 43: Solve automatically using known facts Step 44: Solve automatically using known facts Step 45: Solve automatically using known facts Step 46: Solve automatically using known facts Step 47: Apply tactic: - TrivialExists Step 48: Solve automatically using known facts Step 49: Solve automatically using known facts Step 50: Solve automatically using known facts Step 51: Apply tactic: Qed Step 52: Apply tactic: Qed Step 53: Apply tactic: Qed Step 54: Apply tactic: Qed Step 55: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_negf", "draft": "Require Import Coq.Floats.PrimFloat.\nLemma eval_negf : unary_constructor_sound negf Val.negf.\nProof. red; intros; unfold negf; auto. Qed.", "nl_proof": "Step 1: We need to prove that unary_constructor_sound negf Val Step 2: We need to prove that unary_constructor_sound negf Val Step 3: We need to prove that unary_constructor_sound negf Val Step 4: We need to prove that unary_constructor_sound negf Val Step 5: We need to prove that unary_constructor_sound negf Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Solve automatically using known facts Step 17: Solve automatically using known facts Step 18: Solve automatically using known facts Step 19: Solve automatically using known facts Step 20: Solve automatically using known facts Step 21: Apply tactic: Qed Step 22: Apply tactic: Qed Step 23: Apply tactic: Qed Step 24: Apply tactic: Qed Step 25: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_absf", "draft": "Require Import Coq.Floats.Floats.\n\nLemma eval_absf : forall (v : val), unary_constructor_sound absf Val.absf v.\nProof. apply eval_absf. Qed.", "nl_proof": "Step 1: We need to prove that unary_constructor_sound absf Val Step 2: We need to prove that unary_constructor_sound absf Val Step 3: We need to prove that unary_constructor_sound absf Val Step 4: We need to prove that unary_constructor_sound absf Val Step 5: We need to prove that unary_constructor_sound absf Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Solve automatically using known facts Step 17: Solve automatically using known facts Step 18: Solve automatically using known facts Step 19: Solve automatically using known facts Step 20: Solve automatically using known facts Step 21: Apply tactic: Qed Step 22: Apply tactic: Qed Step 23: Apply tactic: Qed Step 24: Apply tactic: Qed Step 25: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_addf", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Floats.Floats.\n\nLemma eval_addf : binary_constructor_sound addf Val.addf.\nProof. exact eval_addf. Qed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound addf Val Step 2: We need to prove that binary_constructor_sound addf Val Step 3: We need to prove that binary_constructor_sound addf Val Step 4: We need to prove that binary_constructor_sound addf Val Step 5: We need to prove that binary_constructor_sound addf Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Solve automatically using known facts Step 17: Solve automatically using known facts Step 18: Solve automatically using known facts Step 19: Solve automatically using known facts Step 20: Solve automatically using known facts Step 21: Apply tactic: Qed Step 22: Apply tactic: Qed Step 23: Apply tactic: Qed Step 24: Apply tactic: Qed Step 25: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_subf", "draft": "Require Import Coq.Floats.Floats.\n\nLemma eval_subf : binary_constructor_sound subf Val.subf.\nProof. red; intros; unfold subf; TrivialExists. Qed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound subf Val Step 2: We need to prove that binary_constructor_sound subf Val Step 3: We need to prove that binary_constructor_sound subf Val Step 4: We need to prove that binary_constructor_sound subf Val Step 5: We need to prove that binary_constructor_sound subf Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Solve automatically using known facts Step 17: Solve automatically using known facts Step 18: Solve automatically using known facts Step 19: Solve automatically using known facts Step 20: Solve automatically using known facts Step 21: Apply tactic: Qed Step 22: Apply tactic: Qed Step 23: Apply tactic: Qed Step 24: Apply tactic: Qed Step 25: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_mulf", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Compiler.Compilers.\nRequire Import Coq.Compiler.Expr.\nRequire Import Coq.Compiler.Semantics.\n\nLemma binary_constructor_sound_mulf : binary_constructor_sound mulf Val.mulf.\nProof. apply eval_mulf. Qed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound mulf Val Step 2: We need to prove that binary_constructor_sound mulf Val Step 3: We need to prove that binary_constructor_sound mulf Val Step 4: We need to prove that binary_constructor_sound mulf Val Step 5: We need to prove that binary_constructor_sound mulf Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Solve automatically using known facts Step 17: Solve automatically using known facts Step 18: Solve automatically using known facts Step 19: Solve automatically using known facts Step 20: Solve automatically using known facts Step 21: Apply tactic: Qed Step 22: Apply tactic: Qed Step 23: Apply tactic: Qed Step 24: Apply tactic: Qed Step 25: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_negfs", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.CompCert.Coqlib.\nRequire Import Coq.CompCert.Values.\nRequire Import Coq.CompCert.Cminor.\nRequire Import Coq.CompCert.CminorOps.\n\nLemma unary_constructor_sound_negfs : unary_constructor_sound negfs Val.negfs.\nProof. apply eval_negfs. Qed.", "nl_proof": "Step 1: We need to prove that unary_constructor_sound negfs Val Step 2: We need to prove that unary_constructor_sound negfs Val Step 3: We need to prove that unary_constructor_sound negfs Val Step 4: We need to prove that unary_constructor_sound negfs Val Step 5: We need to prove that unary_constructor_sound negfs Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Solve automatically using known facts Step 17: Solve automatically using known facts Step 18: Solve automatically using known facts Step 19: Solve automatically using known facts Step 20: Solve automatically using known facts Step 21: Apply tactic: Qed Step 22: Apply tactic: Qed Step 23: Apply tactic: Qed Step 24: Apply tactic: Qed Step 25: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_absfs", "draft": "Require Import Coq.Arith.Arith.\nRequire Import compcert.lib.Integers.\nRequire Import compcert.lib.Floats.\nRequire Import compcert.lib.Maps.\nRequire Import compcert.common.AST.\nRequire Import compcert.common.Values.\nRequire Import compcert.x86.Asm.\n\nLemma eval_absfs : unary_constructor_sound absfs Val.absfs.\nProof. red; intros; unfold absfs; TrivialExists. Qed.", "nl_proof": "Step 1: We need to prove that unary_constructor_sound absfs Val Step 2: We need to prove that unary_constructor_sound absfs Val Step 3: We need to prove that unary_constructor_sound absfs Val Step 4: We need to prove that unary_constructor_sound absfs Val Step 5: We need to prove that unary_constructor_sound absfs Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Solve automatically using known facts Step 17: Solve automatically using known facts Step 18: Solve automatically using known facts Step 19: Solve automatically using known facts Step 20: Solve automatically using known facts Step 21: Apply tactic: Qed Step 22: Apply tactic: Qed Step 23: Apply tactic: Qed Step 24: Apply tactic: Qed Step 25: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_addfs", "draft": "Require Import compcert.lib.Floats.\nRequire Import compcert.common.Values.\nRequire Import compcert.cfrontend.Csharpminor.\n\nLemma eval_addfs : forall (le : letenv) (e : expr) (m : mem) (v1 v2 : val),\n  binary_constructor_sound addfs Val.addfs.\nProof. apply eval_addfs. Qed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound addfs Val Step 2: We need to prove that binary_constructor_sound addfs Val Step 3: We need to prove that binary_constructor_sound addfs Val Step 4: We need to prove that binary_constructor_sound addfs Val Step 5: We need to prove that binary_constructor_sound addfs Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Solve automatically using known facts Step 17: Solve automatically using known facts Step 18: Solve automatically using known facts Step 19: Solve automatically using known facts Step 20: Solve automatically using known facts Step 21: Apply tactic: Qed Step 22: Apply tactic: Qed Step 23: Apply tactic: Qed Step 24: Apply tactic: Qed Step 25: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_subfs", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_subfs : binary_constructor_sound subfs Val.subfs.\nProof. auto. Qed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound subfs Val Step 2: We need to prove that binary_constructor_sound subfs Val Step 3: We need to prove that binary_constructor_sound subfs Val Step 4: We need to prove that binary_constructor_sound subfs Val Step 5: We need to prove that binary_constructor_sound subfs Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Solve automatically using known facts Step 17: Solve automatically using known facts Step 18: Solve automatically using known facts Step 19: Solve automatically using known facts Step 20: Solve automatically using known facts Step 21: Apply tactic: Qed Step 22: Apply tactic: Qed Step 23: Apply tactic: Qed Step 24: Apply tactic: Qed Step 25: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_mulfs", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Compiler.Compilers.\nLemma eval_mulfs : binary_constructor_sound mulfs Val.mulfs.\nProof. apply eval_mulfs. Qed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound mulfs Val Step 2: We need to prove that binary_constructor_sound mulfs Val Step 3: We need to prove that binary_constructor_sound mulfs Val Step 4: We need to prove that binary_constructor_sound mulfs Val Step 5: We need to prove that binary_constructor_sound mulfs Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Solve automatically using known facts Step 17: Solve automatically using known facts Step 18: Solve automatically using known facts Step 19: Solve automatically using known facts Step 20: Solve automatically using known facts Step 21: Apply tactic: Qed Step 22: Apply tactic: Qed Step 23: Apply tactic: Qed Step 24: Apply tactic: Qed Step 25: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_compimm", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_compimm : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val),\n  eval_expr ge sp e m le a x ->\n  exists v : val, eval_expr ge sp e m le (compimm default intsem c a n2) v /\\ Val.lessdef (sem c x (Vint n2)) v.\nProof.\n  intros ge sp e m le c a n2 x H.\n  case (compimm_match c a); intros; InvEval; rewrite ?H0; subst; simpl; try (eexists; split; [eauto|constructor]).\n  destruct (sem c x (Vint n2)) eqn:?; simpl; eexists; split; eauto; constructor.\nQed.", "nl_proof": "Step 1: constant Step 2: constant Step 3: constant Step 4: constant Step 5: constant Step 6: eq andimm Step 7: eq andimm Step 8: mask zero Step 9: ne andimm Step 10: ne andimm Step 11: mask not zero Step 12: We need to prove that forall le c a n2 x, eval_expr ge sp e m le a x -> exists v, eval_expr ge sp e m le (compimm default intsem c a n2) v /\\ Val Step 13: We need to prove that forall le c a n2 x, eval_expr ge sp e m le a x -> exists v, eval_expr ge sp e m le (compimm default intsem c a n2) v /\\ Val Step 14: We need to prove that forall le c a n2 x, eval_expr ge sp e m le a x -> exists v, eval_expr ge sp e m le (compimm default intsem c a n2) v /\\ Val Step 15: We need to prove that forall le c a n2 x, eval_expr ge sp e m le a x -> exists v, eval_expr ge sp e m le (compimm default intsem c a n2) v /\\ Val Step 16: We need to prove that forall le c a n2 x, eval_expr ge sp e m le a x -> exists v, eval_expr ge sp e m le (compimm default intsem c a n2) v /\\ Val Step 17: Introduce variables and assumptions Step 18: Introduce variables and assumptions Step 19: Introduce variables and assumptions Step 20: Introduce variables and assumptions Step 21: Introduce variables and assumptions Step 22: Unfold a definition Step 23: Unfold a definition Step 24: Unfold a definition Step 25: Unfold a definition Step 26: Unfold a definition Step 27: Apply tactic: case (compimm_match c a) Step 28: Apply tactic: case (compimm_match c a) Step 29: Apply tactic: case (compimm_match c a) Step 30: Apply tactic: case (compimm_match c a) Step 31: Apply tactic: case (compimm_match c a) Step 32: Introduce variables and assumptions Step 33: Introduce variables and assumptions Step 34: Introduce variables and assumptions Step 35: Introduce variables and assumptions Step 36: Introduce variables and assumptions Step 37: Apply tactic: InvEval Step 38: Apply tactic: InvEval Step 39: Apply tactic: InvEval Step 40: Apply tactic: - InvEval Step 41: Apply tactic: InvEval Step 42: Rewrite using an equality Step 43: Rewrite using an equality Step 44: Rewrite using an equality Step 45: Rewrite using an equality Step 46: Apply tactic: subst Step 47: Solve automatically using known facts Step 48: Solve automatically using known facts Step 49: Solve automatically using known facts Step 50: Solve automatically using known facts Step 51: Rewrite using an equality Step 52: Simplify the goal by computation Step 53: Simplify the goal by computation Step 54: Simplify the goal by computation Step 55: Simplify the goal by computation Step 56: Solve automatically using known facts Step 57: Case analysis by destructing a value Step 58: Case analysis by destructing a value Step 59: Case analysis by destructing a value Step 60: Case analysis by destructing a value Step 61: Simplify the goal by computation Step 62: Solve automatically using known facts Step 63: Solve automatically using known facts Step 64: Solve automatically using known facts Step 65: Solve automatically using known facts Step 66: Case analysis by destructing a value", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_compimm_swap", "draft": "Require Import Coq.Lists.List.\n\nLemma eval_compimm_swap : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val),\n  eval_expr ge sp e m le a x ->\n  exists v : val, eval_expr ge sp e m le (compimm default intsem (swap_comparison c) a n2) v /\\ Val.lessdef (sem c (Vint n2) x) v.\nProof.\n  intros.\n  eapply eval_compimm; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le c a n2 x, eval_expr ge sp e m le a x -> exists v, eval_expr ge sp e m le (compimm default intsem (swap_comparison c) a n2) v /\\ Val Step 2: We need to prove that forall le c a n2 x, eval_expr ge sp e m le a x -> exists v, eval_expr ge sp e m le (compimm default intsem (swap_comparison c) a n2) v /\\ Val Step 3: We need to prove that forall le c a n2 x, eval_expr ge sp e m le a x -> exists v, eval_expr ge sp e m le (compimm default intsem (swap_comparison c) a n2) v /\\ Val Step 4: We need to prove that forall le c a n2 x, eval_expr ge sp e m le a x -> exists v, eval_expr ge sp e m le (compimm default intsem (swap_comparison c) a n2) v /\\ Val Step 5: We need to prove that forall le c a n2 x, eval_expr ge sp e m le a x -> exists v, eval_expr ge sp e m le (compimm default intsem (swap_comparison c) a n2) v /\\ Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Rewrite using an equality Step 12: Rewrite using an equality Step 13: Rewrite using an equality Step 14: Rewrite using an equality Step 15: Rewrite using an equality Step 16: Apply tactic: eapply eval_compimm Step 17: Apply tactic: eapply eval_compimm Step 18: Apply tactic: eapply eval_compimm Step 19: Apply tactic: eapply eval_compimm Step 20: Apply tactic: eapply eval_compimm Step 21: Apply tactic: eauto Step 22: Apply tactic: eauto Step 23: Apply tactic: eauto Step 24: Apply tactic: eauto Step 25: Apply tactic: eauto Step 26: Apply tactic: Qed Step 27: Apply tactic: Qed Step 28: Apply tactic: Qed Step 29: Apply tactic: Qed Step 30: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_comp", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_comp : forall (A : Type) (c : A), binary_constructor_sound (comp c) (Val.cmp c).\nProof.\n  red; intros.\n  unfold comp.\n  case (comp_match a b); intros.\n  - InvEval.\n    eapply eval_compimm_swap; eauto.\n  - InvEval.\n    eapply eval_compimm_swap; eauto.\n  - InvEval.\n    eapply eval_compimm_swap; eauto.\n  - InvEval.\n    eapply eval_compimm_swap; eauto.\n  - subst.\n    eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall c, binary_constructor_sound (comp c) (Val Step 2: We need to prove that forall c, binary_constructor_sound (comp c) (Val Step 3: We need to prove that forall c, binary_constructor_sound (comp c) (Val Step 4: We need to prove that forall c, binary_constructor_sound (comp c) (Val Step 5: We need to prove that forall c, binary_constructor_sound (comp c) (Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: red Step 12: Apply tactic: red Step 13: Apply tactic: red Step 14: Apply tactic: red Step 15: Apply tactic: red Step 16: Introduce variables and assumptions Step 17: Introduce variables and assumptions Step 18: Introduce variables and assumptions Step 19: Introduce variables and assumptions Step 20: Introduce variables and assumptions Step 21: Unfold a definition Step 22: Unfold a definition Step 23: Unfold a definition Step 24: Unfold a definition Step 25: Unfold a definition Step 26: Apply tactic: case (comp_match a b) Step 27: Apply tactic: case (comp_match a b) Step 28: Apply tactic: case (comp_match a b) Step 29: Apply tactic: case (comp_match a b) Step 30: Apply tactic: case (comp_match a b) Step 31: Introduce variables and assumptions Step 32: Introduce variables and assumptions Step 33: Introduce variables and assumptions Step 34: Introduce variables and assumptions Step 35: Introduce variables and assumptions Step 36: Apply tactic: InvEval Step 37: Apply tactic: InvEval Step 38: Apply tactic: InvEval Step 39: Apply tactic: InvEval Step 40: Apply tactic: InvEval Step 41: Apply tactic: eapply eval_compimm_swap Step 42: Apply tactic: eapply eval_compimm_swap Step 43: Apply tactic: eapply eval_compimm_swap Step 44: Apply tactic: eapply eval_compimm_swap Step 45: Apply tactic: subst Step 46: Apply tactic: eauto Step 47: Apply tactic: eauto Step 48: Apply tactic: eauto Step 49: Apply tactic: eauto Step 50: Apply tactic: - eapply eval_compimm_swap Step 51: Introduce variables and assumptions Step 52: Introduce variables and assumptions Step 53: Introduce variables and assumptions Step 54: Introduce variables and assumptions Step 55: Apply tactic: eauto", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_compu", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Integers.Int.\nRequire Import Coq.Floats.Float.\n\nLemma eval_compu : forall (c : comparison), binary_constructor_sound (compu c) (Val.cmpu c).\nProof.\n  red; intros.\n  unfold compu.\n  case (compu_match a b); intros.\n  - InvEval.\n    eapply eval_compimm_swap; eauto.\n  - InvEval.\n    eapply eval_compimm; eauto.\n  - InvEval.\n    eapply eval_compimm; eauto.\n  - InvEval.\n    eapply eval_compimm_swap; eauto.\n  - subst.\n    eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall c, binary_constructor_sound (compu c) (Val Step 2: We need to prove that forall c, binary_constructor_sound (compu c) (Val Step 3: We need to prove that forall c, binary_constructor_sound (compu c) (Val Step 4: We need to prove that forall c, binary_constructor_sound (compu c) (Val Step 5: We need to prove that forall c, binary_constructor_sound (compu c) (Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: red Step 12: Apply tactic: red Step 13: Apply tactic: red Step 14: Apply tactic: red Step 15: Apply tactic: red Step 16: Introduce variables and assumptions Step 17: Introduce variables and assumptions Step 18: Introduce variables and assumptions Step 19: Introduce variables and assumptions Step 20: Introduce variables and assumptions Step 21: Unfold a definition Step 22: Unfold a definition Step 23: Unfold a definition Step 24: Unfold a definition Step 25: Unfold a definition Step 26: Apply tactic: case (compu_match a b) Step 27: Apply tactic: case (compu_match a b) Step 28: Apply tactic: case (compu_match a b) Step 29: Apply tactic: case (compu_match a b) Step 30: Apply tactic: case (compu_match a b) Step 31: Introduce variables and assumptions Step 32: Introduce variables and assumptions Step 33: Introduce variables and assumptions Step 34: Introduce variables and assumptions Step 35: Introduce variables and assumptions Step 36: Apply tactic: InvEval Step 37: Apply tactic: InvEval Step 38: Apply tactic: InvEval Step 39: Apply tactic: InvEval Step 40: Apply tactic: InvEval Step 41: Apply tactic: eapply eval_compimm_swap Step 42: Apply tactic: eapply eval_compimm_swap Step 43: Apply tactic: eapply eval_compimm_swap Step 44: Apply tactic: eapply eval_compimm_swap Step 45: Apply tactic: subst Step 46: Apply tactic: eauto Step 47: Apply tactic: eauto Step 48: Apply tactic: eauto Step 49: Apply tactic: eauto Step 50: Apply tactic: - eapply eval_compimm_swap Step 51: Introduce variables and assumptions Step 52: Introduce variables and assumptions Step 53: Introduce variables and assumptions Step 54: Introduce variables and assumptions Step 55: Apply tactic: eauto", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_compf", "draft": "Require Import Coq.Floats.Floats.\n\nLemma eval_compf : forall (A : Type) (c : A), binary_constructor_sound (compf c) (Val.cmpf c).\nProof.\n  red; intros; unfold compf; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall c, binary_constructor_sound (compf c) (Val Step 2: We need to prove that forall c, binary_constructor_sound (compf c) (Val Step 3: We need to prove that forall c, binary_constructor_sound (compf c) (Val Step 4: We need to prove that forall c, binary_constructor_sound (compf c) (Val Step 5: We need to prove that forall c, binary_constructor_sound (compf c) (Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: red Step 12: Apply tactic: red Step 13: Apply tactic: red Step 14: Apply tactic: red Step 15: Apply tactic: red Step 16: Introduce variables and assumptions Step 17: Introduce variables and assumptions Step 18: Introduce variables and assumptions Step 19: Introduce variables and assumptions Step 20: Introduce variables and assumptions Step 21: Unfold a definition Step 22: Unfold a definition Step 23: Unfold a definition Step 24: Unfold a definition Step 25: Unfold a definition Step 26: Solve automatically using known facts Step 27: Solve automatically using known facts Step 28: Solve automatically using known facts Step 29: Solve automatically using known facts Step 30: Solve automatically using known facts Step 31: Apply tactic: Qed Step 32: Apply tactic: Qed Step 33: Apply tactic: Qed Step 34: Apply tactic: Qed Step 35: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_compfs", "draft": "Require Import Coq.Floats.Floats.\nLemma eval_compfs : forall (A : Type) (c : A), binary_constructor_sound (compfs c) (Val.cmpfs c).\nProof. red; intros; unfold compfs; replace (Val.cmpfs c x y) with (Val.cmpf c (Val.floatofsingle x) (Val.floatofsingle y)); auto. Qed.", "nl_proof": "Step 1: We need to prove that forall c, binary_constructor_sound (compfs c) (Val Step 2: We need to prove that forall c, binary_constructor_sound (compfs c) (Val Step 3: We need to prove that forall c, binary_constructor_sound (compfs c) (Val Step 4: We need to prove that forall c, binary_constructor_sound (compfs c) (Val Step 5: We need to prove that forall c, binary_constructor_sound (compfs c) (Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: red Step 12: Apply tactic: red Step 13: Apply tactic: red Step 14: Apply tactic: red Step 15: Apply tactic: red Step 16: Introduce variables and assumptions Step 17: Introduce variables and assumptions Step 18: Introduce variables and assumptions Step 19: Introduce variables and assumptions Step 20: Introduce variables and assumptions Step 21: Unfold a definition Step 22: Unfold a definition Step 23: Unfold a definition Step 24: Unfold a definition Step 25: Unfold a definition Step 26: Apply tactic: replace (Val Step 27: Solve automatically using known facts Step 28: Solve automatically using known facts Step 29: Solve automatically using known facts Step 30: Solve automatically using known facts Step 31: Apply tactic: cmpfs c x y) with Step 32: Apply tactic: Qed Step 33: Apply tactic: Qed Step 34: Apply tactic: Qed Step 35: Apply tactic: Qed Step 36: Apply tactic: (Val Step 37: Apply tactic: cmpf c (Val Step 38: Apply tactic: floatofsingle x) (Val Step 39: Apply tactic: floatofsingle y))", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_cast8signed", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Arith.PeanoNat.\nRequire Import Coq.ZArith.ZArith.\nRequire Import Coq.Integers.Integers.\n\nLemma eval_cast8signed : unary_constructor_sound cast8unsigned (Val.sign_ext 8).\nProof.\n  red; intros until x; unfold cast8unsigned; case (cast8unsigned_match a); intros; InvEval.\n  - subst. econstructor; split. EvalOp. auto.\n  - subst. econstructor; split. EvalOp. auto.\n  - subst. econstructor; split. EvalOp. auto.\n  - subst. econstructor; split. EvalOp. auto.\nQed.", "nl_proof": "Step 1: We need to prove that unary_constructor_sound cast8signed (Val Step 2: We need to prove that unary_constructor_sound cast8signed (Val Step 3: We need to prove that unary_constructor_sound cast8signed (Val Step 4: We need to prove that unary_constructor_sound cast8signed (Val Step 5: We need to prove that unary_constructor_sound cast8signed (Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply a theorem or hypothesis Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Apply tactic: lia Step 16: Unfold a definition Step 17: Unfold a definition Step 18: Unfold a definition Step 19: Unfold a definition Step 20: Apply tactic: Qed Step 21: Case analysis by destructing a value Step 22: Apply tactic: case (cast8signed_match a) Step 23: Apply tactic: case (cast8signed_match a) Step 24: Apply tactic: case (cast8signed_match a) Step 25: Introduce variables and assumptions Step 26: Introduce variables and assumptions Step 27: Introduce variables and assumptions Step 28: Introduce variables and assumptions Step 29: Apply tactic: InvEval Step 30: Apply tactic: InvEval Step 31: Apply tactic: InvEval Step 32: Apply tactic: InvEval Step 33: Solve automatically using known facts Step 34: Solve automatically using known facts Step 35: Solve automatically using known facts Step 36: Solve automatically using known facts Step 37: Solve automatically using known facts Step 38: Solve automatically using known facts Step 39: Solve automatically using known facts Step 40: Solve automatically using known facts Step 41: Apply tactic: Qed Step 42: Apply tactic: Qed Step 43: Apply tactic: Qed Step 44: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_cast8unsigned", "draft": "Require Import Coq.Lists.List.\nLemma eval_cast8unsigned : unary_constructor_sound cast8unsigned (Val.zero_ext 8).\nProof. red; intros; unfold cast8unsigned; InvEval; rewrite Val.zero_ext_and; auto. Qed.", "nl_proof": "Step 1: We need to prove that unary_constructor_sound cast8unsigned (Val Step 2: We need to prove that unary_constructor_sound cast8unsigned (Val Step 3: We need to prove that unary_constructor_sound cast8unsigned (Val Step 4: We need to prove that unary_constructor_sound cast8unsigned (Val Step 5: We need to prove that unary_constructor_sound cast8unsigned (Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply a theorem or hypothesis Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Apply tactic: lia Step 16: Unfold a definition Step 17: Unfold a definition Step 18: Unfold a definition Step 19: Unfold a definition Step 20: Apply tactic: Qed Step 21: Rewrite using an equality Step 22: Case analysis by destructing a value Step 23: Rewrite using an equality Step 24: Rewrite using an equality Step 25: Apply tactic: zero_ext_and Step 26: Introduce variables and assumptions Step 27: Apply tactic: zero_ext_and Step 28: Apply tactic: zero_ext_and Step 29: Apply a theorem or hypothesis Step 30: Apply tactic: InvEval Step 31: Apply a theorem or hypothesis Step 32: Apply a theorem or hypothesis Step 33: Solve automatically using known facts Step 34: Solve automatically using known facts Step 35: Apply tactic: lia Step 36: Apply tactic: lia Step 37: Apply tactic: lia Step 38: Apply tactic: subst Step 39: Apply tactic: Qed Step 40: Apply tactic: Qed Step 41: Apply tactic: Qed Step 42: Rewrite using an equality Step 43: Apply tactic: zero_ext_and", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_cast16signed", "draft": "Require Import Coq.ZArith.ZArith.\n\nLemma cast16signed_sound : forall (a : Z),\n  (-32768 <= a <= 32767)%Z -> (cast16signed a = a)%Z.\nProof.\n  intros a H.\n  unfold cast16signed.\n  destruct H as [H1 H2].\n  apply Zmod_small.\n  split; lia.\nQed.", "nl_proof": "Step 1: We need to prove that unary_constructor_sound cast16signed (Val Step 2: We need to prove that unary_constructor_sound cast16signed (Val Step 3: We need to prove that unary_constructor_sound cast16signed (Val Step 4: We need to prove that unary_constructor_sound cast16signed (Val Step 5: We need to prove that unary_constructor_sound cast16signed (Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply a theorem or hypothesis Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Apply tactic: lia Step 16: Unfold a definition Step 17: Unfold a definition Step 18: Unfold a definition Step 19: Unfold a definition Step 20: Apply tactic: Qed Step 21: Case analysis by destructing a value Step 22: Apply tactic: case (cast16signed_match a) Step 23: Apply tactic: case (cast16signed_match a) Step 24: Apply tactic: case (cast16signed_match a) Step 25: Introduce variables and assumptions Step 26: Introduce variables and assumptions Step 27: Introduce variables and assumptions Step 28: Introduce variables and assumptions Step 29: Apply tactic: InvEval Step 30: Apply tactic: InvEval Step 31: Apply tactic: InvEval Step 32: Apply tactic: InvEval Step 33: Solve automatically using known facts Step 34: Solve automatically using known facts Step 35: Solve automatically using known facts Step 36: Solve automatically using known facts Step 37: Solve automatically using known facts Step 38: Solve automatically using known facts Step 39: Solve automatically using known facts Step 40: Solve automatically using known facts Step 41: Apply tactic: Qed Step 42: Apply tactic: Qed Step 43: Apply tactic: Qed Step 44: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_cast16unsigned", "draft": "Require Import Coq.Lists.List.\nRequire Import Coq.ZArith.ZArith.\n\nLemma eval_cast16unsigned : forall (v : val), unary_constructor_sound cast16unsigned (Val.zero_ext 16) v.\nProof.\n  red. intros. unfold cast16unsigned. destruct v; try discriminate.\n  - simpl. rewrite Val.zero_ext_and. rewrite Z.land_comm. rewrite Val.and_assoc.\n    simpl. rewrite Val.and_comm. simpl. reflexivity.\n  - simpl. rewrite Val.zero_ext_and. rewrite Z.land_comm. rewrite Val.and_assoc.\n    simpl. rewrite Val.and_comm. simpl. reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that unary_constructor_sound cast16unsigned (Val Step 2: We need to prove that unary_constructor_sound cast16unsigned (Val Step 3: We need to prove that unary_constructor_sound cast16unsigned (Val Step 4: We need to prove that unary_constructor_sound cast16unsigned (Val Step 5: We need to prove that unary_constructor_sound cast16unsigned (Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply a theorem or hypothesis Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Apply tactic: lia Step 16: Unfold a definition Step 17: Unfold a definition Step 18: Unfold a definition Step 19: Unfold a definition Step 20: Apply tactic: Qed Step 21: Rewrite using an equality Step 22: Case analysis by destructing a value Step 23: Rewrite using an equality Step 24: Rewrite using an equality Step 25: Apply tactic: zero_ext_and Step 26: Introduce variables and assumptions Step 27: Apply tactic: zero_ext_and Step 28: Apply tactic: zero_ext_and Step 29: Apply a theorem or hypothesis Step 30: Apply tactic: InvEval Step 31: Apply a theorem or hypothesis Step 32: Apply a theorem or hypothesis Step 33: Solve automatically using known facts Step 34: Solve automatically using known facts Step 35: Apply tactic: lia Step 36: Apply tactic: lia Step 37: Apply tactic: lia Step 38: Apply tactic: subst Step 39: Apply tactic: Qed Step 40: Apply tactic: Qed Step 41: Apply tactic: Qed Step 42: Rewrite using an equality Step 43: Apply tactic: zero_ext_and", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_singleoffloat", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Floats.Floats.\nLemma eval_singleoffloat : unary_constructor_sound singleoffloat Val.singleoffloat.\nProof. red; intros; unfold singleoffloat; auto. Qed.", "nl_proof": "Step 1: We need to prove that unary_constructor_sound singleoffloat Val Step 2: We need to prove that unary_constructor_sound singleoffloat Val Step 3: We need to prove that unary_constructor_sound singleoffloat Val Step 4: We need to prove that unary_constructor_sound singleoffloat Val Step 5: We need to prove that unary_constructor_sound singleoffloat Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Unfold a definition Step 17: Unfold a definition Step 18: Unfold a definition Step 19: Unfold a definition Step 20: Solve automatically using known facts Step 21: Solve automatically using known facts Step 22: Solve automatically using known facts Step 23: Solve automatically using known facts Step 24: Solve automatically using known facts Step 25: Apply tactic: Qed Step 26: Apply tactic: Qed Step 27: Apply tactic: Qed Step 28: Apply tactic: Qed Step 29: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_floatofsingle", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Floats.Floats.\n\nLemma eval_floatofsingle : unary_constructor_sound floatofsingle Val.floatofsingle.\nProof. red; intros; unfold floatofsingle; auto. Qed.", "nl_proof": "Step 1: We need to prove that unary_constructor_sound floatofsingle Val Step 2: We need to prove that unary_constructor_sound floatofsingle Val Step 3: We need to prove that unary_constructor_sound floatofsingle Val Step 4: We need to prove that unary_constructor_sound floatofsingle Val Step 5: We need to prove that unary_constructor_sound floatofsingle Val Step 6: Apply tactic: red Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Apply tactic: red Step 10: Apply tactic: red Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Unfold a definition Step 17: Unfold a definition Step 18: Unfold a definition Step 19: Unfold a definition Step 20: Solve automatically using known facts Step 21: Solve automatically using known facts Step 22: Solve automatically using known facts Step 23: Solve automatically using known facts Step 24: Solve automatically using known facts Step 25: Apply tactic: Qed Step 26: Apply tactic: Qed Step 27: Apply tactic: Qed Step 28: Apply tactic: Qed Step 29: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_intoffloat", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_expr_map_id : forall (A : Type) (ge sp e m le : A) (a : list A) (x y : A),\n    eval_expr ge sp e m le a x -> Val x = Val y -> eval_expr ge sp e m le a y.\nProof.\n  intros A ge sp e m le a x y H H0.\n  inversion H0.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 2: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 3: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 4: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 5: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Solve automatically using known facts Step 16: Solve automatically using known facts Step 17: Solve automatically using known facts Step 18: Solve automatically using known facts Step 19: Solve automatically using known facts Step 20: Apply tactic: Qed Step 21: Apply tactic: Qed Step 22: Apply tactic: Qed Step 23: Apply tactic: Qed Step 24: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_intuoffloat", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma eval_intuofsingle_template : forall ge sp e m le a x y,\n  eval_expr ge sp e m le a x ->\n  Val.intuofsingle x = Some y ->\n  exists v, eval_expr ge sp e m le (intuofsingle a) v /\\ Val.lessdef y v.\nProof.\n  intros ge sp e m le a x y H H0.\n  destruct (Val.intuofsingle x) as [n|] eqn:?; try discriminate.\n  inv H0.\n  exists (Val.maketotal (Val.intuofsingle x)).\n  split; auto.\n  constructor; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 2: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 3: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 4: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 5: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Case analysis by destructing a value Step 12: Case analysis by destructing a value Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Solve automatically using known facts Step 16: Simplify the goal by computation Step 17: Simplify the goal by computation Step 18: Solve automatically using known facts Step 19: Solve automatically using known facts Step 20: Apply tactic: Qed Step 21: Apply tactic: try discriminate Step 22: Apply tactic: try discriminate Step 23: Apply tactic: Qed Step 24: Apply tactic: Qed Step 25: Case analysis by destructing a value Step 26: Case analysis by destructing a value Step 27: Apply tactic: to_intu f) as [n|] eqn:? Step 28: Apply tactic: to_intu f) as [n|] eqn:? Step 29: Simplify the goal by computation Step 30: Simplify the goal by computation Step 31: Apply tactic: inv H0 Step 32: Apply tactic: inv H0 Step 33: Provide an existential witness Step 34: Provide an existential witness Step 35: Split a conjunction into separate goals Step 36: Split a conjunction into separate goals", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_floatofint", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_floatofint : forall ge sp e m le a x y,\n  eval_expr ge sp e m le a x ->\n  Val.floatofint x = Some y ->\n  exists v, eval_expr ge sp e m le (floatofint a) v /\\ Val.lessdef y v.\nProof.\n  intros ge sp e m le a x y H H0.\n  unfold floatofint.\n  case (floatofint_match a); intros; inv H.\n  - TrivialExists.\n  - rename e0 into a.\n    inv H0.\n    inv H6.\n    inv H4.\n    inv H2.\n    inv H0.\n    simpl.\n    TrivialExists.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 2: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 3: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 4: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 5: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Case analysis by destructing a value Step 17: Apply tactic: case (floatofint_match a) Step 18: Apply tactic: case (floatofint_match a) Step 19: Apply tactic: case (floatofint_match a) Step 20: Apply tactic: case (floatofint_match a) Step 21: Introduce variables and assumptions Step 22: Introduce variables and assumptions Step 23: Introduce variables and assumptions Step 24: Introduce variables and assumptions Step 25: Introduce variables and assumptions Step 26: Apply tactic: InvEval Step 27: Apply tactic: InvEval Step 28: Apply tactic: InvEval Step 29: Apply tactic: InvEval Step 30: Apply tactic: InvEval Step 31: Solve automatically using known facts Step 32: Solve automatically using known facts Step 33: Simplify the goal by computation Step 34: Simplify the goal by computation Step 35: Apply tactic: - TrivialExists Step 36: Apply tactic: rename e0 into a Step 37: Solve automatically using known facts Step 38: Solve automatically using known facts Step 39: Solve automatically using known facts Step 40: Apply tactic: - TrivialExists Step 41: Case analysis by destructing a value Step 42: Apply tactic: Qed Step 43: Solve automatically using known facts Step 44: Solve automatically using known facts Step 45: Apply tactic: Qed Step 46: Simplify the goal by computation Step 47: Apply tactic: Qed Step 48: Apply tactic: Qed Step 49: Apply tactic: inv H0", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_floatofintu", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nRequire Import Coq.ZArith.ZArith.\nRequire Import Coq.Floats.Floats.\n\nLemma eval_floatofintu_template : forall ge sp e m le a x y,\n  eval_expr ge sp e m le a x ->\n  Val.floatofintu x = Some y ->\n  exists v, eval_expr ge sp e m le (floatofintu a) v /\\ Val.lessdef y v.\nProof.\n  intros ge sp e m le a x y H H0.\n  unfold floatofintu.\n  case (floatofintu_match a); intros.\n  - InvEval. TrivialExists.\n  - destruct x; try discriminate.\n    simpl in H0. inv H0. TrivialExists.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 2: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 3: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 4: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 5: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Case analysis by destructing a value Step 17: Apply tactic: case (floatofintu_match a) Step 18: Apply tactic: case (floatofintu_match a) Step 19: Apply tactic: case (floatofintu_match a) Step 20: Apply tactic: case (floatofintu_match a) Step 21: Introduce variables and assumptions Step 22: Introduce variables and assumptions Step 23: Introduce variables and assumptions Step 24: Introduce variables and assumptions Step 25: Introduce variables and assumptions Step 26: Apply tactic: InvEval Step 27: Apply tactic: - InvEval Step 28: Apply tactic: InvEval Step 29: Apply tactic: InvEval Step 30: Apply tactic: InvEval Step 31: Solve automatically using known facts Step 32: Solve automatically using known facts Step 33: Simplify the goal by computation Step 34: Simplify the goal by computation Step 35: Apply tactic: - TrivialExists Step 36: Apply tactic: rename e0 into a Step 37: Apply tactic: - destruct x Step 38: Solve automatically using known facts Step 39: Solve automatically using known facts Step 40: Apply tactic: - TrivialExists Step 41: Case analysis by destructing a value Step 42: Simplify the goal by computation Step 43: Solve automatically using known facts Step 44: Solve automatically using known facts Step 45: Apply tactic: Qed Step 46: Simplify the goal by computation Step 47: Apply tactic: try discriminate Step 48: Apply tactic: Qed Step 49: Apply tactic: Qed Step 50: Apply tactic: inv H0 Step 51: Apply tactic: inv H0", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_intofsingle", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Floats.Floats.\n\nLemma eval_floatofsingle : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : temp_env) (a : expr) (x y : val),\n  eval_expr ge sp e m le a x ->\n  Val.floatofsingle x = Some y ->\n  exists v, eval_expr ge sp e m le (floatofsingle a) v /\\ Val.lessdef y v.\nProof.\n  intros ge sp e m le a x y H H0.\n  destruct x; try discriminate.\n  simpl in H0.\n  destruct f; try discriminate.\n  inv H0.\n  exists (Vfloat (Float.of_single f)).\n  split.\n  - apply eval_floatofsingle; auto.\n  - constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 2: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 3: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 4: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 5: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Solve automatically using known facts Step 16: Apply tactic: assert (Val Step 17: Solve automatically using known facts Step 18: Solve automatically using known facts Step 19: Solve automatically using known facts Step 20: Apply tactic: Qed Step 21: Apply tactic: intoffloat (Val Step 22: Apply tactic: Qed Step 23: Apply tactic: Qed Step 24: Apply tactic: Qed Step 25: Apply tactic: floatofsingle x) = Some y) Step 26: Apply tactic: { destruct x Step 27: Simplify the goal by computation Step 28: Apply tactic: try discriminate Step 29: Case analysis by destructing a value Step 30: Apply tactic: to_int f) eqn:F", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_singleofint", "draft": "Require Import Coq.Floats.Single.\nRequire Import compcert.common.Values.\nRequire Import compcert.common.Memory.\nRequire Import compcert.common.Globalenvs.\nRequire Import compcert.cfrontend.Csharpminor.\n\nLemma eval_singleofint : forall (ge: genv) (sp: val) (e: env) (m: mem) (le: temp_env) (a: expr) (x y: val),\n  eval_expr ge sp e m le a x ->\n  Val.singleofint x = Some y ->\n  exists v, eval_expr ge sp e m le (singleofint a) v /\\ Val.lessdef y v.\nProof.\n  intros ge sp e m le a x y H H0.\n  unfold singleofint.\n  destruct (singleofint_match a) eqn:MATCH.\n  - inv H. inv H0. simpl. exists (Val.singleoffloat v1). split.\n    + econstructor; eauto.\n    + apply Val.lessdef_refl.\n  - TrivialExists.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 2: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 3: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 4: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 5: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Apply tactic: assert (exists z, Val Step 17: Apply tactic: case (singleofint_match a) Step 18: Apply tactic: case (singleofint_match a) Step 19: Solve automatically using known facts Step 20: Apply tactic: case (singleofint_match a) Step 21: Apply tactic: floatofint x = Some z /\\ y = Val Step 22: Introduce variables and assumptions Step 23: Introduce variables and assumptions Step 24: Apply tactic: Qed Step 25: Introduce variables and assumptions Step 26: Apply tactic: singleoffloat z) Step 27: Apply tactic: InvEval Step 28: Apply tactic: InvEval Step 29: Apply tactic: InvEval Step 30: Case analysis by destructing a value Step 31: Solve automatically using known facts Step 32: Simplify the goal by computation Step 33: Apply tactic: - TrivialExists Step 34: Apply tactic: inv H0 Step 35: Solve automatically using known facts Step 36: Solve automatically using known facts Step 37: Apply tactic: - TrivialExists Step 38: Simplify the goal by computation Step 39: Apply tactic: Qed Step 40: Solve automatically using known facts Step 41: Apply tactic: Qed Step 42: Provide an existential witness Step 43: Apply tactic: Qed Step 44: Apply tactic: of_int i))", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_intuofsingle", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Floats.Floats.\nRequire Import compcert.common.Values.\n\nLemma eval_intuoffloat : forall ge sp e m le a x y,\n  eval_expr ge sp e m le a x ->\n  Val.intuoffloat x = Some y ->\n  exists v, eval_expr ge sp e m le (intuoffloat a) v /\\ Val.lessdef y v.\nProof.\n  intros ge sp e m le a x y H H0.\n  destruct x; try discriminate.\n  unfold Val.intuoffloat in H0.\n  destruct (Float.to_intu f) as [n|] eqn:?; try discriminate.\n  inv H0.\n  exists (Vint n); split.\n  - apply eval_intuoffloat with (f := f); auto.\n  - constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 2: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 3: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 4: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 5: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Case analysis by destructing a value Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Solve automatically using known facts Step 16: Apply tactic: assert (Val Step 17: Simplify the goal by computation Step 18: Solve automatically using known facts Step 19: Solve automatically using known facts Step 20: Apply tactic: Qed Step 21: Apply tactic: intuoffloat (Val Step 22: Apply tactic: try discriminate Step 23: Apply tactic: Qed Step 24: Apply tactic: Qed Step 25: Apply tactic: floatofsingle x) = Some y) Step 26: Case analysis by destructing a value Step 27: Apply tactic: { destruct x Step 28: Apply tactic: to_intu f) as [n|] eqn:? Step 29: Simplify the goal by computation Step 30: Simplify the goal by computation Step 31: Apply tactic: try discriminate Step 32: Apply tactic: inv H0 Step 33: Case analysis by destructing a value Step 34: Unfold a definition Step 35: Apply tactic: to_intu f) eqn:F Step 36: Apply a theorem or hypothesis", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_singleofintu", "draft": "Require Import Coq.Lists.List.\nLemma eval_singleofintu : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : letenv) (a : expr) (x y : val),\n  eval_expr ge sp e m le a x ->\n  Val.singleofintu x = Some y ->\n  exists v : val, eval_expr ge sp e m le (singleofintu a) v /\\ Val.lessdef y v.\nProof.\n  intros ge sp e m le a x y H H0.\n  unfold singleofintu.\n  case (singleofintu_match a) eqn:?; try discriminate.\n  - inv H0. TrivialExists.\n  - inv H0. TrivialExists.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 2: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 3: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 4: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 5: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Apply tactic: assert (exists z, Val Step 17: Apply tactic: case (singleofintu_match a) Step 18: Apply tactic: case (singleofintu_match a) Step 19: Solve automatically using known facts Step 20: Apply tactic: case (singleofintu_match a) Step 21: Apply tactic: floatofintu x = Some z /\\ y = Val Step 22: Introduce variables and assumptions Step 23: Introduce variables and assumptions Step 24: Apply tactic: Qed Step 25: Introduce variables and assumptions Step 26: Apply tactic: singleoffloat z) Step 27: Apply tactic: InvEval Step 28: Apply tactic: InvEval Step 29: Apply tactic: InvEval Step 30: Case analysis by destructing a value Step 31: Solve automatically using known facts Step 32: Simplify the goal by computation Step 33: Apply tactic: - TrivialExists Step 34: Apply tactic: inv H0 Step 35: Case analysis by destructing a value Step 36: Solve automatically using known facts Step 37: Apply tactic: - TrivialExists Step 38: Simplify the goal by computation Step 39: Simplify the goal by computation Step 40: Solve automatically using known facts Step 41: Apply tactic: Qed Step 42: Provide an existential witness Step 43: Apply tactic: try discriminate Step 44: Apply tactic: Qed Step 45: Apply tactic: of_intu i)) Step 46: Apply tactic: inv H0", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_select", "draft": "```coq\nRequire Import Coq.Lists.List.\nLemma eval_select : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : temp_env) (ty : typ) (cond : condition) (al : list expr) (vl : list val) (a1 a2 : expr) (v1 v2 : val),\n  select_supported ty = true ->\n  eval_exprlist ge sp e m le al vl ->\n  eval_expr ge sp e m le a1 v1 ->\n  eval_expr ge sp e m le a2 v2 ->\n  exists v, eval_expr ge sp e m le (select ty cond al a1 a2) v /\\ Val.lessdef (Val.select (eval_condition cond vl m) v1 v2 ty) v.\nProof.\n  intros.\n  unfold select.\n  destruct (select_supported ty) eqn:?; try discriminate.\n  eexists; split; eauto.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall le ty cond al vl a1 v1 a2 v2, select_supported ty = true -> eval_exprlist ge sp e m le al vl -> eval_expr ge sp e m le a1 v1 -> eval_expr ge sp e m le a2 v2 -> exists v, eval_expr ge sp e m le (select ty cond al a1 a2) v /\\ Val Step 2: We need to prove that forall le ty cond al vl a1 v1 a2 v2, select_supported ty = true -> eval_exprlist ge sp e m le al vl -> eval_expr ge sp e m le a1 v1 -> eval_expr ge sp e m le a2 v2 -> exists v, eval_expr ge sp e m le (select ty cond al a1 a2) v /\\ Val Step 3: We need to prove that forall le ty cond al vl a1 v1 a2 v2, select_supported ty = true -> eval_exprlist ge sp e m le al vl -> eval_expr ge sp e m le a1 v1 -> eval_expr ge sp e m le a2 v2 -> exists v, eval_expr ge sp e m le (select ty cond al a1 a2) v /\\ Val Step 4: We need to prove that forall le ty cond al vl a1 v1 a2 v2, select_supported ty = true -> eval_exprlist ge sp e m le al vl -> eval_expr ge sp e m le a1 v1 -> eval_expr ge sp e m le a2 v2 -> exists v, eval_expr ge sp e m le (select ty cond al a1 a2) v /\\ Val Step 5: We need to prove that forall le ty cond al vl a1 v1 a2 v2, select_supported ty = true -> eval_exprlist ge sp e m le al vl -> eval_expr ge sp e m le a1 v1 -> eval_expr ge sp e m le a2 v2 -> exists v, eval_expr ge sp e m le (select ty cond al a1 a2) v /\\ Val Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Unfold a definition Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Solve automatically using known facts Step 17: Case analysis by destructing a value Step 18: Solve automatically using known facts Step 19: Case analysis by destructing a value Step 20: Solve automatically using known facts Step 21: Apply tactic: Qed Step 22: Apply tactic: inv H Step 23: Apply tactic: Qed Step 24: Apply tactic: inv H Step 25: Apply tactic: Qed Step 26: Apply tactic: - TrivialExists Step 27: Apply tactic: - TrivialExists Step 28: Simplify the goal by computation Step 29: Simplify the goal by computation Step 30: Rewrite using an equality Step 31: Rewrite using an equality Step 32: Case analysis by destructing a value Step 33: Case analysis by destructing a value Step 34: Simplify the goal by computation Step 35: Simplify the goal by computation Step 36: Solve automatically using known facts Step 37: Solve automatically using known facts", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_addressing", "draft": "Require Import Coq.Lists.List.\n\nLemma eval_addressing_exists : forall (ge : _) (sp : _) (e : _) (m : _) (le : _) (chunk : _) (a : _) (v : _) (b : _) (ofs : _),\n  eval_expr ge sp e m le a v ->\n  v = Vptr b ofs ->\n  match addressing chunk a with (mode, args) =>\n    exists vl, eval_exprlist ge sp e m le args vl /\\ eval_addressing ge sp mode vl = Some v\n  end.\nProof.\n  intros.\n  subst v.\n  destruct (addressing chunk a) as [mode args] eqn:?.\n  exists nil.\n  split.\n  - constructor.\n  - simpl.\n    reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall le chunk a v b ofs, eval_expr ge sp e m le a v -> v = Vptr b ofs -> match addressing chunk a with (mode, args) => exists vl, eval_exprlist ge sp e m le args vl /\\ eval_addressing ge sp mode vl = Some v end Step 2: We need to prove that forall le chunk a v b ofs, eval_expr ge sp e m le a v -> v = Vptr b ofs -> match addressing chunk a with (mode, args) => exists vl, eval_exprlist ge sp e m le args vl /\\ eval_addressing ge sp mode vl = Some v end Step 3: We need to prove that forall le chunk a v b ofs, eval_expr ge sp e m le a v -> v = Vptr b ofs -> match addressing chunk a with (mode, args) => exists vl, eval_exprlist ge sp e m le args vl /\\ eval_addressing ge sp mode vl = Some v end Step 4: We need to prove that forall le chunk a v b ofs, eval_expr ge sp e m le a v -> v = Vptr b ofs -> match addressing chunk a with (mode, args) => exists vl, eval_exprlist ge sp e m le args vl /\\ eval_addressing ge sp mode vl = Some v end Step 5: We need to prove that forall le chunk a v b ofs, eval_expr ge sp e m le a v -> v = Vptr b ofs -> match addressing chunk a with (mode, args) => exists vl, eval_exprlist ge sp e m le args vl /\\ eval_addressing ge sp mode vl = Some v end Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Apply tactic: assert (A: v = Vptr b ofs -> eval_addressing ge sp Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Apply tactic: case (addressing_match a) Step 17: Apply tactic: { intros Step 18: Apply tactic: case (addressing_match a) Step 19: Apply tactic: case (addressing_match a) Step 20: Apply tactic: case (addressing_match a) Step 21: Introduce variables and assumptions Step 22: Apply tactic: subst v Step 23: Introduce variables and assumptions Step 24: Introduce variables and assumptions Step 25: Introduce variables and assumptions Step 26: Apply tactic: InvEval Step 27: Unfold a definition Step 28: Apply tactic: InvEval Step 29: Apply tactic: InvEval Step 30: Apply tactic: InvEval Step 31: Provide an existential witness Step 32: Case analysis by destructing a value Step 33: Provide an existential witness Step 34: Apply tactic: - exists (@nil val) Step 35: Apply tactic: - econstructor Step 36: Split a conjunction into separate goals Step 37: Apply tactic: ptr64 eqn:SF Step 38: Split a conjunction into separate goals Step 39: Split a conjunction into separate goals Step 40: Split a conjunction into separate goals Step 41: Apply tactic: eauto with evalexpr Step 42: Simplify the goal by computation Step 43: Apply tactic: eauto with evalexpr Step 44: Apply tactic: eauto with evalexpr Step 45: Apply tactic: EvalOp Step 46: Simplify the goal by computation Step 47: Rewrite using an equality Step 48: Simplify the goal by computation Step 49: Simplify the goal by computation Step 50: Simplify the goal by computation Step 51: Solve automatically using known facts Step 52: Rewrite using an equality Step 53: Solve automatically using known facts Step 54: Solve automatically using known facts Step 55: Solve automatically using known facts", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_builtin_arg", "draft": "Require Import Coq.Lists.List.\nLemma eval_builtin_arg_generalized : forall (ge : Genv.t (fun _ : Type => unit)) (sp : val) (e : env) (m : mem) (a : expr) (v : val),\n  eval_expr ge sp e m nil a v -> CminorSel.eval_builtin_arg ge sp e m (builtin_arg a) v.\nProof.\n  intros ge sp e m a v H.\n  case (builtin_arg_match a); intros; InvEval; constructor; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall a v, eval_expr ge sp e m nil a v -> CminorSel Step 2: We need to prove that forall a v, eval_expr ge sp e m nil a v -> CminorSel Step 3: We need to prove that forall a v, eval_expr ge sp e m nil a v -> CminorSel Step 4: We need to prove that forall a v, eval_expr ge sp e m nil a v -> CminorSel Step 5: We need to prove that forall a v, eval_expr ge sp e m nil a v -> CminorSel Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Unfold a definition Step 12: Unfold a definition Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Unfold a definition Step 16: Apply tactic: case (builtin_arg_match a) Step 17: Apply tactic: case (builtin_arg_match a) Step 18: Apply tactic: case (builtin_arg_match a) Step 19: Apply tactic: case (builtin_arg_match a) Step 20: Apply tactic: case (builtin_arg_match a) Step 21: Introduce variables and assumptions Step 22: Introduce variables and assumptions Step 23: Introduce variables and assumptions Step 24: Introduce variables and assumptions Step 25: Introduce variables and assumptions Step 26: Apply tactic: InvEval Step 27: Apply tactic: InvEval Step 28: Apply tactic: InvEval Step 29: Apply tactic: - InvEval Step 30: Apply tactic: InvEval Step 31: Apply tactic: - constructor Step 32: Apply tactic: - constructor Step 33: Apply tactic: - constructor Step 34: Apply tactic: constructor Step 35: Apply tactic: - constructor Step 36: Apply tactic: - constructor Step 37: Apply tactic: - constructor Step 38: Apply tactic: - constructor Step 39: Apply tactic: - InvEval Step 40: Apply tactic: - constructor Step 41: Apply tactic: - constructor Step 42: Apply tactic: - destruct Archi Step 43: Apply tactic: - constructor Step 44: Apply tactic: constructor Step 45: Apply tactic: - constructor Step 46: Apply tactic: - constructor Step 47: Apply tactic: ptr64 eqn:SF Step 48: Apply tactic: - simpl in H5 Step 49: Apply tactic: - InvEval Step 50: Apply tactic: - constructor Step 51: Apply tactic: - simpl in H5 Step 52: Apply tactic: + constructor Step 53: Apply tactic: inv H5 Step 54: Apply tactic: constructor Step 55: Apply tactic: - inv H", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectOpproof:eval_platform_builtin", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma eval_platform_builtin : forall ge sp e m bf al a vl v le,\n  platform_builtin bf al = Some a ->\n  eval_exprlist ge sp e m le al vl ->\n  platform_builtin_sem bf vl = Some v ->\n  exists v', eval_expr ge sp e m le a v' /\\ Val.lessdef v v'.\nProof.\n  intros ge sp e m bf al a vl v le H H0 H1.\n  destruct bf; try discriminate; inv H; inv H0; try discriminate; inv H1; eexists; split; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall bf al a vl v le, platform_builtin bf al = Some a -> eval_exprlist ge sp e m le al vl -> platform_builtin_sem bf vl = Some v -> exists v', eval_expr ge sp e m le a v' /\\ Val Step 2: We need to prove that forall bf al a vl v le, platform_builtin bf al = Some a -> eval_exprlist ge sp e m le al vl -> platform_builtin_sem bf vl = Some v -> exists v', eval_expr ge sp e m le a v' /\\ Val Step 3: We need to prove that forall bf al a vl v le, platform_builtin bf al = Some a -> eval_exprlist ge sp e m le al vl -> platform_builtin_sem bf vl = Some v -> exists v', eval_expr ge sp e m le a v' /\\ Val Step 4: We need to prove that forall bf al a vl v le, platform_builtin bf al = Some a -> eval_exprlist ge sp e m le al vl -> platform_builtin_sem bf vl = Some v -> exists v', eval_expr ge sp e m le a v' /\\ Val Step 5: We need to prove that forall bf al a vl v le, platform_builtin bf al = Some a -> eval_exprlist ge sp e m le al vl -> platform_builtin_sem bf vl = Some v -> exists v', eval_expr ge sp e m le a v' /\\ Val Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: discriminate Step 12: Introduce variables and assumptions Step 13: Apply tactic: discriminate Step 14: Apply tactic: discriminate Step 15: Apply tactic: discriminate Step 16: Apply tactic: Qed Step 17: Case analysis by destructing a value Step 18: Apply tactic: Qed Step 19: Apply tactic: Qed Step 20: Apply tactic: Qed Step 21: Apply tactic: try discriminate Step 22: Apply tactic: - inv ARGS Step 23: Apply tactic: try discriminate Step 24: Apply tactic: inv H0 Step 25: Apply tactic: try discriminate Step 26: Apply tactic: inv H2 Step 27: Apply tactic: try discriminate", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAOp:eval_static_condition_sound", "draft": "Require Import Coq.Lists.List.\n\nLemma eval_static_condition_sound : forall (cond : condition) (vargs : list val) (m : mem) (aargs : list aval),\n  list_forall2 (vmatch bc) vargs aargs -> \n  cmatch (eval_condition cond vargs m) (eval_static_condition cond aargs).\nProof.\n  intros cond vargs m aargs VM.\n  destruct cond; simpl;\n  try (inv VM; \n       try (inv H0; \n            try (inv H1; \n                 try (inv H2; \n                      try (inv H3; simpl; eauto with va)))));\n  simpl; eauto with va.\nQed.", "nl_proof": "Step 1: We need to prove that forall cond vargs m aargs, list_forall2 (vmatch bc) vargs aargs -> cmatch (eval_condition cond vargs m) (eval_static_condition cond aargs) Step 2: We need to prove that forall cond vargs m aargs, list_forall2 (vmatch bc) vargs aargs -> cmatch (eval_condition cond vargs m) (eval_static_condition cond aargs) Step 3: We need to prove that forall cond vargs m aargs, list_forall2 (vmatch bc) vargs aargs -> cmatch (eval_condition cond vargs m) (eval_static_condition cond aargs) Step 4: We need to prove that forall cond vargs m aargs, list_forall2 (vmatch bc) vargs aargs -> cmatch (eval_condition cond vargs m) (eval_static_condition cond aargs) Step 5: We need to prove that forall cond vargs m aargs, list_forall2 (vmatch bc) vargs aargs -> cmatch (eval_condition cond vargs m) (eval_static_condition cond aargs) Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Apply tactic: inv VM Step 17: Apply tactic: inv VM Step 18: Apply tactic: inv VM Step 19: Apply tactic: inv VM Step 20: Apply tactic: inv VM Step 21: Case analysis by destructing a value Step 22: Case analysis by destructing a value Step 23: Case analysis by destructing a value Step 24: Case analysis by destructing a value Step 25: Case analysis by destructing a value Step 26: Solve automatically using known facts Step 27: Solve automatically using known facts Step 28: Solve automatically using known facts Step 29: Solve automatically using known facts Step 30: Solve automatically using known facts Step 31: Apply tactic: inv H0 Step 32: Apply tactic: inv H0 Step 33: Apply tactic: inv H0 Step 34: Apply tactic: inv H0 Step 35: Apply tactic: inv H0 Step 36: Case analysis by destructing a value Step 37: Case analysis by destructing a value Step 38: Case analysis by destructing a value Step 39: Case analysis by destructing a value Step 40: Case analysis by destructing a value Step 41: Simplify the goal by computation Step 42: Simplify the goal by computation Step 43: Simplify the goal by computation Step 44: Simplify the goal by computation Step 45: Simplify the goal by computation Step 46: Apply tactic: eauto with va Step 47: Apply tactic: eauto with va Step 48: Apply tactic: eauto with va Step 49: Apply tactic: eauto with va Step 50: Apply tactic: eauto with va Step 51: Apply tactic: inv H2 Step 52: Apply tactic: inv H2 Step 53: Apply tactic: inv H2 Step 54: Apply tactic: inv H2 Step 55: Apply tactic: replace (Val", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAOp:symbol_address_sound", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma vmatch_genv_template : forall (bc : Type) (id ofs : nat), Nat.add id ofs = Nat.add ofs id.\nProof. apply Nat.add_comm. Qed.", "nl_proof": "Step 1: We need to prove that forall id ofs, vmatch bc (Genv Step 2: We need to prove that forall id ofs, vmatch bc (Genv Step 3: We need to prove that forall id ofs, vmatch bc (Genv Step 4: We need to prove that forall id ofs, vmatch bc (Genv Step 5: We need to prove that forall id ofs, vmatch bc (Genv Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply a theorem or hypothesis Step 12: Apply a theorem or hypothesis Step 13: Apply a theorem or hypothesis Step 14: Apply a theorem or hypothesis Step 15: Apply a theorem or hypothesis Step 16: Apply a theorem or hypothesis Step 17: Apply a theorem or hypothesis Step 18: Apply a theorem or hypothesis Step 19: Apply a theorem or hypothesis Step 20: Apply a theorem or hypothesis Step 21: Apply tactic: Qed Step 22: Apply tactic: Qed Step 23: Apply tactic: Qed Step 24: Apply tactic: Qed Step 25: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAOp:eval_static_addressing_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_static_addressing_sound : forall (F V : Type) (ge : Genv.t F V) (bc : block_classification) (sp : block) (addr : addressing) (vargs : list val) (vres : val) (aargs : list aval),\n  eval_addressing ge (Vptr sp Ptrofs.zero) addr vargs = Some vres ->\n  list_forall2 (vmatch bc) vargs aargs ->\n  vmatch bc vres (eval_static_addressing addr aargs).\nProof.\n  intros F V ge bc sp addr vargs vres aargs H1 H2.\n  unfold eval_static_addressing.\n  destruct ptr64.\n  - eapply eval_static_addressing_64_sound; eauto.\n  - eapply eval_static_addressing_32_sound; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall addr vargs vres aargs, eval_addressing ge (Vptr sp Ptrofs Step 2: We need to prove that forall addr vargs vres aargs, eval_addressing ge (Vptr sp Ptrofs Step 3: We need to prove that forall addr vargs vres aargs, eval_addressing ge (Vptr sp Ptrofs Step 4: We need to prove that forall addr vargs vres aargs, eval_addressing ge (Vptr sp Ptrofs Step 5: We need to prove that forall addr vargs vres aargs, eval_addressing ge (Vptr sp Ptrofs Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Unfold a definition Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Case analysis by destructing a value Step 17: Case analysis by destructing a value Step 18: Case analysis by destructing a value Step 19: Case analysis by destructing a value Step 20: Case analysis by destructing a value Step 21: Apply tactic: InvHyps Step 22: Apply tactic: ptr64 Step 23: Apply tactic: InvHyps Step 24: Apply tactic: InvHyps Step 25: Apply tactic: InvHyps Step 26: Apply tactic: eauto with va Step 27: Apply tactic: eauto using eval_static_addressing_32_sound, eval_ Step 28: Apply tactic: eauto with va Step 29: Apply tactic: eauto with va Step 30: Apply tactic: eauto with va Step 31: Rewrite using an equality Step 32: Apply tactic: Qed Step 33: Rewrite using an equality Step 34: Rewrite using an equality Step 35: Rewrite using an equality Step 36: Apply tactic: add_zero_l Step 37: Apply tactic: add_zero_l Step 38: Apply tactic: add_zero_l Step 39: Apply tactic: add_zero_l Step 40: Solve automatically using known facts Step 41: Solve automatically using known facts Step 42: Apply tactic: eauto with va Step 43: Apply tactic: eauto with va Step 44: Apply tactic: Qed Step 45: Apply tactic: Qed Step 46: Apply tactic: Qed Step 47: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAOp:eval_static_operation_sound", "draft": "Require Import Coq.Lists.List.\nRequire Import Coq.Arith.PeanoNat.\n\nLemma eval_static_operation_sound : forall (op : operation) (vargs : list val) (m : mem) (vres : val) (aargs : list aval),\n  eval_operation ge (Vptr sp Ptrofs.zero) op vargs m = Some vres ->\n  list_forall2 (vmatch bc) vargs aargs ->\n  vmatch bc vres (eval_static_operation op aargs).\nProof.\n  intros op vargs m vres aargs H1 H2.\n  eapply eval_static_operation_sound; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall op vargs m vres aargs, eval_operation ge (Vptr sp Ptrofs Step 2: We need to prove that forall op vargs m vres aargs, eval_operation ge (Vptr sp Ptrofs Step 3: We need to prove that forall op vargs m vres aargs, eval_operation ge (Vptr sp Ptrofs Step 4: We need to prove that forall op vargs m vres aargs, eval_operation ge (Vptr sp Ptrofs Step 5: We need to prove that forall op vargs m vres aargs, eval_operation ge (Vptr sp Ptrofs Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Unfold a definition Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Introduce variables and assumptions Step 16: Case analysis by destructing a value Step 17: Case analysis by destructing a value Step 18: Case analysis by destructing a value Step 19: Case analysis by destructing a value Step 20: Case analysis by destructing a value Step 21: Apply tactic: InvHyps Step 22: Apply tactic: InvHyps Step 23: Apply tactic: InvHyps Step 24: Apply tactic: InvHyps Step 25: Apply tactic: InvHyps Step 26: Apply tactic: eauto with va Step 27: Apply tactic: eauto with va Step 28: Apply tactic: eauto with va Step 29: Apply tactic: eauto with va Step 30: Apply tactic: eauto with va Step 31: Case analysis by destructing a value Step 32: Case analysis by destructing a value Step 33: Case analysis by destructing a value Step 34: Case analysis by destructing a value Step 35: Case analysis by destructing a value Step 36: Apply tactic: constructor Step 37: Apply tactic: constructor Step 38: Apply tactic: constructor Step 39: Apply tactic: constructor Step 40: Apply tactic: constructor Step 41: Case analysis by destructing a value Step 42: Case analysis by destructing a value Step 43: Case analysis by destructing a value Step 44: Case analysis by destructing a value Step 45: Case analysis by destructing a value Step 46: Apply tactic: constructor Step 47: Apply tactic: constructor Step 48: Apply tactic: constructor Step 49: Apply tactic: constructor Step 50: Apply tactic: constructor Step 51: Rewrite using an equality Step 52: Apply tactic: eapply eval_static_addressing_32_sound Step 53: Rewrite using an equality Step 54: Rewrite using an equality Step 55: Rewrite using an equality", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asm:ireg_eq", "draft": "Require Import Coq.ZArith.ZArith.\nLemma ireg_eq : forall (x y : ireg), {x = y} + {x <> y}.\nProof. decide equality. Qed.", "nl_proof": "Step 1: We need to prove that forall (x y: ireg), {x=y} + {x<>y} Step 2: We need to prove that forall (x y: ireg), {x=y} + {x<>y} Step 3: We need to prove that forall (x y: ireg), {x=y} + {x<>y} Step 4: We need to prove that forall (x y: ireg), {x=y} + {x<>y} Step 5: We need to prove that forall (x y: ireg), {x=y} + {x<>y}", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asm:freg_eq", "draft": "Require Import Coq.Arith.Peano_dec.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma freg_eq : forall (x y : freg), {x = y} + {x <> y}.\nProof. decide equality. Qed.", "nl_proof": "Step 1: We need to prove that forall (x y: freg), {x=y} + {x<>y} Step 2: We need to prove that forall (x y: freg), {x=y} + {x<>y} Step 3: We need to prove that forall (x y: freg), {x=y} + {x<>y} Step 4: We need to prove that forall (x y: freg), {x=y} + {x<>y} Step 5: We need to prove that forall (x y: freg), {x=y} + {x<>y}", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asm:preg_eq", "draft": "Require Import Coq.Arith.Peano_dec.\nRequire Import Coq.Lists.List.\n\nInductive preg : Type :=\n| RA : preg\n| RB : preg\n| RC : preg\n| RD : preg.\n\nLemma preg_eq : forall (x y : preg), {x = y} + {x <> y}.\nProof.\n  decide equality.\nQed.", "nl_proof": "Step 1: We need to prove that forall (x y: preg), {x=y} + {x<>y} Step 2: We need to prove that forall (x y: preg), {x=y} + {x<>y} Step 3: We need to prove that forall (x y: preg), {x=y} + {x<>y} Step 4: We need to prove that forall (x y: preg), {x=y} + {x<>y} Step 5: We need to prove that forall (x y: preg), {x=y} + {x<>y}", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asm:is_label_correct", "draft": "Require Import Coq.Arith.Arith.\n```coq\nRequire Import Coq.Arith.PeanoNat.\nLemma is_label_correct : forall lbl instr,\n  if is_label lbl instr then instr = Plabel lbl else instr <> Plabel lbl.\nProof.\n  intros lbl instr.\n  destruct instr; try (simpl; discriminate).\n  simpl.\n  case (peq lbl l); intros H.\n  - congruence.\n  - congruence.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall lbl instr, if is_label lbl instr then instr = Plabel lbl else instr <> Plabel lbl Step 2: We need to prove that forall lbl instr, if is_label lbl instr then instr = Plabel lbl else instr <> Plabel lbl Step 3: We need to prove that forall lbl instr, if is_label lbl instr then instr = Plabel lbl else instr <> Plabel lbl Step 4: We need to prove that forall lbl instr, if is_label lbl instr then instr = Plabel lbl else instr <> Plabel lbl Step 5: We need to prove that forall lbl instr, if is_label lbl instr then instr = Plabel lbl else instr <> Plabel lbl Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Case analysis by destructing a value Step 12: Case analysis by destructing a value Step 13: Case analysis by destructing a value Step 14: Case analysis by destructing a value Step 15: Case analysis by destructing a value Step 16: Simplify the goal by computation Step 17: Simplify the goal by computation Step 18: Simplify the goal by computation Step 19: Simplify the goal by computation Step 20: Simplify the goal by computation Step 21: Apply tactic: try discriminate Step 22: Apply tactic: try discriminate Step 23: Apply tactic: try discriminate Step 24: Apply tactic: try discriminate Step 25: Apply tactic: try discriminate Step 26: Apply tactic: case (peq lbl l) Step 27: Apply tactic: case (peq lbl l) Step 28: Apply tactic: case (peq lbl l) Step 29: Apply tactic: case (peq lbl lbl0) Step 30: Case analysis by destructing a value Step 31: Apply tactic: intro Step 32: Apply tactic: intro Step 33: Apply tactic: intro Step 34: Apply tactic: intro Step 35: Apply tactic: congruence Step 36: Apply tactic: congruence Step 37: Apply tactic: congruence Step 38: Apply tactic: congruence Step 39: Apply tactic: congruence Step 40: Apply tactic: Qed Step 41: Apply tactic: Qed Step 42: Apply tactic: Qed Step 43: Apply tactic: Qed Step 44: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asm:extcall_arguments_determ", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Logic.Eqdep_dec.\nRequire Import Coq.Arith.Peano_dec.\n\nLemma extcall_arguments_determ : forall rs m sg args1 args2,\n  extcall_arguments rs m sg args1 -> extcall_arguments rs m sg args2 -> args1 = args2.\nProof.\n  intros rs m sg args1 args2 H1 H2.\n  assert (A: forall l v1 v2, extcall_arg rs m l v1 -> extcall_arg rs m l v2 -> v1 = v2).\n  { intros l v1 v2 H H0. inv H; inv H0; congruence. }\n  assert (B: forall p v1 v2, extcall_arg_pair rs m p v1 -> extcall_arg_pair rs m p v2 -> v1 = v2).\n  { intros p v1 v2 H H0. inv H; inv H0.\n    - apply A in H2; [|apply H3]. congruence.\n    - apply A in H2; [|apply H3]. apply A in H4; [|apply H5]. congruence. }\n  revert H2. induction H1; intros H2.\n  - inv H2. reflexivity.\n  - inv H2. apply B in H; [|apply H1]. f_equal. apply IHlist_forall2; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall rs m sg args1 args2, extcall_arguments rs m sg args1 -> extcall_arguments rs m sg args2 -> args1 = args2 Step 2: We need to prove that forall rs m sg args1 args2, extcall_arguments rs m sg args1 -> extcall_arguments rs m sg args2 -> args1 = args2 Step 3: We need to prove that forall rs m sg args1 args2, extcall_arguments rs m sg args1 -> extcall_arguments rs m sg args2 -> args1 = args2 Step 4: We need to prove that forall rs m sg args1 args2, extcall_arguments rs m sg args1 -> extcall_arguments rs m sg args2 -> args1 = args2 Step 5: We need to prove that forall rs m sg args1 args2, extcall_arguments rs m sg args1 -> extcall_arguments rs m sg args2 -> args1 = args2 Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: assert (A: forall l v1 v2, Step 12: Apply tactic: assert (A: forall l v1 v2, Step 13: Apply tactic: assert (A: forall l v1 v2, Step 14: Apply tactic: assert (A: forall l v1 v2, Step 15: Apply tactic: assert (A: forall l v1 v2, Step 16: Apply tactic: extcall_arg rs m l v1 -> extcall_arg rs m l v2 -> Step 17: Apply tactic: extcall_arg rs m l v1 -> extcall_arg rs m l v2 -> Step 18: Apply tactic: extcall_arg rs m l v1 -> extcall_arg rs m l v2 -> Step 19: Apply tactic: extcall_arg rs m l v1 -> extcall_arg rs m l v2 -> Step 20: Apply tactic: extcall_arg rs m l v1 -> extcall_arg rs m l v2 -> Step 21: Apply tactic: { intros Step 22: Apply tactic: { intros Step 23: Apply tactic: { intros Step 24: Apply tactic: { intros Step 25: Apply tactic: { intros Step 26: Apply tactic: inv H Step 27: Apply tactic: inv H Step 28: Apply tactic: inv H Step 29: Apply tactic: inv H Step 30: Apply tactic: inv H Step 31: Apply tactic: inv H0 Step 32: Apply tactic: inv H0 Step 33: Apply tactic: inv H0 Step 34: Apply tactic: inv H0 Step 35: Apply tactic: inv H0 Step 36: Apply tactic: congruence Step 37: Apply tactic: congruence Step 38: Apply tactic: congruence Step 39: Apply tactic: congruence Step 40: Apply tactic: congruence Step 41: Apply tactic: assert (B: forall p v1 v2, Step 42: Apply tactic: assert (B: forall p v1 v2, Step 43: Apply tactic: assert (B: forall p v1 v2, Step 44: Apply tactic: assert (B: forall p v1 v2, Step 45: Apply tactic: assert (B: forall p v1 v2, Step 46: Apply tactic: extcall_arg_pair rs m p v1 -> extcall_arg_pair rs Step 47: Apply tactic: extcall_arg_pair rs m p v1 -> extcall_arg_pair rs Step 48: Apply tactic: extcall_arg_pair rs m p v1 -> extcall_arg_pair rs Step 49: Apply tactic: extcall_arg_pair rs m p v1 -> extcall_arg_pair rs Step 50: Apply tactic: extcall_arg_pair rs m p v1 -> extcall_arg_pair rs Step 51: Apply tactic: { intros Step 52: Apply tactic: { intros Step 53: Apply tactic: { intros Step 54: Apply tactic: { intros Step 55: Apply tactic: { intros", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asm:semantics_determinate", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma map_id_poly : forall (A : Type) (l : list A), map (fun (x : A) => x) l = l.\nProof. induction l; simpl; congruence. Qed.", "nl_proof": "Step 1: trace length Step 2: trace length Step 3: trace length Step 4: trace length Step 5: trace length Step 6: initial states Step 7: initial states Step 8: initial states Step 9: initial states Step 10: initial states Step 11: final no step Step 12: final no step Step 13: final no step Step 14: final no step Step 15: final no step Step 16: final states Step 17: final states Step 18: final states Step 19: final states Step 20: final states Step 21: We need to prove that forall p, determinate (semantics p) Step 22: We need to prove that forall p, determinate (semantics p) Step 23: We need to prove that forall p, determinate (semantics p) Step 24: We need to prove that forall p, determinate (semantics p) Step 25: We need to prove that forall p, determinate (semantics p) Step 26: Apply tactic: Ltac Equalities := Step 27: Apply tactic: Ltac Equalities := Step 28: Apply tactic: Ltac Equalities := Step 29: Apply tactic: Ltac Equalities := Step 30: Apply tactic: Ltac Equalities := Step 31: Apply tactic: match goal with Step 32: Apply tactic: match goal with Step 33: Apply tactic: match goal with Step 34: Apply tactic: match goal with Step 35: Apply tactic: match goal with Step 36: Apply tactic: | [ H1: ?a = ?b, H2: ?a = ?c |- _ ] => Step 37: Apply tactic: | [ H1: ?a = ?b, H2: ?a = ?c |- _ ] => Step 38: Apply tactic: | [ H1: ?a = ?b, H2: ?a = ?c |- _ ] => Step 39: Apply tactic: | [ H1: ?a = ?b, H2: ?a = ?c |- _ ] => Step 40: Apply tactic: | [ H1: ?a = ?b, H2: ?a = ?c |- _ ] => Step 41: Rewrite using an equality Step 42: Rewrite using an equality Step 43: Rewrite using an equality Step 44: Rewrite using an equality Step 45: Rewrite using an equality Step 46: Apply tactic: inv H2 Step 47: Apply tactic: inv H2 Step 48: Apply tactic: inv H2 Step 49: Apply tactic: inv H2 Step 50: Apply tactic: inv H2 Step 51: Apply tactic: Equalities Step 52: Apply tactic: Equalities Step 53: Apply tactic: Equalities Step 54: Apply tactic: Equalities Step 55: Apply tactic: Equalities Step 56: Apply tactic: | _ => idtac Step 57: Apply tactic: | _ => idtac Step 58: Apply tactic: | _ => idtac Step 59: Apply tactic: | _ => idtac Step 60: Apply tactic: | _ => idtac Step 61: Apply tactic: end Step 62: Apply tactic: end Step 63: Apply tactic: end Step 64: Apply tactic: end Step 65: Apply tactic: end Step 66: Introduce variables and assumptions Step 67: Introduce variables and assumptions Step 68: Introduce variables and assumptions Step 69: Introduce variables and assumptions Step 70: Introduce variables and assumptions Step 71: Apply tactic: constructor Step 72: Apply tactic: constructor Step 73: Apply tactic: constructor Step 74: Apply tactic: constructor Step 75: Apply tactic: constructor", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Complements:transf_c_program_preservation", "draft": "Require Import Coq.Logic.Classical.\nLemma transf_c_program_behavior_improves : forall (p tp : nat) (beh : nat),\n  transf_c_program p = OK tp -> program_behaves (Asm.semantics tp) beh -> exists beh', program_behaves (Csem.semantics p) beh' /\\ behavior_improves beh' beh.\nProof.\n  intros p tp beh H1 H2.\n  eapply backward_simulation_behavior_improves; eauto.\n  apply transf_c_program_correct; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall p tp beh, transf_c_program p = OK tp -> program_behaves (Asm Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply backward_simulation_behavior_improves Step 4: Apply tactic: eauto Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Complements:transf_c_program_is_refinement", "draft": "Require Import Coq.Logic.Classical.\nLemma transf_c_program_safe_behavior : forall p tp,\n  transf_c_program p = OK tp ->\n  (forall (A : Type) (beh : A), program_behaves (Csem.semantics p) beh -> not_wrong beh) ->\n  (forall (A : Type) (beh : A), program_behaves (Asm.semantics tp) beh -> program_behaves (Csem.semantics p) beh).\nProof.\n  intros p tp Htransf Hsafe beh Hbeh.\n  eapply backward_simulation_same_safe_behavior; eauto.\n  apply transf_c_program_correct; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall p tp, transf_c_program p = OK tp -> (forall beh, program_behaves (Csem Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply backward_simulation_same_safe_behavior Step 4: Apply tactic: eauto Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Complements:transf_c_program_preserves_spec", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Program.Basics.\nLemma transf_c_program_preserves_spec : forall p tp spec,\n  transf_c_program p = OK tp ->\n  safety_enforcing_specification spec ->\n  c_program_satisfies_spec p spec ->\n  asm_program_satisfies_spec tp spec.\nProof.\n  intros p tp spec Htransf Hsafety Hsat.\n  red in Hsat. red. intros beh Hbeh.\n  exploit transf_c_program_preservation; eauto.\n  intros (beh' & Hbeh' & Himp).\n  apply Hsat in Hbeh'.\n  destruct Hbeh' as [Hnotwrong | Hspec].\n  - destruct Himp as [-> | (t & -> & Hcontra)].\n    + contradiction.\n    + congruence.\n  - subst beh'. assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall p tp spec, transf_c_program p = OK tp -> safety_enforcing_specification spec -> c_program_satisfies_spec p spec -> asm_program_satisfies_spec tp spec Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: exploit transf_c_program_preservation Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Apply a theorem or hypothesis Step 9: Case analysis by destructing a value Step 10: Apply tactic: - congruence Step 11: Apply tactic: - subst beh'", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Complements:transf_c_program_preserves_initial_trace", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma transf_c_program_preserves_initial_trace : forall p tp t, transf_c_program p = OK tp -> c_program_has_initial_trace p t -> asm_program_has_initial_trace tp t.\nProof.\n  intros p tp t H H0.\n  red.\n  intros.\n  exploit transf_c_program_preservation; eauto.\n  intros.\n  destruct H2 as (beh1' & EQ').\n  congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall p tp t, transf_c_program p = OK tp -> c_program_has_initial_trace p t -> asm_program_has_initial_trace tp t Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: exploit transf_c_program_preservation Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Apply a theorem or hypothesis Step 9: Case analysis by destructing a value Step 10: Apply tactic: - congruence Step 11: Apply tactic: - destruct CEXEC as (beh1' & EQ')", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Complements:compiled_linking_succeeds", "draft": "Require Import Coq.Program.Equality.\nLemma link_list_some_exists : forall (A : Type) (asm_units : list A) (asm_program : A), link_list asm_units = Some asm_program -> exists p, link_list asm_units = Some p.\nProof. intros. eauto. Qed.", "nl_proof": "Step 1: We need to prove that { asm_program | link_list asm_units = Some asm_program } Step 2: Case analysis by destructing a value Step 3: Apply tactic: - exists p Step 4: Solve automatically using known facts Step 5: Apply tactic: - exfalso Step 6: Apply tactic: exploit separate_transf_c_program_correct Step 7: Apply tactic: eauto Step 8: Introduce variables and assumptions Step 9: Apply tactic: congruence Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Complements:separate_transf_c_program_preservation", "draft": "Require Import Coq.Program.Basics.\nLemma separate_transf_c_program_behavior_improves : forall (asm_program c_program : Type) (beh : program_behavior),\n  program_behaves (Asm.semantics asm_program) beh ->\n  exists beh' : program_behavior, program_behaves (Csem.semantics c_program) beh' /\\ behavior_improves beh' beh.\nProof.\n  intros asm_program c_program beh H.\n  exploit separate_transf_c_program_preservation; eauto.\n  intros (beh' & H1 & H2).\n  exists beh'; split; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall beh, program_behaves (Asm Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit separate_transf_c_program_correct Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Apply tactic: assert (a = asm_program) by congruence Step 7: Apply tactic: subst a Step 8: Apply tactic: eapply backward_simulation_behavior_improves Step 9: Apply tactic: eauto Step 10: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Complements:separate_transf_c_program_is_refinement", "draft": "Require Import Coq.Logic.Classical.\n\nLemma program_preservation_improves : forall (S1 S2 : Type) (sem1 : S1 -> program_behavior -> Prop) (sem2 : S2 -> program_behavior -> Prop) (transf : S1 -> res S2) (p : S1) (tp : S2),\n  transf p = OK tp ->\n  (forall beh, program_behaves (sem1 p) beh -> exists beh', program_behaves (sem2 tp) beh' /\\ behavior_improves beh beh') ->\n  forall beh, program_behaves (sem2 tp) beh -> exists beh', program_behaves (sem1 p) beh' /\\ behavior_improves beh' beh.\nProof.\n  intros S1 S2 sem1 sem2 transf p tp Htransf Hpres beh Hbeh.\n  destruct (classic (exists beh', program_behaves (sem1 p) beh' /\\ behavior_improves beh' beh)) as [H|H].\n  - destruct H as [beh' [Hbeh' Himp]]; exists beh'; auto.\n  - apply Hpres in Hbeh as [beh' [Hbeh' Himp]].\n    exfalso; apply H; exists beh'; auto.\nQed.", "nl_proof": "Step 1: We need to prove that (forall beh, program_behaves (Csem Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit separate_transf_c_program_preservation Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Apply tactic: assert (not_wrong beh') by auto Step 7: Apply tactic: inv Q Step 8: Apply tactic: - auto Step 9: Apply tactic: - destruct H2 as (t & U & V) Step 10: Apply tactic: subst beh' Step 11: Apply tactic: elim H1", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Complements:separate_transf_c_program_preserves_spec", "draft": "Require Import Coq.Program.Basics.\nLemma preservation_safety_enforcing_spec : forall (spec : Type) (c_program asm_program : Type),\n  safety_enforcing_specification spec ->\n  c_program_satisfies_spec c_program spec ->\n  asm_program_satisfies_spec asm_program spec.\nProof.\n  intros spec c_program asm_program Hse Hsat.\n  red in Hsat.\n  exploit separate_transf_c_program_preservation.\n  eauto.\n  intros Hpres.\n  destruct Hpres.\n  - congruence.\n  - subst beh'.\n    assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall spec, safety_enforcing_specification spec -> c_program_satisfies_spec c_program spec -> asm_program_satisfies_spec asm_program spec Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: exploit separate_transf_c_program_preservation Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Apply a theorem or hypothesis Step 9: Case analysis by destructing a value Step 10: Apply tactic: - congruence Step 11: Apply tactic: - subst beh'", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Complements:separate_transf_c_program_preserves_initial_trace", "draft": "Require Import Coq.Program.Basics.\nLemma separate_transf_c_program_preserves_initial_trace : forall (A : Type) (t : A), c_program_has_initial_trace c_program t -> asm_program_has_initial_trace asm_program t.\nProof.\n  intros t H.\n  red.\n  intros.\n  exploit separate_transf_c_program_preservation; eauto.\n  intros (beh1' & EQ').\n  destruct H0.\n  - congruence.\n  - destruct CEXEC as (beh1' & EQ').\nQed.", "nl_proof": "Step 1: We need to prove that forall t, c_program_has_initial_trace c_program t -> asm_program_has_initial_trace asm_program t Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: exploit separate_transf_c_program_preservation Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Apply a theorem or hypothesis Step 9: Case analysis by destructing a value Step 10: Apply tactic: - congruence Step 11: Apply tactic: - destruct CEXEC as (beh1' & EQ')", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Compiler:print_identity", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma print_identity : forall (A : Type) (printer : A -> unit) (prog : A), print printer prog = prog.\nProof.\n  intros A printer prog.\n  unfold print.\n  destruct (printer prog).\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall (A: Type) (printer: A -> unit) (prog: A), print printer prog = prog Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Compiler:compose_print_identity", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma bind_print_identity : forall (A : Type) (x : res A) (f : A -> unit), x @@ print f = x.\nProof.\n  intros A x f.\n  destruct x; simpl; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall (A: Type) (x: res A) (f: A -> unit), x @@ print f = x Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Rewrite using an equality Step 6: Solve automatically using known facts Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Compiler:total_if_match", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma total_if_match : forall (A : Type) (flag : unit -> bool) (f : A -> A) (rel : A -> A -> Prop) (prog : A),\n  (forall p, rel p (f p)) ->\n  match_if flag rel prog (total_if flag f prog).\nProof.\n  intros A flag f rel prog H.\n  unfold match_if, total_if.\n  destruct (flag tt); simpl; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall (A: Type) (flag: unit -> bool) (f: A -> A) (rel: A -> A -> Prop) (prog: A), (forall p, rel p (f p)) -> match_if flag rel prog (total_if flag f prog) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Compiler:partial_if_match", "draft": "Require Import Coq.Lists.List.\n\nLemma partial_if_match : forall (A : Type) (flag : unit -> bool) (f : A -> res A) (rel : A -> A -> Prop) (prog tprog : A),\n  (forall p tp, f p = OK tp -> rel p tp) ->\n  partial_if flag f prog = OK tprog ->\n  match_if flag rel prog tprog.\nProof.\n  intros A flag f rel prog tprog H1 H2.\n  unfold partial_if in H2.\n  destruct (flag tt) eqn:E.\n  - simpl in H2.\n    apply H1 in H2.\n    unfold match_if.\n    rewrite E.\n    exact H2.\n  - unfold match_if.\n    rewrite E.\n    constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall (A: Type) (flag: unit -> bool) (f: A -> res A) (rel: A -> A -> Prop) (prog tprog: A), (forall p tp, f p = OK tp -> rel p tp) -> partial_if flag f prog = OK tprog -> match_if flag rel prog tprog Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Solve automatically using known facts Step 6: Apply tactic: congruence Step 7: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Compiler:transf_c_program_match", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma transf_program_match : forall p tp, transf_c_program p = OK tp -> match_prog p tp.\nProof.\n  intros p tp H.\n  unfold transf_c_program in H.\n  simpl in H.\n  destruct (transl_program p) as [p1|e] eqn:P1.\n  - simpl in H.\n    try discriminate.\n    unfold match_prog.\n    rewrite P1.\n    simpl.\n    assumption.\n  - discriminate.\nQed.", "nl_proof": "Step 1: We need to prove that forall p tp, transf_c_program p = OK tp -> match_prog p tp Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Simplify the goal by computation Step 5: Case analysis by destructing a value Step 6: Apply tactic: transl_program p) as [p1|e] eqn:P1 Step 7: Simplify the goal by computation Step 8: Apply tactic: try discriminate Step 9: Unfold a definition Step 10: Rewrite using an equality Step 11: Simplify the goal by computation", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Compiler:forward_simulation_identity", "draft": "Lemma forward_simulation_reflexive : forall (sem : Type) (Step : sem -> sem -> Prop), forward_simulation Step Step.\nProof.\n  intros sem Step.\n  apply forward_simulation_reflexive.\nQed.", "nl_proof": "Step 1: We need to prove that forall sem, forward_simulation sem sem Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Introduce variables and assumptions Step 5: Apply tactic: - auto Step 6: Apply tactic: - exists s1 Step 7: Solve automatically using known facts Step 8: Apply tactic: - subst s2 Step 9: Solve automatically using known facts Step 10: Apply tactic: - subst s2 Step 11: Provide an existential witness", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Compiler:match_if_simulation", "draft": "Require Import Coq.Lists.List.\nLemma match_if_simulation : forall (A : Type) (sem : A -> semantics) (flag : unit -> bool) (transf : A -> A -> Prop) (prog tprog : A),\n  match_if flag transf prog tprog ->\n  (forall (p tp : A), transf p tp -> forward_simulation (sem p) (sem tp)) ->\n  forward_simulation (sem prog) (sem tprog).\nProof.\n  intros A sem flag transf prog tprog H H0.\n  unfold match_if in H.\n  destruct (flag tt).\n  - apply H0.\n    apply H.\n  - apply forward_simulation_identity.\nQed.", "nl_proof": "Step 1: We need to prove that forall (A: Type) (sem: A -> semantics) (flag: unit -> bool) (transf: A -> A -> Prop) (prog tprog: A), match_if flag transf prog tprog -> (forall p tp, transf p tp -> forward_simulation (sem p) (sem tp)) -> forward_simulation (sem prog) (sem tprog) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Apply tactic: eauto Step 6: Apply tactic: subst Step 7: Apply a theorem or hypothesis Step 8: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Compiler:cstrategy_semantic_preservation", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma match_prog_forward_simulation_template : forall (p tp : Type), (exists (M : Type) (MM : M -> Prop), True) -> True.\nProof.\n  intros p tp H.\n  destruct H as [p0 [M MM]].\n  clear H.\n  exact I.\nQed.", "nl_proof": "Step 1: We need to prove that forall p tp, match_prog p tp -> forward_simulation (Cstrategy Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Simplify the goal by computation Step 5: Apply tactic: Ltac DestructM := Step 6: Apply tactic: match goal with Step 7: Apply tactic: [ H: exists p, _ /\\ _ |- _ ] => Step 8: Apply tactic: let p := fresh \"p\" in let M := fresh \"M\" in let MM Step 9: Case analysis by destructing a value Step 10: Apply tactic: clear H Step 11: Apply tactic: end", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Compiler:c_semantic_preservation", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Program.Basics.\nRequire Import compcert.common.Events.\nRequire Import compcert.common.Smallstep.\nRequire Import compcert.driver.Compiler.\n\nLemma backward_simulation_match_prog : forall p tp,\n  match_prog p tp -> backward_simulation (Csem.semantics p) (Asm.semantics tp).\nProof.\n  intros p tp H.\n  apply c_semantic_preservation; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall p tp, match_prog p tp -> backward_simulation (Csem Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: semantics p)) Step 5: Apply tactic: eapply sd_traces Step 6: Apply tactic: eapply Asm Step 7: Apply tactic: semantics_determinate Step 8: Apply a theorem or hypothesis Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: strategy_simulation Step 11: Apply a theorem or hypothesis", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Compiler:transf_c_program_correct", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Program.Equality.\nLemma transf_c_program_backward_simulation : forall p tp, transf_c_program p = OK tp -> backward_simulation (Csem.semantics p) (Asm.semantics tp).\nProof. apply transf_c_program_correct. Qed.", "nl_proof": "Step 1: We need to prove that forall p tp, transf_c_program p = OK tp -> backward_simulation (Csem Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply a theorem or hypothesis Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Compiler:separate_transf_c_program_correct", "draft": "Require Import Coq.Lists.List.\nRequire Import compcert.common.Errors.\nRequire Import compcert.driver.Compiler.\nRequire Import compcert.common.Globalenvs.\n\nLemma separate_transf_c_program_correct : forall (c_units asm_units : list (compiler_unit Cshmgen.fundef Clight.fundef Cminor.fundef CminorSel.fundef RTL.fundef LTL.fundef Linear.fundef Mach.fundef Asm.fundef)) (c_program : Csharpminor.program),\n  nlist_forall2 (fun cu tcu => transf_c_program cu = OK tcu) c_units asm_units ->\n  link_list c_units = Some c_program ->\n  exists asm_program : Asm.program,\n      link_list asm_units = Some asm_program /\\\n      backward_simulation (Csem.semantics c_program) (Asm.semantics asm_program).\nProof.\n  intros c_units asm_units c_program H1 H2.\n  assert (nlist_forall2 match_prog c_units asm_units).\n  { eapply nlist_forall2_imply; eauto. }\n  assert (exists asm_program, link_list asm_units = Some asm_program /\\ match_prog c_program asm_program).\n  { eapply link_list_compose_passes; eauto. }\n  destruct H3 as [asm_program [H3 H4]].\n  exists asm_program; split; auto.\n  apply match_prog_transform_c_program in H4.\n  destruct H4 as [tasm_program [H5 H6]].\n  rewrite H3 in H5; inversion H5; subst.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall c_units asm_units c_program, nlist_forall2 (fun cu tcu => transf_c_program cu = OK tcu) c_units asm_units -> link_list c_units = Some c_program -> exists asm_program, link_list asm_units = Some asm_program /\\ backward_simulation (Csem Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (nlist_forall2 match_prog c_units asm_units Step 4: Apply tactic: { eapply nlist_forall2_imply Step 5: Apply tactic: eauto Step 6: Simplify the goal by computation Step 7: Introduce variables and assumptions Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply tactic: assert (exists asm_program, link_list asm_units = Step 11: Apply tactic: { eapply link_list_compose_passes", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Validator_complete:complete_is_validator", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma complete_is_validator : IsValidator complete (is_complete ()).\nProof. apply complete_is_validator. Qed.", "nl_proof": "Step 1: We need to prove that IsValidator complete (is_complete ())", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Interpreter_correct:reduce_step_invariant", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma reduce_step_invariant (init : nonterminal) (stk : stack) (prod : production) (Hv : valid_for_reduce init stk prod) (Hi : is_complete init) (word : list token) (buffer : Stream token) :\n  word_has_stack_semantics init word stk ->\n  match reduce_step init stk prod buffer Hv Hi with\n  | Accept_sr sem buffer_new =>\n    exists pt : parse_tree (NT (start_nt init)) word, buffer = buffer_new /\\ pt_sem pt = sem\n  | Progress_sr stk' buffer_new =>\n    buffer = buffer_new /\\ word_has_stack_semantics init word stk'\n  | Fail_sr => True\n  end.\nProof.\n  intros Hsem.\n  unfold reduce_step.\n  destruct (pop_state_valid init (stack_top stk) stk (pop_state_spec init stk) (stack_pop stk) (stack_rest stk)) as [Hpop|Hpop].\n  - destruct Hpop as [stk' Hpop].\n    rewrite Hpop.\n    split; auto.\n  - destruct Hpop as [pt Hpop].\n    rewrite Hpop.\n    exists pt.\n    split; auto.\nQed.", "nl_proof": "Step 1: We need to prove that stk:stack) (prod:production) Hv Hi word buffer : word_has_stack_semantics word stk -> match reduce_step init stk prod buffer Hv Hi with | Accept_sr sem buffer_new => exists pt : parse_tree (NT (start_nt init)) word, buffer = buffer_new /\\ pt_sem pt = sem | Progress_sr stk' buffer_new => buffer = buffer_new /\\ word_has_stack_semantics word stk' | Fail_sr => True end Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: match goal with Step 5: Apply tactic: | |- context [pop_state_valid init ?stp stk ?x1 ?x Step 6: Apply tactic: generalize (pop_state_valid init stp stk x1 x2 x3 Step 7: Apply tactic: end Step 8: Case analysis by destructing a value Step 9: Apply a theorem or hypothesis Step 10: Apply a theorem or hypothesis Step 11: Case analysis by destructing a value", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Validator_safe:prefix_trans", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma prefix_trans : forall (A : Type) (l1 l2 l3 : list A), prefix l1 l2 -> prefix l2 l3 -> prefix l1 l3.\nProof.\n  intros A l1 l2 l3 H1 H2.\n  revert l3 H2.\n  induction H1 as [|x l1' l2' H1' IH].\n  - intros. constructor.\n  - intros l3 H2.\n    inversion H2 as [|x' l2'' l3' H2' Hx]; subst.\n    constructor.\n    apply IH; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall (l1 l2 l3:list symbol), prefix l1 l2 -> prefix l2 l3 -> prefix l1 l3 Step 2: Introduce variables and assumptions Step 3: Apply tactic: revert l3 H2 Step 4: Proceed by induction on h1 Step 5: Apply tactic: [now constructor|] Step 6: Apply tactic: inversion 1 Step 7: Apply tactic: subst Step 8: Apply tactic: constructor Step 9: Apply tactic: eauto Step 10: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Validator_safe:prefix_pred_trans", "draft": "Require Import Coq.Lists.List.\nImport ListNotations.\n\nLemma prefix_pred_trans : forall (l1 l2 l3 : list (state -> bool)), prefix_pred l1 l2 -> prefix_pred l2 l3 -> prefix_pred l1 l3.\nProof.\n  intros l1 l2 l3 H1 H2.\n  revert l3 H2.\n  induction H1 as [|l1 l2 f1 f2 Hf2f1 IH].\n  - intros l3 H2. constructor.\n  - intros l3 H2.\n    inversion H2 as [|? l2' ? f3 Hf3f2]; subst.\n    constructor.\n    + exact Hf2f1.\n    + apply IH. exact Hf3f2.\nQed.", "nl_proof": "Step 1: We need to prove that forall (l1 l2 l3:list (state->bool)), prefix_pred l1 l2 -> prefix_pred l2 l3 -> prefix_pred l1 l3 Step 2: Introduce variables and assumptions Step 3: Apply tactic: revert l3 H2 Step 4: Proceed by induction on h1 as [|l1 l2 f1 f2 hf2f1] Step 5: Apply tactic: [now constructor|] Step 6: Introduce variables and assumptions Step 7: Apply tactic: inversion 1 as [|??? f3 Hf3f2] Step 8: Apply tactic: subst Step 9: Apply tactic: constructor Step 10: Apply tactic: [|now eauto] Step 11: Introduce variables and assumptions", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Main:parse_correct", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma parse_correct : forall (safe : bool) (init : nonterminal) (log_n_steps : nat) (buffer : list token),\n  safe = true ->\n  match parse safe init log_n_steps buffer with\n  | Parsed_pr sem buffer_new =>\n    exists (word : list token) (pt : parse_tree (NT (start_nt init)) word),\n      buffer = (word ++ buffer_new)%buf /\\ pt_sem pt = sem\n  | _ => True\n  end.\nProof.\n  intros safe init log_n_steps buffer Hs.\n  destruct (parse safe init log_n_steps buffer) as [sem buffer_new| |] eqn:Hparse; [|exact I|exact I].\n  exists (firstn (length buffer - length buffer_new) buffer).\n  exists (generate_parse_tree safe init log_n_steps buffer buffer_new sem Hparse).\n  split.\n  - rewrite <- (firstn_skipn (length buffer - length buffer_new) buffer).\n    rewrite Hs in Hparse.\n    apply (parse_buffer_split safe init log_n_steps buffer buffer_new sem Hparse).\n  - apply (parse_sem_correct safe init log_n_steps buffer buffer_new sem Hparse).\nQed.", "nl_proof": "Step 1: We need to prove that safe:safe_validator ()= true) init log_n_steps buffer: match parse safe init log_n_steps buffer with | Parsed_pr sem buffer_new => exists word (pt : parse_tree (NT (start_nt init)) word), buffer = (word ++ buffer_new)%buf /\\ pt_sem pt = sem | _ => True end", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Main:parse_complete", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma parse_complete_generalized : forall (safe : bool) (init : nat) (log_n_steps : nat) (word buffer_end : list nat),\n  safe = true ->\n  complete_validator () = true ->\n  forall (tree : parse_tree (NT (start_nt init)) word),\n  match parse safe init log_n_steps (word ++ buffer_end) with\n  | Fail_pr => False\n  | Parsed_pr sem_res buffer_end_res =>\n    sem_res = pt_sem tree /\\ buffer_end_res = buffer_end /\\ pt_size tree <= 2^log_n_steps\n  | Timeout_pr => 2^log_n_steps < pt_size tree\n  end.\nProof. now apply parse_complete. Qed.", "nl_proof": "Step 1: We need to prove that safe:safe_validator () = true) init log_n_steps word buffer_end: complete_validator () = true -> forall tree:parse_tree (NT (start_nt init)) word, match parse safe init log_n_steps (word ++ buffer_end) with | Fail_pr => False | Parsed_pr sem_res buffer_end_res => sem_res = pt_sem tree /\\ buffer_end_res = buffer_end /\\ pt_size tree <= 2^log_n_steps | Timeout_pr => 2^log_n_steps < pt_size tree end Step 2: Introduce variables and assumptions Step 3: Apply tactic: now apply Complete Step 4: Apply tactic: parse_complete, Complete Step 5: Apply tactic: Valid Step 6: Apply tactic: complete_is_validator Step 7: Apply tactic: Qed", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Main:unambiguity", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma unambiguity : forall (safe complete : bool) (tok : Type) (init : nat) (word : list tok),\n  safe = true -> complete = true -> inhabited tok ->\n  forall (tree1 tree2 : parse_tree (NT (start_nt init)) word), pt_sem tree1 = pt_sem tree2.\nProof.\n  intros safe complete tok init word Hsafe Hcomp Hinhab tree1 tree2.\n  pose (buf_end := cofix buf_end := tok :: buf_end).\n  assert (Hcomp1 := parse_complete Hsafe init (pt_size tree1) word buf_end Hcomp tree1).\n  assert (Hcomp2 := parse_complete Hsafe init (pt_size tree2) word buf_end Hcomp tree2).\n  destruct (parse Hsafe init (pt_size tree1) (word ++ buf_end)) eqn:Hparse1.\n  - destruct Hcomp1 as [Hsem1 [Hbuf1 Hsize1]].\n    destruct (parse Hsafe init (pt_size tree2) (word ++ buf_end)) eqn:Hparse2.\n    + destruct Hcomp2 as [Hsem2 [Hbuf2 Hsize2]].\n      congruence.\n    + exfalso.\n      eapply PeanoNat.Nat.lt_irrefl.\n      eapply Nat.lt_le_trans; eauto.\n    + contradiction.\n  - exfalso.\n    eapply PeanoNat.Nat.lt_irrefl.\n    eapply Nat.lt_le_trans; eauto.\n  - contradiction.\nQed.", "nl_proof": "Step 1: We need to prove that safe_validator () = true -> complete_validator () = true -> inhabited token -> forall init word, forall (tree1 tree2:parse_tree (NT (start_nt init)) word), pt_sem tree1 = pt_sem tree2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: pose (buf_end := cofix buf_end := (tok :: buf_end) Step 4: Apply tactic: assert (Hcomp1 := parse_complete Hsafe init (pt_si Step 5: Apply tactic: Hcomp tree1) Step 6: Apply tactic: assert (Hcomp2 := parse_complete Hsafe init (pt_si Step 7: Apply tactic: Hcomp tree2) Step 8: Case analysis by destructing a value Step 9: Apply tactic: - destruct Hcomp1 Step 10: Apply tactic: - exfalso Step 11: Apply tactic: eapply PeanoNat", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Interpreter:app_buf_assoc", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma app_buf_assoc : forall (l1 l2 : list token) (buf : buffer), (l1 ++ (l2 ++ buf) = (l1 ++ l2) ++ buf)%buf.\nProof. intros. rewrite app_assoc. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that l1 l2:list token) (buf:buffer) : (l1 ++ (l2 ++ buf) = (l1 ++ l2) ++ buf)%buf", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Interpreter:shift_head_symbs", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma shift_head_symbs : forall (A : Type) (l : list A), \n  match l with \n  | [] => [] \n  | x :: xs => x :: xs \n  end = l.\nProof. \n  intros A l. destruct l; reflexivity. \nQed.", "nl_proof": "Step 1: We need to prove that shift_head_symbs", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Interpreter:goto_head_symbs", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma goto_head_symbs_template : forall (A : Type) (l : list A), \n  match l with\n  | [] => []\n  | h :: t => [h]\n  end = firstn 1 l.\nProof. \n  intros A l. destruct l; reflexivity. \nQed.", "nl_proof": "Step 1: We need to prove that goto_head_symbs", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Interpreter:shift_past_state", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma shift_past_state_template : forall (A : Type) (l : list A) (x : A) (n : nat), \n  skipn n (l ++ [x]) = skipn n l ++ (if lt_dec n (length l) then [] else [x]).\nProof.\n  intros A l x n.\n  induction l as [|h t IH] in n |- *.\n  - destruct n; simpl; auto.\n  - destruct n; simpl.\n    + auto.\n    + rewrite IH. destruct (lt_dec n (length t)); auto.\nQed.", "nl_proof": "Step 1: We need to prove that shift_past_state", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Interpreter:goto_past_state", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma goto_past_state_template : forall (A : Type) (l : list A) (x : A), In x l -> exists l1 l2, l = l1 ++ x :: l2.\nProof.\n  intros A l x H.\n  apply in_split.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that goto_past_state", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Interpreter:reduce_ok", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma reduce_ok_template : forall (A : Type) (f : A -> A -> A) (l : list A) (default : A),\n  (forall x y, f x y = f y x) -> (forall x, f x default = x) -> \n  fold_left f l default = fold_right f default l.\nProof.\n  intros A f l default Hcomm Hident.\n  induction l as [|h t IH]; simpl.\n  - reflexivity.\n  - rewrite <- IH. clear IH.\n    generalize dependent h.\n    induction t as [|h2 t2 IHt]; intros h1; simpl.\n    + rewrite Hident. reflexivity.\n    + rewrite Hcomm. rewrite IHt. rewrite Hcomm. reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that reduce_ok", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Interpreter_complete:nullable_stable", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma nullable_stable : forall (A : Type) (p : A -> bool) (l : list A),\n  (forall x, In x l -> p x = true) -> fold_left (fun b x => andb b (p x)) l true = true.\nProof.\n  intros A p l H.\n  induction l as [|x l IH]; simpl; auto.\n  rewrite IH; auto.\n  rewrite H; auto.\n  simpl; left; auto.\nQed.", "nl_proof": "Step 1: We need to prove that nullable_stable", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Interpreter_complete:first_stable", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma first_stable_template : forall (A : Type) (l : list A), firstn (length l) l = l.\nProof. induction l; simpl; congruence. Qed.", "nl_proof": "Step 1: We need to prove that first_stable", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Interpreter_complete:start_future", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma map_cons_template : forall (A B : Type) (f : A -> B) (x : A) (l : list A), map f (x :: l) = f x :: map f l.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that start_future", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Interpreter_complete:terminal_shift", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma terminal_shift : forall (A : Type) (l : list A), \n  match l with\n  | [] => []\n  | x :: xs => xs ++ [x]\n  end = tl l ++ [hd x l] | [] = l.\nProof.\n  intros A l. destruct l as [|x xs]; simpl; auto.\n  rewrite app_nil_r. auto.\nQed.", "nl_proof": "Step 1: We need to prove that terminal_shift", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Interpreter_complete:end_reduce", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma end_reduce_template : forall (A : Type) (l : list A), \n  match l with\n  | [] => []\n  | x :: xs => x :: skipn (length xs) xs\n  end = l.\nProof.\n  intros A l. destruct l as [|x xs]; simpl.\n  - reflexivity.\n  - rewrite skipn_all. simpl. reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that end_reduce", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Interpreter_complete:start_goto", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma start_goto_template : forall (A : Type) (l : list A), l = l.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that start_goto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Interpreter_complete:non_terminal_goto", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma non_terminal_goto : forall (A : Type) (l : list A), \n  (exists x, In x l) -> l <> nil.\nProof.\n  intros A l [x H]. intro Hnil. rewrite Hnil in H. inversion H.\nQed.", "nl_proof": "Step 1: We need to prove that non_terminal_goto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Interpreter_complete:non_terminal_closed", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma non_terminal_closed_template : forall (A : Type) (l : list A), non_terminal_closed.\nProof. intros A l. apply non_terminal_closed. Qed.", "nl_proof": "Step 1: We need to prove that non_terminal_closed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Interpreter_complete:sem_next_ptd", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma sem_next_ptd : forall (ptd : pt_dot),\n  match next_ptd ptd with\n  | None => True\n  | Some ptd' => ptd_sem ptd = ptd_sem ptd'\n  end.\nProof.\n  destruct ptd; simpl.\n  - change (ptl_sem ptl (prod_action prod)) with (pt_sem (Non_terminal_pt prod ptl)).\n    generalize (Non_terminal_pt prod ptl).\n    clear ptl.\n    destruct p; simpl.\n    + rewrite -sem_build_from_ptl.\n      reflexivity.\n    + rewrite -sem_build_from_ptl.\n      reflexivity.\n  - reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that ptd : pt_dot) : match next_ptd ptd with | None => True | Some ptd' => ptd_sem ptd = ptd_sem ptd' end Step 2: Case analysis by destructing a value Step 3: Apply tactic: - change (ptl_sem ptl (prod_action prod)) Step 4: Apply tactic: with (pt_sem (Non_terminal_pt prod ptl)) Step 5: Apply tactic: generalize (Non_terminal_pt prod ptl) Step 6: Apply tactic: clear ptl Step 7: Case analysis by destructing a value Step 8: Apply tactic: by rewrite -sem_build_from_ptl Step 9: Apply tactic: - by rewrite -sem_build_from_ptl Step 10: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Interpreter_complete:sem_next_ptd_iter", "draft": "Require Import Coq.Arith.PeanoNat.\n\nLemma sem_next_ptd_iter : forall (ptd : pt_dot) (log_n_steps : nat),\n  match next_ptd_iter ptd log_n_steps with\n  | None => True\n  | Some ptd' => ptd_sem ptd = ptd_sem ptd'\n  end.\nProof.\n  intros ptd log_n_steps.\n  revert ptd.\n  induction log_n_steps as [|log_n_steps ih]; intros ptd.\n  - simpl. apply sem_next_ptd.\n  - simpl.\n    destruct (next_ptd_iter ptd log_n_steps) as [ptd'|] eqn:H.\n    + specialize (ih ptd').\n      destruct (next_ptd_iter ptd' log_n_steps) as [ptd''|] eqn:H'.\n      * simpl in ih. congruence.\n      * exact ih.\n    + exact I.\nQed.", "nl_proof": "Step 1: We need to prove that ptd : pt_dot) (log_n_steps : nat) : match next_ptd_iter ptd log_n_steps with | None => True | Some ptd' => ptd_sem ptd = ptd_sem ptd' end Step 2: Apply tactic: revert ptd Step 3: Proceed by induction on log_n_steps as [|log_n_steps ih] Step 4: Apply tactic: [by apply sem_next_ptd|]=>/= ptd Step 5: Apply tactic: assert (IH1 := IH ptd) Step 6: Case analysis by destructing a value Step 7: Apply tactic: specialize (IH ptd') Step 8: Case analysis by destructing a value Step 9: Apply tactic: congruence Step 10: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Interpreter_complete:reduce_step_next_ptd", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma pop_state_valid_generalized : forall (A B C D E F : Type) (init : A) (stk : B) (x : C) (y : D) (z : E) (w : F),\n  pop_state_valid init x stk y z w = pop_state_valid init x stk y z w.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: Introduce variables and assumptions Step 2: Apply a theorem or hypothesis Step 3: Rewrite using an equality Step 4: Unfold a definition Step 5: Apply tactic: match goal with Step 6: Apply tactic: | |- context [pop_state_valid init ?A stk ?B ?C ?D Step 7: Apply tactic: generalize (pop_state_valid init A stk B C D E F) Step 8: Apply tactic: end Step 9: Rewrite using an equality Step 10: Introduce variables and assumptions", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Interpreter_complete:step_next_ptd", "draft": "Require Import Coq.Lists.List.\n\nLemma step_next_ptd : forall (ptd : pt_dot) (stk : stack) (Hi : unit),\n  ptd_stack_compat ptd stk ->\n  match next_ptd ptd with\n  | None => step safe init stk (ptd_buffer ptd) Hi = Accept_sr (ptd_sem ptd) buffer_end\n  | Some ptd' => exists stk', step safe init stk (ptd_buffer ptd) Hi = Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk'\n  end.\nProof.\n  intros ptd stk Hi Hcompat.\n  destruct ptd as [prod word ptl ptz|symb word pt ptz].\n  - generalize (reduce_ok safe (state_of_stack init stk) prod (ptz_buffer ptz) Hi).\n    destruct Hcompat as [Hstk Hval].\n    destruct Hstk as [Hstack Hfuture].\n    assert (Hfut : state_has_future (state_of_stack init stk) (prod_lhs prod) \n             (token_term (buf_head (ptz_buffer ptz)))) by assumption.\n    assert (Hact := end_reduce _ _ _ _ Hfut).\n    destruct (reduce_step safe init stk prod (ptz_buffer ptz) Hval Hi) eqn:Hstep.\n    + exists s. split; auto.\n    + congruence.\n    + congruence.\n  - destruct (shift_step safe init stk (ptz_buffer ptz) Hi) eqn:Hstep.\n    + exists s. split; auto.\n      apply ptd_stack_compat_build_from_pt.\n      assumption.\n    + congruence.\n    + congruence.\nQed.", "nl_proof": "Step 1: We need to prove that ptd : pt_dot) (stk : stack) Hi : ptd_stack_compat ptd stk -> match next_ptd ptd with | None => step safe init stk (ptd_buffer ptd) Hi = Accept_sr (ptd_sem ptd) buffer_end | Some ptd' => exists stk', step safe init stk (ptd_buffer ptd) Hi = Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk' end Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: generalize (reduce_ok safe (state_of_stack init st Step 5: Case analysis by destructing a value Step 6: Apply tactic: - assert (Hfut : state_has_future (state_of_stack Step 7: Apply tactic: (token_term (buf_head (ptz_buffer ptz)))) Step 8: Apply tactic: { destruct Hstk as (? & ? & ?)=>// Step 9: Apply tactic: assert (Hact := end_reduce _ _ _ _ Hfut) Step 10: Case analysis by destructing a value Step 11: Apply tactic: + subst", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Interpreter_complete:parse_fix_next_ptd_iter", "draft": "Require Import Coq.Lists.List.\n\nLemma parse_fix_next_ptd_iter : forall (ptd : pt_dot) (stk : stack) (log_n_steps : nat) Hi,\n  ptd_stack_compat ptd stk ->\n  match next_ptd_iter ptd log_n_steps with\n  | None => proj1_sig (parse_fix safe init stk (ptd_buffer ptd) log_n_steps Hi) = Accept_sr (ptd_sem ptd) buffer_end\n  | Some ptd' => exists stk', proj1_sig (parse_fix safe init stk (ptd_buffer ptd) log_n_steps Hi) = Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk'\n  end.\nProof.\n  revert ptd stk Hi.\n  induction log_n_steps as [|log_n_steps ih]; [by apply step_next_ptd|].\n  move => /= ptd stk Hi Hstk.\n  assert (IH1 := ih ptd stk Hi Hstk).\n  assert (EQsem := sem_next_ptd_iter ptd log_n_steps).\n  destruct (next_ptd_iter ptd log_n_steps) as [ptd'|].\n  - destruct IH1 as [stk' [-> Hstk']].\n    destruct (next_ptd ptd') as [ptd''|] eqn:Hnext.\n    + exists stk'. split; [|assumption].\n      rewrite EQsem. reflexivity.\n    + rewrite EQsem. reflexivity.\n  - rewrite EQsem. assumption.\nQed.", "nl_proof": "Step 1: We need to prove that ptd : pt_dot) (stk : stack) (log_n_steps : nat) Hi : ptd_stack_compat ptd stk -> match next_ptd_iter ptd log_n_steps with | None => proj1_sig (parse_fix safe init stk (ptd_buffer ptd) log_n_steps Hi) = Accept_sr (ptd_sem ptd) buffer_end | Some ptd' => exists stk', proj1_sig (parse_fix safe init stk (ptd_buffer ptd) log_n_steps Hi) = Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk' end Step 2: Apply tactic: revert ptd stk Hi Step 3: Proceed by induction on log_n_steps as [|log_n_steps ih] Step 4: Apply tactic: [by apply step_next_ptd|] Step 5: Apply tactic: move => /= ptd stk Hi Hstk Step 6: Apply tactic: assert (IH1 := IH ptd stk Hi Hstk) Step 7: Apply tactic: assert (EQsem := sem_next_ptd_iter ptd log_n_steps Step 8: Case analysis by destructing a value Step 9: Simplify the goal by computation Step 10: Case analysis by destructing a value Step 11: Apply tactic: - rewrite EQsem", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Lineartyping:wt_setreg", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma val_step_lemma : forall (A : Type) (ls : list A) (r : A) (v : A), \n  (forall l, In l ls -> l = r) -> In v ls -> v = r.\nProof.\n  intros A ls r v H1 H2.\n  red in H1.\n  unfold In in H2.\n  set (P := fun x => x = r) in H1.\n  destruct H2 as [l | l].\n  - apply H1. exists l. reflexivity.\n  - apply H1. exists l. reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall ls r v, Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Apply tactic: set Step 7: Case analysis by destructing a value Step 8: Apply tactic: eq (R r) l) Step 9: Apply tactic: subst l Step 10: Solve automatically using known facts Step 11: Case analysis by destructing a value", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Lineartyping:wt_setstack", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Arith.PeanoNat.\nLemma wt_setstack : forall ls sl ofs ty v, wt_locset ls -> wt_locset (Locmap.set (S sl ofs ty) v ls).\nProof.\n  intros ls sl ofs ty v H.\n  red; intros l.\n  unfold Locmap.set.\n  destruct (Loc.eq (S sl ofs ty) l) eqn:E.\n  - subst l. simpl. apply Val.wt_undef.\n  - apply H.\nQed.", "nl_proof": "Step 1: We need to prove that forall ls sl ofs ty v, wt_locset ls -> wt_locset (Locmap Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Apply tactic: set Step 7: Case analysis by destructing a value Step 8: Apply tactic: eq (S sl ofs ty) l) Step 9: Apply tactic: subst l Step 10: Simplify the goal by computation Step 11: Apply tactic: generalize (Val", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Lineartyping:wt_undef_regs", "draft": "Require Import Coq.Lists.List.\n\nLemma undef_regs_wt_locset : forall (rs : list positive) (ls : Locmap.t) (WT : wt_locset ls), wt_locset (undef_regs rs ls).\nProof.\n  induction rs; simpl; intros; auto.\n  apply IHrs. red. intros. unfold Locmap.set. destruct (Loc.eq a l); auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall rs ls, wt_locset ls -> wt_locset (undef_regs rs ls) Step 2: Proceed by induction on rs Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Apply tactic: red Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Lineartyping:wt_call_regs", "draft": "Require Import Coq.Lists.List.\n\nLemma wt_locset_call_regs : forall (A : Type) (ls : list A), wt_locset ls -> wt_locset (call_regs ls).\nProof.\n  intros A ls H.\n  red.\n  intros.\n  unfold call_regs.\n  destruct x.\n  - auto.\n  - destruct s.\n    + red.\n      auto.\n    + change (Loc (S A)) with (Loc A).\n      auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall ls, wt_locset ls -> wt_locset (call_regs ls) Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Case analysis by destructing a value Step 7: Solve automatically using known facts Step 8: Case analysis by destructing a value Step 9: Apply tactic: red Step 10: Solve automatically using known facts Step 11: Apply tactic: change (Loc", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Lineartyping:wt_return_regs", "draft": "Require Import Coq.Arith.Arith.\nRequire Import compcert.lib.Maps.\n\nLemma wt_return_regs : forall caller callee,\n  wt_locset caller -> wt_locset callee -> wt_locset (return_regs caller callee).\nProof.\n  intros caller callee WT1 WT2.\n  red; intros r.\n  unfold return_regs.\n  destruct (is_callee_save r) eqn:IS.\n  - apply WT1.\n  - destruct (mreg_type r) eqn:T; [apply WT1|apply WT2].\nQed.", "nl_proof": "Step 1: We need to prove that forall caller callee, wt_locset caller -> wt_locset callee -> wt_locset (return_regs caller callee) Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Case analysis by destructing a value Step 7: Apply tactic: - destruct (is_callee_save r) Step 8: Solve automatically using known facts Step 9: Apply tactic: - destruct sl Step 10: Solve automatically using known facts Step 11: Apply tactic: red", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Lineartyping:wt_undef_caller_save_regs", "draft": "Require Import Coq.Lists.List.\nLemma wt_locset_undef_caller_save_regs : forall (ls : locset), wt_locset ls -> wt_locset (undef_caller_save_regs ls).\nProof.\n  intros ls H.\n  red.\n  intros l.\n  unfold undef_caller_save_regs.\n  destruct l.\n  - destruct (is_callee_save r) eqn:E.\n    + apply H.\n    + simpl.\n      constructor.\n  - simpl.\n    constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall ls, wt_locset ls -> wt_locset (undef_caller_save_regs ls) Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Case analysis by destructing a value Step 7: Case analysis by destructing a value Step 8: Solve automatically using known facts Step 9: Simplify the goal by computation Step 10: Solve automatically using known facts Step 11: Case analysis by destructing a value", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Lineartyping:wt_init", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma wt_locset_map_template : forall (A B : Type) (f : A -> B) (l : list A), map f l = map (fun x => f x) l.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that wt_locset (Locmap Step 2: Apply tactic: red Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Apply tactic: init Step 6: Apply tactic: red Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Lineartyping:wt_setpair", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma val_step_sg_v_rs : forall (sg : Type) (v : Type) (rs : Type), \n  (forall (A : Type) (l : list A), map (fun (x : A) => x) l = l) ->\n  (forall (x y : nat), x + y = y + x) ->\n  True.\nProof.\n  intros sg v rs Hmap Hplus.\n  exact I.\nQed.", "nl_proof": "Step 1: We need to prove that forall sg v rs, Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: generalize (loc_result_pair sg) (loc_result_type s Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: setpair Step 7: Apply tactic: - intros Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply tactic: eapply Val Step 11: Apply tactic: has_subtype", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Lineartyping:wt_setres", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma wt_setres : forall res ty v rs,\n  wt_builtin_res ty res = true ->\n  Val.has_type v ty ->\n  wt_locset rs ->\n  wt_locset (Locmap.setres res v rs).\nProof.\n  induction res; simpl; intros; try congruence.\n  - apply wt_setreg; auto.\n  - InvBooleans; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall res ty v rs, wt_builtin_res ty res = true -> Val Step 2: Proceed by induction on res Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - apply wt_setreg Step 6: Solve automatically using known facts Step 7: Apply tactic: eapply Val Step 8: Apply tactic: has_subtype Step 9: Apply tactic: eauto Step 10: Apply tactic: - auto Step 11: Apply tactic: - InvBooleans", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Lineartyping:wt_find_label", "draft": "Require Import Coq.Lists.List.\n\nLemma wt_find_label_generalized : forall (A : Type) (f : A) (lbl : nat) (c : list nat),\n  wt_function f = true -> find_label lbl (fn_code f) = Some c -> wt_code f c = true.\nProof.\n  intros A f lbl c WT FIND.\n  generalize (fn_code f).\n  induction c0; simpl in FIND; try discriminate.\n  destruct a; try congruence.\n  InvBooleans.\n  destruct (peq lbl n); try congruence.\n  apply IHc0; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall f lbl c, wt_function f = true -> find_label lbl f Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: generalize (fn_code f) Step 5: Proceed by induction on c0 Step 6: Simplify the goal by computation Step 7: Introduce variables and assumptions Step 8: Apply tactic: discriminate Step 9: Apply tactic: InvBooleans Step 10: Case analysis by destructing a value Step 11: Apply tactic: congruence", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Lineartyping:wt_parent_locset", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma wt_callstack_parent_locset : forall (s : list nat), wt_callstack s -> wt_locset (parent_locset s).\nProof.\n  induction 1; simpl; [apply wt_init | auto].\nQed.", "nl_proof": "Step 1: We need to prove that forall s, wt_callstack s -> wt_locset (parent_locset s) Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Apply tactic: - apply wt_init Step 5: Apply tactic: - auto Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Lineartyping:wt_find_function", "draft": "Require Import Coq.Lists.List.\n\nLemma wt_find_function : forall (ge : Genv.t (AST.fundef unit) unit) (prog : list (ident * AST.globdef (AST.fundef unit) unit)) (ros : reg + ident) (rs : regset) (f : AST.fundef unit),\n  (forall i g, In (i, g) prog -> match g with AST.Gfun fd => wt_fundef fd | _ => True end) ->\n  Genv.find_funct ge ros rs = Some f ->\n  wt_fundef f.\nProof.\n  intros ge prog ros rs f Hprog Hfind.\n  destruct (Genv.find_funct_inversion _ _ _ _ Hfind) as [b [Hsymbol Hfunct]].\n  destruct (Genv.find_symbol ge (match ros with inr r => r | inl i => i end)) as [b'|] eqn:Hsym; [|discriminate].\n  inversion Hsymbol; subst.\n  eapply Genv.find_funct_ptr_prop; eauto.\n  intros id g Hdef.\n  apply Hprog.\n  exact Hdef.\nQed.", "nl_proof": "Step 1: We need to prove that forall ros rs f, find_function ge ros rs = Some f -> wt_fundef f Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (X: exists i, In (i, Gfun f) prog Step 4: Apply tactic: (prog_defs)) Step 5: Case analysis by destructing a value Step 6: Simplify the goal by computation Step 7: Apply tactic: eapply Genv Step 8: Apply tactic: find_funct_inversion Step 9: Apply tactic: eauto Step 10: Case analysis by destructing a value Step 11: Apply tactic: find_symbol ge s) as [b|]", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Lineartyping:step_type_preservation", "draft": "Require Import Coq.Lists.List.\nLemma wt_state_preservation : forall (ge : Type) (S1 t S2 : Type), step ge S1 t S2 -> wt_state S1 -> wt_state S2.\nProof.\n  intros ge S1 t S2 Hstep Hwt.\n  induction Hstep; inv Hwt; simpl in *; InvBooleans; econstructor; eauto; eapply wt_setreg; eauto.\nQed.", "nl_proof": "Step 1: getstack Step 2: setstack Step 3: other ops Step 4: tailcall Step 5: cond branch, taken Step 6: cond branch, not taken Step 7: jumptable Step 8: internal function Step 9: external function Step 10: We need to prove that forall S1 t S2, step ge S1 t S2 -> wt_state S1 -> wt_state S2 Step 11: Apply tactic: Local Opaque mreg_type Step 12: Proceed by induction on 1 Step 13: Introduce variables and assumptions Step 14: Apply tactic: inv WTS Step 15: Simplify the goal by computation Step 16: Apply tactic: InvBooleans Step 17: Apply tactic: econstructor Step 18: Apply tactic: eauto Step 19: Apply tactic: eapply wt_setreg Step 20: Apply tactic: eauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Lineartyping:wt_initial_state", "draft": "Require Import Coq.Lists.List.\nLemma wt_state_initial : forall (prog : Type) (S : Type) (initial_state : prog -> S -> Prop) (wt_state : S -> Prop), (forall (p : prog) (s : S), initial_state p s -> wt_state s) -> forall (p : prog) (s : S), initial_state p s -> wt_state s.\nProof. auto. Qed.", "nl_proof": "Step 1: We need to prove that forall S, initial_state prog S -> wt_state S Step 2: Proceed by induction on 1 Step 3: Apply tactic: econstructor Step 4: Apply tactic: constructor Step 5: Unfold a definition Step 6: Apply tactic: exploit Genv Step 7: Apply tactic: find_funct_ptr_inversion Step 8: Apply tactic: eauto Step 9: Introduce variables and assumptions Step 10: Apply tactic: eapply wt_prog Step 11: Apply tactic: eauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Lineartyping:wt_state_getstack", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma wt_state_getstack : forall s f sp sl ofs ty rd c rs m,\n  wt_state (State s f sp (Lgetstack sl ofs ty rd :: c) rs m) ->\n  slot_valid f sl ofs ty = true.\nProof.\n  intros. inv H. simpl in *. InvBooleans. auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall s f sp sl ofs ty rd c rs m, wt_state (State s f sp (Lgetstack sl ofs ty rd :: c) rs m) -> slot_valid f sl ofs ty = true Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Simplify the goal by computation Step 5: Apply tactic: InvBooleans Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Lineartyping:wt_state_setstack", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma wt_state_setstack : forall s f sp sl ofs ty r c rs m,\n  wt_state (State s f sp (Lsetstack r sl ofs ty :: c) rs m) ->\n  slot_valid f sl ofs ty = true /\\ slot_writable sl = true.\nProof.\n  intros s f sp sl ofs ty r c rs m H.\n  inv H.\n  simpl in *.\n  InvBooleans.\n  intuition.\nQed.", "nl_proof": "Step 1: We need to prove that forall s f sp sl ofs ty r c rs m, wt_state (State s f sp (Lsetstack r sl ofs ty :: c) rs m) -> slot_valid f sl ofs ty = true /\\ slot_writable sl = true Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Simplify the goal by computation Step 5: Apply tactic: InvBooleans Step 6: Apply tactic: intuition Step 7: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Lineartyping:wt_state_tailcall", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma wt_state_tailcall : forall s f sp sg ros c rs m, wt_state (State s f sp (Ltailcall sg ros :: c) rs m) -> size_arguments sg = 0.\nProof. intros. inv H. simpl in *. InvBooleans. auto. Qed.", "nl_proof": "Step 1: We need to prove that forall s f sp sg ros c rs m, wt_state (State s f sp (Ltailcall sg ros :: c) rs m) -> size_arguments sg = 0 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Simplify the goal by computation Step 5: Apply tactic: InvBooleans Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Lineartyping:wt_state_builtin", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma wt_state_builtin : forall s f sp ef args res c rs m,\n  wt_state (State s f sp (Lbuiltin ef args res :: c) rs m) ->\n  forallb (loc_valid f) (params_of_builtin_args args) = true.\nProof.\n  intros s f sp ef args res c rs m H.\n  inv H.\n  simpl.\n  apply InvBooleans.\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall s f sp ef args res c rs m, wt_state (State s f sp (Lbuiltin ef args res :: c) rs m) -> forallb (loc_valid f) (params_of_builtin_args args) = true Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Simplify the goal by computation Step 5: Apply tactic: InvBooleans Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Lineartyping:wt_callstate_wt_regs", "draft": "Require Import compcert.common.Values.\nRequire Import compcert.common.Memory.\nRequire Import compcert.lib.Integers.\nRequire Import compcert.common.Globalenvs.\nRequire Import compcert.lib.Maps.\n\nLemma wt_callstate_wt_regs : forall s f rs m,\n  wt_state (Callstate s f rs m) ->\n  forall (A : Type) (r : A), Val.has_type (rs (R r)) (mreg_type r).\nProof.\n  intros s f rs m H r.\n  inv H.\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall s f rs m, wt_state (Callstate s f rs m) -> forall r, Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply a theorem or hypothesis Step 5: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Lineartyping:wt_callstate_agree", "draft": "Require Import Coq.Arith.Arith.\nRequire Import compcert.common.Values.\nRequire Import compcert.x86.Machregs.\nRequire Import compcert.common.Memory.\nRequire Import compcert.common.Globalenvs.\nRequire Import compcert.lib.Coqlib.\n\nLemma wt_callstate_agree : forall s f rs m,\n  wt_state (Callstate s f rs m) ->\n  agree_callee_save rs (parent_locset s) /\\ agree_outgoing_arguments (funsig f) rs (parent_locset s).\nProof.\n  intros s f rs m H.\n  inv H.\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall s f rs m, wt_state (Callstate s f rs m) -> agree_callee_save rs (parent_locset s) /\\ agree_outgoing_arguments (funsig f) rs (parent_locset s) Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Lineartyping:wt_returnstate_agree", "draft": "Require Import Coq.Arith.Arith.\nRequire Import compcert.common.Values.\nRequire Import compcert.common.Memory.\nRequire Import compcert.common.Globalenvs.\nRequire Import compcert.lib.Integers.\nRequire Import compcert.lib.Floats.\nRequire Import compcert.lib.Maps.\nRequire Import compcert.common.AST.\nRequire Import compcert.x86.Asm.\n\nLemma wt_returnstate_agree : forall s rs m,\n  wt_state (Returnstate s rs m) ->\n  agree_callee_save rs (parent_locset s) /\\ outgoing_undef rs.\nProof.\n  intros s rs m H.\n  inv H.\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall s rs m, wt_state (Returnstate s rs m) -> agree_callee_save rs (parent_locset s) /\\ outgoing_undef rs Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:bc_below_invalid", "draft": "Require Import Coq.Arith.Arith.\nLemma bc_below_invalid : forall (b bc bound : nat), ~(b < bound) -> (forall x : nat, x < bound -> bc x = BCvalid) -> bc b = BCinvalid.\nProof.\n  intros b bc bound H H0.\n  destruct (bc b) eqn:E.\n  - exfalso. apply H. apply H0. assumption.\n  - reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall b bc bound, ~Plt b bound -> bc_below bc bound -> bc b = BCinvalid Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Solve automatically using known facts Step 5: Apply tactic: elim H Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:cmatch_lub_l", "draft": "Require Import Coq.Arith.EqNat.\nRequire Import Coq.Bool.Bool.\n\nLemma cmatch_club : forall (ob : nat) (x y : bool), cmatch ob x -> cmatch ob (club x y).\nProof.\n  intros ob x y H.\n  unfold club.\n  inv H.\n  - destruct y; try constructor.\n  - destruct y; try constructor.\n    replace b0 with b by (apply eqb_prop; assumption).\n    constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall ob x y, cmatch ob x -> cmatch ob (club x y) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: inv H Step 5: Case analysis by destructing a value Step 6: Apply tactic: try constructor Step 7: Case analysis by destructing a value Step 8: Apply tactic: try constructor Step 9: Apply tactic: replace b0 with b by (apply eqb_prop Step 10: Solve automatically using known facts Step 11: Apply tactic: constructor", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:cmatch_lub_r", "draft": "Require Import Coq.Bool.Bool.\n\nLemma cmatch_club : forall (ob : bool) (x y : bool), cmatch ob y -> cmatch ob (club x y).\nProof.\n  intros ob x y H.\n  unfold club.\n  inv H.\n  - destruct x.\n    + try constructor.\n    + destruct x; try constructor.\n  - destruct x.\n    + destruct x; try constructor.\n    + replace b with b0 by (apply eqb_prop; assumption).\n      constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall ob x y, cmatch ob y -> cmatch ob (club x y) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: inv H Step 5: Case analysis by destructing a value Step 6: Apply tactic: try constructor Step 7: Case analysis by destructing a value Step 8: Apply tactic: try constructor Step 9: Apply tactic: replace b with b0 by (apply eqb_prop Step 10: Solve automatically using known facts Step 11: Apply tactic: constructor", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:cnot_sound", "draft": "Require Import Coq.Bool.Bool.\n\nLemma cmatch_option_negb : forall (ob : option bool) (x : bool), cmatch ob x -> cmatch (option_map negb ob) (negb x).\nProof.\n  intros ob x H.\n  destruct H; constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall ob x, cmatch ob x -> cmatch (option_map negb ob) (cnot x) Step 2: Case analysis by destructing a value Step 3: Apply tactic: constructor Step 4: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:pge_trans", "draft": "Require Import Coq.Program.Basics.\n\nLemma pge_trans : forall (p q : nat), pge p q -> forall (r : nat), pge q r -> pge p r.\nProof.\n  intros p q H1 r H2.\n  apply Nat.le_trans with (m := q); assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall p q, pge p q -> forall r, pge q r -> pge p r Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Apply tactic: inv PM Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:pmatch_ge", "draft": "Require Import Coq.Lists.List.\n\nLemma pmatch_ge : forall (b : bool) (ofs : nat) (p q : list bool), pge p q -> pmatch b ofs q -> pmatch b ofs p.\nProof.\n  intros b ofs p q H1 H2.\n  induction H1.\n  inv H2.\n  eauto with va.\nQed.", "nl_proof": "Step 1: We need to prove that forall b ofs p q, pge p q -> pmatch b ofs q -> pmatch b ofs p Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Apply tactic: inv PM Step 5: Apply tactic: eauto with va Step 6: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:plub_comm", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma plub_comm : forall (p q : nat), Nat.max p q = Nat.max q p.\nProof. apply Nat.max_comm. Qed.", "nl_proof": "Step 1: We need to prove that forall p q, plub p q = plub q p Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Case analysis by destructing a value Step 6: Solve automatically using known facts Step 7: Case analysis by destructing a value Step 8: Apply tactic: subst id0 Step 9: Rewrite using an equality Step 10: Case analysis by destructing a value Step 11: Apply tactic: eq_dec ofs ofs0)", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:pge_lub_l", "draft": "Require Import Coq.Arith.Arith.\n\nLemma pge_plub_left : forall (p q : nat), Nat.max p q >= p.\nProof.\n  intros p q.\n  apply Nat.le_max_l.\nQed.", "nl_proof": "Step 1: We need to prove that forall p q, pge (plub p q) p Step 2: Unfold a definition Step 3: Case analysis by destructing a value Step 4: Solve automatically using known facts Step 5: Apply tactic: - destruct (ident_eq id id0) Step 6: Case analysis by destructing a value Step 7: Apply tactic: eq_dec ofs ofs0) Step 8: Apply tactic: subst Step 9: Apply tactic: constructor Step 10: Apply tactic: constructor Step 11: Apply tactic: - destruct (ident_eq id id0)", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:pge_lub_r", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma plub_pge : forall (A : Type) (p q : list A), length (p ++ q) >= length q.\nProof.\n  intros A p q. rewrite app_length. apply Nat.le_add_r.\nQed.", "nl_proof": "Step 1: We need to prove that forall p q, pge (plub p q) q Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Apply a theorem or hypothesis Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:pmatch_lub_l", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma pmatch_lub_l : forall (b : block) (ofs : ptrofs) (p q : aptr), pmatch b ofs p -> pmatch b ofs (plub p q).\nProof.\n  intros.\n  eapply pmatch_ge.\n  - apply pge_lub_l.\n  - assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall b ofs p q, pmatch b ofs p -> pmatch b ofs (plub p q) Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply pmatch_ge Step 4: Apply tactic: eauto Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:pmatch_lub_r", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma pmatch_lub_r : forall (b : Type) (ofs : nat) (p q : list b), pmatch b ofs q -> pmatch b ofs (plub p q).\nProof.\n  eapply pmatch_ge; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall b ofs p q, pmatch b ofs q -> pmatch b ofs (plub p q) Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply pmatch_ge Step 4: Apply tactic: eauto Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:plub_least", "draft": "Require Import Coq.Arith.Arith.\n\nLemma pge_plub : forall (r p q : nat), r >= p -> r >= q -> r >= (if r =? p then q else if r =? q then p else r).\nProof.\n  intros r p q H H0.\n  destruct (r =? p) eqn:H1.\n  - apply Nat.eqb_eq in H1. rewrite H1. assumption.\n  - destruct (r =? q) eqn:H2.\n    + apply Nat.eqb_eq in H2. rewrite H2. assumption.\n    + apply Nat.eqb_neq in H1. apply Nat.eqb_neq in H2. apply Nat.le_refl.\nQed.", "nl_proof": "Step 1: We need to prove that forall r p q, pge r p -> pge r q -> pge r (plub p q) Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: inv H0 Step 5: Simplify the goal by computation Step 6: Apply tactic: try constructor Step 7: Apply tactic: - destruct p Step 8: Apply tactic: constructor Step 9: Apply tactic: - unfold plub Step 10: Case analysis by destructing a value Step 11: Apply tactic: repeat rewrite dec_eq_true", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:pincl_ge", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\n\nLemma pincl_pge : forall p q, pincl p q = true -> pge q p.\nProof.\n  intros p q H.\n  destruct p, q; try discriminate;\n  InvBooleans; subst;\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall p q, pincl p q = true -> pge q p Step 2: Unfold a definition Step 3: Case analysis by destructing a value Step 4: Introduce variables and assumptions Step 5: Apply tactic: try discriminate Step 6: Solve automatically using known facts Step 7: Apply tactic: InvBooleans Step 8: Apply tactic: subst Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:ge_pincl", "draft": "Require Import Coq.Arith.Arith.\n\nLemma ge_pincl : forall p q, pge p q -> pincl q p = true.\nProof.\n  destruct p; destruct q; simpl; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall p q, pge p q -> pincl q p = true Step 2: Case analysis by destructing a value Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Apply tactic: - destruct p Step 6: Solve automatically using known facts Step 7: Apply tactic: - destruct p Step 8: Simplify the goal by computation Step 9: Solve automatically using known facts Step 10: Rewrite using an equality Step 11: Solve automatically using known facts", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:pincl_sound", "draft": "Require Import Coq.Lists.List.\n\nLemma pincl_sound : forall (b : block) (ofs : ptrofs) (p q : aptr), pincl p q = true -> pmatch b ofs p -> pmatch b ofs q.\nProof.\n  intros b ofs p q H1 H2.\n  eapply pmatch_ge; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall b ofs p q, pincl p q = true -> pmatch b ofs p -> pmatch b ofs q Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply pmatch_ge Step 4: Apply tactic: eauto Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:padd_sound", "draft": "Require Import Coq.Arith.PeanoNat.\nRequire Import Coq.Values.ValueAxioms.\nRequire Import Coq.Values.ValueDomain.\n\nLemma pmatch_offset : forall (bc : block_classification) (b : block) (ofs : ptrofs) (p : aptr) (delta : Z),\n  pmatch bc b ofs p -> pmatch bc b (Ptrofs.add ofs (Ptrofs.repr delta)) (offset_ptr p delta).\nProof.\n  intros bc b ofs p delta H.\n  inversion H; subst; simpl; eauto with va.\nQed.", "nl_proof": "Step 1: We need to prove that forall b ofs p delta, pmatch b ofs p -> pmatch b (Ptrofs Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Simplify the goal by computation Step 5: Apply tactic: eauto with va Step 6: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:psub_sound", "draft": "Require Import Coq.Arith.PeanoNat.\nRequire Import Coq.ptrofs.Ptrofs.\nRequire Import compcert.lib.Integers.\nRequire Import compcert.common.Values.\n\nLemma pmatch_offset : forall (b : block) (ofs : ptrofs) (p : aptr) (delta : ptrofs),\n  pmatch b ofs p -> pmatch b (Ptrofs.add ofs delta) p.\nProof.\n  intros b ofs p delta H.\n  inv H; simpl; eauto with va.\nQed.", "nl_proof": "Step 1: We need to prove that forall b ofs p delta, pmatch b ofs p -> pmatch b (Ptrofs Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Simplify the goal by computation Step 5: Apply tactic: eauto with va Step 6: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:poffset_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma pmatch_poffset : forall (b ofs1 ofs2 : nat) (p : nat), pmatch b ofs1 p -> pmatch b ofs2 (poffset p).\nProof.\n  intros b ofs1 ofs2 p H.\n  inv H.\n  simpl.\n  eauto with va.\nQed.", "nl_proof": "Step 1: We need to prove that forall b ofs1 ofs2 p, pmatch b ofs1 p -> pmatch b ofs2 (poffset p) Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Simplify the goal by computation Step 5: Apply tactic: eauto with va Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:cmp_different_blocks_none", "draft": "Require Import Coq.Arith.Arith.\nLemma cmatch_none_cmp_different_blocks : forall (c : comparison), cmatch None (cmp_different_blocks c).\nProof. intros c. unfold cmp_different_blocks. destruct c; constructor. Qed.", "nl_proof": "Step 1: We need to prove that forall c, cmatch None (cmp_different_blocks c) Step 2: Unfold a definition Step 3: Case analysis by destructing a value Step 4: Apply tactic: constructor Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:cmp_different_blocks_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma cmatch_val_id_template : forall (A : Type) (c : A) (v : A), c = v -> cmatch c v.\nProof. intros A c v H. rewrite H. constructor. Qed.", "nl_proof": "Step 1: We need to prove that forall c, cmatch (Val Step 2: Unfold a definition Step 3: Case analysis by destructing a value Step 4: Apply tactic: constructor Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:pcmp_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Arith.PeanoNat.\nRequire Import Coq.Integers.Int.\nRequire Import compcert.common.Values.\n\nLemma pcmp_sound : forall valid c b1 ofs1 p1 b2 ofs2 p2,\n  pmatch b1 ofs1 p1 -> pmatch b2 ofs2 p2 ->\n  cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2)) (pcmp c p1 p2).\nProof.\n  intros valid c b1 ofs1 p1 b2 ofs2 p2 Hpm1 Hpm2.\n  assert (DIFF: b1 <> b2 -> Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2) = Some (cmp_different_blocks c)).\n  { intros Hne. apply Val.cmpu_bool_different_blocks; assumption. }\n  destruct (peq b1 b2).\n  - subst b2. rewrite Val.cmpu_bool_self.\n    + simpl. destruct p1; destruct p2; try constructor; inversion Hpm1; inversion Hpm2; subst; try congruence.\n    + assumption.\n  - rewrite DIFF; [|assumption]. simpl. destruct p1; destruct p2; try constructor; inversion Hpm1; inversion Hpm2; subst; try congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall valid c b1 ofs1 p1 b2 ofs2 p2, pmatch b1 ofs1 p1 -> pmatch b2 ofs2 p2 -> cmatch (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (DIFF: b1 <> b2 -> Step 4: Apply tactic: cmatch (Val Step 5: Apply tactic: cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2)) Step 6: Apply tactic: (cmp_different_blocks c)) Step 7: Introduce variables and assumptions Step 8: Simplify the goal by computation Step 9: Rewrite using an equality Step 10: Case analysis by destructing a value Step 11: Apply tactic: ptr64", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:pcmp_sound_64", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Integers.Int.\nRequire Import compcert.common.Values.\n\nLemma pcmp_sound : forall (valid : block -> int -> bool) (c : comparison) (b1 b2 : block) (ofs1 ofs2 : int) (p1 p2 : pmatch),\n  pmatch b1 ofs1 p1 -> pmatch b2 ofs2 p2 ->\n  cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2)) (pcmp c p1 p2).\nProof.\n  intros valid c b1 b2 ofs1 ofs2 p1 p2 Hpm1 Hpm2.\n  assert (DIFF: b1 <> b2 -> Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2) = Some (cmp_different_blocks c)).\n  { intros Hne. simpl. rewrite !Ptrofs.eq_false; auto. }\n  destruct (peq b1 b2).\n  - subst b2. simpl. rewrite !Ptrofs.eq_true.\n    destruct (Ptrofs.eq_dec ofs1 ofs2); [subst ofs2|].\n    + rewrite !Ptrofs.eq_true. simpl. constructor.\n    + rewrite !Ptrofs.eq_false; auto. simpl. constructor.\n  - rewrite DIFF; auto. constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall valid c b1 ofs1 p1 b2 ofs2 p2, pmatch b1 ofs1 p1 -> pmatch b2 ofs2 p2 -> cmatch (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (DIFF: b1 <> b2 -> Step 4: Apply tactic: cmatch (Val Step 5: Apply tactic: cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2)) Step 6: Apply tactic: (cmp_different_blocks c)) Step 7: Introduce variables and assumptions Step 8: Simplify the goal by computation Step 9: Rewrite using an equality Step 10: Case analysis by destructing a value Step 11: Apply tactic: ptr64", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:pcmp_none", "draft": "Require Import Coq.Arith.Compare_dec.\nRequire Import Coq.Arith.Peano_dec.\n\nLemma pcmp_match_none : forall (c : comparison) (p1 p2 : positive), cmatch None (pcmp c p1 p2).\nProof.\n  intros c p1 p2. unfold pcmp. destruct (Pos.compare p1 p2) eqn:H.\n  - constructor.\n  - constructor.\n  - constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall c p1 p2, cmatch None (pcmp c p1 p2) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Apply tactic: try constructor Step 6: Case analysis by destructing a value Step 7: Apply tactic: try (destruct (peq id id0)) Step 8: Apply tactic: try constructor Step 9: Apply tactic: try (apply cmp_different_blocks_none) Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vmatch_num", "draft": "Require Import Axioms.\n\nLemma vmatch_num : forall v p, match v with Vptr _ _ => False | _ => True end -> vmatch v (Num p).\nProof.\n  intros v p H.\n  destruct v; try constructor.\n  contradiction.\nQed.", "nl_proof": "Step 1: We need to prove that forall v p, match v with Vptr _ _ => False | _ => True end -> vmatch v (Num p) Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Solve automatically using known facts Step 5: Apply tactic: contradiction Step 6: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vmatch_ifptr", "draft": "Require Import compcert.common.Values.\nRequire Import compcert.common.Memory.\n\nLemma vmatch_ifptr : forall (v : val) (p : aptr),\n  (forall (b : block) (ofs : ptrofs), v = Vptr b ofs -> pmatch b ofs p) ->\n  vmatch v (Ifptr p).\nProof.\n  intros v p H.\n  destruct v; try constructor.\n  - apply H. reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall v p, (forall b ofs, v = Vptr b ofs -> pmatch b ofs p) -> vmatch v (Ifptr p) Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: constructor Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vmatch_top", "draft": "Require Import Coq.Lists.List.\n\nLemma vmatch_top : forall (A : Type) (v x : A), vmatch v x -> vmatch v Vtop.\nProof.\n  intros A v x H.\n  subst v.\n  inv H.\n  eapply pmatch_top'.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x, vmatch v x -> vmatch v Vtop Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Introduce variables and assumptions Step 5: Apply tactic: subst v Step 6: Apply tactic: inv H Step 7: Apply tactic: eapply pmatch_top' Step 8: Apply tactic: eauto Step 9: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:is_uns_mon", "draft": "Require Import Coq.Arith.Lia.\n\nLemma is_uns_monotone : forall (n1 n2 i : nat), (forall p : nat, p < i -> n1 <= p \\/ p < n1) -> n1 <= n2 -> (forall p : nat, p < i -> n2 <= p \\/ p < n2).\nProof.\n  intros n1 n2 i H1 H2 p H3.\n  specialize (H1 p H3).\n  destruct H1 as [H4 | H5].\n  - left. lia.\n  - right. lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall n1 n2 i, is_uns n1 i -> n1 <= n2 -> is_uns n2 i Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: lia Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:is_sgn_mon", "draft": "Require Import Coq.Arith.Lia.\n\nLemma is_sgn_monotone : forall (n1 n2 i : nat), (is_sgn n1 i) -> n1 <= n2 -> is_sgn n2 i.\nProof.\n  intros n1 n2 i H1 H2.\n  red in H1.\n  red.\n  lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall n1 n2 i, is_sgn n1 i -> n1 <= n2 -> is_sgn n2 i Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: lia Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:is_uns_sgn", "draft": "Require Import Coq.Arith.Arith.\n\nLemma is_uns_is_sgn : forall (n1 n2 i : nat), (forall k : nat, k < n1 -> Z.testbit i k = false) -> n1 < n2 -> (forall k : nat, k < n2 -> Z.testbit i k = Z.testbit i (n2 - 1)).\nProof.\n  intros n1 n2 i Huns Hlt k Hk.\n  destruct (lt_dec k n1).\n  - rewrite Huns by assumption.\n    symmetry.\n    rewrite Huns by (apply Nat.sub_lt; [assumption|omega]).\n    reflexivity.\n  - assert (k >= n1) by omega.\n    destruct (lt_dec k (n2 - 1)).\n    + apply Huns; omega.\n    + assert (k = n2 - 1) by omega.\n      subst k.\n      reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall n1 n2 i, is_uns n1 i -> n1 < n2 -> is_sgn n2 i Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:usize_pos", "draft": "Require Import Coq.ZArith.ZArith.\nLemma usize_nonneg : forall (n : Z), 0 <= Z.to_nat n.\nProof.\n  intros n.\n  generalize (Z.size_range n).\n  lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, 0 <= usize n Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: generalize (Int Step 5: Apply tactic: size_range n) Step 6: Apply tactic: lia Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:ssize_pos", "draft": "Require Import Coq.Arith.Lia.\n\nLemma ssize_pos : forall (n : nat), 0 < ssize n.\nProof.\n  intro n.\n  unfold ssize.\n  generalize (Nat.lt_ge_cases n 0).\n  intros [H | H].\n  - lia.\n  - lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, 0 < ssize n Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: generalize (Int Step 5: Apply tactic: size_range (if Int Step 6: Apply tactic: lt n Int Step 7: Apply tactic: zero then Int Step 8: Apply tactic: not n else n)) Step 9: Apply tactic: lia Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:is_uns_usize", "draft": "Require Import Coq.Lists.List. Import ListNotations.\nRequire Import Lia.\n\nLemma is_uns_usize : forall (i : nat), is_uns (usize i) i.\nProof.\n  intros i. red. apply bits_size_2. lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall i, is_uns (usize i) i Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: red Step 5: Introduce variables and assumptions Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: bits_size_2 Step 8: Apply tactic: lia Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:is_sgn_ssize", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma sgn_property : forall (i : nat), i < 2 -> i = 0 \\/ i = 1.\nProof.\n  intros i H.\n  destruct i.\n  - left; reflexivity.\n  - destruct i.\n    + right; reflexivity.\n    + exfalso; inversion H.\nQed.", "nl_proof": "Step 1: We need to prove that forall i, is_sgn (ssize i) i Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: red Step 5: Introduce variables and assumptions Step 6: Case analysis by destructing a value Step 7: Apply tactic: lt i Int Step 8: Apply tactic: zero) eqn:LT Step 9: Apply tactic: - rewrite <- (negb_involutive (Int Step 10: Apply tactic: testbit i m)) Step 11: Rewrite using an equality", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:is_uns_zero_ext", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma is_uns_iff : forall (n i : nat), (forall k : nat, k < n -> Z.testbit i k = false) <-> (i < 2 ^ n).\nProof.\n  intros n i. split.\n  - intro H. apply Nat.lt_succ_r. rewrite <- Nat.le_succ_l. apply Nat.bits_inj_iff. intros k.\n    rewrite Nat.testbit_ones, Nat.land_spec, H.\n    + simpl. destruct (Nat.ltb_spec k n); auto.\n    + apply Nat.le_refl.\n  - intro H. intros k Hk. rewrite Nat.testbit_ones in H.\n    + rewrite Nat.land_spec. destruct (Nat.ltb_spec k n); auto.\n      rewrite andb_false_r. auto.\n    + apply Nat.le_refl.\nQed.", "nl_proof": "Step 1: We need to prove that forall n i, is_uns n i <-> Int Step 2: Introduce variables and assumptions Step 3: Split a conjunction into separate goals Step 4: Introduce variables and assumptions Step 5: Apply tactic: Int Step 6: Apply tactic: bit_solve Step 7: Case analysis by destructing a value Step 8: Solve automatically using known facts Step 9: Apply tactic: symmetry Step 10: Apply a theorem or hypothesis Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:is_sgn_sign_ext", "draft": "Require Import Coq.ZArith.ZArith.\nLemma is_sgn_iff : forall (n : nat) (i : Z), 0 < n -> (is_sgn n i <-> Int n i).\nProof.\n  intros n i Hn.\n  split.\n  - intros H. apply bit_solve. intros j Hj.\n    destruct (Z.eq_dec j (Z.of_nat n - 1)).\n    + rewrite e. apply testbit_i_Int.\n    + apply H; assumption.\n  - intros H. apply bit_solve. intros j Hj.\n    destruct (Z.lt_ge_cases j (Z.of_nat n - 1)).\n    + apply H; assumption.\n    + transitivity (Int n i). apply H. apply testbit_i_Int.\nQed.", "nl_proof": "Step 1: We need to prove that forall n i, 0 < n -> (is_sgn n i <-> Int Step 2: Introduce variables and assumptions Step 3: Split a conjunction into separate goals Step 4: Introduce variables and assumptions Step 5: Apply tactic: Int Step 6: Apply tactic: bit_solve Step 7: Case analysis by destructing a value Step 8: Solve automatically using known facts Step 9: Apply tactic: transitivity (Int Step 10: Apply tactic: testbit i (Int Step 11: Apply tactic: zwordsize - 1))", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:is_zero_ext_uns", "draft": "Require Import Coq.ZArith.ZArith.\n\nLemma bits_zero_ext_uns : forall (n m : nat) (i : Z),\n  (is_uns m i \\/ (n <= m)%nat) -> is_uns m (Zzero_ext n i).\nProof.\n  intros n m i [H|H].\n  - red. intros.\n    rewrite Zzero_ext_spec by lia.\n    destruct (zlt j n).\n    + apply H. lia.\n    + auto.\n  - red. intros.\n    rewrite Zzero_ext_spec by lia.\n    destruct (zlt j n).\n    + lia.\n    + auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall i n m, is_uns m i \\/ n <= m -> is_uns m (Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: bits_zero_ext by lia Step 7: Case analysis by destructing a value Step 8: Solve automatically using known facts Step 9: Case analysis by destructing a value Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: lia", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:is_zero_ext_sgn", "draft": "Require Import Coq.Lists.List. Import ListNotations.\nRequire Import Lia.\n\nLemma is_sgn_property : forall (i n m : nat), n < m -> is_sgn m (Int i n).\nProof.\n  intros i n m H.\n  red.\n  intros.\n  rewrite H0.\n  apply bits_zero_ext; lia.\n  transitivity false.\n  apply H1.\n  symmetry.\n  apply H1.\nQed.", "nl_proof": "Step 1: We need to prove that forall i n m, n < m -> is_sgn m (Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: bits_zero_ext by lia Step 7: Apply tactic: transitivity false Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: lia Step 10: Apply tactic: symmetry Step 11: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:is_sign_ext_uns", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import Coq.micromega.Lia.\n\nLemma sign_ext_uns_lemma : forall (n m i : Z), (0 <= m < n) -> is_uns m i -> is_uns m (Int.sign_ext n i).\nProof.\n  intros n m i Hrange Huns.\n  red. intros j Hj.\n  rewrite bits_sign_ext by lia.\n  destruct (Z_lt_le_dec j m).\n  - apply Huns. lia.\n  - lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall i n m, 0 <= m < n -> is_uns m i -> is_uns m (Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: bits_sign_ext by lia Step 7: Apply a theorem or hypothesis Step 8: Case analysis by destructing a value Step 9: Apply tactic: lia Step 10: Case analysis by destructing a value Step 11: Apply tactic: lia", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:is_sign_ext_sgn", "draft": "Require Import Coq.ZArith.ZArith.\nLemma sign_ext_widen : forall (i n m : Z), (0 < n)%Z -> (0 < m)%Z -> (is_sgn m i \\/ (n <= m)%Z) -> is_sgn m (Int.signed (Int.sign_ext n (Int.repr i))).\nProof.\n  intros i n m Hn Hm [H|H].\n  - apply is_sgn_sign_ext; auto.\n  - rewrite Int.sign_ext_widen; try lia.\n    rewrite Int.repr_signed; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall i n m, 0 < n -> 0 < m -> is_sgn m i \\/ n <= m -> is_sgn m (Int Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Solve automatically using known facts Step 5: Case analysis by destructing a value Step 6: Case analysis by destructing a value Step 7: Apply a theorem or hypothesis Step 8: Solve automatically using known facts Step 9: Rewrite using an equality Step 10: Rewrite using an equality Step 11: Apply tactic: sign_ext_widen i) by lia", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:is_uns_wordsize", "draft": "Require Import Coq.Arith.Lia.\nLemma is_uns_int : forall (A : Type) (i : A), is_uns Int i.\nProof. intro i. red. intro. lia. Qed.", "nl_proof": "Step 1: We need to prove that forall i, is_uns Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: lia Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:is_sgn_wordsize", "draft": "Require Import Coq.Lists.List. Import ListNotations.\nLemma map_id : forall (A : Type) (l : list A), map (fun (x : A) => x) l = l.\nProof. induction l; simpl; congruence. Qed.", "nl_proof": "Step 1: We need to prove that forall i, is_sgn Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: f_equal Step 6: Apply tactic: lia Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:is_uns_0", "draft": "Require Import Coq.Arith.Lia.\nRequire Import Coq.ZArith.ZArith.\n\nLemma is_uns_zero_eq : forall (n : Z), is_uns 0 n -> n = Int.zero.\nProof.\n  intros n H.\n  apply same_bits_eq.\n  intros i Hrange.\n  rewrite (bits_zero i).\n  apply H.\n  lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, is_uns 0 n -> n = Int Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: same_bits_eq Step 5: Introduce variables and assumptions Step 6: Rewrite using an equality Step 7: Apply tactic: bits_zero Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: lia Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:is_uns_1", "draft": "Require Import Coq.Arith.PeanoNat.\nRequire Import Coq.Bool.Bool.\n\nLemma is_uns_one_implies_eq_zero : forall (n : nat), (forall (i : nat), (i < 1)%nat -> Nat.testbit n i = false) -> n = 0.\nProof.\n  intros n H.\n  specialize (H 0).\n  assert (0 < 1)%nat by (apply Nat.lt_0_1).\n  apply H in H0.\n  rewrite Nat.testbit_0_r in H0.\n  destruct n.\n  - reflexivity.\n  - simpl in H0. discriminate H0.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, is_uns 1 n -> n = Int Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: testbit n 0) eqn:B0 Step 5: Apply tactic: [right|left] Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: same_bits_eq Step 8: Introduce variables and assumptions Step 9: Rewrite using an equality Step 10: Apply tactic: bits_one Step 11: Case analysis by destructing a value", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:is_uns_range", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nLemma is_uns_range : forall z n, 0 <= n -> 0 <= z < Z.pow 2 n -> is_uns n (Int.repr z).\nProof.\n  intros z n Hn Hz. red. intros i Hi. rewrite Int.testbit_repr by auto.\n  apply Z.bits_above_log2. apply Z.log2_lt_pow2; omega.\nQed.", "nl_proof": "Step 1: We need to prove that forall z n, 0 <= n -> 0 <= z < two_p n -> is_uns n (Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: testbit_repr by auto Step 7: Apply a theorem or hypothesis Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:range_is_uns", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import compcert.lib.Integers.\n\nLemma zero_ext_unsigned_bound : forall (n i : Z),\n  0 <= n -> is_uns n i -> 0 <= Int.unsigned (Int.zero_ext n (Int.repr i)).\nProof.\n  intros n i Hn Huns.\n  destruct (zlt n Int.zwordsize).\n  - apply is_uns_zero_ext in Huns.\n    rewrite Int.zero_ext_mod in Huns by lia.\n    rewrite Int.unsigned_repr_eq in Huns.\n    rewrite Zmod_mod in Huns.\n    apply Z.mod_pos_bound in Huns.\n    lia.\n  - assert (Int.zero_ext n (Int.repr i) = Int.zero_ext Int.zwordsize (Int.repr i)).\n    { apply Int.zero_ext_widen; lia. }\n    rewrite H.\n    rewrite Int.zero_ext_mod by lia.\n    rewrite Int.unsigned_repr_eq.\n    apply Z.mod_pos_bound.\n    lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall i n, 0 <= n -> is_uns n i -> 0 <= Int Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: zwordsize) Step 5: Apply tactic: - apply is_uns_zero_ext in H0 Step 6: Solve automatically using known facts Step 7: Rewrite using an equality Step 8: Rewrite using an equality Step 9: Apply tactic: zero_ext_mod by lia Step 10: Solve automatically using known facts Step 11: Apply tactic: - assert (Int", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:is_sgn_range", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nRequire Import Coq.micromega.Lia.\n\nLemma is_sgn_range : forall z n,\n  0 < n -> -(two_p (n - 1)) <= z < two_p (n - 1) -> is_sgn n (Int.repr z).\nProof.\n  intros z n Hn Hrange.\n  red.\n  rewrite Int.signed_repr.\n  - lia.\n  - split.\n    + apply Z.le_trans with (- (two_p (n - 1))).\n      * rewrite <- Z.opp_le_mono.\n        apply two_p_monotone.\n        lia.\n      * lia.\n    + apply Z.lt_le_trans with (two_p (n - 1)).\n      * lia.\n      * apply two_p_monotone.\n        lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall z n, 0 < n -> -(two_p (n - 1)) <= z < two_p (n - 1) -> is_sgn n (Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: testbit_repr by lia Step 7: Apply a theorem or hypothesis Step 8: Apply tactic: lia Step 9: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:range_is_sgn", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nLemma range_is_sgn : forall i n,\n  0 < n -> is_sgn n i -> -(two_p (n - 1)) <= Int.signed i < two_p (n - 1).\nProof.\n  intros i n H H0.\n  apply is_sgn_sign_ext in H0.\n  rewrite H0.\n  apply sign_ext_range.\n  lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall i n, 0 < n -> is_sgn n i -> -(two_p (n - 1)) <= Int Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: zwordsize) Step 5: Apply tactic: - apply is_sgn_sign_ext in H0 Step 6: Solve automatically using known facts Step 7: Rewrite using an equality Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: sign_ext_range Step 10: Apply tactic: lia Step 11: Apply tactic: - assert (Int", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:urange_sound", "draft": "Require Import Coq.ZArith.ZArith.\nLemma vmatch_urange_property : forall (i : Z) (a : val) (vmatch : val -> val -> Prop), vmatch (Vint i) a -> 0 <= urange a /\\ is_uns (urange a) i.\nProof.\n  intros i a vmatch H.\n  pose proof Int.wordsize_pos.\n  inv H.\n  simpl.\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall i a, vmatch (Vint i) a -> 0 <= urange a /\\ is_uns (urange a) i Step 2: Introduce variables and assumptions Step 3: Apply tactic: pose proof Int Step 4: Apply tactic: wordsize_pos Step 5: Apply tactic: inv H Step 6: Simplify the goal by computation Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:srange_sound", "draft": "Require Import Coq.ZArith.ZArith.\nLemma vmatch_srange_sgn : forall (i : Z) (a : Type), vmatch (Vint i) a -> (0 < srange a) /\\ is_sgn (srange a) i.\nProof.\n  intros i a H.\n  pose proof Int.wordsize_pos.\n  inv H.\n  simpl.\n  eauto with va.\nQed.", "nl_proof": "Step 1: We need to prove that forall i a, vmatch (Vint i) a -> 0 < srange a /\\ is_sgn (srange a) i Step 2: Introduce variables and assumptions Step 3: Apply tactic: pose proof Int Step 4: Apply tactic: wordsize_pos Step 5: Apply tactic: inv H Step 6: Simplify the goal by computation Step 7: Apply tactic: eauto with va Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vmatch_uns", "draft": "Require Import Coq.Arith.Arith.\nLemma vmatch_uns : forall (p : nat) (i : nat) (n : nat), is_uns n i -> vmatch (Vint i) (uns p n).\nProof. eauto with va. Qed.", "nl_proof": "Step 1: We need to prove that forall p i n, is_uns n i -> vmatch (Vint i) (uns p n) Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: eauto with va Step 5: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vmatch_uns_undef", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import compcert.lib.Integers.\n\nLemma vmatch_undef_uns : forall (p n : Z), vmatch Vundef (uns p n).\nProof.\n  intros p n. unfold uns. repeat (destruct zle; auto).\nQed.", "nl_proof": "Step 1: We need to prove that forall p n, vmatch Vundef (uns p n) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: repeat destruct zle Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vmatch_sgn", "draft": "Require Import Coq.Lists.List.\nLemma vmatch_sgn : forall p i n, is_sgn n i -> vmatch (Vint i) (sgn p n).\nProof. eauto with va. Qed.", "nl_proof": "Step 1: We need to prove that forall p i n, is_sgn n i -> vmatch (Vint i) (sgn p n) Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: eauto with va Step 5: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vmatch_sgn_undef", "draft": "Require Import Coq.ZArith.ZArith.\n\nLemma sgn_vmatch_undef : forall (p n : Z), vmatch Vundef (sgn p n).\nProof.\n  intros p n.\n  unfold sgn.\n  repeat (destruct zle).\n  all: constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall p n, vmatch Vundef (sgn p n) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: repeat destruct zle Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vmatch_norm_bool_uns", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma vmatch_val_norm_bool_cases : forall (v : nat) (p : Prop), vmatch (Val v) p -> vmatch (Val (norm_bool_cases v)) p.\nProof.\n  intros v p H.\n  destruct v as [|v'].\n  - constructor.\n  - destruct v' as [|v''].\n    + constructor.\n    + destruct v'' as [|v'''].\n      * constructor.\n      * lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall v p, vmatch (Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: norm_bool_cases v) as [A | [A | A]] Step 5: Rewrite using an equality Step 6: Apply tactic: constructor Step 7: Apply tactic: lia Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply tactic: lia Step 11: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vmatch_Uns_1", "draft": "Require Import Coq.Arith.Arith.\nLemma vmatch_Uns_1 : forall p v, vmatch v (Uns p 1) -> v = Vundef \\/ v = Vint Int.zero \\/ v = Vint Int.one.\nProof.\n  intros p v H.\n  inv H.\n  right; left.\n  exploit is_uns_1.\n  eauto.\n  intuition congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall p v, vmatch v (Uns p 1) -> v = Vundef \\/ v = Vint Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Solve automatically using known facts Step 5: Apply tactic: right Step 6: Apply tactic: exploit is_uns_1 Step 7: Apply tactic: eauto Step 8: Apply tactic: intuition congruence Step 9: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vmatch_Uns_0", "draft": "Require Import Coq.Arith.Arith.\nLemma vmatch_Uns_0 : forall p v, vmatch v (Uns p 0) -> v = Vundef \\/ v = Vint Int.zero.\nProof.\n  intros p v H.\n  inv H.\n  right.\n  exploit is_uns_0.\n  eauto.\n  intuition congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall p v, vmatch v (Uns p 0) -> v = Vundef \\/ v = Vint Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Solve automatically using known facts Step 5: Apply tactic: right Step 6: Apply tactic: exploit is_uns_0 Step 7: Apply tactic: eauto Step 8: Apply tactic: intuition congruence Step 9: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vge_top", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma vge_top : forall (A : Type) (x : A), Vtop x.\nProof. destruct x; auto. Qed.", "nl_proof": "Step 1: We need to prove that forall x, vge Vtop x Step 2: Unfold a definition Step 3: Case analysis by destructing a value Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vge_refl", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma vge_refl : forall (x : nat), x >= x.\nProof. apply Nat.le_refl. Qed.", "nl_proof": "Step 1: We need to prove that forall x, vge x x Step 2: Case analysis by destructing a value Step 3: Solve automatically using known facts Step 4: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vge_trans", "draft": "Require Import Coq.Arith.Arith.\nLemma vge_trans : forall (x y z : nat), vge x y -> vge y z -> vge x z.\nProof.\n  revert y z.\n  induction x; destruct y, z; intros; inv H; inv H0; eauto using pge_trans with va.\nQed.", "nl_proof": "Step 1: We need to prove that forall x y z, vge x y -> vge y z -> vge x z Step 2: Introduce variables and assumptions Step 3: Apply tactic: revert y z YZ x XY Step 4: Case analysis by destructing a value Step 5: Introduce variables and assumptions Step 6: Solve automatically using known facts Step 7: Apply tactic: inv V Step 8: Apply tactic: eauto using pge_trans with va Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vmatch_ge", "draft": "Require Import Coq.Lists.List.\n\nLemma vmatch_ge : forall (v x y : Type), vge x y -> vmatch v y -> vmatch v x.\nProof.\n  intros v x y H H0.\n  induction H.\n  inv H0.\n  eauto using pmatch_ge with va.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x y, vge x y -> vmatch v y -> vmatch v x Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Apply tactic: inv V Step 5: Apply tactic: eauto using pmatch_ge with va Step 6: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vlub_comm", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Bool.Bool.\n\nLemma vlub_comm : forall (v w : bool), orb v w = orb w v.\nProof. apply orb_comm. Qed.", "nl_proof": "Step 1: We need to prove that forall v w, vlub v w = vlub w v Step 2: Apply tactic: assert (INT: forall cstr i j, vlub_int cstr i j = Step 3: Apply tactic: { intros Step 4: Unfold a definition Step 5: Rewrite using an equality Step 6: Apply tactic: eq_sym, orb_comm Step 7: Apply tactic: predSpec Int Step 8: Apply tactic: eq Int Step 9: Apply tactic: eq_spec j i Step 10: Apply tactic: congruence Step 11: Case analysis by destructing a value", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vge_lub_l", "draft": "Require Import Coq.Arith.Arith.\n\nLemma vlub_ge_left : forall (x y : nat), x <= Nat.max x y.\nProof.\n  intros x y.\n  apply Nat.le_max_l.\nQed.", "nl_proof": "Step 1: We need to prove that forall x y, vge (vlub x y) x Step 2: Apply tactic: assert (INT: forall i j, vge (vlub_int I i j) (I i Step 3: Apply tactic: { unfold vlub_int Step 4: Introduce variables and assumptions Step 5: Apply tactic: predSpec Int Step 6: Apply tactic: eq Int Step 7: Apply tactic: eq_spec i j Step 8: Solve automatically using known facts Step 9: Case analysis by destructing a value Step 10: Apply tactic: eauto with va Step 11: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vge_lub_r", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma vlub_ge_r : forall (A : Type) (vge vlub : A -> A -> Prop) (x y : A), \n  (forall a b c, vge a b -> vge b c -> vge a c) ->\n  (forall a b, vge (vlub a b) a) ->\n  (forall a b, vge (vlub a b) b) ->\n  vge (vlub x y) y.\nProof.\n  intros A vge vlub x y TRANS GE1 GE2.\n  apply GE2.\nQed.", "nl_proof": "Step 1: We need to prove that forall x y, vge (vlub x y) y Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Apply a theorem or hypothesis Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vmatch_lub_l", "draft": "Lemma vmatch_vlub : forall (v x y : Type), vmatch v x -> vmatch v (vlub x y).\nProof. intros. eapply vmatch_ge; eauto. Qed.", "nl_proof": "Step 1: We need to prove that forall v x y, vmatch v x -> vmatch v (vlub x y) Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply vmatch_ge Step 4: Apply tactic: eauto Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vmatch_lub_r", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma vmatch_vlub_r : forall (A : Type) (v x y : A), vmatch v y -> vmatch v (vlub x y).\nProof.\n  intros A v x y H.\n  rewrite vlub_comm.\n  apply vmatch_vlub_l.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x y, vmatch v y -> vmatch v (vlub x y) Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Apply a theorem or hypothesis Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:match_aptr_of_aval", "draft": "Require Import compcert.backend.Cminor.\nRequire Import compcert.common.AST.\nRequire Import compcert.common.Globalenvs.\nRequire Import compcert.common.Memory.\nRequire Import compcert.common.Values.\nRequire Import compcert.lib.Maps.\n\nLemma match_aptr_of_aval : forall (b : block) (ofs : ptrofs) (av : aval),\n  vmatch (Vptr b ofs) av -> pmatch b ofs (aptr_of_aval av).\nProof.\n  intros b ofs av H.\n  inv H.\nQed.", "nl_proof": "Step 1: We need to prove that forall b ofs av, vmatch (Vptr b ofs) av -> pmatch b ofs (aptr_of_aval av) Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: inv H Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vmatch_vplub_l", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma vmatch_vplub_l : forall (v : val) (x p : aval), vmatch v x -> vmatch v (Ifptr (vplub x p)).\nProof.\n  intros v x p H.\n  inv H; constructor; eapply pmatch_lub_l; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x p, vmatch v x -> vmatch v (Ifptr (vplub x p)) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: inv H Step 5: Solve automatically using known facts Step 6: Apply tactic: constructor Step 7: Apply tactic: eapply pmatch_lub_l Step 8: Apply tactic: eauto Step 9: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:pmatch_vplub", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma pmatch_vplub : forall (b : block) (ofs : ptrofs) (x : aval) (p : aptr), pmatch b ofs p -> pmatch b ofs (vplub x p).\nProof.\n  intros b ofs x p H.\n  unfold vplub.\n  destruct x; try (apply pmatch_top'; eauto).\n  destruct (ptr_eq _ _); subst; auto.\n  destruct p; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall b ofs x p, pmatch b ofs p -> pmatch b ofs (vplub x p) Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (DFL: pmatch b ofs (if va_strict tt then p Step 4: Apply tactic: { destruct (va_strict tt) Step 5: Solve automatically using known facts Step 6: Apply tactic: eapply pmatch_top' Step 7: Apply tactic: eauto Step 8: Unfold a definition Step 9: Case analysis by destructing a value Step 10: Solve automatically using known facts Step 11: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vmatch_vplub_r", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma vmatch_ifptr_vplub : forall (v x p : nat), vmatch v (Ifptr p) -> vmatch v (Ifptr (vplub x p)).\nProof.\n  intros v x p H.\n  subst v.\n  inv H.\n  apply H.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x p, vmatch v (Ifptr p) -> vmatch v (Ifptr (vplub x p)) Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Introduce variables and assumptions Step 5: Apply tactic: subst v Step 6: Apply tactic: inv H Step 7: Apply a theorem or hypothesis Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vpincl_ge", "draft": "Require Import Coq.Arith.Arith.\nRequire Import compcert.lib.Integers.\nRequire Import compcert.common.Values.\n\nLemma vpincl_ge : forall x p, vpincl x p = true -> vge (Ifptr p) x.\nProof.\n  intros x p H.\n  destruct x; simpl in *; try discriminate; eauto using pincl_ge with va.\nQed.", "nl_proof": "Step 1: We need to prove that forall x p, vpincl x p = true -> vge (Ifptr p) x Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: eauto using pincl_ge with va Step 6: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vpincl_sound", "draft": "Require Import compcert.lib.Integers.\nRequire Import compcert.common.Values.\n\nLemma vpincl_sound : forall (v : val) (x : aval) (p : aptr), vpincl x p = true -> vmatch v x -> vmatch v (Ifptr p).\nProof.\n  intros v x p H1 H2.\n  apply vpincl_sound in H1; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x p, vpincl x p = true -> vmatch v x -> vmatch v (Ifptr p) Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Solve automatically using known facts Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vincl_ge", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma vincl_ge : forall v w, vincl v w = true -> vge w v.\nProof.\n  intros v w H.\n  destruct v; destruct w; try discriminate;\n  try (apply InvBooleans in H; subst; constructor);\n  eauto using pincl_ge with va.\nQed.", "nl_proof": "Step 1: We need to prove that forall v w, vincl v w = true -> vge w v Step 2: Unfold a definition Step 3: Case analysis by destructing a value Step 4: Case analysis by destructing a value Step 5: Introduce variables and assumptions Step 6: Apply tactic: try discriminate Step 7: Apply tactic: try InvBooleans Step 8: Apply tactic: try subst Step 9: Apply tactic: eauto using pincl_ge with va Step 10: Apply tactic: - constructor Step 11: Solve automatically using known facts", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:ge_vincl", "draft": "Require Import Coq.Arith.Arith.\nLemma ge_vincl : forall v w, vge v w -> vincl w v = true.\nProof.\n  induction 1; simpl; try (apply andb_true_intro; split); \n  all: try (unfold proj_sumbool; rewrite ?IHvge1, ?IHvge2); auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall v w, vge v w -> vincl w v = true Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Apply tactic: try (apply andb_true_intro Step 5: Split a conjunction into separate goals Step 6: Solve automatically using known facts Step 7: Apply tactic: all: try (unfold proj_sumbool Step 8: Rewrite using an equality Step 9: Solve automatically using known facts Step 10: Apply tactic: all: try (unfold proj_sumbool Step 11: Rewrite using an equality", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:symbol_address_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma symbol_address_sound : forall (ge : Genv.t (fun _ : Type => unit) unit) (id : ident) (ofs : ptrofs),\n  genv_match ge -> vmatch (Genv.symbol_address ge id ofs) (Ptr (Gl id ofs)).\nProof.\n  intros ge id ofs MATCH.\n  unfold Genv.symbol_address.\n  destruct (Genv.find_symbol ge id) as [b|] eqn:F.\n  - constructor. constructor. assumption.\n  - constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall ge id ofs, genv_match ge -> vmatch (Genv Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: symbol_address Step 5: Case analysis by destructing a value Step 6: Apply tactic: find_symbol ge id) as [b|] eqn:F Step 7: Apply tactic: constructor Step 8: Apply tactic: constructor Step 9: Apply a theorem or hypothesis Step 10: Solve automatically using known facts Step 11: Apply tactic: constructor", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vmatch_ptr_gl", "draft": "Require Import Coq.Classes.RelationClasses.\n\nLemma vmatch_ptr_gl : forall (ge : Genv.t (fun _ : Type => unit) unit) (v : val) (id : ident) (ofs : ptrofs),\n  genv_match ge ->\n  vmatch v (Ptr (Gl id ofs)) ->\n  Val.lessdef v (Genv.symbol_address ge id ofs).\nProof.\n  intros ge v id ofs H H0.\n  unfold Genv.symbol_address.\n  inv H0.\n  - inv H3.\n    replace (Genv.find_symbol ge id) with (Some b).\n    constructor.\n    symmetry.\n    apply H.\n  Qed.", "nl_proof": "Step 1: We need to prove that forall ge v id ofs, genv_match ge -> vmatch v (Ptr (Gl id ofs)) -> Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: symbol_address Step 5: Apply tactic: inv H0 Step 6: Apply tactic: - inv H3 Step 7: Apply tactic: replace (Genv Step 8: Apply tactic: find_symbol ge id) with (Some b) Step 9: Apply tactic: constructor Step 10: Apply tactic: symmetry Step 11: Apply a theorem or hypothesis", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vmatch_ptr_stk", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Arith.PeanoNat.\nRequire Import Coq.Values.Val.\nRequire Import Coq.Memory.Mem.\n\nLemma vmatch_ptr_stk : forall v ofs sp,\n  vmatch v (Ptr(Stk ofs)) ->\n  bc sp = BCstack ->\n  Val.lessdef v (Vptr sp ofs).\nProof.\n  intros v ofs sp H H0.\n  inversion H.\n  - inversion H3.\n    replace b with sp by (eapply bc_stack; eauto).\n    constructor.\n  - constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall v ofs sp, vmatch v (Ptr(Stk ofs)) -> bc sp = BCstack -> Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: - inv H3 Step 5: Apply tactic: replace b with sp by (eapply bc_stack Step 6: Apply tactic: eauto) Step 7: Apply tactic: constructor Step 8: Apply tactic: - constructor Step 9: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:unop_int_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma unop_int_sound : forall sem v x,\n  vmatch v x ->\n  vmatch (match v with Vint i => Vint(sem i) | _ => Vundef end) (unop_int sem x).\nProof.\n  intros sem v x H. unfold unop_int. inv H; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall sem v x, vmatch v x -> vmatch (match v with Vint i => Vint(sem i) | _ => Vundef end) (unop_int sem x) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: inv H Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:binop_int_sound", "draft": "Lemma binop_int_sound : forall sem v x w y, vmatch v x -> vmatch w y -> vmatch (match v, w with Vint i, Vint j => Vint(sem i j) | _, _ => Vundef end) (binop_int sem x y).\nProof.\n  intros sem v x w y H H0.\n  unfold binop_int.\n  inv H; inv H0; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall sem v x w y, vmatch v x -> vmatch w y -> vmatch (match v, w with Vint i, Vint j => Vint(sem i j) | _, _ => Vundef end) (binop_int sem x y) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: inv H Step 5: Solve automatically using known facts Step 6: Apply tactic: inv H0 Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:unop_long_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma unop_long_sound : forall sem v x,\n  vmatch v x ->\n  vmatch (match v with Vlong i => Vlong(sem i) | _ => Vundef end) (unop_long sem x).\nProof.\n  intros sem v x H. inv H; simpl; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall sem v x, vmatch v x -> vmatch (match v with Vlong i => Vlong(sem i) | _ => Vundef end) (unop_long sem x) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: inv H Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:binop_long_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma binop_long_sound : forall sem v x w y, vmatch v x -> vmatch w y -> vmatch (match v, w with Vlong i, Vlong j => Vlong(sem i j) | _, _ => Vundef end) (binop_long sem x y).\nProof.\n  intros sem v x w y H H0.\n  unfold binop_long.\n  inv H.\n  all: inv H0.\n  all: constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall sem v x w y, vmatch v x -> vmatch w y -> vmatch (match v, w with Vlong i, Vlong j => Vlong(sem i j) | _, _ => Vundef end) (binop_long sem x y) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: inv H Step 5: Solve automatically using known facts Step 6: Apply tactic: inv H0 Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:unop_float_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma unop_float_sound : forall sem v x,\n  vmatch v x ->\n  vmatch (match v with Vfloat i => Vfloat(sem i) | _ => Vundef end) (unop_float sem x).\nProof.\n  intros sem v x H. unfold unop_float. inv H; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall sem v x, vmatch v x -> vmatch (match v with Vfloat i => Vfloat(sem i) | _ => Vundef end) (unop_float sem x) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: inv H Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:binop_float_sound", "draft": "Require Import Coq.Floats.Floats.\n\nLemma binop_float_sound : forall sem v x w y,\n  vmatch v x -> vmatch w y ->\n  vmatch (match v, w with Vfloat i, Vfloat j => Vfloat(sem i j) | _, _ => Vundef end) (binop_float sem x y).\nProof.\n  intros sem v x w y H H0.\n  unfold binop_float.\n  inv H; inv H0; constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall sem v x w y, vmatch v x -> vmatch w y -> vmatch (match v, w with Vfloat i, Vfloat j => Vfloat(sem i j) | _, _ => Vundef end) (binop_float sem x y) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: inv H Step 5: Solve automatically using known facts Step 6: Apply tactic: inv H0 Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:unop_single_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma unop_single_sound : forall (sem : float32 -> float32) (v : val) (x : aval),\n  vmatch v x -> vmatch (match v with Vsingle i => Vsingle(sem i) | _ => Vundef end) (unop_single sem x).\nProof.\n  intros sem v x H. inv H; simpl; constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall sem v x, vmatch v x -> vmatch (match v with Vsingle i => Vsingle(sem i) | _ => Vundef end) (unop_single sem x) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: inv H Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:binop_single_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma binop_single_sound : forall sem v x w y, vmatch v x -> vmatch w y -> vmatch (match v, w with Vsingle i, Vsingle j => Vsingle(sem i j) | _, _ => Vundef end) (binop_single sem x y).\nProof.\n  intros sem v x w y H H0.\n  unfold binop_single.\n  inv H.\n  inv H0.\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall sem v x w y, vmatch v x -> vmatch w y -> vmatch (match v, w with Vsingle i, Vsingle j => Vsingle(sem i j) | _, _ => Vundef end) (binop_single sem x y) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: inv H Step 5: Solve automatically using known facts Step 6: Apply tactic: inv H0 Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:shl_sound", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma val_shl_match : forall (v w x y : nat), vmatch v x -> vmatch w y -> vmatch (Nat.shiftl v w) (ntop1 x).\nProof.\n  intros v w x y Hv Hw.\n  assert (DEFAULT: vmatch (Nat.shiftl v w) (ntop1 x)).\n  { constructor. }\n  destruct v.\n  - simpl. constructor.\n  - destruct w.\n    + simpl. constructor.\n    + simpl. try constructor.\n      destruct (Nat.ltb n (2 ^ Nat.size n)).\n      * constructor.\n      * constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (DEFAULT: vmatch (Val Step 4: Apply tactic: shl v w) (ntop1 x)) Step 5: Case analysis by destructing a value Step 6: Case analysis by destructing a value Step 7: Simplify the goal by computation Step 8: Apply tactic: try constructor Step 9: Case analysis by destructing a value Step 10: Apply tactic: ltu i0 Int Step 11: Apply tactic: iwordsize)", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:shru_sound", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma vmatch_shru_template : forall (v w : val) (x y : val_type), vmatch v x -> vmatch w y -> vmatch (Val.shru v w) (ntop1 x).\nProof.\n  intros v w x y Hv Hw.\n  assert (DEFAULT: vmatch (Val.shru v w) (ntop1 x)).\n  { constructor. }\n  destruct v; destruct w; simpl; try constructor.\n  destruct (Int.ltu i0 Int.iwordsize) eqn:?; constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (DEFAULT: vmatch (Val Step 4: Apply tactic: shru v w) (ntop1 x)) Step 5: Case analysis by destructing a value Step 6: Case analysis by destructing a value Step 7: Simplify the goal by computation Step 8: Apply tactic: try constructor Step 9: Case analysis by destructing a value Step 10: Apply tactic: ltu i0 Int Step 11: Apply tactic: iwordsize)", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:shr_sound", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma vmatch_shr_template : forall (v w x y : nat), vmatch v x -> vmatch w y -> vmatch (Nat.shiftr v w) (ntop1 x).\nProof.\n  intros v w x y Hv Hw.\n  assert (DEFAULT: vmatch (Nat.shiftr v w) (ntop1 x)).\n  { constructor. }\n  destruct v as [|i0].\n  - simpl. constructor.\n  - destruct w as [|i1].\n    + simpl. constructor.\n    + simpl. \n      destruct (lt_dec i1 (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred 32)))))))))))))))))))))))))))))))).\n      * constructor.\n      * constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (DEFAULT: vmatch (Val Step 4: Apply tactic: shr v w) (ntop1 x)) Step 5: Case analysis by destructing a value Step 6: Case analysis by destructing a value Step 7: Simplify the goal by computation Step 8: Apply tactic: try constructor Step 9: Case analysis by destructing a value Step 10: Apply tactic: ltu i0 Int Step 11: Apply tactic: iwordsize)", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:and_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma and_sound : forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val.and v w) (and x y).\nProof.\n  intros v w x y Hv Hw.\n  destruct Hv as [| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |.\nQed.", "nl_proof": "Step 1: We need to prove that forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Apply tactic: assert (UNS_l: forall i j n, is_uns n i -> is_uns Step 3: Apply tactic: and i j)) Step 4: Introduce variables and assumptions Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Rewrite using an equality Step 8: Apply tactic: bits_and by auto Step 9: Rewrite using an equality Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: assert (UNS_r: forall i j n, is_uns n i -> is_uns", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:or_sound", "draft": "Require Import Coq.ZArith.ZArith.\n\nLemma is_uns_or : forall (n : nat) (i j : int), is_uns n i -> is_uns n j -> is_uns n (Int.or i j).\nProof.\n  intros n i j H H0.\n  red.\n  intros.\n  rewrite bits_or by auto.\n  rewrite (H m H1).\n  rewrite (H0 m H1).\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Apply tactic: assert (UNS: forall i j n m, is_uns n i -> is_uns Step 3: Apply tactic: max n m) (Int Step 4: Apply tactic: or i j)) Step 5: Introduce variables and assumptions Step 6: Apply tactic: red Step 7: Introduce variables and assumptions Step 8: Rewrite using an equality Step 9: Apply tactic: bits_or by auto Step 10: Rewrite using an equality Step 11: Rewrite using an equality", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:xor_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma bits_xor_uns : forall (n m i j : nat), is_uns n i -> is_uns m j -> is_uns (Nat.max n m) (Nat.lxor i j).\nProof.\n  intros n m i j H H0.\n  red.\n  intros.\n  rewrite Nat.lxor_bits.\n  rewrite H by auto with arith.\n  rewrite H0 by auto with arith.\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Apply tactic: assert (UNS: forall i j n m, is_uns n i -> is_uns Step 3: Apply tactic: max n m) (Int Step 4: Apply tactic: xor i j)) Step 5: Introduce variables and assumptions Step 6: Apply tactic: red Step 7: Introduce variables and assumptions Step 8: Rewrite using an equality Step 9: Apply tactic: bits_xor by auto Step 10: Rewrite using an equality Step 11: Rewrite using an equality", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:notint_sound", "draft": "Require Import Coq.ZArith.ZArith.\nLemma bits_not_sgn : forall n i, is_sgn n i -> is_sgn n (Z.lnot i).\nProof.\n  intros n i H.\n  red in H.\n  red.\n  rewrite Z.lnot_spec.\n  f_equal.\n  apply H.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x, vmatch v x -> vmatch (Val Step 2: Apply tactic: assert (SGN: forall n i, is_sgn n i -> is_sgn n (I Step 3: Apply tactic: not i)) Step 4: Introduce variables and assumptions Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Rewrite using an equality Step 8: Apply tactic: bits_not by lia Step 9: Apply tactic: f_equal Step 10: Apply a theorem or hypothesis Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:rol_sound", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma vmatch_rol : forall (v w x y : nat), vmatch v x -> vmatch w y -> vmatch (Nat.lor (Nat.land v (Nat.lnot w 32)) (Nat.land (Nat.shiftl v 32) w)) (Num (Nat.lor (Nat.land x (Nat.lnot y 32)) (Nat.land (Nat.shiftl x 32) y))).\nProof.\n  intros v w x y Hv Hw.\n  assert (DEFAULT: forall p, vmatch (Nat.lor (Nat.land v (Nat.lnot w 32)) (Nat.land (Nat.shiftl v 32) w)) (Num p)).\n  { intros p. constructor. }\n  destruct v; destruct w; simpl; try apply DEFAULT; constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (DEFAULT: forall p, vmatch (Val Step 4: Apply tactic: rol v w) (Num p)) Step 5: Case analysis by destructing a value Step 6: Case analysis by destructing a value Step 7: Simplify the goal by computation Step 8: Apply tactic: constructor Step 9: Unfold a definition Step 10: Case analysis by destructing a value Step 11: Apply tactic: try apply DEFAULT", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:ror_sound", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma vmatch_ror : forall (v w x y : nat), vmatch v x -> vmatch w y -> vmatch (Nat.lor v w) (Nat.lor x y).\nProof.\n  intros v w x y Hv Hw.\n  assert (DEFAULT: forall p, vmatch (Nat.lor v w) (Num p)).\n  { intros p. constructor. }\n  destruct v; destruct w; simpl; try apply DEFAULT; constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (DEFAULT: forall p, vmatch (Val Step 4: Apply tactic: ror v w) (Num p)) Step 5: Case analysis by destructing a value Step 6: Case analysis by destructing a value Step 7: Simplify the goal by computation Step 8: Apply tactic: constructor Step 9: Unfold a definition Step 10: Case analysis by destructing a value Step 11: Apply tactic: try apply DEFAULT", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:rolm_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Compcert.Values.\nRequire Import Compcert.AST.\n\nLemma rolm_sound : forall v x amount mask,\n  vmatch v x -> vmatch (Val.rolm v amount mask) (rolm x amount mask).\nProof.\n  intros v x amount mask H.\n  replace (Val.rolm v amount mask) with (Val.and (Val.rol v (Vint amount)) (Vint mask)).\n  constructor.\n  constructor.\n  apply H.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x amount mask, vmatch v x -> vmatch (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: replace (Val Step 4: Apply tactic: rolm v amount mask) with (Val Step 5: Apply tactic: and (Val Step 6: Apply tactic: rol v (Vint amount)) (Vint mask)) Step 7: Apply a theorem or hypothesis Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply tactic: constructor Step 11: Apply tactic: constructor", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:neg_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma unop_int_sound : forall (sem : int -> int) (v : val) (x : aval),\n  vmatch v x -> vmatch (match v with Vint i => Vint (sem i) | _ => Vundef end) (unop_int sem x).\nProof.\n  intros sem v x H.\n  destruct H; simpl; eauto with va.\n  assert (A: Int.repr (sem i) = Int.repr (sem i)) by reflexivity.\n  apply vmatch_sgn; eauto with va.\n  apply vmatch_uns; eauto with va.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x, vmatch v x -> vmatch (Val Step 2: Case analysis by destructing a value Step 3: Simplify the goal by computation Step 4: Apply tactic: eauto with va Step 5: Apply tactic: assert (A: Int Step 6: Apply tactic: neg i = Int Step 7: Apply tactic: repr (- Int Step 8: Apply tactic: signed i)) Step 9: Apply tactic: { intros Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: eqm_samerepr", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:add_sound", "draft": "Require Import Coq.ZArith.ZArith.\n\nLemma uns_add_sound : forall (n m : Z) (i j : int),\n  0 <= n -> 0 <= m -> is_uns n i -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i j).\nProof.\n  intros n m i j Hn Hm Hi Hj.\n  apply is_uns_add; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Apply tactic: assert (UNS: forall n i m j, Step 3: Apply tactic: 0 <= n -> 0 <= m -> is_uns n i -> is_uns m j -> Step 4: Apply tactic: is_uns (Z Step 5: Apply tactic: max n m + 1) (Int Step 6: Apply tactic: add i j)) Step 7: Apply tactic: { intros Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply a theorem or hypothesis Step 11: Solve automatically using known facts", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:sub_sound", "draft": "Require Import Coq.ZArith.ZArith.\n\nLemma vmatch_sub_uns : forall (v w x y : int) (n m : Z),\n    0 <= n -> 0 <= m -> is_uns n v -> is_uns m w -> is_sgn (Z.max n m + 1) (Int.sub v w).\nProof.\n  intros v w x y n m Hn Hm Hv Hw.\n  apply is_uns_inj in Hv.\n  apply is_uns_inj in Hw.\n  apply is_sgn_inj.\n  rewrite Int.sub_signed.\n  rewrite Hv, Hw.\n  rewrite <- Z.sub_signed.\n  apply is_sgn_range.\n  split.\n  - apply Z.le_trans with (-2 ^ (Z.max n m)).\n    + apply Z.pow_le_mono_r; lia.\n    + lia.\n  - apply Z.le_trans with (2 ^ (Z.max n m) - 1).\n    + lia.\n    + apply Z.pow_le_mono_r; lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Apply tactic: assert (UNS: forall n i m j, Step 3: Apply tactic: 0 <= n -> 0 <= m -> is_uns n i -> is_uns m j -> Step 4: Apply tactic: is_sgn (Z Step 5: Apply tactic: max n m + 1) (Int Step 6: Apply tactic: sub i j)) Step 7: Apply tactic: { intros Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply a theorem or hypothesis Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:mul_base_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nRequire Import Coq.micromega.Lia.\n\nLemma vmatch_mul_uns : forall p i1 i2 n1 n2,\n  0 <= n1 -> is_uns n1 i1 -> 0 <= n2 -> is_uns n2 i2 -> vmatch (Val.mul (Vint i1) (Vint i2)) (uns p (n1 + n2)).\nProof.\n  intros. apply vmatch_uns. red. intros. rewrite is_uns_add in H3.\n  apply is_uns_inv in H3. destruct H3 as [H3 H4]. \n  apply is_uns_mon with (n1 := n1) in H3; try lia.\n  apply is_uns_mon with (n1 := n2) in H4; try lia.\n  apply is_uns_mult; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (UNS: forall i1 i2 n1 n2 p, Step 4: Apply tactic: 0 <= n1 -> is_uns n1 i1 -> Step 5: Apply tactic: 0 <= n2 -> is_uns n2 i2 -> Step 6: Apply tactic: vmatch (Val Step 7: Apply tactic: mul (Vint i1) (Vint i2)) (uns p (n1 + n2))) Step 8: Apply tactic: { intros Step 9: Apply a theorem or hypothesis Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: lia", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:mul_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma vmatch_mul_base : forall (v w : val) (x y : aval),\n  vmatch v x -> vmatch w y -> vmatch (Val.mul v w) (if vincl x (Uns Ptop 0) || vincl y (Uns Ptop 0) then IU Int.zero else mul_base x y).\nProof.\n  intros v w x y Hv Hw.\n  destruct (orb_true_elim (vincl x (Uns Ptop 0)) (vincl y (Uns Ptop 0)) (eq_refl _)) as [H|H].\n  - apply vmatch_Uns_0; auto.\n  - apply vmatch_mul_base; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (vmatch (Val Step 4: Apply tactic: mul v w) Step 5: Apply tactic: (if vincl x (Uns Ptop 0) || vincl y (Uns Ptop 0) Step 6: Apply tactic: then IU Int Step 7: Apply tactic: zero Step 8: Apply tactic: else mul_base x y)) Step 9: Apply tactic: { destruct orb eqn:INCL Step 10: Solve automatically using known facts Step 11: Rewrite using an equality", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:mulhs_base_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma mulhs_sound : forall v w u x y, vmatch v x -> vmatch w y -> Val.mulhs v w = Some u -> vmatch u (mulhs x y).\nProof.\n  intros v w u x y Hv Hw H.\n  unfold Val.mulhs in H.\n  destruct v; destruct w; try discriminate.\n  destruct (Int.mulhs i i0) eqn:?; try discriminate.\n  inversion H; subst.\n  apply mulhs_base; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: mulhs, mulhs_base Step 5: Case analysis by destructing a value Step 6: Solve automatically using known facts Step 7: Apply tactic: rename i0 into j Step 8: Apply a theorem or hypothesis Step 9: Case analysis by destructing a value Step 10: Apply a theorem or hypothesis Step 11: Solve automatically using known facts", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:mulhs_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Bool.Bool.\n\nLemma vmatch_binop_template : forall (v w : nat) (x y : bool), \n  (v =? 0) = x -> (w =? 0) = y -> ((v + w) =? 0) = (x || y).\nProof.\n  intros v w x y Hv Hw.\n  rewrite Hv, Hw.\n  destruct x; destruct y; simpl; reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Solve automatically using known facts Step 6: Apply tactic: - rewrite orb_true_iff in Heqb Step 7: Case analysis by destructing a value Step 8: Apply tactic: exploit vmatch_Uns_0 Step 9: Apply tactic: eapply vmatch_ge Step 10: Apply tactic: eapply vincl_ge Step 11: Apply tactic: eauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:mulhu_base_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma mulhu_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val.mulhu v w) (mulhu x y).\nProof.\n  intros v x w y H H0.\n  unfold Val.mulhu.\n  apply mulhu_base.\n  destruct v; try solve [constructor].\n  destruct w; try solve [constructor].\n  apply mulhu_base_sound; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: mulhu, mulhu_base Step 5: Case analysis by destructing a value Step 6: Solve automatically using known facts Step 7: Apply a theorem or hypothesis Step 8: Case analysis by destructing a value Step 9: Apply a theorem or hypothesis Step 10: Solve automatically using known facts Step 11: Apply a theorem or hypothesis", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:mulhu_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma mulhu_sound : forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val.mulhu v w) (mulhu x y).\nProof.\n  intros v w x y Hv Hw.\n  destruct v; try (apply vmatch_undef).\n  destruct w; try (apply vmatch_undef).\n  eapply mulhu_base_sound; eauto.\n  unfold mulhu.\n  rewrite orb_true_iff in Heqb.\n  destruct Heqb as [H|H].\n  - exploit (vmatch_Uns_1 Ptop v); eauto.\n  - eapply vmatch_ge; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: try eapply mulhu_base_sound Step 5: Apply tactic: eauto Step 6: Unfold a definition Step 7: Rewrite using an equality Step 8: Apply tactic: - rewrite orb_true_iff in Heqb Step 9: Case analysis by destructing a value Step 10: Apply tactic: exploit (vmatch_Uns_1 Ptop v) Step 11: Apply tactic: eapply vmatch_ge", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:divs_sound", "draft": "Require Import Coq.ZArith.Int.\nLemma val_match_trans : forall (v w u : val) (x y : val), vmatch v x -> vmatch w y -> Val.lessdef (Val.add v w) u -> vmatch u (Val.add x y).\nProof.\n  intros v w u x y H H0 H1.\n  destruct v; destruct w; try discriminate; simpl in H1;\n  destruct u; try discriminate; inv H1; rename i0 into j;\n  assert (E' : i = j) by (apply Int.add_assoc; auto); subst j; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall v w u x y, vmatch v x -> vmatch w y -> Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Case analysis by destructing a value Step 5: Apply tactic: try discriminate Step 6: Simplify the goal by computation Step 7: Case analysis by destructing a value Step 8: Apply tactic: inv H1 Step 9: Apply tactic: rename i0 into j Step 10: Apply tactic: assert (E': Int Step 11: Apply tactic: eq j Int", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:divu_sound", "draft": "Require Import Coq.ZArith.ZArith.\nLemma val_match_trans : forall (v w u x y : val), vmatch v x -> vmatch w y -> Val.add v w = u -> vmatch u (x + y).\nProof.\n  intros v w u x y H H0 H1.\n  destruct v; destruct w; try discriminate; simpl in H1; injection H1; intro; subst u;\n  rename i0 into j; destruct y; try discriminate; destruct x; try discriminate;\n  destruct (eq j Int.zero) eqn:E; inv H1.\nQed.", "nl_proof": "Step 1: We need to prove that forall v w u x y, vmatch v x -> vmatch w y -> Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Case analysis by destructing a value Step 5: Apply tactic: try discriminate Step 6: Simplify the goal by computation Step 7: Apply tactic: rename i0 into j Step 8: Case analysis by destructing a value Step 9: Apply tactic: eq j Int Step 10: Apply tactic: zero) eqn:E Step 11: Apply tactic: inv H1", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:mods_sound", "draft": "Require Import Coq.ZArith.ZArith.\nLemma mods_sgn_proof : forall (i j : Z) (H : j =? 0 = false), is_sgn (ssize j) (Z.rem i j).\nProof.\n  intros i j H.\n  pose proof (is_sgn_ssize j).\n  unfold ssize in *.\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall v w u x y, vmatch v x -> vmatch w y -> Val Step 2: Apply tactic: assert (SGN: forall i j, Int Step 3: Apply tactic: eq j Int Step 4: Apply tactic: zero = false -> is_sgn (ssize j) (Int Step 5: Apply tactic: mods i j)) Step 6: Introduce variables and assumptions Step 7: Unfold a definition Step 8: Apply tactic: mods Step 9: Apply tactic: pose proof (is_sgn_ssize j) Step 10: Apply a theorem or hypothesis Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:modu_sound", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma modu_zero_uns : forall (i j : nat), j <> 0 -> is_uns (usize j) (Int.modu i j).\nProof.\n  intros i j H.\n  apply is_uns_mon with (n := usize j).\n  - apply usize_pos.\n  - apply Int.modu_range; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall v w u x y, vmatch v x -> vmatch w y -> Val Step 2: Apply tactic: assert (UNS: forall i j, j <> Int Step 3: Apply tactic: zero -> is_uns (usize j) (Int Step 4: Apply tactic: modu i j)) Step 5: Introduce variables and assumptions Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: modu i j)) Step 8: Solve automatically using known facts Step 9: Unfold a definition Step 10: Apply tactic: size Step 11: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:shrx_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma ltu_repr_lt : forall (i0 i1 : nat) (LTU : i0 <? i1 = true), i0 < i1.\nProof. intros. apply Nat.ltb_lt. assumption. Qed.", "nl_proof": "Step 1: We need to prove that forall v w u x y, vmatch v x -> vmatch w y -> Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Case analysis by destructing a value Step 5: Apply tactic: try discriminate Step 6: Simplify the goal by computation Step 7: Case analysis by destructing a value Step 8: Apply tactic: ltu i0 (Int Step 9: Apply tactic: repr 31)) eqn:LTU Step 10: Apply tactic: inv H1 Step 11: Unfold a definition", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:shift_long_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma shift_long_sound : forall sem v w x y,\n  vmatch v x -> vmatch w y ->\n  vmatch (match v, w with\n          | Vlong i, Vint j => if Int.ltu j Int64.iwordsize'\n                               then Vlong (sem i j) else Vundef\n          | _, _ => Vundef end)\n         (shift_long sem x y).\nProof.\n  intros sem v w x y Hv Hw.\n  destruct v; try (apply vmatch_ntop1).\n  destruct w; try (apply vmatch_ntop1).\n  destruct (Int.ltu i Int64.iwordsize') eqn:EQ.\n  - apply vmatch_lub_l. apply vmatch_lub_r.\n    apply vmatch_lub_l. apply vmatch_lub_r.\n    apply vmatch_lub_l. apply vmatch_lub_r.\n    apply vmatch_lub_l. apply vmatch_lub_r.\n    apply vmatch_lub_l. apply vmatch_lub_r.\n    apply vmatch_lub_l. apply vmatch_lub_r.\n    apply vmatch_lub_l. apply vmatch_lub_r.\n    apply vmatch_lub_l. apply vmatch_lub_r.\n    apply vmatch_lub_l. apply vmatch_lub_r.\n    apply vmatch_lub_l. apply vmatch_lub_r.\n    apply vmatch_lub_l. apply vmatch_lub_r.\n    apply vmatch_lub_l. apply vmatch_lub_r.\n    apply vmatch_lub_l. apply vmatch_lub_r.\n    apply vmatch_lub_l. apply vmatch_lub_r.\n    apply vmatch_lub_l. apply vmatch_lub_r.\n    apply vmatch_lub_l. apply vmatch_lub_r.\n    apply vmatch_lub_l. apply vmatch_lub_r.\n    apply vmatch_lub_l. apply vmatch_lub_r.\n    apply vmatch_lub_l. apply vmatch_lub_r.\n    apply vmatch_lub_l. apply vmatch_lub_r.\n    apply vmatch_lub_l. apply vmatch_lub_r.\n    apply vmatch_lub_l. apply vmatch_lub_r.\n    apply vmatch_lub.\nQed.", "nl_proof": "Step 1: We need to prove that forall sem v w x y, vmatch v x -> vmatch w y -> vmatch (match v, w with | Vlong i, Vint j => if Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (DEFAULT: Step 4: Apply tactic: vmatch (match v, w with Step 5: Apply tactic: | Vlong i, Vint j => if Int Step 6: Apply tactic: ltu j Int64 Step 7: Apply tactic: iwordsize' Step 8: Apply tactic: then Vlong (sem i j) else Vundef Step 9: Apply tactic: | _, _ => Vundef end) Step 10: Apply tactic: (ntop1 x)) Step 11: Apply tactic: { destruct v", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:shll_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma shrl_sound : forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val.shrl v w) (shrl x y).\nProof. apply shift_long_sound. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Apply tactic: Definition shrl := shift_long Int64 Step 3: Apply tactic: shr' Step 4: Apply tactic: Lemma shrl_sound: Step 5: Apply tactic: forall v w x y, vmatch v x -> vmatch w y -> vmatch Step 6: Apply tactic: shrl v w) (shrl x y) Step 7: Apply tactic: Definition shrlu := shift_long Int64 Step 8: Apply tactic: shru' Step 9: Apply tactic: Lemma shrlu_sound: Step 10: Apply tactic: forall v w x y, vmatch v x -> vmatch w y -> vmatch Step 11: Apply tactic: shrlu v w) (shrlu x y)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:shrl_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma andl_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (andl v w) (andl x y).\nProof. apply binop_long_sound. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Apply tactic: Definition shrlu := shift_long Int64 Step 3: Apply tactic: shru' Step 4: Apply tactic: Lemma shrlu_sound: Step 5: Apply tactic: forall v w x y, vmatch v x -> vmatch w y -> vmatch Step 6: Apply tactic: shrlu v w) (shrlu x y) Step 7: Apply tactic: Definition andl := binop_long Int64 Step 8: Apply tactic: and Step 9: Apply tactic: Lemma andl_sound: Step 10: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 11: Apply tactic: andl v w) (andl x y)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:shrlu_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma andl_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val.andl v w) (binop_long Int64.and x y).\nProof.\n  intros v x w y Hv Hw.\n  apply binop_long_sound; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Apply tactic: Definition andl := binop_long Int64 Step 3: Apply tactic: and Step 4: Apply tactic: Lemma andl_sound: Step 5: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 6: Apply tactic: andl v w) (andl x y) Step 7: Apply tactic: Definition orl := binop_long Int64 Step 8: Apply tactic: Lemma orl_sound: Step 9: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 10: Apply tactic: orl v w) (orl x y) Step 11: Apply tactic: Definition xorl := binop_long Int64", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:andl_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Integers.Int.\nLemma notl_sound : forall v x, vmatch v x -> vmatch (Val.notl v) (notl x).\nProof. apply unop_long_sound. Qed.", "nl_proof": "Step 1: We need to prove that forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Apply tactic: Definition orl := binop_long Int64 Step 3: Apply tactic: Lemma orl_sound: Step 4: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 5: Apply tactic: orl v w) (orl x y) Step 6: Apply tactic: Definition xorl := binop_long Int64 Step 7: Apply tactic: xor Step 8: Apply tactic: Lemma xorl_sound: Step 9: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 10: Apply tactic: xorl v w) (xorl x y) Step 11: Apply tactic: Definition notl := unop_long Int64", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:orl_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma notl_sound : forall v x, vmatch v x -> vmatch (Val.notl v) (notl x).\nProof.\n  intros v x H.\n  unfold notl, Val.notl.\n  destruct v; try constructor.\n  destruct (Int64.not i) eqn:?; constructor.\n  apply H.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Apply tactic: Definition xorl := binop_long Int64 Step 3: Apply tactic: xor Step 4: Apply tactic: Lemma xorl_sound: Step 5: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 6: Apply tactic: xorl v w) (xorl x y) Step 7: Apply tactic: Definition notl := unop_long Int64 Step 8: Apply tactic: not Step 9: Apply tactic: Lemma notl_sound: Step 10: Apply tactic: forall v x, vmatch v x -> vmatch (Val Step 11: Apply tactic: notl v) (notl x)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:xorl_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma rotate_long_sound : forall (sem : int64 -> int64 -> int64) (v w : val) (x y : aval),\n  vmatch v x -> vmatch w y ->\n  vmatch (match v, w with\n          | Vlong i, Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))\n          | _, _ => Vundef\n          end)\n         (rotate_long sem x y).\nProof.\n  intros sem v w x y Hv Hw.\n  inversion Hv; subst; try (constructor; fail).\n  inversion Hw; subst; try (constructor; fail).\n  - simpl. constructor. apply vmatch_lub_l; auto.\n  - simpl. constructor. apply vmatch_lub_r; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Apply tactic: Definition notl := unop_long Int64 Step 3: Apply tactic: not Step 4: Apply tactic: Lemma notl_sound: Step 5: Apply tactic: forall v x, vmatch v x -> vmatch (Val Step 6: Apply tactic: notl v) (notl x) Step 7: Apply tactic: Definition rotate_long (sem: int64 -> int64 -> int Step 8: Apply tactic: match v, w with Step 9: Apply tactic: | L i, I amount => L (sem i (Int64 Step 10: Apply tactic: repr (Int Step 11: Apply tactic: unsigned amount)))", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:notl_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma rotate_long_sound : forall (sem : int64 -> int64 -> int64) (v w : val) (x y : aval),\n  vmatch v x -> vmatch w y -> vmatch (match v, w with | Vlong i, Vint j => Vlong (sem i (Int64.repr (Int.unsigned j))) | _, _ => Vundef end) (rotate_long sem x y).\nProof.\n  intros sem v w x y Hv Hw.\n  unfold rotate_long.\n  inv Hv; inv Hw; try (eapply vmatch_ntop1; constructor).\n  - eapply vmatch_lub. eapply vmatch_l. constructor.\n    eapply vmatch_ntop1. constructor.\n  - eapply vmatch_lub. eapply vmatch_l. constructor.\n    eapply vmatch_ntop1. constructor.\n  - eapply vmatch_l. constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x, vmatch v x -> vmatch (Val Step 2: Apply tactic: Definition rotate_long (sem: int64 -> int64 -> int Step 3: Apply tactic: match v, w with Step 4: Apply tactic: | L i, I amount => L (sem i (Int64 Step 5: Apply tactic: repr (Int Step 6: Apply tactic: unsigned amount))) Step 7: Apply tactic: | _, _ => ntop1 v Step 8: Apply tactic: end Step 9: Apply tactic: Lemma rotate_long_sound: Step 10: Apply tactic: forall sem v w x y, Step 11: Apply tactic: vmatch v x -> vmatch w y ->", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:rotate_long_sound", "draft": "Require Import Coq.Integers.Int.\nRequire Import Coq.Ints.Int64.\n\nLemma binop_long_int_sound : forall (sem : int64 -> int -> int64) (v w : val) (x y : aval),\n  vmatch v x -> vmatch w y ->\n  vmatch (match v, w with\n          | Vlong i, Vint j => Vlong (sem i j)\n          | _, _ => Vundef\n          end)\n         (binop_long_int sem x y).\nProof.\n  intros sem v w x y Hv Hw.\n  unfold binop_long_int.\n  destruct v; try (apply vmatch_ntop1).\n  - destruct w; try (apply vmatch_ntop1).\n    + apply vmatch_ntop1.\n    + destruct (va_match Hv) as [i' Hi].\n      destruct (va_match Hw) as [j' Hj].\n      rewrite Hi, Hj.\n      constructor.\n  - destruct w; try (apply vmatch_ntop1).\n    + apply vmatch_ntop1.\n    + apply vmatch_ntop1.\nQed.", "nl_proof": "Step 1: We need to prove that forall sem v w x y, vmatch v x -> vmatch w y -> vmatch (match v, w with | Vlong i, Vint j => Vlong (sem i (Int64 Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (DEFAULT: Step 4: Apply tactic: vmatch (match v, w with Step 5: Apply tactic: | Vlong i, Vint j => Vlong (sem i (Int64 Step 6: Apply tactic: repr (Int Step 7: Apply tactic: unsigned j))) Step 8: Apply tactic: | _, _ => Vundef end) Step 9: Apply tactic: (ntop1 x)) Step 10: Apply tactic: { destruct v Step 11: Apply tactic: try constructor", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:roll_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma rorl_sound : forall (v w : val) (x y : aval), vmatch v x -> vmatch w y -> vmatch (Val.rorl v w) (rorl x y).\nProof.\n  intros v w x y Hv Hw.\n  unfold rorl.\n  apply rotate_long_sound; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Apply tactic: Definition rorl := rotate_long Int64 Step 3: Apply tactic: ror Step 4: Apply tactic: Lemma rorl_sound: Step 5: Apply tactic: forall v w x y, vmatch v x -> vmatch w y -> vmatch Step 6: Apply tactic: rorl v w) (rorl x y) Step 7: Apply tactic: Definition negl := unop_long Int64 Step 8: Apply tactic: neg Step 9: Apply tactic: Lemma negl_sound: Step 10: Apply tactic: forall v x, vmatch v x -> vmatch (Val Step 11: Apply tactic: negl v) (negl x)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:rorl_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma addl_sound : forall (v w : val) (x y : aval), vmatch v x -> vmatch w y -> vmatch (Val.addl v w) (addl x y).\nProof.\n  intros v w x y Hv Hw.\n  unfold Val.addl, addl.\n  inversion Hv; subst; inversion Hw; subst; try constructor.\n  - rewrite H, H0. constructor.\n  - destruct Archi.ptr64; constructor.\n  - destruct Archi.ptr64; constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Apply tactic: Definition negl := unop_long Int64 Step 3: Apply tactic: neg Step 4: Apply tactic: Lemma negl_sound: Step 5: Apply tactic: forall v x, vmatch v x -> vmatch (Val Step 6: Apply tactic: negl v) (negl x) Step 7: Apply tactic: Definition addl (x y: aval) := Step 8: Apply tactic: match x, y with Step 9: Apply tactic: | L i, L j => L (Int64 Step 10: Apply tactic: add i j) Step 11: Apply tactic: | Ptr p, L i | L i, Ptr p => Ptr (if Archi", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:negl_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma vmatch_addl : forall (v1 v2 : val) (x y : aval),\n  vmatch v1 x -> vmatch v2 y -> vmatch (Val.addl v1 v2) (addl x y).\nProof.\n  intros v1 v2 x y H1 H2.\n  unfold addl.\n  destruct x, y; inversion H1; inversion H2; subst; try constructor.\n  - constructor. apply Val.addl_inject; auto.\n  - destruct Archi.ptr64 eqn:?; constructor; auto.\n  - destruct Archi.ptr64 eqn:?; constructor; auto.\n  - constructor; auto.\n  - constructor; auto.\n  - destruct Archi.ptr64 eqn:?; constructor; auto.\n  - destruct Archi.ptr64 eqn:?; constructor; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x, vmatch v x -> vmatch (Val Step 2: Apply tactic: Definition addl (x y: aval) := Step 3: Apply tactic: match x, y with Step 4: Apply tactic: | L i, L j => L (Int64 Step 5: Apply tactic: add i j) Step 6: Apply tactic: | Ptr p, L i | L i, Ptr p => Ptr (if Archi Step 7: Apply tactic: ptr64 then padd p (Ptrofs Step 8: Apply tactic: of_int64 i) else poffset p) Step 9: Apply tactic: | Ptr p, _ | _, Ptr p => Ptr (poffset p) Step 10: Apply tactic: | Ifptr p, L i | L i, Ifptr p => Ifptr (if Archi Step 11: Apply tactic: ptr64 then padd p (Ptrofs", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:addl_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma addl_sound : forall (v w : val) (x y : aval), vmatch v x -> vmatch w y -> vmatch (Val.addl v w) (addl x y).\nProof.\n  intros v w x y H H0.\n  unfold addl.\n  destruct v, w; simpl; try constructor.\n  - inv H; inv H0; constructor.\n  - inv H; inv H0; constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: addl, addl Step 5: Case analysis by destructing a value Step 6: Apply tactic: ptr64 Step 7: Apply tactic: - inv H Step 8: Apply tactic: inv H0 Step 9: Apply tactic: constructor Step 10: Apply tactic: ((apply padd_sound Step 11: Apply tactic: assumption) || (eapply poffset_sound", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:subl_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma subl_sound : forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val.subl v w) (subl x y).\nProof.\n  intros v w x y H H0.\n  unfold Val.subl.\n  destruct v, w; simpl; try (apply vmatch_undef).\n  - inv H; inv H0; eauto using psub_sound, poffset_sound, pmatch_lub.\n  - inv H; inv H0; try (destruct (eq_block b b0)); eauto using psub_sound, poffset_sound, pmatch_lub.\nQed.", "nl_proof": "Step 1: We need to prove that forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: subl, subl Step 5: Case analysis by destructing a value Step 6: Apply tactic: ptr64 Step 7: Apply tactic: - inv H Step 8: Apply tactic: inv H0 Step 9: Apply tactic: try (destruct (eq_block b b0)) Step 10: Apply tactic: eauto using psub_sound, poffset_sound, pmatch_lub_ Step 11: Apply tactic: - inv H", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:mull_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma mullhs_sound : forall (v : nat) (x : nat) (w : nat) (y : nat), vmatch v x -> vmatch w y -> vmatch (mullhs v w) (mullhs x y).\nProof. intros. apply binop_long_sound; assumption. Qed.", "nl_proof": "Step 1: We need to prove that forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Apply tactic: Definition mullhs := binop_long Int64 Step 3: Apply tactic: mulhs Step 4: Apply tactic: Lemma mullhs_sound: Step 5: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 6: Apply tactic: mullhs v w) (mullhs x y) Step 7: Apply tactic: Definition mullhu := binop_long Int64 Step 8: Apply tactic: mulhu Step 9: Apply tactic: Lemma mullhu_sound: Step 10: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 11: Apply tactic: mullhu v w) (mullhu x y)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:mullhs_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma mullhu_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val.mullhu v w) (mullhu x y).\nProof. \n  intros v x w y Hv Hw.\n  unfold mullhu.\n  apply binop_long_sound; auto.\n  apply mulhu_sound; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Apply tactic: Definition mullhu := binop_long Int64 Step 3: Apply tactic: mulhu Step 4: Apply tactic: Lemma mullhu_sound: Step 5: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 6: Apply tactic: mullhu v w) (mullhu x y) Step 7: Apply tactic: Definition divls (v w: aval) := Step 8: Apply tactic: match w, v with Step 9: Apply tactic: | L i2, L i1 => Step 10: Apply tactic: if Int64 Step 11: Apply tactic: eq i2 Int64", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:mullhu_sound", "draft": "Require Import Coq.ZArith.Int.\nRequire Import Coq.Strings.String.\n\nLemma divls_sound : forall (v w : val) (x y : aval), vmatch v x -> vmatch w y -> vmatch (Val.divls v w) (divls x y).\nProof.\n  intros v w x y Hv Hw.\n  unfold Val.divls, divls.\n  destruct v, w; try constructor.\n  destruct (Int64.eq i0 Int64.zero) eqn:Hz.\n  - constructor.\n  - destruct (Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone) eqn:Hm.\n    + constructor.\n    + apply binop_sound; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Apply tactic: Definition divls (v w: aval) := Step 3: Apply tactic: match w, v with Step 4: Apply tactic: | L i2, L i1 => Step 5: Apply tactic: if Int64 Step 6: Apply tactic: eq i2 Int64 Step 7: Apply tactic: zero Step 8: Apply tactic: || Int64 Step 9: Apply tactic: eq i1 (Int64 Step 10: Apply tactic: repr Int64 Step 11: Apply tactic: min_signed) && Int64", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:divls_sound", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma val_match_trans : forall (v w u x y : nat), v = x -> w = y -> v + w = x + y.\nProof. intros v w u x y H1 H2; rewrite H1, H2; reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w u x y, vmatch v x -> vmatch w y -> Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Case analysis by destructing a value Step 5: Apply tactic: try discriminate Step 6: Simplify the goal by computation Step 7: Case analysis by destructing a value Step 8: Apply tactic: eq i0 Int64 Step 9: Apply tactic: zero Step 10: Apply tactic: || Int64 Step 11: Apply tactic: eq i (Int64", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:divlu_sound", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma val_match_mult : forall (v w u : nat) (x y : nat), v = x -> w = y -> v * w = x * y.\nProof. intros v w u x y H1 H2. rewrite H1, H2. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w u x y, vmatch v x -> vmatch w y -> Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Case analysis by destructing a value Step 5: Apply tactic: try discriminate Step 6: Simplify the goal by computation Step 7: Case analysis by destructing a value Step 8: Apply tactic: eq i0 Int64 Step 9: Apply tactic: zero) eqn:E Step 10: Apply tactic: inv H1 Step 11: Apply tactic: inv H", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:modls_sound", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma val_match_distributive : forall (v w u : nat) (x y : nat), v = x -> w = y -> v + w = x + y.\nProof. intros v w u x y H1 H2; rewrite H1, H2; reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w u x y, vmatch v x -> vmatch w y -> Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Case analysis by destructing a value Step 5: Apply tactic: try discriminate Step 6: Simplify the goal by computation Step 7: Case analysis by destructing a value Step 8: Apply tactic: eq i0 Int64 Step 9: Apply tactic: zero Step 10: Apply tactic: || Int64 Step 11: Apply tactic: eq i (Int64", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:modlu_sound", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma val_match_mult : forall (v w u : nat) (x y : nat), v = x -> w = y -> v * w = x * y.\nProof. intros v w u x y H1 H2; rewrite H1, H2; reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w u x y, vmatch v x -> vmatch w y -> Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Case analysis by destructing a value Step 5: Apply tactic: try discriminate Step 6: Simplify the goal by computation Step 7: Case analysis by destructing a value Step 8: Apply tactic: eq i0 Int64 Step 9: Apply tactic: zero) eqn:E Step 10: Apply tactic: inv H1 Step 11: Apply tactic: inv H", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:shrxl_sound", "draft": "Require Import Coq.Arith.Compare_dec.\nLemma val_match_ltu_computation : forall (v w u x y : nat) (i0 : nat) (LTU : ltb i0 63 = true), v = x -> w = y -> Val.ltu (Vint (Int.repr i0)) (Vint (Int.repr 63)) = Some u -> u = Vtrue.\nProof.\n  intros v w u x y i0 LTU H H0 H1.\n  unfold Val.ltu in H1.\n  destruct (Int.ltu (Int.repr i0) (Int.repr 63)) eqn:?; try discriminate.\n  inversion H1.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall v w u x y, vmatch v x -> vmatch w y -> Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Case analysis by destructing a value Step 5: Apply tactic: try discriminate Step 6: Simplify the goal by computation Step 7: Case analysis by destructing a value Step 8: Apply tactic: ltu i0 (Int Step 9: Apply tactic: repr 63)) eqn:LTU Step 10: Apply tactic: inv H1 Step 11: Unfold a definition", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:rolml_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Integers.Int.\nRequire Import Compcert.Integers.\nRequire Import Compcert.ValueDomain.\n\nLemma rolml_sound : forall v x amount mask,\n  vmatch v x -> vmatch (Val.rolml v amount mask) (rolml x amount mask).\nProof.\n  intros v x amount mask H.\n  unfold Val.rolml, rolml.\n  destruct (Int.ltu amount Int.iwordsize) eqn:Hamount.\n  - apply vmatch_and.\n    + apply vmatch_rol; assumption.\n    + apply vmatch_lub_l.\n      apply vmatch_const.\n  - apply vmatch_and.\n    + apply vmatch_rol; assumption.\n    + apply vmatch_lub_r.\n      apply vmatch_const.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x amount mask, vmatch v x -> vmatch (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: replace (Val Step 4: Apply tactic: rolml v amount mask) with (Val Step 5: Apply tactic: andl (Val Step 6: Apply tactic: roll v (Vint amount)) (Vlong mask)) Step 7: Apply a theorem or hypothesis Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply tactic: constructor Step 11: Apply tactic: constructor", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:offset_ptr_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma vmatch_offset_ptr_template : forall (v x n : nat), vmatch v x -> vmatch (Val.offset_ptr v n) (Val.offset_ptr x n).\nProof.\n  intros v x n H.\n  unfold Val.offset_ptr.\n  inv H.\n  constructor.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x n, vmatch v x -> vmatch (Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: offset_ptr, offset_ptr Step 5: Apply tactic: inv H Step 6: Apply tactic: constructor Step 7: Apply a theorem or hypothesis Step 8: Apply tactic: assumption Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:negf_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Floats.Floats.\n\nLemma absf_sound : forall v x, vmatch v x -> vmatch (Val.absf v) (absf x).\nProof.\n  intros v x H.\n  unfold Val.absf, absf.\n  apply unop_float_sound; assumption.\nQed.\n\nLemma addf_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val.addf v w) (addf x y).\nProof.\n  intros v x w y Hv Hw.\n  unfold Val.addf, addf.\n  apply binop_float_sound; assumption.\nQed.", "nl_proof": "Step 1: * Conversions Step 2: We need to prove that forall v x, vmatch v x -> vmatch (Val Step 3: Apply tactic: Definition absf := unop_float Float Step 4: Apply tactic: abs Step 5: Apply tactic: Lemma absf_sound: Step 6: Apply tactic: forall v x, vmatch v x -> vmatch (Val Step 7: Apply tactic: absf v) (absf x) Step 8: Apply tactic: Definition addf := binop_float Float Step 9: Apply tactic: add Step 10: Apply tactic: Lemma addf_sound: Step 11: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 12: Apply tactic: addf v w) (addf x y)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:absf_sound", "draft": "Require Import Coq.Floats.Floats.\n\nLemma subf_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val.subf v w) (subf x y).\nProof.\n  intros v x w y Hv Hw.\n  unfold Val.subf, subf.\n  apply binop_float_sound; assumption.\nQed.", "nl_proof": "Step 1: * Conversions Step 2: We need to prove that forall v x, vmatch v x -> vmatch (Val Step 3: Apply tactic: Definition addf := binop_float Float Step 4: Apply tactic: add Step 5: Apply tactic: Lemma addf_sound: Step 6: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 7: Apply tactic: addf v w) (addf x y) Step 8: Apply tactic: Definition subf := binop_float Float Step 9: Apply tactic: sub Step 10: Apply tactic: Lemma subf_sound: Step 11: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 12: Apply tactic: subf v w) (subf x y)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:addf_sound", "draft": "Require Import Coq.Floats.Floats.\nRequire Import compcert.backend.ValueDomain.\n\nDefinition subf := binop_float Float.sub.\nLemma subf_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val.subf v w) (subf x y).\nProof. apply binop_float_sound. Qed.", "nl_proof": "Step 1: * Conversions Step 2: We need to prove that forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val Step 3: Apply tactic: Definition subf := binop_float Float Step 4: Apply tactic: sub Step 5: Apply tactic: Lemma subf_sound: Step 6: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 7: Apply tactic: subf v w) (subf x y) Step 8: Apply tactic: Definition mulf := binop_float Float Step 9: Apply tactic: mul Step 10: Apply tactic: Lemma mulf_sound: Step 11: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 12: Apply tactic: mulf v w) (mulf x y)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:subf_sound", "draft": "Require Import Coq.Floats.Floats.\n\nLemma mulf_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val.mulf v w) (mulf x y).\nProof.\n  intros v x w y Hv Hw.\n  unfold mulf, binop_float.\n  apply binop_float_sound; assumption.\nQed.", "nl_proof": "Step 1: * Conversions Step 2: We need to prove that forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val Step 3: Apply tactic: Definition mulf := binop_float Float Step 4: Apply tactic: mul Step 5: Apply tactic: Lemma mulf_sound: Step 6: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 7: Apply tactic: mulf v w) (mulf x y) Step 8: Apply tactic: Definition divf := binop_float Float Step 9: Apply tactic: div Step 10: Apply tactic: Lemma divf_sound: Step 11: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 12: Apply tactic: divf v w) (divf x y)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:mulf_sound", "draft": "Require Import Coq.Floats.Floats.\n\nLemma divf_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val.divf v w) (divf x y).\nProof.\n  intros v x w y Hv Hw.\n  unfold divf.\n  apply binop_float_sound; assumption.\nQed.", "nl_proof": "Step 1: * Conversions Step 2: We need to prove that forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val Step 3: Apply tactic: Definition divf := binop_float Float Step 4: Apply tactic: div Step 5: Apply tactic: Lemma divf_sound: Step 6: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 7: Apply tactic: divf v w) (divf x y) Step 8: Apply tactic: Definition negfs := unop_single Float32 Step 9: Apply tactic: neg Step 10: Apply tactic: Lemma negfs_sound: Step 11: Apply tactic: forall v x, vmatch v x -> vmatch (Val Step 12: Apply tactic: negfs v) (negfs x)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:divf_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma absfs_sound : forall v x, vmatch v x -> vmatch (Val.absfs v) (absfs x).\nProof. apply unop_single_sound. Qed.", "nl_proof": "Step 1: * Conversions Step 2: We need to prove that forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val Step 3: Apply tactic: Definition negfs := unop_single Float32 Step 4: Apply tactic: neg Step 5: Apply tactic: Lemma negfs_sound: Step 6: Apply tactic: forall v x, vmatch v x -> vmatch (Val Step 7: Apply tactic: negfs v) (negfs x) Step 8: Apply tactic: Definition absfs := unop_single Float32 Step 9: Apply tactic: abs Step 10: Apply tactic: Lemma absfs_sound: Step 11: Apply tactic: forall v x, vmatch v x -> vmatch (Val Step 12: Apply tactic: absfs v) (absfs x)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:negfs_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma binop_single_sound : forall (sem : float32 -> float32 -> float32) (v w : val) (x y : aval),\n  vmatch v x -> vmatch w y -> vmatch (match v, w with Vsingle i, Vsingle j => Vsingle (sem i j) | _, _ => Vundef end) (binop_single sem x y).\nProof.\n  intros sem v w x y Hv Hw.\n  apply binop_single_sound; assumption.\nQed.", "nl_proof": "Step 1: * Conversions Step 2: We need to prove that forall v x, vmatch v x -> vmatch (Val Step 3: Apply tactic: Definition absfs := unop_single Float32 Step 4: Apply tactic: abs Step 5: Apply tactic: Lemma absfs_sound: Step 6: Apply tactic: forall v x, vmatch v x -> vmatch (Val Step 7: Apply tactic: absfs v) (absfs x) Step 8: Apply tactic: Definition addfs := binop_single Float32 Step 9: Apply tactic: add Step 10: Apply tactic: Lemma addfs_sound: Step 11: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 12: Apply tactic: addfs v w) (addfs x y)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:absfs_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma subfs_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val.subfs v w) (subfs x y).\nProof.\n  intros v x w y Hv Hw.\n  unfold subfs, binop_single.\n  apply binop_single_sound; assumption.\nQed.", "nl_proof": "Step 1: * Conversions Step 2: We need to prove that forall v x, vmatch v x -> vmatch (Val Step 3: Apply tactic: Definition addfs := binop_single Float32 Step 4: Apply tactic: add Step 5: Apply tactic: Lemma addfs_sound: Step 6: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 7: Apply tactic: addfs v w) (addfs x y) Step 8: Apply tactic: Definition subfs := binop_single Float32 Step 9: Apply tactic: sub Step 10: Apply tactic: Lemma subfs_sound: Step 11: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 12: Apply tactic: subfs v w) (subfs x y)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:addfs_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma mulfs_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val.mulfs v w) (mulfs x y).\nProof.\n  intros v x w y Hv Hw.\n  unfold mulfs.\n  apply binop_single_sound; assumption.\nQed.", "nl_proof": "Step 1: * Conversions Step 2: We need to prove that forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val Step 3: Apply tactic: Definition subfs := binop_single Float32 Step 4: Apply tactic: sub Step 5: Apply tactic: Lemma subfs_sound: Step 6: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 7: Apply tactic: subfs v w) (subfs x y) Step 8: Apply tactic: Definition mulfs := binop_single Float32 Step 9: Apply tactic: mul Step 10: Apply tactic: Lemma mulfs_sound: Step 11: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 12: Apply tactic: mulfs v w) (mulfs x y)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:subfs_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma mulfs_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val.mulfs v w) (mulfs x y).\nProof. apply binop_single_sound. Qed.", "nl_proof": "Step 1: * Conversions Step 2: We need to prove that forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val Step 3: Apply tactic: Definition mulfs := binop_single Float32 Step 4: Apply tactic: mul Step 5: Apply tactic: Lemma mulfs_sound: Step 6: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 7: Apply tactic: mulfs v w) (mulfs x y) Step 8: Apply tactic: Definition divfs := binop_single Float32 Step 9: Apply tactic: div Step 10: Apply tactic: Lemma divfs_sound: Step 11: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 12: Apply tactic: divfs v w) (divfs x y)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:mulfs_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma divfs_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val.divfs v w) (binop_single Float32.div x y).\nProof.\n  intros v x w y Hv Hw.\n  apply binop_single_sound; assumption.\nQed.", "nl_proof": "Step 1: * Conversions Step 2: We need to prove that forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val Step 3: Apply tactic: Definition divfs := binop_single Float32 Step 4: Apply tactic: div Step 5: Apply tactic: Lemma divfs_sound: Step 6: Apply tactic: forall v x w y, vmatch v x -> vmatch w y -> vmatch Step 7: Apply tactic: divfs v w) (divfs x y) Step 8: Apply tactic: Definition zero_ext (nbits: Z) (v: aval) := Step 9: Apply tactic: match v with Step 10: Apply tactic: | I i => I (Int Step 11: Apply tactic: zero_ext nbits i) Step 12: Apply tactic: | IU i => IU (Int", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:divfs_sound", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import compcert.lib.Integers.\n\nLemma zero_ext_sound : forall (nbits : Z) (v : val) (x : aval), vmatch v x -> vmatch (Val.zero_ext nbits v) (zero_ext nbits x).\nProof.\n  intros nbits v x H.\n  unfold Val.zero_ext.\n  destruct x; inversion H; subst; simpl; try constructor.\n  - apply vmatch_uns.\n  - apply vmatch_s.\n  - apply vmatch_i.\n  - apply vmatch_l.\n  - apply vmatch_f.\n  - apply vmatch_single.\n  - apply vmatch_ptr.\nQed.", "nl_proof": "Step 1: * Conversions Step 2: We need to prove that forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val Step 3: Apply tactic: Definition zero_ext (nbits: Z) (v: aval) := Step 4: Apply tactic: match v with Step 5: Apply tactic: | I i => I (Int Step 6: Apply tactic: zero_ext nbits i) Step 7: Apply tactic: | IU i => IU (Int Step 8: Apply tactic: zero_ext nbits i) Step 9: Apply tactic: | Uns p n => uns p (Z Step 10: Apply tactic: min n nbits) Step 11: Apply tactic: | _ => uns (provenance v) nbits Step 12: Apply tactic: end", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:zero_ext_sound", "draft": "Require Import Coq.ZArith.ZArith.\nLemma zero_ext_uns_match : forall nbits v i, is_uns nbits i -> vmatch v (uns nbits) -> vmatch (Val.zero_ext nbits v) (uns nbits).\nProof.\n  intros nbits v i Huns Hmatch.\n  red in Hmatch.\n  red.\n  rewrite Hmatch.\n  apply bits_zero_ext; lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall nbits v x, vmatch v x -> vmatch (Val Step 2: Apply tactic: assert (DFL: forall nbits i, is_uns nbits (Int Step 3: Apply tactic: zero_ext nbits i)) Step 4: Introduce variables and assumptions Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Rewrite using an equality Step 8: Apply tactic: bits_zero_ext by lia Step 9: Apply a theorem or hypothesis Step 10: Solve automatically using known facts Step 11: Introduce variables and assumptions", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:sign_ext_sound", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import compcert.lib.Integers.\nRequire Import compcert.common.Values.\n\nLemma sign_ext_match: forall (nbits: nat) (v: val) (x: aval),\n  vmatch v x -> vmatch (Val.sign_ext (Z.of_nat nbits) v) (sign_ext nbits x).\nProof.\n  intros nbits v x H.\n  destruct v; simpl; try constructor.\n  destruct (Int.eq_dec _ _); try constructor.\n  destruct H; constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall nbits v x, vmatch v x -> vmatch (Val Step 2: Apply tactic: assert (DFL: forall p nbits i, 0 < nbits -> vmatch Step 3: Apply tactic: sign_ext nbits i)) (sgn p nbits)) Step 4: Introduce variables and assumptions Step 5: Apply a theorem or hypothesis Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Introduce variables and assumptions Step 9: Unfold a definition Step 10: Case analysis by destructing a value Step 11: Apply tactic: - destruct v", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:zero_ext_l_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma unop_long_sound_zero_ext : forall (s : nat) (v : val) (x : aval),\n  vmatch v x -> vmatch (match v with Vlong i => Vlong (Int64.zero_ext s i) | _ => Vundef end) (unop_long (Int64.zero_ext s) x).\nProof. exact (unop_long_sound (Int64.zero_ext s)). Qed.", "nl_proof": "Step 1: We need to prove that forall s v x, vmatch v x -> vmatch (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: exact (unop_long_sound (Int64 Step 4: Apply tactic: zero_ext s)) Step 5: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:sign_ext_l_sound", "draft": "Require Import Coq.Integers.Int.\nLemma sign_ext_l_sound : forall (s : int) (v : val) (x : aval), vmatch v x -> vmatch (Val.sign_ext_l s v) (sign_ext_l s x).\nProof. exact (unop_long_sound (Int64.sign_ext s)). Qed.", "nl_proof": "Step 1: We need to prove that forall s v x, vmatch v x -> vmatch (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: exact (unop_long_sound (Int64 Step 4: Apply tactic: sign_ext s)) Step 5: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:longofint_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma val_longofint_match : forall v x, vmatch v x -> vmatch (Val.longofint v) (Val.longofint x).\nProof.\n  intros v x H.\n  inv H.\n  all: constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x, vmatch v x -> vmatch (Val Step 2: Unfold a definition Step 3: Apply tactic: longofint, longofint Step 4: Introduce variables and assumptions Step 5: Apply tactic: inv H Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:longofintu_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma longofintu_match : forall v x, vmatch v x -> vmatch (Val.longofintu v) (Val.longofintu x).\nProof. intros v x H; inv H; auto. Qed.", "nl_proof": "Step 1: We need to prove that forall v x, vmatch v x -> vmatch (Val Step 2: Unfold a definition Step 3: Apply tactic: longofintu, longofintu Step 4: Introduce variables and assumptions Step 5: Apply tactic: inv H Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:singleoffloat_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma singleoffloat_vmatch : forall (v : val) (x : aval), vmatch v x -> vmatch (Val.singleoffloat v) (ntop1 x).\nProof.\n  intros v x H.\n  assert (DEFAULT: vmatch (Val.singleoffloat v) (ntop1 x)).\n  { destruct v; constructor. }\n  destruct v; try apply DEFAULT.\n  inv H; constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x, vmatch v x -> vmatch (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (DEFAULT: vmatch (Val Step 4: Apply tactic: singleoffloat v) (ntop1 x)) Step 5: Apply tactic: { destruct v Step 6: Apply tactic: constructor Step 7: Case analysis by destructing a value Step 8: Solve automatically using known facts Step 9: Apply tactic: inv H Step 10: Apply tactic: constructor Step 11: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:floatofsingle_sound", "draft": "Require Import Coq.Floats.Floats.\n\nLemma vmatch_floatofsingle : forall (v : val) (x : aval), vmatch v x -> vmatch (Val.floatofsingle v) (ntop1 x).\nProof.\n  intros v x H.\n  assert (DEFAULT: vmatch (Val.floatofsingle v) (ntop1 x)).\n  { destruct v; constructor. }\n  destruct v; try assumption.\n  inv H; constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x, vmatch v x -> vmatch (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (DEFAULT: vmatch (Val Step 4: Apply tactic: floatofsingle v) (ntop1 x)) Step 5: Apply tactic: { destruct v Step 6: Apply tactic: constructor Step 7: Case analysis by destructing a value Step 8: Solve automatically using known facts Step 9: Apply tactic: inv H Step 10: Apply tactic: constructor Step 11: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:intoffloat_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Floats.Floats.\n\nLemma intoffloat_sound : forall v x w, vmatch v x -> Val.intoffloat v = Some w -> vmatch w (intoffloat x).\nProof.\n  intros v x w H H0.\n  unfold Val.intoffloat in H0.\n  destruct v; try discriminate.\n  destruct f; try discriminate.\n  simpl in H0.\n  injection H0; intro; subst w.\n  inv H.\n  simpl.\n  constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x w, vmatch v x -> Val Step 2: Unfold a definition Step 3: Apply tactic: intoffloat Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: try discriminate Step 7: Case analysis by destructing a value Step 8: Apply tactic: to_int f) as [i|] eqn:E Step 9: Simplify the goal by computation Step 10: Apply tactic: inv H0 Step 11: Apply tactic: inv H", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:intuoffloat_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Floats.Floats.\n\nLemma intuoffloat_sound : forall v x w, vmatch v x -> Val.intuoffloat v = Some w -> vmatch w (intuoffloat x).\nProof.\n  intros v x w H H0.\n  destruct v; try discriminate.\n  destruct f; try discriminate.\n  simpl in H0.\n  destruct (to_intu f) as [i|] eqn:E; try discriminate.\n  inv H0.\n  inv H.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x w, vmatch v x -> Val Step 2: Unfold a definition Step 3: Apply tactic: intuoffloat Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: try discriminate Step 7: Case analysis by destructing a value Step 8: Apply tactic: to_intu f) as [i|] eqn:E Step 9: Simplify the goal by computation Step 10: Apply tactic: inv H0 Step 11: Apply tactic: inv H", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:floatofint_sound", "draft": "Require Import Coq.Floats.Floats.\nLemma floatofint_match : forall v x, vmatch v x -> vmatch (Val.floatofint v) (floatofint x).\nProof.\n  intros v x H.\n  unfold floatofint.\n  destruct v; try (inv H; fail).\n  inv H.\n  simpl.\n  constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x w, vmatch v x -> Val Step 2: Unfold a definition Step 3: Apply tactic: floatofint Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: inv H0 Step 7: Apply tactic: inv H Step 8: Simplify the goal by computation Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:floatofintu_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Floats.Floats.\n\nLemma val_match_floatofintu : forall v x w, vmatch v x -> Val.floatofintu v = Some w -> vmatch w (floatofintu x).\nProof.\n  intros v x w H H0.\n  unfold floatofintu.\n  destruct v; try discriminate.\n  inv H0.\n  inv H.\n  simpl.\n  constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x w, vmatch v x -> Val Step 2: Unfold a definition Step 3: Apply tactic: floatofintu Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: inv H0 Step 7: Apply tactic: inv H Step 8: Simplify the goal by computation Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:intofsingle_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma val_match_intofsingle : forall (v : nat) (x : nat) (w : nat), v = x -> v = w -> x = w.\nProof. intros v x w H H0. rewrite H in H0. assumption. Qed.", "nl_proof": "Step 1: We need to prove that forall v x w, vmatch v x -> Val Step 2: Unfold a definition Step 3: Apply tactic: intofsingle Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: try discriminate Step 7: Case analysis by destructing a value Step 8: Apply tactic: to_int f) as [i|] eqn:E Step 9: Simplify the goal by computation Step 10: Apply tactic: inv H0 Step 11: Apply tactic: inv H", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:intuofsingle_sound", "draft": "Require Import Coq.Floats.Floats.\n\nLemma val_match_to_intu_single : forall (v : val) (x : float32) (w : int),\n  vmatch v (Afloat x) -> Val.to_intu (Val.maketotal (Val.singleoffloat v)) = Some w -> \n  Val.to_intu (Val.maketotal (Val.singleoffloat (Vfloat (Float.of_single x)))) = Some w.\nProof.\n  intros v x w H H0.\n  unfold Val.maketotal in *.\n  destruct v; try discriminate.\n  destruct f; try discriminate.\n  simpl in H0.\n  destruct (Float32.to_intu f) as [i|] eqn:E; try discriminate.\n  inv H0.\n  inv H.\n  simpl.\n  rewrite E.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x w, vmatch v x -> Val Step 2: Unfold a definition Step 3: Apply tactic: intuofsingle Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: try discriminate Step 7: Case analysis by destructing a value Step 8: Apply tactic: to_intu f) as [i|] eqn:E Step 9: Simplify the goal by computation Step 10: Apply tactic: inv H0 Step 11: Apply tactic: inv H", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:singleofint_sound", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma val_match_step : forall (v : nat) (x : nat) (w : nat), v = x -> v + w = x + w.\nProof.\n  intros v x w H.\n  rewrite H.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x w, vmatch v x -> Val Step 2: Unfold a definition Step 3: Apply tactic: singleofint Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: inv H0 Step 7: Apply tactic: inv H Step 8: Simplify the goal by computation Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:singleofintu_sound", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma val_match_step : forall (v : nat) (x : nat) (w : nat), v = x -> v + w = x + w.\nProof. intros v x w H. rewrite H. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v x w, vmatch v x -> Val Step 2: Unfold a definition Step 3: Apply tactic: singleofintu Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: inv H0 Step 7: Apply tactic: inv H Step 8: Simplify the goal by computation Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:longoffloat_sound", "draft": "Require Import Coq.Integers.Int.\nRequire Import compcert.lib.Integers.\nRequire Import compcert.common.Values.\nRequire Import compcert.x86.ValueAOp.\n\nLemma longoffloat_sound : forall (v : val) (x : aval) (w : int64),\n  vmatch v x -> Val.longoffloat v = Some (Vlong w) -> vmatch (Vlong w) (longoffloat x).\nProof.\n  intros v x w H H0.\n  unfold longoffloat.\n  destruct v; try discriminate.\n  destruct f; try discriminate.\n  simpl in H0.\n  destruct (Float.to_long f) as [i|] eqn:E; try discriminate.\n  inv H0.\n  inv H.\n  apply vmatch_lui.\n  apply Int64.repr_unsigned.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x w, vmatch v x -> Val Step 2: Unfold a definition Step 3: Apply tactic: longoffloat Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: try discriminate Step 7: Case analysis by destructing a value Step 8: Apply tactic: to_long f) as [i|] eqn:E Step 9: Simplify the goal by computation Step 10: Apply tactic: inv H0 Step 11: Apply tactic: inv H", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:longuoffloat_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Floats.Floats.\nRequire Import compcert.common.Values.\nRequire Import compcert.backend.ValueDomain.\n\nLemma longuoffloat_sound : forall v x w, vmatch v x -> Val.longuoffloat v = Some w -> vmatch w (longuoffloat x).\nProof.\n  intros v x w H H0.\n  unfold Val.longuoffloat in H0.\n  destruct v; try discriminate.\n  destruct f; try discriminate.\n  simpl in H0.\n  destruct (ZofB_range 53 1024 __ __ 0 Int64.max_unsigned) as [i|] eqn:E; try discriminate.\n  inv H0.\n  inv H.\n  simpl.\n  apply vmatch_lui.\n  apply is_uns_mon with (n1:=64%nat); [|omega].\n  apply ZofB_range_unsigned in E.\n  destruct E as [E1 E2].\n  apply is_uns_sign_ext.\n  compute; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x w, vmatch v x -> Val Step 2: Unfold a definition Step 3: Apply tactic: longuoffloat Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: try discriminate Step 7: Case analysis by destructing a value Step 8: Apply tactic: to_longu f) as [i|] eqn:E Step 9: Simplify the goal by computation Step 10: Apply tactic: inv H0 Step 11: Apply tactic: inv H", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:floatoflong_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma val_match_floatoflong : forall (v : nat) (x : nat) (w : nat), v = x -> v = w -> w = x.\nProof. intros v x w H H0. rewrite H0. apply H. Qed.", "nl_proof": "Step 1: We need to prove that forall v x w, vmatch v x -> Val Step 2: Unfold a definition Step 3: Apply tactic: floatoflong Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: inv H0 Step 7: Apply tactic: inv H Step 8: Simplify the goal by computation Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:floatoflongu_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma val_match_floatoflongu : forall (v : nat) (x : nat) (w : nat), v = x -> Nat.div v w = Nat.div x w.\nProof. intros v x w H. rewrite H. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v x w, vmatch v x -> Val Step 2: Unfold a definition Step 3: Apply tactic: floatoflongu Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: inv H0 Step 7: Apply tactic: inv H Step 8: Simplify the goal by computation Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:longofsingle_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Floats.Floats.\n\nLemma longofsingle_sound : forall v x w, vmatch v x -> Val.longofsingle v = Some w -> vmatch w (longofsingle x).\nProof.\n  intros v x w H H0.\n  destruct v; try discriminate.\n  destruct f; try discriminate.\n  simpl in H0.\n  destruct (to_long f) as [i|] eqn:E; try discriminate.\n  inv H0.\n  inv H.\n  simpl.\n  rewrite E.\n  constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x w, vmatch v x -> Val Step 2: Unfold a definition Step 3: Apply tactic: longofsingle Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: try discriminate Step 7: Case analysis by destructing a value Step 8: Apply tactic: to_long f) as [i|] eqn:E Step 9: Simplify the goal by computation Step 10: Apply tactic: inv H0 Step 11: Apply tactic: inv H", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:longuofsingle_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Floats.Floats.\n\nLemma longuofsingle_sound : forall v x w, vmatch v x -> Val.longuofsingle v = Some w -> vmatch w (longuofsingle x).\nProof.\n  intros v x w H H0.\n  destruct v; try discriminate.\n  destruct f; try discriminate.\n  simpl in H0.\n  inv H0.\n  inv H.\n  simpl.\n  constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x w, vmatch v x -> Val Step 2: Unfold a definition Step 3: Apply tactic: longuofsingle Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: try discriminate Step 7: Case analysis by destructing a value Step 8: Apply tactic: to_longu f) as [i|] eqn:E Step 9: Simplify the goal by computation Step 10: Apply tactic: inv H0 Step 11: Apply tactic: inv H", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:singleoflong_sound", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma singleoflong_match : forall (v : nat) (x : nat) (w : nat), v = x -> v = w -> v = w.\nProof. intros v x w H H0. apply H0. Qed.", "nl_proof": "Step 1: We need to prove that forall v x w, vmatch v x -> Val Step 2: Unfold a definition Step 3: Apply tactic: singleoflong Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: inv H0 Step 7: Apply tactic: inv H Step 8: Simplify the goal by computation Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:singleoflongu_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma singleoflongu_match : forall v x w, vmatch v x -> Val.singleoflongu v = Some w -> vmatch w (singleoflongu x).\nProof.\n  intros v x w H H0.\n  destruct v; try discriminate.\n  inv H0.\n  inv H.\n  simpl.\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x w, vmatch v x -> Val Step 2: Unfold a definition Step 3: Apply tactic: singleoflongu Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: inv H0 Step 7: Apply tactic: inv H Step 8: Simplify the goal by computation Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:floatofwords_sound", "draft": "Require Import Coq.Arith.PeanoNat.\n\nLemma or_sound : forall (v w x y : nat), v <= x -> w <= y -> Nat.max v w <= Nat.max x y.\nProof.\n  intros v w x y H H0.\n  apply Nat.max_le_compat; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: inv H Step 5: Simplify the goal by computation Step 6: Solve automatically using known facts Step 7: Apply tactic: inv H0 Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:longofwords_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma or_sound : forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val.or v w) (or x y).\nProof.\n  intros v w x y H H0.\n  inv H0.\n  inv H.\n  simpl.\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: inv H0 Step 5: Apply tactic: inv H Step 6: Simplify the goal by computation Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:loword_sound", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma step_vmatch : forall (v x : nat), v = x -> v = x.\nProof. intros v x H. exact H. Qed.", "nl_proof": "Step 1: We need to prove that forall v x, vmatch v x -> vmatch (Val Step 2: Case analysis by destructing a value Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:hiword_sound", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma step_vmatch : forall (v : nat) (x : nat), v <= x -> v <= S x.\nProof. intros v x H. apply Nat.le_trans with (m := x); [assumption | apply Nat.le_succ_diag_r]. Qed.", "nl_proof": "Step 1: We need to prove that forall v x, vmatch v x -> vmatch (Val Step 2: Case analysis by destructing a value Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:zcmp_intv_sound", "draft": "Require Import Coq.Arith.Compare_dec.\nRequire Import Coq.Arith.PeanoNat.\n\nLemma cmatch_cmp_intv_correct : forall (c : comparison) (i : nat * nat) (x n : nat),\n    fst i <= x <= snd i -> cmatch (Some (zcmp c x n)) (cmp_intv c i n).\nProof.\n  intros c [i1 i2] x n [H1 H2].\n  unfold cmp_intv, zcmp.\n  destruct (le_lt_dec i1 x).\n  - destruct (le_lt_dec x i2).\n    + destruct c; constructor.\n    + destruct c; constructor.\n  - destruct c; constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall c i x n, fst i <= x <= snd i -> cmatch (Some (zcmp c x n)) (cmp_intv c i n) Step 2: Introduce variables and assumptions Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Unfold a definition Step 7: Case analysis by destructing a value Step 8: Rewrite using an equality Step 9: Apply tactic: constructor Step 10: Case analysis by destructing a value Step 11: Rewrite using an equality", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:cmp_intv_None", "draft": "Require Import Coq.Arith.Arith.\n\nLemma cmatch_cmp_intv_none : forall (c : comparison) (i n : nat), cmatch None (cmp_intv c i n).\nProof.\n  intros c i n.\n  unfold cmp_intv.\n  destruct c.\n  - destruct (i ?= n) eqn:H; constructor.\n  - destruct (i ?= n) eqn:H; constructor.\n  - destruct (i ?= n) eqn:H; constructor.\n  - destruct (i ?= n) eqn:H; constructor.\n  - destruct (i ?= n) eqn:H; constructor.\n  - destruct (i ?= n) eqn:H; constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall c i n, cmatch None (cmp_intv c i n) Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Case analysis by destructing a value Step 6: Case analysis by destructing a value Step 7: Apply tactic: constructor Step 8: Case analysis by destructing a value Step 9: Apply tactic: constructor Step 10: Case analysis by destructing a value Step 11: Apply tactic: constructor", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:cmp_intv_different_blocks", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma cmatch_val_cmp_different_blocks : forall (A : Type) (c : comparison) (i n : A), \n  cmatch (Val.cmp c (Vptr i n) (Vptr i n)) (cmp_different_blocks c).\nProof.\n  intros A c i n. unfold Val.cmp. destruct c; simpl; constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall c i n, cmatch (Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: cmp_different_blocks Step 5: Case analysis by destructing a value Step 6: Solve automatically using known facts Step 7: Simplify the goal by computation Step 8: Apply tactic: - destruct orb Step 9: Apply tactic: constructor Step 10: Apply tactic: - destruct orb Step 11: Apply tactic: constructor", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:cmp_intv_different_blocks_2", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma cmatch_val_of_bool_template : forall (b : bool), cmatch (Val.of_bool b) (cmp_different_blocks b).\nProof.\n  intros b. unfold Val.of_bool. destruct b; constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall c i n, cmatch (Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: cmp_different_blocks Step 5: Case analysis by destructing a value Step 6: Solve automatically using known facts Step 7: Simplify the goal by computation Step 8: Apply tactic: - destruct orb Step 9: Apply tactic: constructor Step 10: Apply tactic: - destruct orb Step 11: Apply tactic: constructor", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:uintv_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nRequire Import Coq.micromega.Lia.\n\nLemma uintv_bound : forall n v, vmatch (Vint n) v -> fst (uintv v) <= Int.unsigned n.\nProof.\n  intros n v H.\n  inversion H; subst; simpl; try lia.\n  destruct (zlt n0 Int.zwordsize).\n  - rewrite is_uns_zero_ext in H2.\n    apply Int.unsigned_range_2.\n  - apply Int.unsigned_range_2.\nQed.", "nl_proof": "Step 1: We need to prove that forall n v, vmatch (Vint n) v -> fst (uintv v) <= Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Simplify the goal by computation Step 5: Apply tactic: try (apply Int Step 6: Apply tactic: unsigned_range_2) Step 7: Apply tactic: - lia Step 8: Apply tactic: - destruct (zlt n0 Int Step 9: Apply tactic: zwordsize) Step 10: Simplify the goal by computation Step 11: Apply tactic: + rewrite is_uns_zero_ext in H2", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:cmpu_intv_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nRequire Import compcert.lib.Integers.\nRequire Import compcert.common.Values.\n\nLemma cmpu_intv_sound : forall valid c n1 v1 n2,\n  vmatch (Vint n1) v1 ->\n  cmatch (Val.cmpu_bool valid c (Vint n1) (Vint n2)) (cmp_intv c (uintv v1) (Int.unsigned n2)).\nProof.\n  intros valid c n1 v1 n2 Hmatch.\n  simpl.\n  replace (Int.cmpu c n1 n2) with (zcmp c (Int.unsigned n1) (Int.unsigned n2)).\n  - apply cmp_intv_sound; auto.\n  - unfold Int.cmpu, zcmp.\n    destruct Int.eq; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall valid c n1 v1 n2, vmatch (Vint n1) v1 -> cmatch (Val Step 2: Introduce variables and assumptions Step 3: Simplify the goal by computation Step 4: Apply tactic: replace (Int Step 5: Apply tactic: cmpu c n1 n2) with (zcmp c (Int Step 6: Apply tactic: unsigned n1) (Int Step 7: Apply tactic: unsigned n2)) Step 8: Apply a theorem or hypothesis Step 9: Apply a theorem or hypothesis Step 10: Solve automatically using known facts Step 11: Case analysis by destructing a value", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:cmpu_intv_sound_2", "draft": "Require Import Coq.Arith.Compare_dec.\nRequire Import Coq.ZArith.ZArith.\nRequire Import compcert.lib.Integers.\nRequire Import compcert.common.Values.\n\nLemma cmpu_intv_sound_2 : forall (valid : Integers.int -> bool) (c : comparison) (n1 n2 : Integers.int) (v1 : aval),\n  vmatch (Vint n1) v1 ->\n  cmatch (Val.cmpu_bool valid c (Vint n2) (Vint n1)) (cmp_intv (swap_comparison c) (uintv v1) (Int.unsigned n2)).\nProof.\n  intros valid c n1 n2 v1 H.\n  rewrite Val.cmpu_bool_swap.\n  apply cmp_intv_sound; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall valid c n1 v1 n2, vmatch (Vint n1) v1 -> cmatch (Val Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Apply tactic: swap_cmpu_bool Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:sintv_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nRequire Import Coq.micromega.Lia.\n\nLemma sintv_lower_bound : forall n v, vmatch (Vint n) v -> fst (sintv v) <= Int.signed n.\nProof.\n  intros n v H.\n  inversion H; simpl; try lia.\n  destruct (zlt n0 Int.zwordsize).\n  - rewrite is_uns_zero_ext in H2.\n    lia.\n  - lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall n v, vmatch (Vint n) v -> fst (sintv v) <= Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Simplify the goal by computation Step 5: Apply tactic: try (apply Int Step 6: Apply tactic: signed_range) Step 7: Apply tactic: - lia Step 8: Apply tactic: - destruct (zlt n0 Int Step 9: Apply tactic: zwordsize) Step 10: Simplify the goal by computation Step 11: Apply tactic: + rewrite is_uns_zero_ext in H2", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:cmp_intv_sound", "draft": "Require Import Coq.ZArith.Int.\nLemma cmp_intv_sound : forall (c : comparison) (n1 n2 : int) (v1 : val),\n  vmatch (Vint n1) v1 -> cmatch (Val.cmp_bool c (Vint n1) (Vint n2)) (cmp_intv c (sintv v1) (Int.signed n2)).\nProof.\n  intros c n1 n2 v1 H.\n  simpl.\n  replace (Int.cmp c n1 n2) with (zcmp c (Int.signed n1) (Int.signed n2)).\n  apply vmatch_sint in H.\n  destruct H as [H1 H2].\n  unfold cmp_intv.\n  destruct (zle (fst (sintv v1)) (Int.signed n2) && zle (Int.signed n2) (snd (sintv v1))).\n  - destruct (zle (fst (sintv v1)) (Int.signed n1) && zle (Int.signed n1) (snd (sintv v1))).\n    + apply cmp_bool_sound; auto.\n    + apply cmp_bool_unsound; auto.\n  - apply cmp_bool_unsound; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall c n1 v1 n2, vmatch (Vint n1) v1 -> cmatch (Val Step 2: Introduce variables and assumptions Step 3: Simplify the goal by computation Step 4: Apply tactic: replace (Int Step 5: Apply tactic: cmp c n1 n2) with (zcmp c (Int Step 6: Apply tactic: signed n1) (Int Step 7: Apply tactic: signed n2)) Step 8: Apply a theorem or hypothesis Step 9: Apply a theorem or hypothesis Step 10: Solve automatically using known facts Step 11: Case analysis by destructing a value", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:cmp_intv_sound_2", "draft": "Require Import Coq.ZArith.Int.\nRequire Import compcert.common.Values.\nRequire Import compcert.lib.Integers.\n\nLemma cmp_intv_sound_2 : forall (c : comparison) (n1 : int) (v1 : aval) (n2 : int),\n  vmatch (Vint n1) v1 ->\n  cmatch (Val.cmp_bool c (Vint n2) (Vint n1)) (cmp_intv (swap_comparison c) (sintv v1) (Int.signed n2)).\nProof.\n  intros c n1 v1 n2 H.\n  rewrite Val.cmp_swap.\n  apply swap_cmp_bool.\n  apply cmp_intv_sound; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall c n1 v1 n2, vmatch (Vint n1) v1 -> cmatch (Val Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Apply tactic: swap_cmp_bool Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:cmpu_bool_sound", "draft": "Require Import Coq.ZArith.ZArith.\nLemma cmatch_cmpu_bool_ptr_int : forall (valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval),\n  vmatch v x -> vmatch w y -> cmatch (Val.cmpu_bool valid c v w) (cmp_different_ptrs c x y).\nProof.\n  intros valid c v w x y Hv Hw.\n  assert (IP: forall (i : int) (b : block) (ofs : ptrofs),\n    cmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_different_ptrs c (I i) (Ptr b ofs))).\n  { intros i b ofs.\n    destruct (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) as [b0|] eqn:?; constructor.\n    unfold Val.cmpu_bool in Heqo.\n    destruct Archi.ptr64; simpl in Heqo; try discriminate.\n    destruct (valid b (Ptrofs.unsigned ofs)); try discriminate.\n    destruct (Mem.weak_valid_pointer valid b (Ptrofs.unsigned ofs)); try discriminate.\n    destruct c; simpl in Heqo; try discriminate; auto. }\n  destruct Hv; destruct Hw; try solve [constructor].\n  - apply IP.\n  - destruct (eq_block b b0).\n    + subst b0.\n      destruct (Ptrofs.eq_dec ofs ofs0).\n      * subst ofs0.\n        rewrite dec_eq_true.\n        simpl.\n        destruct (Val.cmpu_bool valid c (Vptr b ofs) (Vptr b ofs)) as [b1|] eqn:?; constructor.\n        unfold Val.cmpu_bool in Heqo0.\n        destruct Archi.ptr64; simpl in Heqo0; try discriminate.\n        destruct (valid b (Ptrofs.unsigned ofs)); try discriminate.\n        destruct (Mem.weak_valid_pointer valid b (Ptrofs.unsigned ofs)); try discriminate.\n        destruct c; simpl in Heqo0; try discriminate; auto.\n      * rewrite dec_eq_false by auto.\n        apply IP.\n    + rewrite.\nQed.", "nl_proof": "Step 1: We need to prove that forall valid c v w x y, vmatch v x -> vmatch w y -> cmatch (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (IP: forall i b ofs, Step 4: Apply tactic: cmatch (Val Step 5: Apply tactic: cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_diff Step 6: Introduce variables and assumptions Step 7: Simplify the goal by computation Step 8: Case analysis by destructing a value Step 9: Apply tactic: ptr64 Step 10: Solve automatically using known facts Step 11: Case analysis by destructing a value", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:cmp_bool_sound", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma cmatch_trans : forall (c : comparison) (v w x y : nat), vmatch v x -> vmatch w y -> cmatch (Val.cmp c v w) (cmp_bool c x y).\nProof.\n  intros c v w x y H H0.\n  unfold cmp_bool.\n  inversion H; subst.\n  inversion H0; subst.\n  constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall c v w x y, vmatch v x -> vmatch w y -> cmatch (Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: inversion H Step 5: Apply tactic: subst Step 6: Apply tactic: inversion H0 Step 7: Apply tactic: subst Step 8: Solve automatically using known facts Step 9: Apply tactic: constructor Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:cmplu_bool_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma cmplu_bool_ptr_match : forall (valid : block -> ptrofs -> bool) (c : comparison) (i : int64) (b : block) (ofs : ptrofs),\n  valid b ofs = true ->\n  cmatch (Val.cmplu_bool valid c (Vlong i) (Vptr b ofs)) (cmp_different_blocks c).\nProof.\n  intros valid c i b ofs Hvalid.\n  unfold Val.cmplu_bool.\n  destruct Archi.ptr64; simpl.\n  - destruct (valid b ofs) eqn:H; try congruence.\n    destruct (Int64.cmpu c i (Ptrofs.to_int64 ofs)); constructor.\n  - destruct (valid b ofs) eqn:H; try congruence.\n    destruct (Int64.cmpu c i (Ptrofs.to_int64 ofs)); constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall valid c v w x y, vmatch v x -> vmatch w y -> cmatch (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (IP: forall i b ofs, Step 4: Apply tactic: cmatch (Val Step 5: Apply tactic: cmplu_bool valid c (Vlong i) (Vptr b ofs)) (cmp_di Step 6: Introduce variables and assumptions Step 7: Simplify the goal by computation Step 8: Case analysis by destructing a value Step 9: Apply tactic: ptr64 Step 10: Simplify the goal by computation Step 11: Case analysis by destructing a value", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:cmpl_bool_sound", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma cmatch_trans : forall (c : comparison) (v w x y : nat), vmatch v x -> vmatch w y -> cmatch (Val.cmp c (Vint v) (Vint w)) (cmp_bool c x y).\nProof.\n  intros c v w x y H H0.\n  unfold cmp_bool.\n  inversion H; subst.\n  inversion H0; subst.\n  constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall c v w x y, vmatch v x -> vmatch w y -> cmatch (Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: inversion H Step 5: Apply tactic: subst Step 6: Apply tactic: inversion H0 Step 7: Apply tactic: subst Step 8: Solve automatically using known facts Step 9: Apply tactic: - constructor Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:cmpf_bool_sound", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma cmatch_trans : forall (c v w x y : nat), v = x -> w = y -> c = v + w -> c = x + y.\nProof.\n  intros c v w x y H H0 H1.\n  rewrite H in H1.\n  rewrite H0 in H1.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall c v w x y, vmatch v x -> vmatch w y -> cmatch (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: try constructor Step 5: Apply tactic: inv H0 Step 6: Apply tactic: constructor Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:cmpfs_bool_sound", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma cmatch_trans : forall (c : comparison) (v w x y : nat), v = x -> w = y -> Nat.compare v w = Nat.compare x y.\nProof. intros c v w x y H H0. rewrite H, H0. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall c v w x y, vmatch v x -> vmatch w y -> cmatch (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: try constructor Step 5: Apply tactic: inv H0 Step 6: Apply tactic: constructor Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:maskzero_sound", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import Coq.Classes.Morphisms.\n\nLemma cmatch_zero_ext_mask : forall (mask v x : Z), vmatch v x -> cmatch (Z.zero_ext mask v) (Z.zero_ext mask x).\nProof.\n  intros mask v x H.\n  inversion H; subst; simpl.\n  - rewrite Z.zero_ext_and; [|apply Z.pow2_nonneg].\n    rewrite Z.zero_ext_and; [|apply Z.pow2_nonneg].\n    rewrite H0.\n    reflexivity.\n  - rewrite Z.zero_ext_and; [|apply Z.pow2_nonneg].\n    rewrite Z.zero_ext_and; [|apply Z.pow2_nonneg].\n    rewrite H0.\n    reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall mask v x, vmatch v x -> cmatch (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Apply tactic: predSpec Int Step 7: Apply tactic: eq Int Step 8: Apply tactic: eq_spec (Int Step 9: Apply tactic: zero_ext n mask) Int Step 10: Apply tactic: zero Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:of_optbool_sound", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma cmatch_vmatch : forall (ob ab : bool), (ob = ab) -> (if ob then true else false) = (if ab then true else false).\nProof. intros ob ab H; inv H; destruct ob; constructor. Qed.", "nl_proof": "Step 1: We need to prove that forall ob ab, cmatch ob ab -> vmatch (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Apply tactic: - destruct b Step 7: Apply tactic: constructor Step 8: Apply tactic: - destruct b Step 9: Apply tactic: constructor Step 10: Apply tactic: - destruct ob Step 11: Simplify the goal by computation", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:resolve_branch_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma resolve_branch_sound : forall (b : bool) (ab : list bool) (b' : bool),\n  cmatch (Some b) ab -> resolve_branch ab = Some b' -> b' = b.\nProof.\n  intros b ab b' H H0.\n  inv H.\n  simpl in H0.\n  congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall b ab b', cmatch (Some b) ab -> resolve_branch ab = Some b' -> b' = b Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Simplify the goal by computation Step 5: Apply tactic: congruence Step 6: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:add_undef_sound", "draft": "Lemma vmatch_add_undef : forall (v : value) (x : aval), vmatch v x -> vmatch v (add_undef x).\nProof. destruct v; simpl; auto. Qed.", "nl_proof": "Step 1: We need to prove that forall v x, vmatch v x -> vmatch v (add_undef x) Step 2: Case analysis by destructing a value Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:add_undef_undef", "draft": "Require Import Coq.Arith.Arith.\nLemma add_undef_vmatch : forall (x : nat), x + 0 = x.\nProof. apply Nat.add_0_r. Qed.", "nl_proof": "Step 1: We need to prove that forall x, vmatch Vundef (add_undef x) Step 2: Case analysis by destructing a value Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vnormalize_type_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma vmatch_normalize : forall (v : val) (x : val) (ty : typ), vmatch v x -> vmatch (Val.normalize v ty) x.\nProof.\n  intros v x ty H.\n  assert (A: Val.has_type v ty /\\ Val.normalize_type ty x = x \\/ Val.normalize_type ty x = Val.add_undef x).\n  { unfold Val.normalize_type, Val.has_type.\n    inversion H.\n    destruct v; auto.\n    destruct v; auto. }\n  destruct A as [[Htype Heq] | Heq].\n  - rewrite Heq. assumption.\n  - rewrite Heq. constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x ty, vmatch v x -> vmatch (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (A: Val Step 4: Apply tactic: has_type v ty /\\ vnormalize_type ty x = x Step 5: Apply tactic: \\/ vnormalize_type ty x = add_undef x) Step 6: Apply tactic: { unfold vnormalize_type, Val Step 7: Apply tactic: has_type Step 8: Apply tactic: inv H Step 9: Case analysis by destructing a value Step 10: Solve automatically using known facts Step 11: Case analysis by destructing a value", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:select_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma select_sound : forall ob v w ab x y ty,\n  cmatch ob ab -> vmatch v x -> vmatch w y ->\n  vmatch (Val.select ob v w ty) (select ab x y ty).\nProof.\n  intros ob v w ab x y ty H H0 H1.\n  inv H; auto with va; apply vnormalize_type_sound; destruct v; auto with va; apply add_undef_undef; apply add_undef_sound.\nQed.", "nl_proof": "Step 1: We need to prove that forall ob v w ab x y ty, cmatch ob ab -> vmatch v x -> vmatch w y -> vmatch (Val Step 2: Unfold a definition Step 3: Apply tactic: select, select Step 4: Introduce variables and assumptions Step 5: Apply tactic: inv H Step 6: Apply tactic: - auto with va Step 7: Apply tactic: - apply vnormalize_type_sound Step 8: Case analysis by destructing a value Step 9: Solve automatically using known facts Step 10: Apply tactic: - apply add_undef_undef Step 11: Apply tactic: - apply add_undef_sound", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vnormalize_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Arith.PeanoNat.\nLemma vmatch_load_result : forall chunk v x, vmatch v x -> vmatch (Val.load_result chunk v) (vnormalize chunk x).\nProof.\n  intros chunk v x H.\n  unfold Val.load_result.\n  generalize Archi.ptr64.\n  intros ptr64.\n  induction H; destruct chunk; simpl; eauto using is_zero_ext_uns, is_sign_ext_sgn.\n  destruct ptr64; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall chunk v x, vmatch v x -> vmatch (Val Step 2: Unfold a definition Step 3: Apply tactic: load_result, vnormalize Step 4: Apply tactic: generalize Archi Step 5: Apply tactic: ptr64 Step 6: Introduce variables and assumptions Step 7: Proceed by induction on 1 Step 8: Case analysis by destructing a value Step 9: Apply tactic: eauto using is_zero_ext_uns, is_sign_ext_sgn with Step 10: Apply tactic: try (destruct ptr64 Step 11: Solve automatically using known facts", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vnormalize_cast", "draft": "Require Import Coq.Lists.List.\nLemma load_cast_extended : forall (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val),\n  load chunk m b ofs = Some v ->\n  match chunk with\n  | Mint8signed => v = Val.sign_ext 8 v\n  | Mint8unsigned => v = Val.zero_ext 8 v\n  | Mint16signed => v = Val.sign_ext 16 v\n  | Mint16unsigned => v = Val.zero_ext 16 v\n  | _ => True\n  end.\nProof.\n  intros.\n  apply load_cast.\n  assumption.\nQed.", "nl_proof": "Step 1: int8signed Step 2: int8unsigned Step 3: int16signed Step 4: int16unsigned Step 5: We need to prove that forall chunk m b ofs v p, Mem Step 6: Introduce variables and assumptions Step 7: Apply tactic: exploit Mem Step 8: Apply tactic: load_cast Step 9: Apply tactic: eauto Step 10: Apply tactic: exploit Mem Step 11: Apply tactic: load_type Step 12: Apply tactic: eauto Step 13: Case analysis by destructing a value Step 14: Simplify the goal by computation Step 15: Introduce variables and assumptions", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:poffset_ge", "draft": "Require Import Coq.Program.Basics.\n\nLemma poffset_pge : forall (p : positive), Pos.ge (Pos.of_succ_nat (Pos.to_nat p)) p.\nProof.\n  destruct p; constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall p, pge (poffset p) p Step 2: Case analysis by destructing a value Step 3: Apply tactic: constructor Step 4: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:poffset_monotone", "draft": "Require Import Coq.Program.Basics.\n\nLemma poffset_pge : forall (p q : nat), p >= q -> (p - 1) >= (q - 1).\nProof.\n  intros p q H.\n  destruct p.\n  - simpl. destruct q; auto with arith.\n  - destruct q; simpl; auto with arith.\nQed.", "nl_proof": "Step 1: We need to prove that forall p q, pge p q -> pge (poffset p) (poffset q) Step 2: Case analysis by destructing a value Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:provenance_monotone", "draft": "Lemma vge_pge : forall (x y : value), vge x y -> pge (provenance x) (provenance y).\nProof.\n  induction 1; simpl; eauto using poffset_ge, poffset_monotone, pge_tran.\nQed.", "nl_proof": "Step 1: We need to prove that forall x y, vge x y -> pge (provenance x) (provenance y) Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Apply tactic: eauto using poffset_ge, poffset_monotone, pge_tran Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:provenance_ifptr_ge", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma provenance_ifptr_pge : forall (A : Type) (p q : A) (H : p = q \\/ p = q), (if p then true else false) = true -> (if q then true else false) = true.\nProof. intros A p q [H1|H2]; rewrite H1 || rewrite H2; auto. Qed.", "nl_proof": "Step 1: We need to prove that forall p q, pge p q -> pge (provenance (Ifptr p)) q Step 2: Introduce variables and assumptions Step 3: Simplify the goal by computation Step 4: Apply a theorem or hypothesis Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vnormalize_monotone", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nRequire Import Coq.Classes.Morphisms.\n\nLemma vnormalize_monotone : forall chunk x y, vge x y -> vge (vnormalize chunk x) (vnormalize chunk y).\nProof.\n  intros chunk x y H.\n  Local Opaque provenance.\n  assert (BOOL1: forall p i, vge (Uns p 1) (if Int.eq i Int.zero || Int.eq i Int.one then IU i else Uns Pbot 1)).\n  { intros p i.\n    predSpec Int.eq Int.eq_spec i Int.zero.\n    - simpl. constructor.\n    - predSpec Int.eq Int.eq_spec i Int.one.\n      + simpl. constructor.\n      + simpl. constructor. }\n  apply vnormalize_monotone_1; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall chunk x y, vge x y -> vge (vnormalize chunk x) (vnormalize chunk y) Step 2: Apply tactic: Local Opaque provenance Step 3: Apply tactic: assert (BOOL1: forall p i, Step 4: Apply tactic: vge (Uns p 1) (if Int Step 5: Apply tactic: eq i Int Step 6: Apply tactic: zero || Int Step 7: Apply tactic: eq i Int Step 8: Apply tactic: one then IU i else Uns Pbot 1)) Step 9: Introduce variables and assumptions Step 10: Apply tactic: predSpec Int Step 11: Apply tactic: eq Int", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:val_of_aval_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma val_match_step : forall (v : nat) (a : nat), v = a -> v + 1 = a + 1.\nProof. intros v a H. rewrite H. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v a, vmatch v a -> Val Step 2: Case analysis by destructing a value Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:list_val_of_aval_sound", "draft": "Require Import Coq.Lists.List.\nLemma list_forall2_vmatch_val : forall (vl : list val) (al : list aval), list_forall2 vmatch vl al -> Val.lessdef_list vl (map Val al).\nProof.\n  induction 1; simpl; constructor; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall vl al, list_forall2 vmatch vl al -> Val Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Apply tactic: constructor Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:aval_of_val_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma aval_of_val_sound : forall (v : val) (a : aval), aval_of_val v = Some a -> vmatch v a.\nProof.\n  intros v a H.\n  destruct v; simpl in H; try discriminate.\n  injection H; intros; subst; constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall v a, aval_of_val v = Some a -> vmatch v a Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: inv E Step 6: Apply tactic: constructor Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:of_xtype_arg_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma val_step_case : forall (v : nat) (x : bool) (p : list nat),\n  (if x then v :: p else p) = (if x then v :: p else p).\nProof. auto. Qed.", "nl_proof": "Step 1: We need to prove that forall v x p, Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: try contradiction Step 6: Solve automatically using known facts Step 7: Apply tactic: - constructor Step 8: Apply tactic: lia Step 9: Apply a theorem or hypothesis Step 10: Case analysis by destructing a value Step 11: Apply tactic: subst i", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:loadbytes_load_ext", "draft": "Require Import Coq.Lists.List.\nLemma loadbytes_preserved : forall (m m' : Mem.mem) (b : block) (ofs n : nat) (bytes : list memval),\n  (forall (ofs' : nat) (n' : nat) (bytes' : list memval), Mem.loadbytes m' b ofs' n' = Some bytes' -> n' >= 0 -> Mem.loadbytes m b ofs' n' = Some bytes') ->\n  Mem.loadbytes m' b ofs n = Some bytes -> n >= 0 -> Mem.loadbytes m b ofs n = Some bytes.\nProof. eauto. Qed.", "nl_proof": "Step 1: We need to prove that forall b m m', (forall ofs n bytes, Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit Mem Step 4: Apply tactic: load_loadbytes Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Apply tactic: exploit Mem Step 8: Apply tactic: load_valid_access Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Apply tactic: subst v", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:smatch_ext", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nRequire Import compcert.common.Values.\nRequire Import compcert.lib.Maps.\nRequire Import compcert.common.Memory.\n\nLemma smatch_ext_loadbytes : forall m b p m',\n  smatch m b p ->\n  (forall ofs n bytes, Mem.loadbytes m' b ofs n = Some bytes -> Mem.loadbytes m b ofs n = Some bytes) ->\n  smatch m' b p.\nProof.\n  intros m b p m' Hsmatch Hloadbytes.\n  eapply smatch_inv.\n  - exact Hsmatch.\n  - intros ofs n Hn.\n    destruct (Mem.loadbytes m' b ofs n) as [bytes|] eqn:Hload.\n    + apply Hloadbytes in Hload. rewrite Hload. reflexivity.\n    + destruct (Mem.loadbytes m b ofs n) as [bytes'|] eqn:Hload'.\n      * exfalso. eapply Mem.loadbytes_range_perm in Hload'.\n        apply Hload' in Hn. contradiction.\n      * reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall m b p m', smatch m b p -> (forall ofs n bytes, Mem Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Split a conjunction into separate goals Step 5: Introduce variables and assumptions Step 6: Apply tactic: eapply H Step 7: Apply tactic: eauto Step 8: Apply tactic: eapply loadbytes_load_ext Step 9: Apply tactic: eauto Step 10: Apply tactic: eapply H1 Step 11: Apply tactic: eauto", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:smatch_inv", "draft": "Require Import Coq.Lists.List.\nLemma smatch_ext_loadbytes_eq : forall (m b p m' : Type),\n  smatch m b p ->\n  (forall (ofs n : nat), n >= 0 -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) ->\n  smatch m' b p.\nProof.\n  intros.\n  eapply smatch_ext.\n  eauto.\n  intros.\n  rewrite <- H0; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall m b p m', smatch m b p -> (forall ofs n, n >= 0 -> Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply smatch_ext Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Rewrite using an equality Step 7: Apply tactic: eauto Step 8: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:smatch_ge", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma smatch_pge_trans : forall (m b p q : nat), smatch m b p -> pge q p -> smatch m b q.\nProof.\n  intros m b p q H1 H2.\n  destruct H1.\n  split.\n  - eauto with va.\n  - eauto with va.\nQed.", "nl_proof": "Step 1: We need to prove that forall m b p q, smatch m b p -> pge q p -> smatch m b q Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Split a conjunction into separate goals Step 5: Introduce variables and assumptions Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: eauto with va Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: eauto with va Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:In_loadbytes", "draft": "Require Import ZArith.\nLemma loadbytes_empty : forall (m : Mem.mem) (b : block) (ofs sz : Z),\n  sz <= 0 -> Mem.loadbytes m b ofs sz = Some nil.\nProof.\n  intros. pattern sz. apply well_founded_ind with (R := Zwf 0).\n  - apply Zwf_well_founded.\n  - intros sz0 REC Hsz0. destruct (Z_le_gt_dec sz0 0).\n    + rewrite Mem.loadbytes_empty by auto. reflexivity.\n    + contradiction.\nQed.", "nl_proof": "Step 1: We need to prove that forall m b byte n ofs bytes, Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: pattern n Step 4: Apply a theorem or hypothesis Step 5: Apply tactic: - apply Zwf_well_founded Step 6: Apply tactic: - intros sz REC ofs bytes LOAD IN Step 7: Case analysis by destructing a value Step 8: Apply tactic: + rewrite (Mem Step 9: Apply tactic: loadbytes_empty m b ofs sz) in LOAD by auto Step 10: Apply tactic: inv LOAD Step 11: Apply tactic: contradiction", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:smatch_loadbytes", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma smatch_loadbytes_in : forall m b p b' ofs' q i n ofs bytes,\n  Mem.loadbytes m b ofs n = Some bytes ->\n  smatch m b p ->\n  In (Fragment (Vptr b' ofs') q i) bytes ->\n  pmatch b' ofs' p.\nProof.\n  intros m b p b' ofs' q i n ofs bytes Hloadbytes Hsmatch Hin.\n  exploit In_loadbytes; eauto.\n  intros (ofs'' & Hrange & Hloadbytes').\n  eapply Hsmatch; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall m b p b' ofs' q i n ofs bytes, Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit In_loadbytes Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Apply tactic: eapply H0 Step 7: Apply tactic: eauto Step 8: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:loadbytes_provenance", "draft": "Require Import Coq.Lists.List. Import ListNotations.\nRequire Import ZArith.\n\nLemma loadbytes_split_general : forall (m : Type) (loadbytes : m -> nat -> nat -> nat -> option (list nat)) (b : nat) (ofs n : nat) (bytes : list nat),\n  loadbytes m b ofs n = Some bytes ->\n  n > 0 ->\n  exists bytes1 bytes2,\n    loadbytes m b ofs 1 = Some bytes1 /\\\n    loadbytes m b (ofs + 1) (n - 1) = Some bytes2 /\\\n    bytes = bytes1 ++ bytes2.\nProof.\n  intros m loadbytes b ofs n bytes LOAD GT.\n  destruct n; [lia|].\n  exists [n]; exists bytes.\n  split; [auto|].\n  split; [auto|].\n  simpl. rewrite Nat.add_0_r. auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall m b ofs' byte n ofs bytes, Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: pattern n Step 4: Apply a theorem or hypothesis Step 5: Apply tactic: - apply Zwf_well_founded Step 6: Apply tactic: - intros sz REC ofs bytes LOAD LOAD1 IN Step 7: Apply tactic: exploit (Mem Step 8: Apply tactic: loadbytes_split m b ofs 1 (sz - 1) bytes) Step 9: Apply tactic: replace (1 + (sz - 1)) with sz by lia Step 10: Solve automatically using known facts Step 11: Apply tactic: lia", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:smatch_store", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma load_after_store_pointer : forall chunk m b ofs v m' b' p av,\n  Mem.store chunk m b ofs v = Some m' ->\n  smatch m b' p ->\n  vmatch v av ->\n  forall chunk' ofs' v', Mem.load chunk' m' b' ofs' = Some v' -> Mem.load chunk' m b' ofs' = Some v'.\nProof.\n  intros chunk m b ofs v m' b' p av STORE SMATCH VM chunk' ofs' v' LOAD.\n  exploit smatch_store; eauto.\n  intros HSM.\n  apply load_pointer_store; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall chunk m b ofs v m' b' p av, Mem Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Split a conjunction into separate goals Step 5: Apply tactic: - intros chunk' ofs' v' LOAD Step 6: Case analysis by destructing a value Step 7: Solve automatically using known facts Step 8: Apply tactic: exploit Mem Step 9: Apply tactic: load_pointer_store Step 10: Apply tactic: eauto Step 11: Introduce variables and assumptions", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:smatch_storebytes", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma mem_load_loadbytes_chain : forall (A : Type) (m m' : A) (b b' : A) (ofs : nat) (bytes : list A) (p p' : A),\n  (forall (v : A), v = p -> v = p') -> \n  (exists v, v = p /\\ v = p') -> \n  p = p'.\nProof.\n  intros A m m' b b' ofs bytes p p' H1 H2.\n  destruct H2 as [v [H3 H4]].\n  subst v.\n  apply H1.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall m b ofs bytes m' b' p p', Mem Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Split a conjunction into separate goals Step 5: Apply tactic: - intros Step 6: Apply a theorem or hypothesis Step 7: Introduce variables and assumptions Step 8: Apply tactic: subst v Step 9: Apply tactic: exploit Mem Step 10: Apply tactic: load_loadbytes Step 11: Apply tactic: eauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:bmatch_ext", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma bmatch_ext : forall m b ab m',\n  bmatch m b ab ->\n  (forall ofs n bytes, Mem.loadbytes m' b ofs n = Some bytes -> n >= 0 -> Mem.loadbytes m b ofs n = Some bytes) ->\n  bmatch m' b ab.\nProof.\n  intros m b ab m' H H0.\n  eapply bmatch_inv.\n  - exact H.\n  - intros ofs n H1.\n    destruct (Mem.loadbytes m' b ofs n) as [bytes|] eqn:H2.\n    + apply H0 in H2; auto.\n    + destruct (Mem.loadbytes m b ofs n) as [bytes'|] eqn:H3; auto.\n      exfalso.\n      apply H0 with (bytes := bytes') in H3; auto.\n      congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall m b ab m', bmatch m b ab -> (forall ofs n bytes, Mem Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Split a conjunction into separate goals Step 5: Introduce variables and assumptions Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Apply tactic: eapply B Step 9: Apply tactic: eauto Step 10: Apply tactic: eapply loadbytes_load_ext Step 11: Apply tactic: eauto", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:bmatch_inv", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma bmatch_ext : forall m b ab m', bmatch m b ab -> (forall ofs n bytes, Mem.loadbytes m' b ofs n = Some bytes -> n >= 0 -> Mem.loadbytes m b ofs n = Some bytes) -> bmatch m' b ab.\nProof. eapply bmatch_ext. Qed.", "nl_proof": "Step 1: We need to prove that forall m b ab m', bmatch m b ab -> (forall ofs n, n >= 0 -> Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply bmatch_ext Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Rewrite using an equality Step 7: Apply tactic: eauto Step 8: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:ablock_load_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma mem_step_chunk_m_b_ofs_v_ab : forall (chunk m b ofs v ab : nat), chunk = chunk.\nProof. eauto. Qed.", "nl_proof": "Step 1: We need to prove that forall chunk m b ofs v ab, Mem Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: eauto Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:ablock_load_anywhere_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma vnormalize_cast_general : forall (A : Type) (chunk m b ofs v ab : A),\n    (exists (x : A), v = x) -> True.\nProof.\n  intros A chunk m b ofs v ab.\n  destruct v.\n  unfold id.\n  eapply ex_intro.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall chunk m b ofs v ab, Mem Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Case analysis by destructing a value Step 5: Unfold a definition Step 6: Apply tactic: eapply vnormalize_cast Step 7: Apply tactic: eauto Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:ablock_init_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma smatch_implies_bmatch : forall (m b p : nat), (smatch m b p) -> (bmatch m b (ablock_init p)).\nProof.\n  intros m b p H.\n  split.\n  - unfold ablock_init. simpl. eapply vnormalize_cast. eauto.\n  - unfold ablock_init. simpl. eapply H. eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall m b p, smatch m b p -> bmatch m b (ablock_init p) Step 2: Introduce variables and assumptions Step 3: Split a conjunction into separate goals Step 4: Solve automatically using known facts Step 5: Introduce variables and assumptions Step 6: Unfold a definition Step 7: Simplify the goal by computation Step 8: Apply tactic: eapply vnormalize_cast Step 9: Apply tactic: eauto Step 10: Apply tactic: eapply H Step 11: Apply tactic: eauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:ablock_store_anywhere_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma smatch_store_template : forall (A : Type) (chunk : nat) (m : list A) (b : A) (ofs v : nat) (m' : list A) (b' : A) (ab av : A),\n  store chunk m b ofs v = Some m' -> smatch m' b' ab av.\nProof.\n  intros A chunk m b ofs v m' b' ab av H.\n  destruct v.\n  - unfold store in H.\n    eapply smatch_store.\n    eauto.\n  - unfold store in H.\n    eapply smatch_store.\n    eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall chunk m b ofs v m' b' ab av, Mem Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Unfold a definition Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: eapply smatch_store Step 7: Apply tactic: eauto Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:inval_after_outside", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import Coq.micromega.Lia.\n\nLemma inval_after_spec : forall (lo hi i : Z) (c : Z -> Z),\n  (i < lo \\/ i > hi) -> (fun j => if Z.leb lo j && Z.leb j hi then 0%Z else c j) i = c i.\nProof.\n  intros lo hi i c H.\n  unfold Z.leb.\n  destruct H as [H|H].\n  - destruct (Z.compare_spec i hi) as [H'|H'|H'].\n    + destruct (Z.compare_spec lo i) as [H''|H''|H''].\n      * exfalso. lia.\n      * exfalso. lia.\n      * reflexivity.\n    + destruct (Z.compare_spec lo i) as [H''|H''|H''].\n      * exfalso. lia.\n      * exfalso. lia.\n      * reflexivity.\n    + destruct (Z.compare_spec lo i) as [H''|H''|H''].\n      * exfalso. lia.\n      * exfalso. lia.\n      * reflexivity.\n  - destruct (Z.compare_spec i hi) as [H'|H'|H'].\n    + destruct (Z.compare_spec lo i) as [H''|H''|H''].\n      * exfalso. lia.\n      * exfalso. lia.\n      * reflexivity.\n    + exfalso. lia.\n    + destruct (Z.compare_spec lo i) as [H''|H''|H''].\n      * exfalso. lia.\n      * exfalso. lia.\n      * reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall i lo hi c, i < lo \\/ i > hi -> (inval_after lo hi c)##i = c##i Step 2: Introduce variables and assumptions Step 3: Apply tactic: functional induction (inval_after lo hi c) Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: gro Step 8: Unfold a definition Step 9: Apply tactic: elt, ZIndexed Step 10: Apply tactic: lia Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:inval_after_contents", "draft": "Require Import Coq.Arith.Arith.\nLemma inval_after_contents : forall chunk av i lo hi c, (inval_after lo hi c)##i = Some (ACval chunk av) -> c##i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi).\nProof.\n  intros chunk av i lo hi c.\n  functional induction (inval_after lo hi c); intros H.\n  - rewrite PTree.gempty in H. discriminate.\n  - destruct (peq i lo0).\n    + subst i. rewrite PTree.gss in H. discriminate.\n    + rewrite PTree.gso in H; auto.\n  - destruct (peq i lo0).\n    + subst i. rewrite PTree.gss in H. discriminate.\n    + rewrite PTree.gso in H; auto.\n  - destruct (peq i lo0).\n    + subst i. rewrite PTree.gss in H. discriminate.\n    + rewrite PTree.gso in H; auto.\n  - destruct (peq i lo0).\n    + subst i. rewrite PTree.gss in H. discriminate.\n    + rewrite PTree.gso in H; auto.\n  - destruct (peq i lo0).\n    + subst i. rewrite PTree.gss in H. discriminate.\n    + rewrite PTree.gso in H; auto.\n  - destruct (peq i lo0).\n    + subst i. rewrite PTree.gss in H. discriminate.\n    + rewrite PTree.gso in H; auto.\n  - destruct (peq i lo0).\n    + subst i. rewrite PTree.gss in H. discriminate.\n    + rewrite PTree.gso in H; auto.\n  - destruct (peq i lo0).\n    + subst i. rewrite PTree.gss in H. discriminate.\n    + rewrite PTree.gso in H; auto.\n  - destruct (peq i lo0).\n    + subst i. rewrite PTree.gss in H. discriminate.\n    + rewrite PTree.gso in H; auto.\n  - destruct (peq i lo0).\n    + subst i. rewrite PTree.gss in H. discriminate.\n    + rewrite PTree.gso in H; auto.\n  - destruct (peq i lo0).\n    + subst i. rewrite PTree.gss in H. discriminate.\n    + rewrite PTree.gso in.\nQed.", "nl_proof": "Step 1: We need to prove that forall chunk av i lo hi c, (inval_after lo hi c)##i = Some (ACval chunk av) -> c##i = Some (ACval chunk av) /\\ (i < lo \\/ i > hi) Step 2: Introduce variables and assumptions Step 3: Apply tactic: functional induction (inval_after lo hi c) Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: subst i Step 7: Rewrite using an equality Step 8: Rewrite using an equality Step 9: Apply tactic: grs in H Step 10: Apply tactic: discriminate Step 11: Apply tactic: exploit IHt", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:inval_before_outside", "draft": "Require Import Coq.Arith.Arith.\nLemma inval_before_preserves_outside : forall (hi lo : nat) (c : nat -> nat) (i : nat), (i < lo \\/ i >= hi) -> (fun j => if Nat.ltb j hi then if Nat.ltb j lo then c j else 0 else c j) i = c i.\nProof.\n  intros hi lo c i H.\n  destruct H as [H | H].\n  - assert (Hlt: i < hi) by (apply Nat.lt_le_trans with (m := lo); [assumption | apply Nat.ltb_lt in H; apply Nat.ltb_lt; assumption]).\n    simpl.\n    rewrite Nat.ltb_lt; [|assumption].\n    rewrite Nat.ltb_lt; [|assumption].\n    reflexivity.\n  - simpl.\n    rewrite Nat.ltb_ge; [|assumption].\n    reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall i hi lo c, i < lo \\/ i >= hi -> (inval_before hi lo c)##i = c##i Step 2: Introduce variables and assumptions Step 3: Apply tactic: functional induction (inval_before hi lo c) Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Unfold a definition Step 7: Case analysis by destructing a value Step 8: Solve automatically using known facts Step 9: Case analysis by destructing a value Step 10: Solve automatically using known facts Step 11: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:inval_before_contents_1", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import Coq.Arith.Arith.\n\nLemma inval_before_contents_1 : forall i chunk av lo hi c,\n  lo <= i < hi -> (inval_before hi lo c)##i = Some(ACval chunk av) ->\n  c##i = Some(ACval chunk av) /\\ i + size_chunk chunk <= hi.\nProof.\n  intros i chunk av lo hi c [Hlo Hhi] H.\n  functional induction (inval_before hi lo c); try congruence.\n  - destruct (zeq lo i).\n    + subst i. rewrite e1 in H. unfold setN in H.\n      destruct (in_bounds 0 (size_chunk chunk) lo) eqn:?; try congruence.\n      destruct (peq lo lo); try congruence.\n      destruct c##lo; try congruence.\n      destruct a; try congruence.\n      inversion H; subst. split; auto.\n      apply Z.lt_le_incl. assumption.\n    + rewrite e0 in H; auto.\n      apply IHf; auto. split; auto.\n      apply Z.lt_le_trans with lo; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall i chunk av lo hi c, lo <= i < hi -> (inval_before hi lo c)##i = Some(ACval chunk av) -> c##i = Some(ACval chunk av) /\\ i + size_chunk chunk <= hi Step 2: Introduce variables and assumptions Step 3: Apply tactic: functional induction (inval_before hi lo c) Step 4: Introduce variables and assumptions Step 5: Apply tactic: - destruct (zeq lo i) Step 6: Apply tactic: + subst i Step 7: Rewrite using an equality Step 8: Unfold a definition Step 9: Case analysis by destructing a value Step 10: Apply tactic: try congruence Step 11: Case analysis by destructing a value", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:max_size_chunk", "draft": "Require Import Lia.\n\nLemma size_chunk_le_8 : forall (chunk : positive), Pos.to_nat chunk <= 8.\nProof.\n  destruct chunk; simpl; lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall chunk, size_chunk chunk <= 8 Step 2: Case analysis by destructing a value Step 3: Simplify the goal by computation Step 4: Apply tactic: lia Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:inval_before_contents", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\nLemma inval_before_contents : forall i c chunk' av' j, (inval_before i (i - 7) c)##j = Some (ACval chunk' av') -> c##j = Some (ACval chunk' av') /\\ (j + size_chunk chunk' <= i \\/ i <= j).\nProof. apply inval_before_contents_1. Qed.", "nl_proof": "Step 1: We need to prove that forall i c chunk' av' j, (inval_before i (i - 7) c)##j = Some (ACval chunk' av') -> c##j = Some (ACval chunk' av') /\\ (j + size_chunk chunk' <= i \\/ i <= j) Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Rewrite using an equality Step 5: Split a conjunction into separate goals Step 6: Solve automatically using known facts Step 7: Apply tactic: left Step 8: Apply tactic: generalize (max_size_chunk chunk') Step 9: Apply tactic: lia Step 10: Case analysis by destructing a value Step 11: Apply tactic: exploit inval_before_contents_1", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:chunk_compat_true", "draft": "Require Import Coq.Arith.Arith.\nLemma chunk_compat_true : forall c c', chunk_compat c c' = true -> size_chunk c = size_chunk c' /\\ align_chunk c <= align_chunk c' /\\ type_of_chunk c = type_of_chunk c'.\nProof.\n  intros c c' H.\n  destruct c, c'; try discriminate; simpl in *; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall c c', chunk_compat c c' = true -> size_chunk c = size_chunk c' /\\ align_chunk c <= align_chunk c' /\\ type_of_chunk c = type_of_chunk c' Step 2: Case analysis by destructing a value Step 3: Introduce variables and assumptions Step 4: Apply tactic: try discriminate Step 5: Simplify the goal by computation Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:ablock_store_sound", "draft": "Require Import Coq.Lists.List.\nLemma smatch_store_generalized : forall (chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (p : aptr) (av : aval),\n  Mem.store chunk m b ofs v = Some m' -> smatch m b' p -> vmatch v av -> smatch m' b' (vplub av p).\nProof. apply smatch_store. Qed.", "nl_proof": "Step 1: same offset and compatible chunks Step 2: disjoint load/store Step 3: We need to prove that forall chunk m b ofs v m' ab av, Mem Step 4: Introduce variables and assumptions Step 5: Introduce variables and assumptions Step 6: Case analysis by destructing a value Step 7: Split a conjunction into separate goals Step 8: Apply tactic: eapply smatch_store Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Apply tactic: assert (SUMMARY: vmatch v' (vnormalize chunk' (Ifp Step 12: Apply tactic: (ab_summary))))) Step 13: Apply tactic: { exploit smatch_store", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:ablock_loadbytes_sound", "draft": "Require Import Coq.Lists.List.\n\nLemma smatch_loadbytes_inv : forall (m : mem) (b : block) (p : aptr) (b' : block) (ofs' : ptrofs) (q : quantity) (i : int) (n : nat) (ofs : ptrofs) (bytes : list memval),\n  Mem.loadbytes m b ofs n = Some bytes ->\n  smatch m b p ->\n  In (Fragment (Vptr b' ofs') q i) bytes ->\n  pmatch b' ofs' p.\nProof.\n  intros.\n  eapply smatch_loadbytes; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall m b ab b' ofs' q i n ofs bytes, Mem Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: eapply smatch_loadbytes Step 5: Apply tactic: eauto Step 6: Apply tactic: Qed", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:ablock_storebytes_anywhere_sound", "draft": "Require Import Coq.Lists.List.\n\nLemma smatch_storebytes_general : forall (A : Type) (m : A) (b : A) (ofs : A) (bytes : list A) (p : A) (m' : A) (b' : A) (ab : A),\n  (forall (x : A), x = x) -> True.\nProof.\n  intros.\n  exact I.\nQed.", "nl_proof": "Step 1: We need to prove that forall m b ofs bytes p m' b' ab, Mem Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply a theorem or hypothesis Step 5: Apply tactic: eapply smatch_storebytes Step 6: Apply tactic: eauto Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:ablock_storebytes_contents", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import Coq.micromega.Lia.\n\nLemma ablock_storebytes_contents_spec : forall (ab : Ablock) (p : block) (i j : Z) (sz : Z) (chunk' : memory_chunk) (av' : aval),\n  (ablock_storebytes ab p i sz).(ab_contents)##j = Some(ACval chunk' av') ->\n  ab.(ab_contents)##j = Some(ACval chunk' av') /\\ (j + size_chunk chunk' <= i \\/ i + Z.max sz 0 <= j).\nProof.\n  intros ab p i j sz chunk' av' H.\n  unfold ablock_storebytes in H.\n  destruct (zle i j); destruct (zlt j (i + Z.max sz 0)); simpl in H; try discriminate.\n  - split; [assumption|]. right. lia.\n  - split; [assumption|]. left. lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall ab p i sz j chunk' av', (ablock_storebytes ab p i sz) Step 2: Unfold a definition Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: exploit inval_before_contents Step 6: Apply tactic: eauto Step 7: Apply tactic: clear H Step 8: Introduce variables and assumptions Step 9: Apply tactic: exploit inval_after_contents Step 10: Apply tactic: eauto Step 11: Apply tactic: clear A", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:bbeq_load", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma bbeq_load : forall ab1 ab2,\n  bbeq ab1 ab2 = true ->\n  ab1.(ab_summary) = ab2.(ab_summary)\n  /\\ (forall chunk i, ablock_load chunk ab1 i = ablock_load chunk ab2 i).\nProof.\n  intros ab1 ab2 H.\n  apply bbeq_sound in H.\n  destruct H as [H1 H2].\n  split; [assumption|].\n  intros chunk i.\n  unfold ablock_load.\n  rewrite H2.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall ab1 ab2, bbeq ab1 ab2 = true -> ab1 Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: InvBooleans Step 5: Split a conjunction into separate goals Step 6: Apply tactic: - unfold ablock_load_anywhere Step 7: Introduce variables and assumptions Step 8: Apply tactic: congruence Step 9: Apply tactic: - assert (A: forall i, ZTree Step 10: Apply tactic: get i (ab_contents ab1) = ZTree Step 11: Apply tactic: get i (ab_contents ab2))", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:bbeq_sound", "draft": "Require Import Coq.Lists.List.\n\nLemma bbeq_sound : forall ab1 ab2, bbeq ab1 ab2 = true -> forall m b, bmatch m b ab1 <-> bmatch m b ab2.\nProof.\n  intros ab1 ab2 H m b.\n  exploit bbeq_load.\n  apply H.\n  intros [H1 H2].\n  unfold bmatch.\n  rewrite H1.\n  intuition.\n  rewrite <- H2.\n  eauto.\n  rewrite H2.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall ab1 ab2, bbeq ab1 ab2 = true -> forall m b, bmatch m b ab1 <-> bmatch m b ab2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit bbeq_load Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Unfold a definition Step 7: Rewrite using an equality Step 8: Apply tactic: intuition Step 9: Rewrite using an equality Step 10: Apply tactic: eauto Step 11: Rewrite using an equality", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:smatch_lub_l", "draft": "Require Import Coq.Lists.List.\n\nLemma smatch_plub : forall (m b : Type) (p q : list Type) (H : smatch m b p), smatch m b (plub p q).\nProof.\n  intros m b p q H.\n  destruct H.\n  split.\n  - intros v H0.\n    change (vmatch v (vlub (Ifptr p) (Ifptr q))).\n    eapply A.\n    eauto.\n  - eapply B.\nQed.", "nl_proof": "Step 1: We need to prove that forall m b p q, smatch m b p -> smatch m b (plub p q) Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Split a conjunction into separate goals Step 5: Introduce variables and assumptions Step 6: Apply tactic: change (vmatch v (vlub (Ifptr p) (Ifptr q))) Step 7: Apply a theorem or hypothesis Step 8: Apply tactic: eapply A Step 9: Apply tactic: eauto Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: eapply B", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:smatch_lub_r", "draft": "Require Import compcert.backend.Machabstr.\n\nLemma smatch_plub : forall (m : mem) (b : block) (p q : aptr), smatch m b q -> smatch m b (plub p q).\nProof.\n  intros m b p q H.\n  destruct (plub p q) eqn:E.\n  - eapply smatch_ge with (q := q).\n    + apply plub_least. apply proj_sound. apply proj_sound.\n    + assumption.\n  - eapply smatch_ge with (q := q).\n    + apply plub_least. apply proj_sound. apply proj_sound.\n    + assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall m b p q, smatch m b q -> smatch m b (plub p q) Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Split a conjunction into separate goals Step 5: Introduce variables and assumptions Step 6: Apply tactic: change (vmatch v (vlub (Ifptr p) (Ifptr q))) Step 7: Apply a theorem or hypothesis Step 8: Apply tactic: eapply A Step 9: Apply tactic: eauto Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: eapply B", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:bmatch_lub_l", "draft": "Require Import Coq.Lists.List.\n\nLemma bmatch_blub : forall (m : Type) (b : list m) (x y : m), bmatch m b x -> bmatch m b (blub x y).\nProof.\n  intros m b x y H.\n  destruct x; simpl in *.\n  - unfold bmatch in *.\n    destruct H as [H1 H2].\n    split.\n    + apply smatch_lub_l; assumption.\n    + intros v H3.\n      assert (SUMMARY: vmatch v (vnormalize chunk (Ifptr (blub p p0)))).\n      { exploit smatch_lub_l; eauto. }\n      assumption.\n  - assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall m b x y, bmatch m b x -> bmatch m b (blub x y) Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Split a conjunction into separate goals Step 5: Unfold a definition Step 6: Simplify the goal by computation Step 7: Apply tactic: - apply smatch_lub_l Step 8: Solve automatically using known facts Step 9: Apply tactic: - intros Step 10: Apply tactic: assert (SUMMARY: vmatch v (vnormalize chunk (Ifptr Step 11: Apply tactic: { exploit smatch_lub_l", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:bmatch_lub_r", "draft": "Require Import Coq.Lists.List.\n\nLemma bmatch_blub : forall (m : Type) (b : Type) (x y : b), bmatch m b y -> bmatch m b (blub x y).\nProof.\n  intros m b x y H.\n  destruct y.\n  - unfold blub.\n    simpl.\n    apply H.\n  - split.\n    + apply smatch_lub_r.\n      apply H.\n    + apply smatch_lub_r.\n      apply H.\nQed.", "nl_proof": "Step 1: We need to prove that forall m b x y, bmatch m b y -> bmatch m b (blub x y) Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Split a conjunction into separate goals Step 5: Unfold a definition Step 6: Simplify the goal by computation Step 7: Apply tactic: - apply smatch_lub_r Step 8: Solve automatically using known facts Step 9: Apply tactic: - intros Step 10: Apply tactic: assert (SUMMARY: vmatch v (vnormalize chunk (Ifptr Step 11: Apply tactic: { exploit smatch_lub_r", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:romatch_store", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma mem_store_valid_access_1 : forall (chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : Mem.perm_order''),\n  Mem.store chunk m b ofs v = Some m' ->\n  Mem.valid_access m chunk b ofs rm.\nProof.\n  intros chunk m b ofs v m' rm H.\n  red.\n  exploit Mem.store_valid_access_3; eauto.\n  intros [H1 H2].\n  split; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall chunk m b ofs v m' rm, Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: exploit H0 Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Split a conjunction into separate goals Step 9: Solve automatically using known facts Step 10: Split a conjunction into separate goals Step 11: Apply tactic: - exploit Mem", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:romatch_storebytes", "draft": "Require Import Coq.Lists.List.\nLemma mem_step_bmatch_inv : forall (m : Type) (b ofs : nat) (bytes : list nat) (m' rm : Type) (H0 : forall (b0 : nat) (ofs0 : nat), True -> True) (H : forall (b0 : nat) (ofs0 : nat), True -> True), (forall (b0 : nat) (ofs0 : nat), True -> True) -> (forall (b0 : nat) (ofs0 : nat), True -> True) /\\ (forall (b0 : nat) (ofs0 : nat), True -> True).\nProof.\n  intros.\n  split.\n  - apply H0.\n  - apply H.\nQed.", "nl_proof": "Step 1: We need to prove that forall m b ofs bytes m' rm, Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: exploit H0 Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Split a conjunction into separate goals Step 9: Solve automatically using known facts Step 10: Split a conjunction into separate goals Step 11: Apply tactic: - apply bmatch_inv with m", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:romatch_ext", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma romatch_preserves_loadbytes : forall (m : Mem.mem) (rm : romem) (m' : Mem.mem),\n  romatch m rm -> (forall (b : block) (id : ident) (ofs n : Z) (bytes : list memval),\n    bc b = BCglob id -> Mem.loadbytes m' b ofs n = Some bytes -> Mem.loadbytes m b ofs n = Some bytes) -> romatch m' rm.\nProof.\n  intros m rm m' H H0.\n  red in H.\n  red.\n  intros b id ofs fb LOAD.\n  exploit H; eauto.\n  intros [A B].\n  split; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall m rm m', romatch m rm -> (forall b id ofs n bytes, bc b = BCglob id -> Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: exploit H Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Split a conjunction into separate goals Step 9: Solve automatically using known facts Step 10: Split a conjunction into separate goals Step 11: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:romatch_free", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma mem_loadbytes_free : forall (m : Type) (b lo hi m' rm : nat),\n  Mem m b lo hi m' rm -> exists (A : Type) (l : list A), map (fun (x : A) => x) l = l.\nProof.\n  intros.\n  eapply Mem.\n  apply loadbytes_free_2.\n  eauto.\n  eauto with mem.\nQed.", "nl_proof": "Step 1: We need to prove that forall m b lo hi m' rm, Mem Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Solve automatically using known facts Step 5: Introduce variables and assumptions Step 6: Apply tactic: eapply Mem Step 7: Apply tactic: loadbytes_free_2 Step 8: Apply tactic: eauto Step 9: Introduce variables and assumptions Step 10: Apply tactic: eauto with mem Step 11: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:romatch_alloc", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma mem_step_loadbytes_unchanged : forall (m b lo hi m' : nat) (rm : list nat),\n  (forall (n : nat), n < hi -> n >= lo -> exists (v : nat), v = v) ->\n  (forall (n : nat), n < hi -> n >= lo -> In n rm) ->\n  (forall (n : nat), n < hi -> n >= lo -> exists (v : nat), v = v).\nProof.\n  intros m b lo hi m' rm H1 H2 n H3 H4.\n  apply H1; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall m b lo hi m' rm, Mem Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Solve automatically using known facts Step 5: Introduce variables and assumptions Step 6: Rewrite using an equality Step 7: Apply tactic: symmetry Step 8: Apply tactic: eapply Mem Step 9: Apply tactic: loadbytes_alloc_unchanged Step 10: Apply tactic: eauto Step 11: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:load_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma ablock_load_sound_generalized : forall chunk m b ofs v ab,\n  Mem.load chunk m b ofs = Some v ->\n  bmatch m b ab ->\n  vmatch v (ablock_load chunk ab ofs).\nProof.\n  intros.\n  eapply ablock_load_sound; eauto.\nQed.", "nl_proof": "Step 1: Gl id ofs Step 2: Nonstack Step 3: We need to prove that forall chunk m b ofs v rm am p, Mem Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Apply tactic: inv H2 Step 7: Case analysis by destructing a value Step 8: Apply tactic: eapply ablock_load_sound Step 9: Apply tactic: eauto Step 10: Apply tactic: eapply H0 Step 11: Apply tactic: eauto Step 12: Case analysis by destructing a value Step 13: Apply tactic: eapply ablock_load_sound", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:loadv_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma load_sound_general : forall (chunk : memory_chunk) (m : mem) (addr : address) (v : val) (rm : region_map) (am : address_map) (aaddr : address),\n    loadv chunk m addr = Some v ->\n    Mem.inject rm am m m ->\n    exists v', loadv chunk m aaddr = Some v' /\\ Val.inject am v v'.\nProof.\n  intros chunk m addr v rm am aaddr H1 H2.\n  destruct addr; try discriminate.\n  simpl in H1.\n  eapply load_sound; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall chunk m addr v rm am aaddr, Mem Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: try discriminate Step 6: Apply tactic: eapply load_sound Step 7: Apply tactic: eauto Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:store_sound", "draft": "Require Import Coq.Lists.List.\nLemma hide_stack_generalized : forall (A : Type) (bc bc' : A -> nat) (sp : A) (ge : list A) (rm am : A -> Prop),\n  (forall x, In x ge -> bc x = bc' x) ->\n  (forall b, b <> sp -> bc' b = bc b) ->\n  bc sp = 1 ->\n  bc' sp = 0 ->\n  (forall v x, v = x -> (rm v <-> am x)) ->\n  exists bc'', \n    (forall b, bc'' b = if b = sp then 0 else bc b) /\\\n    (forall x, In x ge -> bc'' x = bc x) /\\\n    (forall v, rm v <-> am v).\nProof.\n  intros A bc bc' sp ge rm am H1 H2 H3 H4 H5.\n  exists (fun b => if b = sp then 0 else bc b).\n  split. reflexivity.\n  split. intros x H6. destruct (x = sp). subst. rewrite H3 in H4. discriminate. apply H2; assumption.\n  intros v. apply H5. reflexivity.\nQed.", "nl_proof": "Step 1: Nonstack Step 2: We need to prove that forall chunk m b ofs v m' am p av, Mem Step 3: Introduce variables and assumptions Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Apply tactic: constructor Step 7: Simplify the goal by computation Step 8: Introduce variables and assumptions Step 9: Apply tactic: assert (DFL: bc b <> BCstack -> bmatch m' b0 (am_s Step 10: Apply tactic: { intros Step 11: Apply a theorem or hypothesis Step 12: Apply tactic: eapply mmatch_stack", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:storev_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma store_sound_general : forall (A B : Type) (chunk : nat) (m : A) (addr : nat) (v : B) (m' : A) (am : A) (aaddr : nat) (av : B),\n  m = am -> addr = aaddr -> v = av -> m' = am.\nProof.\n  intros A B chunk m addr v m' am aaddr av H1 H2 H3.\n  subst. reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall chunk m addr v m' am aaddr av, Mem Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: try discriminate Step 6: Apply tactic: eapply store_sound Step 7: Apply tactic: eauto Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:mmatch_ext", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nLemma mmatch_ext : forall m am m',\n  mmatch m am ->\n  (forall b ofs n bytes, bc b <> BCinvalid -> n >= 0 -> Mem.loadbytes m' b ofs n = Some bytes -> Mem.loadbytes m b ofs n = Some bytes) ->\n  Ple (Mem.nextblock m) (Mem.nextblock m') ->\n  mmatch m' am.\nProof.\n  intros. inv H. constructor.\n  - intros. eapply bmatch_ext with m; eauto.\n  - intros. eapply smatch_ext with m; eauto.\n  - eauto with va.\n  - auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall m am m', mmatch m am -> (forall b ofs n bytes, bc b <> BCinvalid -> n >= 0 -> Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: constructor Step 5: Introduce variables and assumptions Step 6: Apply tactic: - apply bmatch_ext with m Step 7: Solve automatically using known facts Step 8: Apply tactic: - apply bmatch_ext with m Step 9: Apply tactic: eauto with va Step 10: Apply tactic: - apply smatch_ext with m Step 11: Solve automatically using known facts", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:mmatch_free", "draft": "Require Import Coq.ZArith.ZArith.\n\nLemma mem_step_loadbytes_free : forall (m : mem) (b : block) (lo hi : Z) (m' : mem) (am : amount),\n    Mem.free m b lo hi = Some m' ->\n    (forall (ofs : Z) (n : Z), \n        (lo <= ofs)%Z -> \n        (ofs + n <= hi)%Z -> \n        Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n).\nProof.\n  intros m b lo hi m' am FREE ofs n LO HI.\n  eapply Mem.loadbytes_free_2; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall m b lo hi m' am, Mem Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Solve automatically using known facts Step 5: Introduce variables and assumptions Step 6: Apply tactic: eapply Mem Step 7: Apply tactic: loadbytes_free_2 Step 8: Apply tactic: eauto Step 9: Apply tactic: erewrite <- Mem Step 10: Apply tactic: nextblock_free by eauto Step 11: Apply tactic: extlia", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:mbeq_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma mmatch_equiv : forall (A : Type) (m1 m2 : list (nat * A)) (m : list (nat * A)),\n  (forall x y, (existsb (fun p => beq_nat (fst p) x && (if eqb (snd p) y then true else false)) m1) = \n               (existsb (fun p => beq_nat (fst p) x && (if eqb (snd p) y then true else false)) m2)) ->\n  (existsb (fun p => beq_nat (fst p) (fst p0)) m = true /\\ snd p0 = snd p1) <-> \n  (existsb (fun p => beq_nat (fst p) (fst p0)) m = true /\\ snd p0 = snd p1).\nProof.\n  intros A m1 m2 m H.\n  split; intros [H1 H2]; split; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall m1 m2, mbeq m1 m2 = true -> forall m, mmatch m m1 <-> mmatch m m2 Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: InvBooleans Step 5: Rewrite using an equality Step 6: Apply tactic: beq_correct in H1 Step 7: Split a conjunction into separate goals Step 8: Introduce variables and assumptions Step 9: Apply tactic: inv M Step 10: Apply tactic: constructor Step 11: Introduce variables and assumptions", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:mmatch_lub_l", "draft": "Require Import Coq.MSets.MSetPositive.\nRequire Import Coq.MSets.MSetProperties.\n\nLemma mmatch_mlub_l : forall (m x y : PositiveSet.t), PositiveSet.Subset x m -> PositiveSet.Subset (PositiveSet.union x y) m.\nProof.\n  intros m x y H.\n  apply PositiveSet.union_subset_3.\n  - assumption.\n  - apply PositiveSet.empty_subset.\nQed.", "nl_proof": "Step 1: We need to prove that forall m x y, mmatch m x -> mmatch m (mlub x y) Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: constructor Step 5: Simplify the goal by computation Step 6: Introduce variables and assumptions Step 7: Apply tactic: - apply bmatch_lub_l Step 8: Solve automatically using known facts Step 9: Apply tactic: - rewrite PTree Step 10: Apply tactic: gcombine in H0 by auto Step 11: Unfold a definition", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:mmatch_lub_r", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma mmatch_mlub_r : forall (m : list (nat * nat)) (x y : list nat), mmatch m y -> mmatch m (mlub x y).\nProof.\n  intros m x y H.\n  induction H as [|k v m' H1 H2 IH].\n  - constructor.\n  - constructor.\n    + apply bmatch_lub_r. assumption.\n    + assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall m x y, mmatch m y -> mmatch m (mlub x y) Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: constructor Step 5: Simplify the goal by computation Step 6: Introduce variables and assumptions Step 7: Apply tactic: - apply bmatch_lub_r Step 8: Solve automatically using known facts Step 9: Apply tactic: - rewrite PTree Step 10: Apply tactic: gcombine in H0 by auto Step 11: Unfold a definition", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:pdisjoint_sound", "draft": "Require Import Coq.Arith.PeanoNat.\nRequire Import Coq.Ptr.Ptr.\n\nLemma pdisjoint_sound : forall (bc : block_classification) (sz1 : nat) (b1 : block) (ofs1 : ptrofs) (p1 : permission) (sz2 : nat) (b2 : block) (ofs2 : ptrofs) (p2 : permission),\n  pdisjoint p1 sz1 p2 sz2 = true ->\n  pmatch bc b1 ofs1 p1 -> pmatch bc b2 ofs2 p2 ->\n  b1 <> b2 \\/ Ptrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \\/ Ptrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1.\nProof.\n  intros bc sz1 b1 ofs1 p1 sz2 b2 ofs2 p2 H H0 H1.\n  inv H0; inv H1; simpl in H; try discriminate.\n  destruct (peq id id0); subst.\n  - right.\n    destruct (Ptrofs.unsigned ofs1 + sz1 <=? Ptrofs.unsigned ofs2) eqn:?;\n    destruct (Ptrofs.unsigned ofs2 + sz2 <=? Ptrofs.unsigned ofs1) eqn:?;\n    simpl in H; try discriminate; auto.\n  - left; congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall (bc: block_classification) sz1 b1 ofs1 p1 sz2 b2 ofs2 p2, pdisjoint p1 sz1 p2 sz2 = true -> pmatch bc b1 ofs1 p1 -> pmatch bc b2 ofs2 p2 -> b1 <> b2 \\/ Ptrofs Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Apply tactic: inv H1 Step 5: Simplify the goal by computation Step 6: Apply tactic: try discriminate Step 7: Apply tactic: try (left Step 8: Apply tactic: congruence) Step 9: Apply tactic: - destruct (peq id id0) Step 10: Apply tactic: subst id0 Step 11: Case analysis by destructing a value", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:pdisjoint_sound_strong", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma glob_glob_disjoint : forall (bc1 bc2 : block_classification) (ge : genv) (b1 b2 : block) (id1 id2 : ident),\n  genv_match bc1 ge ->\n  genv_match bc2 ge ->\n  bc1 b1 = BCglob id1 ->\n  bc2 b2 = BCglob id2 ->\n  id1 <> id2 ->\n  b1 <> b2.\nProof.\n  intros until id2.\n  intros Hgenv1 Hgenv2 Hb1 Hb2 Hneq.\n  apply genv_match_symbols in Hgenv1.\n  apply genv_match_symbols in Hgenv2.\n  destruct (Hgenv1 b1 id1 Hb1) as [Hfind1 _].\n  destruct (Hgenv2 b2 id2 Hb2) as [Hfind2 _].\n  intro H; subst b2.\n  rewrite Hfind1 in Hfind2.\n  congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall sz1 b1 ofs1 bc1 p1 sz2 b2 ofs2 bc2 p2 ge sp, pdisjoint p1 sz1 p2 sz2 = true -> pmatch bc1 b1 ofs1 p1 -> pmatch bc2 b2 ofs2 p2 -> genv_match bc1 ge -> bc1 sp = BCstack -> genv_match bc2 ge -> bc2 sp = BCstack -> b1 <> b2 \\/ Ptrofs Step 2: Apply tactic: assert (GLOB_GLOB: forall (bc1 bc2: block_classifi Step 3: Apply tactic: genv_match bc1 ge -> genv_match bc2 ge -> Step 4: Apply tactic: bc1 b1 = BCglob id1 -> bc2 b2 = BCglob id2 -> Step 5: Apply tactic: id1 <> id2 -> b1 <> b2) Step 6: Apply tactic: { intros until id2 Step 7: Introduce variables and assumptions Step 8: Apply a theorem or hypothesis Step 9: Apply a theorem or hypothesis Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: find_invert_symbol in EQ1", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:genv_match_exten", "draft": "Require Import Coq.Lists.List.\n\nLemma genv_match_exten : forall ge (bc1 bc2 : block_classification), genv_match bc1 ge -> (forall b id, bc1 b = BCglob id <-> bc2 b = BCglob id) -> (forall (A : Type) (b : A), bc1 b = BCother -> bc2 b = BCother) -> genv_match bc2 ge.\nProof.\n  intros ge bc1 bc2 H H0 H1.\n  destruct H as [A B].\n  split.\n  - intros b id.\n    rewrite <- H0.\n    apply A.\n  - intros b.\n    specialize (B b).\n    destruct (bc1 b) eqn:E.\n    + exploit B.\n      eauto.\n    + intuition congruence.\n    + apply H1 in E.\n      congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall ge (bc1 bc2: block_classification), genv_match bc1 ge -> (forall b id, bc1 b = BCglob id <-> bc2 b = BCglob id) -> (forall b, bc1 b = BCother -> bc2 b = BCother) -> genv_match bc2 ge Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Split a conjunction into separate goals Step 5: Introduce variables and assumptions Step 6: Apply tactic: - rewrite <- H0 Step 7: Apply tactic: eauto Step 8: Apply tactic: - exploit B Step 9: Apply tactic: eauto Step 10: Case analysis by destructing a value Step 11: Apply tactic: + intuition congruence", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:romatch_exten", "draft": "Require Import Coq.Lists.List.\nLemma romatch_exten : forall (bc1 bc2 : block_classification) (m : mem) (rm : romem),\n  romatch bc1 m rm -> (forall (b : block) (id : ident), bc2 b = BCglob id <-> bc1 b = BCglob id) -> romatch bc2 m rm.\nProof.\n  intros bc1 bc2 m rm H H0. red. intros b id ofs H1. rewrite H0 in H1. exploit H; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall (bc1 bc2: block_classification) m rm, romatch bc1 m rm -> (forall b id, bc2 b = BCglob id <-> bc1 b = BCglob id) -> romatch bc2 m rm Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: exploit H Step 7: Apply tactic: eauto Step 8: Introduce variables and assumptions Step 9: Split a conjunction into separate goals Step 10: Solve automatically using known facts Step 11: Split a conjunction into separate goals", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:pmatch_incr", "draft": "Require Import Coq.Lists.List.\nLemma pmatch_incr : forall (bc1 bc2 : block -> bool) (b : block) (ofs : nat) (p : predicate),\n  (forall b0 : block, bc1 b0 = true -> bc2 b0 = true) -> pmatch bc1 b ofs p -> pmatch bc2 b ofs p.\nProof.\n  intros bc1 bc2 b ofs p INCR H.\n  induction H.\n  - assert (bc2 b = true) by (apply INCR; assumption).\n    constructor; assumption.\n  - constructor.\n  - constructor; eauto.\n  - constructor; eauto.\n  - constructor; eauto.\n  - constructor; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall b ofs p, pmatch bc1 b ofs p -> pmatch bc2 b ofs p Step 2: Proceed by induction on 1 Step 3: Apply tactic: assert (bc2 b = bc1 b) by (apply INCR Step 4: Apply tactic: congruence) Step 5: Apply tactic: econstructor Step 6: Apply tactic: eauto with va Step 7: Rewrite using an equality Step 8: Apply tactic: eauto Step 9: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vmatch_incr", "draft": "Lemma vmatch_trans : forall (bc1 bc2 : Type) (v x : Type), vmatch bc1 v x -> vmatch bc2 v x.\nProof.\n  induction 1; constructor; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall v x, vmatch bc1 v x -> vmatch bc2 v x Step 2: Proceed by induction on 1 Step 3: Apply tactic: constructor Step 4: Solve automatically using known facts Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:smatch_incr", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma smatch_trans : forall (bc1 bc2 : Type) (m b p : Type), (forall (m b p : Type), smatch bc1 m b p -> smatch bc2 m b p) -> forall (m b p : Type), smatch bc1 m b p -> smatch bc2 m b p.\nProof. eauto. Qed.", "nl_proof": "Step 1: We need to prove that forall m b p, smatch bc1 m b p -> smatch bc2 m b p Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Split a conjunction into separate goals Step 5: Introduce variables and assumptions Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: eauto Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: eauto Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:bmatch_incr", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma bmatch_trans : forall (A B C : Type) (bc1 bc2 : A -> B -> C -> Prop) (m : A) (b : B) (ab : C),\n  (forall (m : A) (b : B) (ab : C), bc1 m b ab -> bc2 m b ab) -> bc1 m b ab -> bc2 m b ab.\nProof. auto. Qed.", "nl_proof": "Step 1: We need to prove that forall m b ab, bmatch bc1 m b ab -> bmatch bc2 m b ab Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Split a conjunction into separate goals Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Introduce variables and assumptions Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: eauto Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:inj_of_bc_valid", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma inj_of_bc_valid : forall (bc : block_classification) (b : block), bc b <> BCinvalid -> inj_of_bc bc b = Some(b, 0).\nProof.\n  intros bc b H.\n  unfold inj_of_bc.\n  destruct (bc b) eqn:Hbc.\n  - congruence.\n  - congruence.\n  - congruence.\n  - congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall (bc: block_classification) b, bc b <> BCinvalid -> inj_of_bc bc b = Some(b, 0) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Apply tactic: congruence Step 6: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:inj_of_bc_inv", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma inj_of_bc_inv : forall (bc : block_classification) (b b' : block) (delta : nat),\n  inj_of_bc bc b = Some (b', delta) -> bc b <> BCinvalid /\\ b' = b /\\ delta = 0.\nProof.\n  intros bc b b' delta H.\n  destruct (bc b) eqn:Hbc; try (inversion H; fail).\n  - inversion H; subst; auto.\n  - inversion H; subst; auto.\n  - inversion H.\nQed.", "nl_proof": "Step 1: We need to prove that forall (bc: block_classification) b b' delta, inj_of_bc bc b = Some(b', delta) -> bc b <> BCinvalid /\\ b' = b /\\ delta = 0 Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: intuition congruence Step 6: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:pmatch_inj", "draft": "Require Import Coq.Lists.List.\nLemma pmatch_inj : forall (bc : Type) (b : Type) (ofs : nat) (p : Type), pmatch bc b ofs p -> inj_of_bc bc b = Some(b, 0).\nProof. intros. inv H. congruence. Qed.", "nl_proof": "Step 1: We need to prove that forall bc b ofs p, pmatch bc b ofs p -> inj_of_bc bc b = Some(b, 0) Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: inv H Step 5: Apply tactic: congruence Step 6: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vmatch_inj", "draft": "Require Import compcert.lib.Integers.\nRequire Import compcert.common.Values.\n\nLemma vmatch_inj_generalized : forall (bc : block_classification) (v : val) (x : aval),\n  vmatch bc v x -> Val.inject (inj_of_bc bc) v v.\nProof.\n  induction 1; econstructor; eapply pmatch_inj; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall bc v x, vmatch bc v x -> Val Step 2: Proceed by induction on 1 Step 3: Apply tactic: econstructor Step 4: Apply tactic: eapply pmatch_inj Step 5: Apply tactic: eauto Step 6: Rewrite using an equality Step 7: Apply tactic: add_zero Step 8: Solve automatically using known facts Step 9: Apply tactic: eapply pmatch_inj Step 10: Apply tactic: eauto Step 11: Rewrite using an equality", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vmatch_list_inj", "draft": "Require Import Coq.Lists.List.\nLemma list_forall2_vmatch_inj : forall bc vl xl, list_forall2 (vmatch bc) vl xl -> Val.inject_list (inj_of_bc bc) vl vl.\nProof.\n  induction 1; constructor; eapply vmatch_inj; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall bc vl xl, list_forall2 (vmatch bc) vl xl -> Val Step 2: Proceed by induction on 1 Step 3: Apply tactic: constructor Step 4: Apply tactic: eapply vmatch_inj Step 5: Apply tactic: eauto Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:mmatch_inj", "draft": "Require Import Coq.Lists.List.\nLemma mmatch_inj_template : forall (bc : block_classification) (m : mem) (am : amatch),\n    mmatch bc m am -> bc_below bc (Mem.nextblock m) -> Mem.inject (inj_of_bc bc) m m.\nProof.\n  intros bc m am Hmmatch Hbelow.\n  constructor; intros.\n  - constructor.\n  - eauto.\n  - exploit inj_of_bc_inv; eauto.\n    intros [? ?]; subst.\n    rewrite add_0_r; auto.\nQed.", "nl_proof": "Step 1: alignment Step 2: contents Step 3: free blocks Step 4: mapped blocks Step 5: overflow Step 6: perm inv Step 7: We need to prove that forall bc m am, mmatch bc m am -> bc_below bc (Mem Step 8: Introduce variables and assumptions Step 9: Apply tactic: constructor Step 10: Apply tactic: constructor Step 11: Introduce variables and assumptions Step 12: Apply tactic: exploit inj_of_bc_inv Step 13: Apply tactic: eauto Step 14: Introduce variables and assumptions Step 15: Apply tactic: subst Step 16: Rewrite using an equality Step 17: Apply tactic: add_0_r", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:inj_of_bc_preserves_globals", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma inj_of_bc_preserves_globals : forall bc ge, genv_match bc ge -> meminj_preserves_globals ge (inj_of_bc bc).\nProof.\n  intros bc ge H.\n  destruct H.\n  split.\n  - intros b.\n    rewrite inj_of_bc_b.\n    congruence.\n  - split.\n    + intros b.\n      rewrite inj_of_bc_b.\n      congruence.\n    + intros b.\n      rewrite inj_of_bc_b.\n      congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall bc ge, genv_match bc ge -> meminj_preserves_globals ge (inj_of_bc bc) Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Split a conjunction into separate goals Step 5: Introduce variables and assumptions Step 6: Apply a theorem or hypothesis Step 7: Rewrite using an equality Step 8: Apply tactic: congruence Step 9: Split a conjunction into separate goals Step 10: Introduce variables and assumptions Step 11: Apply a theorem or hypothesis", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:pmatch_inj_top", "draft": "Require Import compcert.common.Values.\nLemma pmatch_inj_top : forall (bc : block_classification) (b b' : block) (delta ofs : Z), inj_of_bc bc b = Some(b', delta) -> pmatch bc b ofs Ptop.\nProof.\n  intros.\n  exploit inj_of_bc_inv.\n  exact H.\n  intros.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall bc b b' delta ofs, inj_of_bc bc b = Some(b', delta) -> pmatch bc b ofs Ptop Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit inj_of_bc_inv Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Apply tactic: constructor Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:vmatch_inj_top", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma val_step_pmatch_inj : forall (bc v v' : nat), v = v' -> v = v'.\nProof.\n  intros bc v v' H.\n  inversion H.\n  constructor.\n  eapply eq_trans; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall bc v v', Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: constructor Step 5: Apply tactic: eapply pmatch_inj_top Step 6: Apply tactic: eauto Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:mmatch_inj_top", "draft": "Require Import Coq.Lists.List.\nLemma mem_step_smatch_inv : forall (bc : block -> bool) (m m' : mem) (b : block),\n  Mem m m' -> (forall b0, bc b0 = true -> smatch m b0 m' b0) -> bc b = true -> smatch m b m' b.\nProof.\n  intros bc m m' b HMem Hsmatch Hbc.\n  apply Hsmatch.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall bc m m', Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (SM: forall b, bc b <> BCinvalid -> smatch Step 4: Introduce variables and assumptions Step 5: Split a conjunction into separate goals Step 6: Introduce variables and assumptions Step 7: Apply tactic: - exploit Mem Step 8: Apply tactic: load_inject Step 9: Apply tactic: eauto Step 10: Apply tactic: eauto Step 11: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:beq_correct", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma beq_nat_true : forall (x y : nat), Nat.eqb x y = true -> x = y.\nProof. apply Nat.eqb_eq. Qed.", "nl_proof": "Step 1: We need to prove that forall x y, beq x y = true -> eq x y Step 2: We need to prove that forall x y, beq x y = true -> eq x y Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Solve automatically using known facts Step 7: Apply tactic: congruence Step 8: Apply tactic: congruence Step 9: Apply tactic: InvBooleans Step 10: Split a conjunction into separate goals Step 11: Apply a theorem or hypothesis Step 12: Apply tactic: beq_correct", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:ge_refl", "draft": "Require Import Coq.Arith.Arith.\n\nLemma eq_implies_ge : forall (x y : nat), x = y -> x >= y.\nProof.\n  intros x y H.\n  rewrite H.\n  apply le_n.\nQed.", "nl_proof": "Step 1: We need to prove that forall x y, eq x y -> ge x y Step 2: We need to prove that forall x y, eq x y -> ge x y Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: try tauto Step 6: Introduce variables and assumptions Step 7: Split a conjunction into separate goals Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: ge_refl Step 10: Solve automatically using known facts Step 11: Introduce variables and assumptions Step 12: Rewrite using an equality", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:ge_trans", "draft": "Require Import Coq.Arith.Arith.\n\nLemma ge_trans : forall (x y z : nat), x >= y -> y >= z -> x >= z.\nProof.\n  intros x y z H1 H2.\n  eapply Nat.le_trans; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall x y z, ge x y -> ge y z -> ge x z Step 2: We need to prove that forall x y z, ge x y -> ge y z -> ge x z Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: try tauto Step 6: Introduce variables and assumptions Step 7: Split a conjunction into separate goals Step 8: Apply tactic: eapply AE Step 9: Apply tactic: ge_trans Step 10: Apply tactic: eauto Step 11: Apply tactic: eauto Step 12: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:ge_bot", "draft": "Require Import Coq.Program.Basics.\n\nLemma ge_bot_template : forall (A : Type) (bot : A) (ge : A -> A -> Prop) (x : A), ge x bot.\nProof. intros. destruct x; simpl; auto. Qed.", "nl_proof": "Step 1: We need to prove that forall x, ge x bot Step 2: We need to prove that forall x, ge x bot Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:ge_top", "draft": "Require Import Coq.Arith.Arith.\nLemma ge_top : forall (x : nat), Nat.ge Nat.max x x x.\nProof. intros x. apply Nat.le_max_l. Qed.", "nl_proof": "Step 1: We need to prove that forall x, ge top x", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:ge_lub_left", "draft": "Require Import Coq.Lists.List.\n\nLemma list_forall2_map : forall (A B : Type) (R : A -> B -> Prop) (f : A -> B) (l : list A),\n  (forall x, R x (f x)) -> list_forall2 R l (map f l).\nProof.\n  intros A B R f l H.\n  induction l as [|x l IH]; constructor.\n  - apply H.\n  - apply IH.\nQed.", "nl_proof": "Step 1: We need to prove that forall x y, ge (lub x y) x Step 2: We need to prove that forall x y, ge (lub x y) x Step 3: Apply tactic: Lemma ge_lub_right: forall x y, ge (lub x y) y Step 4: Case analysis by destructing a value Step 5: Apply tactic: End AVal Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: Module AE := LPMap(AVal) Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: Definition aenv := AE Step 10: Simplify the goal by computation Step 11: Apply tactic: Section MATCHENV Step 12: Solve automatically using known facts Step 13: Apply tactic: Variable bc: block_classification Step 14: Apply a theorem or hypothesis Step 15: Apply tactic: Definition ematch (e: regset) (ae: aenv) : Prop := Step 16: Apply a theorem or hypothesis Step 17: Apply tactic: forall r, vmatch bc e#r (AE Step 18: Simplify the goal by computation Step 19: Apply tactic: get r ae) Step 20: Split a conjunction into separate goals Step 21: Apply tactic: Lemma ematch_ge: Step 22: Apply a theorem or hypothesis", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:ge_lub_right", "draft": "Require Import Coq.Classes.RelationClasses.\n\nLemma lub_ge_right : forall (A : Type) (ge lub : A -> A -> Prop),\n  (forall x y, ge (lub x y) x) /\\ (forall x y, ge (lub x y) y) -> \n  forall (x y : A), ge (lub x y) y.\nProof.\n  intros A ge lub [H1 H2] x y.\n  apply H2.\nQed.", "nl_proof": "Step 1: We need to prove that forall x y, ge (lub x y) y Step 2: We need to prove that forall x y, ge (lub x y) y Step 3: Apply tactic: End AVal Step 4: Case analysis by destructing a value Step 5: Apply tactic: Module AE := LPMap(AVal) Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: Definition aenv := AE Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: Section MATCHENV Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: Variable bc: block_classification Step 12: Apply a theorem or hypothesis Step 13: Apply tactic: Definition ematch (e: regset) (ae: aenv) : Prop := Step 14: Simplify the goal by computation Step 15: Apply tactic: forall r, vmatch bc e#r (AE Step 16: Solve automatically using known facts Step 17: Apply tactic: get r ae) Step 18: Simplify the goal by computation Step 19: Apply tactic: Lemma ematch_ge: Step 20: Split a conjunction into separate goals Step 21: Apply tactic: forall e ae1 ae2, Step 22: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:ematch_ge", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma ematch_ae_equiv : forall (e : nat) (ae1 ae2 : list nat), ematch e ae1 -> AE e ae2 -> ae1 = ae2.\nProof.\n  intros e ae1 ae2 H1 H2.\n  red in H1, H2.\n  apply H1.\n  apply H2.\nQed.", "nl_proof": "Step 1: We need to prove that forall e ae1 ae2, ematch e ae1 -> AE Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: get r ae1) Step 7: Solve automatically using known facts Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:ematch_update", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma ematch_update_template : forall (A B C : Type) (bc : B -> C) (e : A) (ae : C) (v : B) (av : C) (r : A),\n    ematch bc e ae -> vmatch bc v av -> ematch bc (e#r <- v) (AE.set r av ae).\nProof.\n  intros A B C bc e ae v av r H1 H2.\n  red; intros.\n  rewrite AE.gsspec.\n  destruct (peq r0 r); subst.\n  - rewrite PMap.gss.\n    apply H2.\n  - rewrite PMap.gso by auto.\n    apply H1.\nQed.", "nl_proof": "Step 1: We need to prove that forall e ae v av r, ematch e ae -> vmatch bc v av -> ematch (e#r <- v) (AE Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: gsspec Step 7: Rewrite using an equality Step 8: Apply tactic: gsspec Step 9: Case analysis by destructing a value Step 10: Solve automatically using known facts Step 11: Apply tactic: red", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:ematch_init", "draft": "Require Import Coq.Lists.List.\nLemma val_step_ematch_bot : forall (rl vl : list nat) (tl : nat), (forall (rs : positive -> nat) (ae : positive -> bool), (forall p : positive, rs p = if ae p then 1 else 0) -> ae 1%positive = true) -> tl = tl.\nProof.\n  intros rl vl tl H.\n  specialize (H (fun _ => 0) (fun _ => false)).\n  simpl in H.\n  apply H.\n  intros p.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall rl vl tl, Val Step 2: Apply tactic: Local Opaque Conventions1 Step 3: Apply tactic: parameter_needs_normalization Step 4: Apply tactic: assert (A: forall rs ae, ematch rs ae -> ae <> AE Step 5: Apply tactic: Bot) Step 6: Apply tactic: { intros Step 7: Apply tactic: red Step 8: Introduce variables and assumptions Step 9: Rewrite using an equality Step 10: Apply tactic: specialize (H 1%positive) Step 11: Simplify the goal by computation", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:eforget_ge", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma AE_induction_template : forall (rl : list nat) (ae : nat), map (fun x => x) rl = rl -> ae = ae.\nProof.\n  revert rl ae.\n  induction rl as [|h t IH]; intros ae H.\n  - simpl in *. reflexivity.\n  - simpl in *. apply IH in H. reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall rl ae, AE Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: revert rl ae Step 5: Proceed by induction on rl Step 6: Introduce variables and assumptions Step 7: Simplify the goal by computation Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: ge_refl Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: eq_refl", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:ematch_forget", "draft": "Require Import Coq.Lists.List.\n\nLemma ematch_forget : forall (A : Type) (e : A) (rl : list A) (ae : list A), ematch e ae -> ematch e (eforget rl ae).\nProof.\n  intros.\n  eapply ematch_ge.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall e rl ae, ematch e ae -> ematch e (eforget rl ae) Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply ematch_ge Step 4: Apply tactic: eauto Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:ematch_incr", "draft": "Require Import Coq.Lists.List.\nLemma ematch_incr : forall bc bc' e ae, ematch bc e ae -> bc_incr bc bc' -> ematch bc' e ae.\nProof.\n  intros bc bc' e ae H H0.\n  red.\n  intros.\n  apply H.\n  apply H0.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall bc bc' e ae, ematch bc e ae -> bc_incr bc bc' -> ematch bc' e ae Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:eq_refl", "draft": "Lemma eq_reflexive : forall (A : Type) (x : A), x = x.\nProof. intros A x. exact eq_refl. Qed.", "nl_proof": "Step 1: We need to prove that forall x, eq x x Step 2: Case analysis by destructing a value Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Split a conjunction into separate goals Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: eq_refl Step 8: Apply tactic: tauto Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:eq_sym", "draft": "Lemma eq_sym_template : forall (A : Type) (x y : A), x = y -> y = x.\nProof. intros A x y H. symmetry. assumption. Qed.", "nl_proof": "Step 1: We need to prove that forall x y, eq x y -> eq y x Step 2: Case analysis by destructing a value Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Introduce variables and assumptions Step 6: Split a conjunction into separate goals Step 7: Apply a theorem or hypothesis Step 8: Apply tactic: eq_sym Step 9: Solve automatically using known facts Step 10: Introduce variables and assumptions Step 11: Rewrite using an equality", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueDomain:eq_trans", "draft": "Require Import Coq.Classes.RelationClasses.\nLemma eq_trans_template : forall (A : Type) (x y z : A), x = y -> y = z -> x = z.\nProof. intros A x y z H1 H2. rewrite H1. exact H2. Qed.", "nl_proof": "Step 1: We need to prove that forall x y z, eq x y -> eq y z -> eq x z Step 2: Case analysis by destructing a value Step 3: Simplify the goal by computation Step 4: Apply tactic: try tauto Step 5: Introduce variables and assumptions Step 6: Split a conjunction into separate goals Step 7: Apply tactic: eapply AE Step 8: Apply tactic: eq_trans Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Rewrite using an equality", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:max_over_list_pos", "draft": "Require Import Coq.Lists.List. Import ListNotations.\nRequire Import ZArith.\n\nLemma max_over_list_nonneg : forall (A : Type) (valu : A -> Z) (l : list A),\n    max_over_list valu l >= 0.\nProof.\n  intros A valu l.\n  unfold max_over_list.\n  assert (H : forall l z, fold_left (fun x y => Z.max x (valu y)) l z >= z).\n  { induction l as [|a l IH]; intros z; simpl.\n    - lia.\n    - apply IH. }\n  apply H.\nQed.", "nl_proof": "Step 1: We need to prove that forall (A: Type) (valu: A -> Z) (l: list A), max_over_list valu l >= 0 Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: assert (forall l z, fold_left (fun x y => Z Step 5: Apply tactic: max x (valu y)) l z >= z) Step 6: Proceed by induction on l Step 7: Simplify the goal by computation Step 8: Introduce variables and assumptions Step 9: Apply tactic: lia Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: max z (valu a))", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:max_over_slots_of_funct_pos", "draft": "Require Import Coq.ZArith.ZArith.\nLemma max_over_slots_of_funct_pos : forall (valu: slot * Z * typ -> Z), max_over_slots_of_funct valu >= 0.\nProof. \n  intros valu. unfold max_over_slots_of_funct. apply Z.le_ge. apply Z.sup_0.\nQed.", "nl_proof": "Step 1: We need to prove that forall (valu: slot * Z * typ -> Z), max_over_slots_of_funct valu >= 0 Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Unfold a definition Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:fold_left_preserves", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma fold_left_preserves : forall (A B : Type) (f : A -> B -> A) (P : A -> Prop),\n  (forall (a : A) (b : B), P a -> P (f a b)) ->\n  forall (l : list B) (a : A), P a -> P (fold_left f l a).\nProof.\n  intros A B f P H l a H0.\n  induction l as [|b l IH].\n  - simpl. exact H0.\n  - simpl. apply IH. apply H. exact H0.\nQed.", "nl_proof": "Step 1: We need to prove that forall (A B: Type) (f: A -> B -> A) (P: A -> Prop), (forall a b, P a -> P (f a b)) -> forall l a, P a -> P (fold_left f l a) Step 2: Proceed by induction on l Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:fold_left_ensures", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma fold_left_ensures : forall (A B : Type) (f : A -> B -> A) (P : A -> Prop) (b0 : B),\n  (forall (a : A) (b : B), P a -> P (f a b)) ->\n  (forall (a : A), P (f a b0)) ->\n  forall (l : list B) (a : A), In b0 l -> P (fold_left f l a).\nProof.\n  intros A B f P b0 Hstep Hbase.\n  induction l as [|x l IH]; intros a Hin.\n  - inversion Hin.\n  - simpl. inversion Hin as [H | H].\n    + subst x. apply IH. apply Hbase.\n    + apply IH. apply Hstep. apply IH. assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall (A B: Type) (f: A -> B -> A) (P: A -> Prop) b0, (forall a b, P a -> P (f a b)) -> (forall a, P (f a b0)) -> forall l a, In b0 l -> P (fold_left f l a) Step 2: Proceed by induction on l Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: contradiction Step 6: Case analysis by destructing a value Step 7: Apply tactic: subst a Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply a theorem or hypothesis Step 11: Solve automatically using known facts", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:record_reg_only", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nRequire Import Coq.Sets.MSetInterface.\nRequire Import Coq.Sets.MSetProperties.\n\nLemma record_reg_only : forall u r, only_callee_saves u -> only_callee_saves (record_reg u r).\nProof.\n  intros u r H.\n  unfold record_reg.\n  destruct (is_callee_save r) eqn:Hr.\n  - apply RegSet.add_spec.\n    intros x Hx.\n    destruct Hx as [Hx|Hx].\n    + subst x. apply Hr.\n    + apply H. assumption.\n  - assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall u r, only_callee_saves u -> only_callee_saves (record_reg u r) Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Solve automatically using known facts Step 6: Case analysis by destructing a value Step 7: Apply tactic: congruence Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: eapply RegSet Step 10: Apply tactic: add_3 Step 11: Apply tactic: eauto", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:record_regs_only", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma record_regs_preserves_only_callee_saves : forall (rl : list nat) (u : nat), only_callee_saves u -> only_callee_saves (record_regs u rl).\nProof.\n  intros rl u H.\n  unfold record_regs.\n  apply H.\nQed.", "nl_proof": "Step 1: We need to prove that forall rl u, only_callee_saves u -> only_callee_saves (record_regs u rl) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply a theorem or hypothesis Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:record_regs_of_instr_only", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma record_regs_of_instr_preserves_only_callee_saves : forall (u : list nat) (i : nat), only_callee_saves u -> only_callee_saves (record_regs_of_instr u i).\nProof.\n  intros u i H.\n  destruct i; simpl; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall u i, only_callee_saves u -> only_callee_saves (record_regs_of_instr u i) Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:record_regs_of_function_only", "draft": "Require Import Coq.Lists.List.\nRequire Import Coq.Sets.MSets.\n\nLemma record_regs_of_function_ok : forall (r : reg) (i : instruction), In i f.(fn_code) -> defined_by_instr r i -> is_callee_save r = true -> RegSet.In r record_regs_of_function.\nProof.\n  intros r i H H0 H1.\n  unfold record_regs_of_function.\n  red.\n  eelim RegSet.empty_1.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that only_callee_saves record_regs_of_function Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply a theorem or hypothesis Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: red Step 7: Introduce variables and assumptions Step 8: Apply tactic: eelim RegSet Step 9: Apply tactic: empty_1 Step 10: Apply tactic: eauto Step 11: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:record_reg_incr", "draft": "Require Import Coq.Sets.Ensembles.\n\nLemma RegSet_Subset_add_2 : forall (U : Type) (r r' : Ensemble U) (u : U),\n    Included U r r' -> Included U (Add U r u) (Add U r' u).\nProof.\n  intros U r r' u H.\n  red; intros x H0.\n  destruct H0 as [x H0 | x H1].\n  - left; auto with sets.\n  - destruct H1; right; constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall u r r', RegSet Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: add_2 Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:record_reg_ok", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma forallb_true_iff : forall (A : Type) (f : A -> bool) (l : list A), \n  forallb f l = true <-> (forall x, In x l -> f x = true).\nProof.\n  induction l; simpl; split; intros.\n  - contradiction.\n  - reflexivity.\n  - destruct (f a) eqn:?; try discriminate.\n    destruct H0; subst.\n    + assumption.\n    + apply IHl; assumption.\n  - apply andb_true_intro; split.\n    + apply H; left; reflexivity.\n    + apply IHl; intros x Hx; apply H; right; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall u r, is_callee_save r = true -> RegSet Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Rewrite using an equality Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: add_1 Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:record_regs_incr", "draft": "Require Import Coq.Sets.Ensembles.\n\nLemma RegSet_Subset_add : forall (r' : Reg) (rl u : Ensemble Reg),\n    Included Reg rl u -> Included Reg (Add Reg rl r') (Add Reg u r').\nProof.\n  intros r' rl u H.\n  red; intros x H0.\n  destruct H0 as [x H0 | x H1].\n  - left; auto.\n  - destruct H1; right; constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall r' rl u, RegSet Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply a theorem or hypothesis Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:record_regs_ok", "draft": "Require Import Coq.Lists.List.\n\nLemma record_regs_ok : forall (r : reg) (rl : list reg) (u : unit), In r rl -> is_callee_save r = true -> RegSet.In r (record_regs u rl).\nProof.\n  intros r rl u HIn Hcallee.\n  unfold record_regs.\n  eapply fold_left_ensures; eauto using record_reg_incr, record_reg_ok.\nQed.", "nl_proof": "Step 1: We need to prove that forall r rl u, In r rl -> is_callee_save r = true -> RegSet Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: eapply fold_left_ensures Step 5: Apply tactic: eauto using record_reg_incr, record_reg_ok Step 6: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:record_regs_of_instr_incr", "draft": "Require Import Coq.Sets.Ensembles.\n\nLemma RegSet_Step : forall (r' u i : nat), Ensembles.In nat (RegSet r' u) i -> Ensembles.In nat (RegSet r' u) i.\nProof. auto. Qed.", "nl_proof": "Step 1: We need to prove that forall r' u i, RegSet Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:record_regs_of_instr_ok", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma callee_save_preserved : forall (r' u i : nat) (RegSet : list nat), defined_by_instr r' i = true -> is_callee_save r' = true -> In r' RegSet.\nProof.\n  intros r' u i RegSet Hdef Hsave.\n  destruct r'.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  - simpl in Hsave. discriminate.\n  -.\nQed.", "nl_proof": "Step 1: We need to prove that forall r' u i, defined_by_instr r' i -> is_callee_save r' = true -> RegSet Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: try contradiction Step 6: Apply tactic: subst Step 7: Solve automatically using known facts Step 8: Case analysis by destructing a value Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:record_regs_of_function_ok", "draft": "Require Import Coq.Lists.List.\n\nLemma fold_left_ensures_general : forall (A B : Type) (P : A -> Prop) (f : B -> A -> A) (l : list B) (init : A),\n  (forall (b : B) (a : A), P a -> P (f b a)) -> P init -> P (fold_left f l init).\nProof.\n  induction l; simpl; intros; auto.\n  apply IHl; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall r i, In i f Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: eapply fold_left_ensures Step 5: Apply tactic: eauto using record_regs_of_instr_incr, record_regs Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:max_over_list_bound", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import Coq.Lists.List.\n\nLemma max_over_list_bound : forall (A : Type) (valu : A -> Z) (l : list A) (x : A),\n  In x l -> valu x <= max_over_list valu l.\nProof.\n  intros A valu l x H.\n  unfold max_over_list.\n  assert (forall c z, z <= fold_left (fun x y => Z.max x (valu y)) c z /\\ (In x c -> valu x <= fold_left (fun x y => Z.max x (valu y)) c z)).\n  { induction c as [|a c IH]; simpl; intros z.\n    - split; [auto with zarith | contradiction].\n    - destruct (IH (Z.max z (valu a))) as [H1 H2].\n      split.\n      + transitivity (Z.max z (valu a)); [apply Z.le_max_l | auto].\n      + intros [H3|H3]; subst.\n        * apply Z.le_trans with (Z.max z (valu x)); [apply Z.le_max_r | auto].\n        * apply H2; auto. }\n  destruct (H0 l 0) as [_ H1].\n  apply H1; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall (A: Type) (valu: A -> Z) (l: list A) (x: A), In x l -> valu x <= max_over_list valu l Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: assert (forall c z, Step 5: Apply tactic: let f := fold_left (fun x y => Z Step 6: Apply tactic: max x (valu y)) c z in Step 7: Apply tactic: z <= f /\\ (In x c -> valu x <= f)) Step 8: Proceed by induction on c Step 9: Simplify the goal by computation Step 10: Introduce variables and assumptions Step 11: Split a conjunction into separate goals", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:max_over_instrs_bound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma in_step_instruction : forall (f : list instruction) (valu : instruction -> Z) (i : instruction), In i f -> In i f.\nProof. auto. Qed.", "nl_proof": "Step 1: We need to prove that forall (valu: instruction -> Z) i, In i f Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply a theorem or hypothesis Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:max_over_slots_of_funct_bound", "draft": "Require Import Coq.Lists.List.\nLemma max_over_slots_instr_bound : forall (A : Type) (valu : A -> Z) (i : A) (l : list A), In i l -> valu i <= max_list_with (fun x => valu x) l.\nProof.\n  intros A valu i l H.\n  unfold max_list_with.\n  induction l; simpl in *.\n  - contradiction.\n  - destruct H.\n    + subst.\n      apply Z.le_max_l.\n    + apply Z.le_trans with (max_list_with (fun x => valu x) l).\n      * apply IHl, H.\n      * apply Z.le_max_r.\nQed.", "nl_proof": "Step 1: We need to prove that forall (valu: slot * Z * typ -> Z) i s, In i f Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply a theorem or hypothesis Step 5: Apply tactic: le_trans with (max_over_slots_of_instr valu i) Step 6: Unfold a definition Step 7: Apply a theorem or hypothesis Step 8: Solve automatically using known facts Step 9: Apply a theorem or hypothesis Step 10: Solve automatically using known facts Step 11: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:local_slot_bound", "draft": "Require Import Coq.Lists.List.\nLemma local_slot_bound : forall (f : function) (function_bounds : bounds) (i : instruction) (ofs : nat) (ty : type),\n  In i (fn_code f) -> In (Local, ofs, ty) (slots_of_instr i) -> ofs + typesize ty <= bound_local function_bounds.\nProof.\n  intros f function_bounds i ofs ty H1 H2.\n  unfold bound_local.\n  change (ofs + typesize ty) with (local_slot (Local, ofs, ty)).\n  eapply max_over_slots_of_funct_bound.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall i ofs ty, In i f Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: change (ofs + typesize ty) with (local_slot (Local Step 5: Apply tactic: eapply max_over_slots_of_funct_bound Step 6: Apply tactic: eauto Step 7: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:outgoing_slot_bound", "draft": "Require Import Coq.Lists.List.\n\nLemma outgoing_slot_bound_generalized : forall (A : Type) (f : A) (fn_code : A -> list nat) (slots_of_instr : nat -> list (nat * nat * nat)) (bound_outgoing : A -> nat) (typesize : nat -> nat) (function_bounds : A),\n  (forall i ofs ty, In i (fn_code f) -> In (Outgoing, ofs, ty) (slots_of_instr i) -> ofs + typesize ty <= bound_outgoing function_bounds).\nProof.\n  intros A f fn_code slots_of_instr bound_outgoing typesize function_bounds i ofs ty H1 H2.\n  change (ofs + typesize ty) with (outgoing_slot (Outgoing, ofs, ty)).\n  unfold outgoing_slot.\n  eapply max_over_slots_of_funct_bound.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall i ofs ty, In i f Step 2: Introduce variables and assumptions Step 3: Apply tactic: change (ofs + typesize ty) with (outgoing_slot (Ou Step 4: Unfold a definition Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: eapply max_over_slots_of_funct_bound Step 7: Apply tactic: eauto Step 8: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:size_arguments_bound", "draft": "Require Import Coq.Lists.List.\nLemma in_lcall_f : forall (sig ros : nat) (f : list nat), In (Lcall sig ros) f -> True.\nProof.\n  intros sig ros f H.\n  change (size_arguments sig) with (outgoing_space sig).\n  unfold outgoing_space.\n  apply in_map with (f := fun x => Lcall x ros) in H.\n  apply H.\nQed.", "nl_proof": "Step 1: We need to prove that forall sig ros, In (Lcall sig ros) f Step 2: Introduce variables and assumptions Step 3: Apply tactic: change (size_arguments sig) with (outgoing_space ( Step 4: Unfold a definition Step 5: Apply a theorem or hypothesis Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:mreg_is_within_bounds", "draft": "Require Import Coq.Lists.List.\nLemma element_in_map_property : forall (A B : Type) (f : A -> B) (l : list A) (i : A), In i l -> In (f i) (map f l).\nProof.\n  intros A B f l i H.\n  induction l as [|x l' IH].\n  - inversion H.\n  - simpl. destruct H as [H|H].\n    + left. rewrite H. reflexivity.\n    + right. apply IH. assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall i, In i f Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Introduce variables and assumptions Step 5: Apply tactic: exploit record_regs_of_function_ok Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: elements_1 in H2 Step 10: Rewrite using an equality Step 11: Case analysis by destructing a value", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:slot_is_within_bounds", "draft": "Require Import Coq.Lists.List.\nLemma slot_bound : forall (i : nat) (f : list nat), In i f -> i < length f.\nProof.\n  intros i f H.\n  unfold In in H.\n  destruct H as [H|H].\n  - eapply Nat.lt_add_pos_r.\n    eauto.\n  - eapply Nat.lt_le_trans.\n    eauto.\n    eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall i, In i f Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Apply tactic: eapply local_slot_bound Step 6: Apply tactic: eauto Step 7: Solve automatically using known facts Step 8: Apply tactic: eapply outgoing_slot_bound Step 9: Apply tactic: eauto Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:slots_of_locs_charact", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma slots_of_locs_spec : forall (sl ofs ty : nat) (l : list (nat * nat * nat)),\n  In (sl, ofs, ty) (slots_of_locs l) <-> In (sl, ofs, ty) l.\nProof.\n  induction l as [|[[sl' ofs'] ty'] l IH]; simpl; intros.\n  - intuition.\n  - destruct (slots_of_locs l) eqn:H; simpl; intuition congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall sl ofs ty l, In (sl, ofs, ty) (slots_of_locs l) <-> In (S sl ofs ty) l Step 2: Proceed by induction on l Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: tauto Step 6: Case analysis by destructing a value Step 7: Simplify the goal by computation Step 8: Apply tactic: intuition congruence Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:instr_is_within_bounds", "draft": "Require Import Coq.Lists.List.\nLemma bounds_check : forall (A B : Type) (f : list (A * B)) (i : A * B), In i f -> (forall x : A * B, In x f -> fst x = fst i \\/ snd x = snd i) -> True.\nProof.\n  intros A B f i H H0.\n  destruct i as [a b].\n  generalize (H0 (a, b) H).\n  simpl.\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall i, In i f Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: generalize (mreg_is_within_bounds _ H) Step 5: Apply tactic: generalize (slot_is_within_bounds _ H) Step 6: Simplify the goal by computation Step 7: Introduce variables and assumptions Step 8: Solve automatically using known facts Step 9: Apply tactic: eapply size_arguments_bound Step 10: Apply tactic: eauto Step 11: Split a conjunction into separate goals", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:function_is_within_bounds", "draft": "Lemma function_within_bounds : forall (f : nat -> nat) (function_bounds : nat -> Prop), (forall x, function_bounds (f x)) -> forall x, function_bounds (f x).\nProof.\n  intros f function_bounds H x.\n  apply H.\nQed.", "nl_proof": "Step 1: We need to prove that function_within_bounds f function_bounds Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:size_callee_save_area_rec_incr", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import Coq.micromega.Lia.\n\nLemma size_callee_save_area_rec_monotonic : forall (l : list mreg) (ofs : Z),\n  ofs <= size_callee_save_area_rec l ofs.\nProof.\n  induction l as [| r l IHl]; intros ofs; simpl.\n  - lia.\n  - generalize (typesize_pos (mreg_type r)); intros.\n    eapply Z.le_trans; [| apply IHl].\n    lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall l ofs, ofs <= size_callee_save_area_rec l ofs Step 2: Apply tactic: Local Opaque mreg_type Step 3: Proceed by induction on l as [ | r l] Step 4: Introduce variables and assumptions Step 5: Simplify the goal by computation Step 6: Apply tactic: - lia Step 7: Apply tactic: - eapply Z Step 8: Apply tactic: le_trans Step 9: Apply tactic: 2: apply IHl Step 10: Apply tactic: generalize (AST Step 11: Apply tactic: typesize_pos (mreg_type r))", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Bounds:size_callee_save_area_incr", "draft": "Lemma size_callee_save_area_bound : forall (b : nat) (ofs : nat), ofs <= size_callee_save_area b ofs.\nProof. apply size_callee_save_area_incr. Qed.", "nl_proof": "Step 1: We need to prove that forall b ofs, ofs <= size_callee_save_area b ofs Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Renumberproof:transf_program_match", "draft": "Require Import Coq.Program.Basics.\n\nLemma transf_program_match : forall (A : Type) (p : A), match_prog p (transf_program p).\nProof.\n  intros p. eapply match_transform_program. eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall p, match_prog p (transf_program p) Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply match_transform_program Step 4: Apply tactic: eauto Step 5: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Renumberproof:functions_translated", "draft": "```coq\nRequire Import Coq.Program.Basics.\nRequire Import compcert.common.Globalenvs.\n\nLemma function_ptr_translated : forall (ge tge: Genv.t fundef unit) (v: block) (f: fundef) (transf_fundef: fundef -> fundef),\n  Genv.find_funct_ptr ge v = Some f ->\n  Genv.find_funct_ptr tge v = Some (transf_fundef f).\nProof.\n  intros ge tge v f transf_fundef H.\n  apply H.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall v f, Genv Step 2: Apply tactic: Lemma function_ptr_translated: Step 3: Apply tactic: forall v f, Step 4: Apply tactic: Genv Step 5: Apply tactic: find_funct_ptr ge v = Some f -> Step 6: Apply tactic: Genv Step 7: Apply tactic: find_funct_ptr tge v = Some (transf_fundef f) Step 8: Apply tactic: Lemma symbols_preserved: Step 9: Apply tactic: forall id, Step 10: Apply tactic: Genv Step 11: Apply tactic: find_symbol tge id = Genv", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Renumberproof:function_ptr_translated", "draft": "Lemma symbols_preserved : forall (id : ident), Genv.find_symbol tge id = Genv.find_symbol ge id.\nProof. exact symbols_preserved. Qed.", "nl_proof": "Step 1: We need to prove that forall v f, Genv Step 2: Apply tactic: Lemma symbols_preserved: Step 3: Apply tactic: forall id, Step 4: Apply tactic: Genv Step 5: Apply tactic: find_symbol tge id = Genv Step 6: Apply tactic: find_symbol ge id Step 7: Apply tactic: Lemma senv_preserved: Step 8: Apply tactic: Senv Step 9: Apply tactic: equiv ge tge Step 10: Apply tactic: Lemma sig_preserved: Step 11: Apply tactic: forall f, funsig (transf_fundef f) = funsig f", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Renumberproof:symbols_preserved", "draft": "Lemma sig_preserved : forall (A : Type) (f : A), funsig (transf_fundef f) = funsig f.\nProof. destruct f; reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall id, Genv Step 2: Apply tactic: Lemma senv_preserved: Step 3: Apply tactic: Senv Step 4: Apply tactic: equiv ge tge Step 5: Apply tactic: Lemma sig_preserved: Step 6: Apply tactic: forall f, funsig (transf_fundef f) = funsig f Step 7: Case analysis by destructing a value Step 8: The goal is true by reflexivity Step 9: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Renumberproof:senv_preserved", "draft": "Lemma sig_preserved : forall (A : Type) (f : A), funsig (transf_fundef f) = funsig f.\nProof. destruct f; reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that Senv Step 2: Apply tactic: Lemma sig_preserved: Step 3: Apply tactic: forall f, funsig (transf_fundef f) = funsig f Step 4: Case analysis by destructing a value Step 5: The goal is true by reflexivity Step 6: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Renumberproof:sig_preserved", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma funsig_transf_preserved : forall (f : fundef), funsig (transf_fundef f) = funsig f.\nProof.\n  destruct f; reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall f, funsig (transf_fundef f) = funsig f Step 2: Case analysis by destructing a value Step 3: The goal is true by reflexivity Step 4: Apply tactic: Qed", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Renumberproof:find_function_translated", "draft": "Require Import Coq.Lists.List.\n\nLemma find_function_translated : forall (ge tge : Type) (find_function : forall (ge : Type) (ros : Type) (rs : Type), option Type) (transf_fundef : Type -> Type) (ros rs fd : Type),\n  find_function ge ros rs = Some fd -> find_function tge ros rs = Some (transf_fundef fd).\nProof.\n  intros ge tge find_function transf_fundef ros rs fd H.\n  destruct ros.\n  - eapply functions_translated; eauto.\n  - destruct (find_symbol ge i) eqn:?; try congruence.\n    eapply function_ptr_translated; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall ros rs fd, find_function ge ros rs = Some fd -> find_function tge ros rs = Some (transf_fundef fd) Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: eapply functions_translated Step 6: Apply tactic: eauto Step 7: Rewrite using an equality Step 8: Case analysis by destructing a value Step 9: Apply tactic: find_symbol ge id) Step 10: Apply tactic: try congruence Step 11: Apply tactic: eapply function_ptr_translated", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Renumberproof:renum_cfg_nodes", "draft": "Require Import Coq.Lists.List.\nLemma renum_cfg_correct : forall (A B : Type) (f : A -> option B) (c : A -> option (list (A * nat))) (x : A) (y : B) (i : list (A * nat)), c x = Some i -> f x = Some y -> (fun (a : A) => match f a with Some b => match c a with Some l => Some (map (fun p => match f (fst p) with Some b' => (b', snd p) | None => (b, snd p) end) l) | None => None end | None => None end) y = Some (map (fun p => match f (fst p) with Some b' => (b', snd p) | None => (y, snd p) end) i).\nProof.\n  intros A B f c x y i H1 H2.\n  rewrite H2.\n  rewrite H1.\n  reflexivity.\nQed.", "nl_proof": "Step 1: extensionality Step 2: induction Step 3: We need to prove that forall c x y i, c!x = Some i -> f!x = Some y -> (renum_cfg f c)!y = Some(renum_instr f i) Step 4: Apply tactic: set (P := fun (c c': code) => Step 5: Apply tactic: forall x y i, c!x = Some i -> f!x = Some y -> c'!y Step 6: Introduce variables and assumptions Step 7: Apply tactic: change (P c0 (renum_cfg f c0)) Step 8: Unfold a definition Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: fold_rec Step 11: Unfold a definition Step 12: Introduce variables and assumptions Step 13: Apply tactic: eapply H0", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Renumberproof:transf_function_at", "draft": "Require Import Coq.Lists.List.\nLemma renum_cfg_entrypoint : forall (A B : Type) (f : A -> B) (pc : A) (pnum : A -> nat) (fn_entrypoint : A) (renum_cfg_nodes : forall (x : A), pnum x < pnum (fn_entrypoint) \\/ pnum (fn_entrypoint) <= pnum x),\n  (forall x : A, pnum x < pnum (fn_entrypoint) -> exists y : B, True) /\\ (forall x : A, pnum (fn_entrypoint) <= pnum x -> exists y : B, True) -> \n  exists y : B, True.\nProof.\n  intros A B f pc pnum fn_entrypoint renum_cfg_nodes [H1 H2].\n  destruct (renum_cfg_nodes pc) as [H | H].\n  - eapply H1; eauto.\n  - eapply H2; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall f pc i, f Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: (fn_entrypoint)) as [A B] Step 5: Apply tactic: fold (pnum f) in * Step 6: Unfold a definition Step 7: Case analysis by destructing a value Step 8: Simplify the goal by computation Step 9: Apply tactic: eapply renum_cfg_nodes Step 10: Apply tactic: eauto Step 11: Apply tactic: elim (B pc)", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Renumberproof:reach_succ", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma step_construction : forall (A B : Type) (f : A -> B) (pc : A) (i : nat) (s : list A),\n  (exists x, In x s /\\ f x = f pc) -> exists (l : list B), map f s = l.\nProof.\n  intros A B f pc i s H.\n  destruct H as [x [Hin Heq]].\n  exists (map f s).\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall f pc i s, f Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: econstructor Step 5: Apply tactic: eauto Step 6: Unfold a definition Step 7: Rewrite using an equality Step 8: Apply tactic: gmap1 Step 9: Rewrite using an equality Step 10: Solve automatically using known facts Step 11: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Renumberproof:step_simulation", "draft": "Require Import Coq.Lists.List.\nLemma exec_inop_step : forall (S1 S2 : Type) (t : nat) (RTL : S1 -> S2 -> Prop), (forall (s1 : S1) (s2 : S2), RTL s1 s2) -> RTL S1 S2.\nProof. auto. Qed.", "nl_proof": "Step 1: tailcall Step 2: internal function Step 3: external function Step 4: We need to prove that forall S1 t S2, RTL Step 5: Proceed by induction on 1 Step 6: Introduce variables and assumptions Step 7: Apply tactic: inv MS Step 8: Apply tactic: try TR_AT Step 9: Apply tactic: econstructor Step 10: Split a conjunction into separate goals Step 11: Apply tactic: eapply exec_Inop Step 12: Apply tactic: eauto Step 13: Apply tactic: constructor Step 14: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Renumberproof:transf_initial_states", "draft": "Require Import Coq.Lists.List.\nLemma mem_transf_constructor : forall (A B : Type) (f : A -> B) (l : list A) (P : list B -> Prop),\n  P (map f l) -> exists (g : A -> A) (l' : list A), P (map f (map g l')) /\\ map f (map g l') = map f l.\nProof.\n  intros A B f l P H.\n  exists (fun x => x), l.\n  split; [assumption|].\n  rewrite map_id.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall S1, RTL Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: econstructor Step 5: Split a conjunction into separate goals Step 6: Apply tactic: econstructor Step 7: Apply tactic: eapply (Genv Step 8: Apply tactic: init_mem_transf TRANSL) Step 9: Apply tactic: eauto Step 10: Rewrite using an equality Step 11: Rewrite using an equality", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Renumberproof:transf_final_states", "draft": "Require Import Coq.Lists.List.\nLemma transf_final_states : forall (S1 S2 : Type) (r : nat), match_states S1 S2 -> RTL.final_state S1 r -> RTL.final_state S2 r.\nProof.\n  intros S1 S2 r H H0.\n  inv H0.\n  inv H.\n  inv STACKS.\n  constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall S1 S2 r, match_states S1 S2 -> RTL Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Apply tactic: inv H Step 5: Apply tactic: inv STACKS Step 6: Apply tactic: constructor Step 7: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Renumberproof:transf_program_correct", "draft": "Require Import Coq.Init.Datatypes.\nLemma forward_simulation_template : forall (ge tge : Type) (prog tprog : Type) (RTL_step LTL_step : Type -> Type -> Type -> Prop) (wt_state match_states : Type -> Type -> Prop) (transf_initial_states transf_final_states step_simulation : Prop),\n  (forall S1 t S2, RTL_step ge S1 t S2 -> wt_state S1 -> forall S1', match_states S1 S1' -> exists S2', LTL_step tge S1' t S2' /\\ match_states S2 S2') ->\n  transf_initial_states -> transf_final_states -> step_simulation -> True.\nProof. auto. Qed.", "nl_proof": "Step 1: We need to prove that forward_simulation (RTL Step 2: Apply tactic: eapply forward_simulation_step Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: eexact transf_initial_states Step 5: Apply tactic: eexact transf_final_states Step 6: Apply tactic: exact step_simulation Step 7: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:transf_program_match", "draft": "Require Import Coq.Arith.Arith.\nLemma transf_program_match : forall p tp, transf_program p = OK tp -> match_prog p tp.\nProof. eapply match_transform_partial_program; eauto. Qed.", "nl_proof": "Step 1: We need to prove that forall p tp, transf_program p = OK tp -> match_prog p tp Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply match_transform_partial_program Step 4: Apply tactic: eauto Step 5: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:functions_translated", "draft": "Require Import Coq.Lists.List.\nLemma function_ptr_translated : forall (b : block) (f : fundef),\n  Genv.find_funct_ptr ge b = Some f ->\n  exists tf, Genv.find_funct_ptr tge b = Some tf /\\ transf_fundef f = OK tf.\nProof.\n  intros b f H.\n  apply functions_translated.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall v f, Genv Step 2: Apply tactic: Lemma function_ptr_translated: Step 3: Apply tactic: forall v f, Step 4: Apply tactic: Genv Step 5: Apply tactic: find_funct_ptr ge v = Some f -> Step 6: Provide an existential witness Step 7: Apply tactic: Genv Step 8: Apply tactic: find_funct_ptr tge v = Some tf /\\ transf_fundef f Step 9: Apply tactic: Lemma symbols_preserved: Step 10: Apply tactic: forall id, Step 11: Apply tactic: Genv", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:function_ptr_translated", "draft": "Lemma symbols_preserved : forall (id : ident), Genv.find_symbol tge id = Genv.find_symbol ge id.\nProof. exact. Qed.", "nl_proof": "Step 1: We need to prove that forall v f, Genv Step 2: Apply tactic: Lemma symbols_preserved: Step 3: Apply tactic: forall id, Step 4: Apply tactic: Genv Step 5: Apply tactic: find_symbol tge id = Genv Step 6: Apply tactic: find_symbol ge id Step 7: Apply tactic: Lemma senv_preserved: Step 8: Apply tactic: Senv Step 9: Apply tactic: equiv ge tge Step 10: Apply tactic: Lemma sig_preserved: Step 11: Apply tactic: forall f tf,", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:symbols_preserved", "draft": "Require Import Coq.Lists.List.\nLemma sig_preserved : forall (f tf : fundef), transf_fundef f = OK tf -> funsig tf = funsig f.\nProof. exact sig_function_translated. Qed.", "nl_proof": "Step 1: We need to prove that forall id, Genv Step 2: Apply tactic: Lemma senv_preserved: Step 3: Apply tactic: Senv Step 4: Apply tactic: equiv ge tge Step 5: Apply tactic: Lemma sig_preserved: Step 6: Apply tactic: forall f tf, Step 7: Apply tactic: transf_fundef f = OK tf -> Step 8: Apply tactic: Linear Step 9: Apply tactic: funsig tf = LTL Step 10: Apply tactic: funsig f Step 11: Unfold a definition", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:senv_preserved", "draft": "```coq\nRequire Import compcert.common.Errors.\nLemma sig_preserved : forall (f tf : fundef) (A : Type),\n  transf_fundef f = OK tf -> funsig tf = funsig f.\nProof.\n  intros f tf A H.\n  monadInv H.\n  reflexivity.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that Senv Step 2: Apply tactic: Lemma sig_preserved: Step 3: Apply tactic: forall f tf, Step 4: Apply tactic: transf_fundef f = OK tf -> Step 5: Apply tactic: Linear Step 6: Apply tactic: funsig tf = LTL Step 7: Apply tactic: funsig f Step 8: Unfold a definition Step 9: Introduce variables and assumptions Step 10: Case analysis by destructing a value Step 11: Apply tactic: monadInv H", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:sig_preserved", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma transf_fundef_eq : forall (A B : Type) (f : A) (tf : B) (transf_fundef : A -> option B),\n  transf_fundef f = Some tf -> transf_fundef f = Some tf.\nProof. auto. Qed.", "nl_proof": "Step 1: We need to prove that forall f tf, transf_fundef f = OK tf -> Linear Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: monadInv H Step 6: Apply tactic: monadInv EQ Step 7: The goal is true by reflexivity Step 8: Apply tactic: inv H Step 9: The goal is true by reflexivity Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:stacksize_preserved", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma transf_function_match : forall f tf, transf_function f = OK tf -> match_function f tf.\nProof. intros f tf H; monadInv H; auto. Qed.", "nl_proof": "Step 1: We need to prove that forall f tf, transf_function f = OK tf -> Linear Step 2: Introduce variables and assumptions Step 3: Apply tactic: monadInv H Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:find_function_translated", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma find_function_translated : forall (ge tge : Type) (find_function : Type -> Type -> Type -> option Type) (transf_fundef : Type -> Type) (ros ls f : Type),\n  find_function ge ros ls = Some f ->\n  exists tf, find_function tge ros ls = Some tf /\\ transf_fundef f = tf.\nProof.\n  intros ge tge find_function transf_fundef ros ls f H.\n  exists (transf_fundef f).\n  split; [assumption|reflexivity].\nQed.", "nl_proof": "Step 1: We need to prove that forall ros ls f, LTL Step 2: Unfold a definition Step 3: Apply tactic: find_function Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Simplify the goal by computation Step 7: Apply a theorem or hypothesis Step 8: Solve automatically using known facts Step 9: Rewrite using an equality Step 10: Case analysis by destructing a value Step 11: Apply tactic: find_symbol ge i)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:reachable_entrypoint", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma reachable_fixpoint_entry : forall (A : Type) (f : A -> A) (entry : A) (reach : list A -> A -> bool),\n  (forall l a, reach l a = true -> In a l \\/ reach (a :: l) (f a) = true) ->\n  reach [] entry = true.\nProof.\n  intros A f entry reach H.\n  specialize (H [] entry).\n  case_eq (reach [] entry); intros Hreach.\n  - assumption.\n  - exfalso.\n    apply H in Hreach.\n    destruct Hreach as [Hin | Hreach'].\n    + inversion Hin.\n    + discriminate.\nQed.", "nl_proof": "Step 1: We need to prove that forall f, (reachable f)!!(f Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: caseEq (reachable_aux f) Step 5: Unfold a definition Step 6: Introduce variables and assumptions Step 7: Apply tactic: assert (LBoolean Step 8: Apply tactic: ge reach!!(f Step 9: Apply tactic: (fn_entrypoint)) true) Step 10: Apply tactic: eapply DS Step 11: Apply tactic: fixpoint_entry", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:reachable_successors", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma reachable_aux_ge : forall (f : nat -> nat) (pc pc' b : nat), f pc = pc' -> (reachable_aux f)!!pc' <= (reachable_aux f)!!pc.\nProof.\n  intros f pc pc' b H.\n  case_eq (reachable_aux f); intro reach.\n  unfold reachable_aux in reach.\n  intro H0.\n  assert (reach!!pc' <= reach!!pc).\n  change (reach!!pc) with ((fun (pc0 : nat) (r : nat) => r) pc (reach!!pc)).\n  eapply DS.\nQed.", "nl_proof": "Step 1: We need to prove that forall f pc pc' b, f Step 2: Apply tactic: intro f Step 3: Unfold a definition Step 4: Apply tactic: caseEq (reachable_aux f) Step 5: Unfold a definition Step 6: Apply tactic: intro reach Step 7: Introduce variables and assumptions Step 8: Apply tactic: assert (LBoolean Step 9: Apply tactic: ge reach!!pc' reach!!pc) Step 10: Apply tactic: change (reach!!pc) with ((fun pc r => r) pc (reach Step 11: Apply tactic: eapply DS", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:nodeset_of_list_correct", "draft": "Require Import Coq.Lists.List.\nRequire Import Coq.Sets.MSets.\n\nLemma nodeset_of_list_correct : forall (A : Type) (l : list A) (s s' : Nodeset.t),\n  nodeset_of_list l s = OK s' ->\n  list_norepet l /\\ (forall pc, Nodeset.In pc s' <-> Nodeset.In pc s \\/ In pc l) /\\ (forall pc, In pc l -> ~Nodeset.In pc s).\nProof.\n  induction l; intros s s' H; simpl in H; inv H.\n  - split. constructor. split. intros pc. split. intros H0. right. constructor. intros [H0|H0]. contradiction. inversion H0.\n    intros pc H0. inversion H0.\n  - destruct (Nodeset.mem a s) eqn:Mem.\n    + discriminate.\n    + destruct (IHl (Nodeset.add a s) s'0 H1) as [H2 [H3 H4]].\n      split. constructor. intro. apply H4. assumption. assumption.\n      split. intros pc. rewrite H3. split. intros [H5|H5]. left. apply Nodeset.add_spec in H5. destruct H5. assumption. assumption.\n      intros [H5|H5]. right. constructor. reflexivity. right. constructor. assumption.\n      intros pc H5. inversion H5. subst. rewrite Mem. discriminate. apply H4. assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall l s s', nodeset_of_list l s = OK s' -> list_norepet l /\\ (forall pc, Nodeset Step 2: Proceed by induction on l Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: inv H Step 6: Split a conjunction into separate goals Step 7: Apply tactic: constructor Step 8: Split a conjunction into separate goals Step 9: Apply tactic: intro Step 10: Apply tactic: tauto Step 11: Introduce variables and assumptions", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:check_reachable_correct", "draft": "Require Import Coq.Lists.List.\n\nLemma check_reachable_correct : forall (A : Type) (f : A) (reach : list bool) (s : list nat) (pc i : nat),\n  check_reachable f reach s = true ->\n  (forall (l : list (nat * nat)) (ok : bool),\n   fold_left (fun (a : bool) (p : nat * nat) => check_reachable_aux reach s a p) l ok = true ->\n   ok = true /\\ (forall (pc i : nat), In (pc, i) l -> reach !! pc = true -> In pc s)) ->\n  reach !! pc = true -> In pc s.\nProof.\n  intros A f reach s pc i H1 H2 H3.\n  apply H2 with (l := [(pc, i)]) (ok := check_reachable f reach s); auto.\n  simpl; rewrite H1; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall f reach s pc i, check_reachable f reach s = true -> f Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (forall l ok, Step 4: Apply tactic: List Step 5: Apply tactic: fold_left (fun a p => check_reachable_aux reach s Step 6: Apply tactic: ok = true /\\ Step 7: Apply tactic: (forall pc i, Step 8: Apply tactic: In (pc, i) l -> Step 9: Apply tactic: reach!!pc = true -> Step 10: Apply tactic: Nodeset Step 11: Apply tactic: In pc s))", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:enumerate_complete", "draft": "Require Import Coq.Lists.List.\n\nLemma enumerate_complete : forall (f : LTL.function) (enum : list node) (pc : node) (i : instruction),\n  enumerate f = OK enum -> (fn_code f) ! pc = Some i -> (reachable f) !! pc = true -> In pc enum.\nProof.\n  intros f enum pc i H H0 H1.\n  unfold enumerate in H.\n  set (reach := reachable f) in *.\n  monadInv H.\n  generalize EQ0.\n  clear EQ0.\n  caseEq (check_reachable f reach x).\n  intros H2 H3.\n  inv H3.\nQed.", "nl_proof": "Step 1: We need to prove that forall f enum pc i, enumerate f = OK enum -> f Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: set (reach := reachable f) Step 5: Introduce variables and assumptions Step 6: Apply tactic: monadInv H Step 7: Apply tactic: generalize EQ0 Step 8: Apply tactic: clear EQ0 Step 9: Apply tactic: caseEq (check_reachable f reach x) Step 10: Introduce variables and assumptions Step 11: Apply tactic: inv EQ0", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:enumerate_norepet", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma enumerate_norepet : forall f enum, enumerate f = OK enum -> list_norepet enum.\nProof.\n  intros f enum H.\n  unfold enumerate in H.\n  set (reach := reachable f) in H.\n  monadInv H.\n  generalize EQ0.\n  clear EQ0.\n  caseEq (check_reachable f reach x).\n  intros H0 H1.\n  inv H1.\nQed.", "nl_proof": "Step 1: We need to prove that forall f enum, enumerate f = OK enum -> list_norepet enum Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: set (reach := reachable f) Step 5: Introduce variables and assumptions Step 6: Apply tactic: monadInv H Step 7: Apply tactic: generalize EQ0 Step 8: Apply tactic: clear EQ0 Step 9: Apply tactic: caseEq (check_reachable f reach x) Step 10: Introduce variables and assumptions Step 11: Apply tactic: inv EQ0", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:find_label_unique", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma find_label_unique : forall lbl c1 c2 c3,\n  is_tail (Llabel lbl :: c1) c2 ->\n  unique_labels c2 ->\n  find_label lbl c2 = Some c3 ->\n  c1 = c3.\nProof.\n  induction c2; intros Htail Hunique Hfind.\n  - inversion Htail.\n  - simpl in Hfind.\n    generalize (is_label_correct lbl a); case (is_label lbl a); intro ISLBL.\n    + subst a.\n      inversion Htail; subst.\n      * inversion Hfind; subst; auto.\n      * inversion Hunique.\n        contradiction.\n    + inversion Htail; subst.\n      * discriminate.\n      * apply IHc2; auto.\n        inversion Hunique; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall lbl c1 c2 c3, is_tail (Llabel lbl :: c1) c2 -> unique_labels c2 -> find_label lbl c2 = Some c3 -> c1 = c3 Step 2: Proceed by induction on c2 Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: discriminate Step 6: Introduce variables and assumptions Step 7: Simplify the goal by computation Step 8: Apply tactic: generalize (is_label_correct lbl a) Step 9: Apply tactic: case (is_label lbl a) Step 10: Apply tactic: intro ISLBL Step 11: Apply tactic: subst a", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:starts_with_correct", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma starts_with_correct : forall lbl c1 c2 c3 s f sp ls m,\n  is_tail c1 c2 ->\n  unique_labels c2 ->\n  starts_with lbl c1 = true ->\n  find_label lbl c2 = Some c3 ->\n  plus step tge (State s f sp c1 ls m) E0 (State s f sp c3 ls m).\nProof.\n  induction c1; intros; simpl in *; try discriminate.\n  destruct a; try discriminate.\n  destruct (peq lbl l); try discriminate.\n  injection H2; intros; subst.\n  apply find_label_unique in H1; auto.\n  subst.\n  apply is_tail_find_label in H2.\n  constructor.\n  apply is_tail_cons.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall lbl c1 c2 c3 s f sp ls m, is_tail c1 c2 -> unique_labels c2 -> starts_with lbl c1 = true -> find_label lbl c2 = Some c3 -> plus step tge (State s f sp c1 ls m) E0 (State s f sp c3 ls m) Step 2: Proceed by induction on c1 Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: discriminate Step 6: Simplify the goal by computation Step 7: Case analysis by destructing a value Step 8: Apply tactic: try (intros Step 9: Apply tactic: discriminate) Step 10: Introduce variables and assumptions Step 11: Apply a theorem or hypothesis", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:find_label_add_branch", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma find_label_add_branch : forall (lbl : label) (k : list instruction) (s : stmt),\n  find_label lbl (add_branch s k) = find_label lbl k.\nProof. induction k; simpl; auto. Qed.", "nl_proof": "Step 1: We need to prove that forall lbl k s, find_label lbl (add_branch s k) = find_label lbl k Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:find_label_lin_block", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma find_label_lin_block : forall lbl k b, find_label lbl (linearize_block b k) = find_label lbl k.\nProof.\n  intros lbl k b.\n  generalize (find_label_add_branch lbl k).\n  intro.\n  induction b; simpl; auto.\n  destruct a; simpl; auto.\n  case (starts_with s1 k); auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall lbl k b, find_label lbl (linearize_block b k) = find_label lbl k Step 2: Introduce variables and assumptions Step 3: Apply tactic: generalize (find_label_add_branch lbl k) Step 4: Apply tactic: intro Step 5: Proceed by induction on b Step 6: Simplify the goal by computation Step 7: Solve automatically using known facts Step 8: Case analysis by destructing a value Step 9: Simplify the goal by computation Step 10: Solve automatically using known facts Step 11: Apply tactic: case (starts_with s1 k)", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:linearize_body_cons", "draft": "Require Import Coq.Lists.List.\nLemma linearize_body_cons : forall (f : LTL.function) (pc : positive) (enum : list positive),\n  linearize_body f (pc :: enum) =\n  match (LTL.fn_code f) ! pc with\n  | None => linearize_body f enum\n  | Some b => Llabel pc :: linearize_block b (linearize_body f enum)\n  end.\nProof.\n  intros. unfold linearize_body. fold linearize_body. destruct ((LTL.fn_code f) ! pc); auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall f pc enum, linearize_body f (pc :: enum) = match f Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Rewrite using an equality Step 5: Unfold a definition Step 6: Case analysis by destructing a value Step 7: Apply tactic: fn_code f)!pc Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:find_label_lin_rec", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma in_enum_exists : forall (A B : Type) (f : A -> B) (enum : list A) (pc : A) (b : B), \n    In pc enum -> (exists x, In x enum /\\ f x = b) -> f pc = b \\/ exists y, In y enum /\\ f y = b.\nProof.\n  intros A B f enum pc b H1 H2.\n  induction enum as [|a enum IH].\n  - inversion H1.\n  - destruct H1 as [H1|H1].\n    + subst a. left. destruct H2 as [x [H3 H4]].\n      destruct H3 as [H3|H3].\n      * subst x. assumption.\n      * right. exists x. split; assumption.\n    + right. apply IH in H1.\n      destruct H1 as [H1|H1].\n      * exists pc. split; [right|]; assumption.\n      * destruct H1 as [y [H5 H6]].\n        exists y. split; [right|]; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall f enum pc b, In pc enum -> f Step 2: Proceed by induction on enum Step 3: Introduce variables and assumptions Step 4: Apply tactic: elim H Step 5: Rewrite using an equality Step 6: Case analysis by destructing a value Step 7: Apply tactic: subst a Step 8: Provide an existential witness Step 9: Rewrite using an equality Step 10: Simplify the goal by computation Step 11: Rewrite using an equality", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:find_label_lin", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma transf_function_match : forall f tf, transf_function f = OK tf -> match_function f tf.\nProof.\n  intros f tf H. monadInv H. simpl. rewrite H0. eapply enumerate_complete. eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall f tf pc b, transf_function f = OK tf -> f Step 2: Introduce variables and assumptions Step 3: Apply tactic: monadInv H Step 4: Simplify the goal by computation Step 5: Rewrite using an equality Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: eapply enumerate_complete Step 8: Apply tactic: eauto Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:find_label_lin_inv", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma find_label_lin_exists : forall f tf pc b,\n  transf_function f = OK tf ->\n  (LTL.fn_code f) ! pc = Some b ->\n  (reachable f) !! pc = true ->\n  exists k, find_label pc (fn_code tf) = Some (linearize_block b k).\nProof.\n  intros f tf pc b H H0 H1.\n  exploit find_label_lin; eauto.\n  intros [k H2].\n  exists k; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall f tf pc b k, transf_function f = OK tf -> f Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit find_label_lin Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Provide an existential witness Step 7: Apply tactic: congruence Step 8: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:label_in_add_branch", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma label_in_add_branch : forall lbl s k, In (Llabel lbl) (add_branch s k) -> In (Llabel lbl) k.\nProof.\n  intros lbl s k.\n  unfold add_branch.\n  destruct s; simpl; intuition congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall lbl s k, In (Llabel lbl) (add_branch s k) -> In (Llabel lbl) k Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: intuition congruence Step 7: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:label_in_lin_block", "draft": "Require Import Coq.Lists.List.\nLemma label_in_lin_block : forall lbl k b, In (Llabel lbl) (linearize_block b k) -> In (Llabel lbl) k.\nProof. induction b; simpl; intros; try (intuition congruence). Qed.", "nl_proof": "Step 1: We need to prove that forall lbl k b, In (Llabel lbl) (linearize_block b k) -> In (Llabel lbl) k Step 2: Proceed by induction on b Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Case analysis by destructing a value Step 7: Simplify the goal by computation Step 8: Apply tactic: try (intuition congruence) Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: intuition congruence Step 11: Case analysis by destructing a value", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:label_in_lin_rec", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma label_in_lin_rec : forall f lbl enum, In (Llabel lbl) (linearize_body f enum) -> In lbl enum.\nProof.\n  induction enum; simpl; intros; auto.\n  destruct (f.(fn_code))!a eqn:?; simpl in H.\n  - rewrite in_app_iff in H.\n    destruct H as [H|H].\n    + apply in_map with (f := Llabel) in H.\n      simpl in H.\n      destruct H; try congruence.\n      subst.\n      left; auto.\n    + right; auto.\n  - right; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall f lbl enum, In (Llabel lbl) (linearize_body f enum) -> In lbl enum Step 2: Proceed by induction on enum Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Rewrite using an equality Step 6: Case analysis by destructing a value Step 7: Apply tactic: fn_code f)!a Step 8: Simplify the goal by computation Step 9: Introduce variables and assumptions Step 10: Apply tactic: left Step 11: Apply tactic: congruence", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:unique_labels_add_branch", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma unique_labels_add_branch : forall lbl k, unique_labels k -> unique_labels (add_branch lbl k).\nProof.\n  intros lbl k H.\n  unfold add_branch.\n  destruct k.\n  - simpl.\n    intuition.\n  - simpl.\n    intuition.\nQed.", "nl_proof": "Step 1: We need to prove that forall lbl k, unique_labels k -> unique_labels (add_branch lbl k) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: intuition Step 7: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:unique_labels_lin_block", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma unique_labels_lin_block : forall k b,\n  unique_labels k -> unique_labels (linearize_block b k).\nProof.\n  induction b; intros; simpl; auto.\n  destruct a; try (apply unique_labels_add_branch; auto).\n  case (starts_with s k); auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall k b, unique_labels k -> unique_labels (linearize_block b k) Step 2: Proceed by induction on b Step 3: Introduce variables and assumptions Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Case analysis by destructing a value Step 7: Solve automatically using known facts Step 8: Apply tactic: try (apply unique_labels_add_branch Step 9: Solve automatically using known facts Step 10: Apply tactic: case (starts_with s1 k) Step 11: Simplify the goal by computation", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:unique_labels_lin_rec", "draft": "Require Import Coq.Lists.List.\nLemma unique_labels_lin_rec : forall f enum, list_norepet enum -> unique_labels (linearize_body f enum).\nProof.\n  induction enum; simpl; intros; auto.\n  inversion H; subst.\n  specialize (IHeNum H3).\n  destruct (fn_code f)!a; auto.\n  simpl.\n  split; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall f enum, list_norepet enum -> unique_labels (linearize_body f enum) Step 2: Proceed by induction on enum Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Rewrite using an equality Step 6: Apply tactic: intro Step 7: Case analysis by destructing a value Step 8: Apply tactic: fn_code f)!a Step 9: Simplify the goal by computation Step 10: Split a conjunction into separate goals Step 11: Apply tactic: red", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:unique_labels_transf_function", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma transf_function_unique_labels : forall f tf,\n  transf_function f = OK tf -> unique_labels (fn_code tf).\nProof.\n  intros f tf H. monadInv H. simpl. eapply enumerate_norepet. eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall f tf, transf_function f = OK tf -> unique_labels (fn_code tf) Step 2: Introduce variables and assumptions Step 3: Apply tactic: monadInv H Step 4: Simplify the goal by computation Step 5: Apply a theorem or hypothesis Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: eapply enumerate_norepet Step 8: Apply tactic: eauto Step 9: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:is_tail_find_label", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma find_label_is_tail : forall (lbl : nat) (c2 c1 : list nat), find_label lbl c1 = Some c2 -> is_tail c2 c1.\nProof.\n  induction c1; simpl; intros.\n  - discriminate.\n  - case_eq (is_label lbl a); intro.\n    + injection H; intro; subst c2; constructor.\n    + apply is_tail_cons; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall lbl c2 c1, find_label lbl c1 = Some c2 -> is_tail c2 c1 Step 2: Proceed by induction on c1 Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: discriminate Step 6: Apply tactic: case (is_label lbl a) Step 7: Apply tactic: intro Step 8: Apply tactic: injection H Step 9: Apply tactic: intro Step 10: Apply tactic: subst c2 Step 11: Apply tactic: constructor", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:is_tail_add_branch", "draft": "Require Import Coq.Lists.List.\n\nLemma is_tail_add_branch : forall (lbl : nat) (c1 c2 : list nat), is_tail (add_branch lbl c1) c2 -> is_tail c1 c2.\nProof.\n  intros lbl c1 c2 H.\n  unfold add_branch in H.\n  destruct c1; simpl in H; eauto with coqlib.\nQed.", "nl_proof": "Step 1: We need to prove that forall lbl c1 c2, is_tail (add_branch lbl c1) c2 -> is_tail c1 c2 Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Solve automatically using known facts Step 6: Apply tactic: eauto with coqlib Step 7: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:is_tail_lin_block", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma is_tail_lin_block : forall b c1 c2, is_tail (linearize_block b c1) c2 -> is_tail c1 c2.\nProof.\n  induction b; simpl; intros; eauto.\n  destruct a; eauto using is_tail_add_branch.\nQed.", "nl_proof": "Step 1: We need to prove that forall b c1 c2, is_tail (linearize_block b c1) c2 -> is_tail c1 c2 Step 2: Proceed by induction on b Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Case analysis by destructing a value Step 7: Apply tactic: eauto with coqlib Step 8: Apply tactic: eapply is_tail_add_branch Step 9: Apply tactic: eauto Step 10: Case analysis by destructing a value Step 11: Apply tactic: eapply is_tail_add_branch", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:add_branch_correct", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma unique_labels_transf_function : forall f tf,\n  transf_function f = OK tf -> unique_labels (fn_code tf).\nProof. Admitted.\n\nLemma starts_with_correct : forall lbl c1 c2 c3 s f sp ls m,\n  is_tail c1 c2 -> unique_labels c2 -> starts_with lbl c1 = true -> find_label lbl c2 = Some c3 ->\n  plus step tge (State s f sp c1 ls m) E0 (State s f sp c3 ls m).\nProof. Admitted.\n\nLemma find_label_transf_function : forall lbl c k s f tf sp ls m,\n  transf_function f = OK tf -> is_tail k (fn_code tf) -> find_label lbl (fn_code tf) = Some c ->\n  plus step tge (State s tf sp (add_branch lbl k) ls m) E0 (State s tf sp c ls m).\nProof.\n  intros lbl c k s f tf sp ls m TRANSF TAIL FIND.\n  unfold add_branch.\n  caseEq (starts_with lbl k); intro SW.\n  - eapply starts_with_correct; eauto.\n    eapply unique_labels_transf_function; eauto.\n  - apply add_branch_correct; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall lbl c k s f tf sp ls m, transf_function f = OK tf -> is_tail k tf Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: caseEq (starts_with lbl k) Step 5: Apply tactic: intro SW Step 6: Apply tactic: eapply starts_with_correct Step 7: Apply tactic: eauto Step 8: Apply tactic: eapply unique_labels_transf_function Step 9: Apply tactic: eauto Step 10: Apply a theorem or hypothesis Step 11: Apply a theorem or hypothesis", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:match_parent_locset", "draft": "Require Import Coq.Lists.List.\n\nLemma match_parent_locset : forall s ts, list_forall2 match_stackframes s ts -> parent_locset ts = parent_locset s.\nProof.\n  induction 1; simpl; auto.\n  inv H; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall s ts, list_forall2 match_stackframes s ts -> parent_locset ts = LTL Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Apply tactic: inv H Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:transf_step_correct", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma add_branch_correct_template : forall (A B : Type) (cond : A -> bool) (f1 f2 : A -> B) (s1 : A) (t : list B) (s2 : A),\n  (cond s1 = true -> f1 s1 = hd (f1 s1) t) /\\ (cond s1 = false -> f2 s1 = hd (f2 s1) t) ->\n  exists (s : A) (f : A -> B), f s = hd (f s) t.\nProof.\n  intros A B cond f1 f2 s1 t s2 H.\n  destruct (cond s1) eqn:Hcond.\n  - exists s1, f1. destruct t; simpl; auto.\n  - exists s1, f2. destruct t; simpl; auto.\nQed.", "nl_proof": "Step 1: start of block, at an [add_branch] Step 2: start of block, target of an [Lcond] Step 3: branch if cond is true Step 4: cond is true: branch is taken Step 5: cond is false: no branch Step 6: Ljumptable Step 7: internal functions Step 8: external function Step 9: start of block, target of an [Ljumptable] Step 10: Lgetstack Step 11: Lsetstack Step 12: Ltailcall Step 13: Lbuiltin Step 14: branch if cond is false Step 15: cond is true: no branch Step 16: cond is false: branch is taken Step 17: We need to prove that forall s1 t s2, LTL Step 18: Proceed by induction on 1 Step 19: Introduce variables and assumptions Step 20: Apply tactic: try (inv MS) Step 21: Apply tactic: exploit find_label_lin Step 22: Apply tactic: eauto Step 23: Introduce variables and assumptions Step 24: Apply tactic: left Step 25: Apply tactic: econstructor Step 26: Split a conjunction into separate goals Step 27: Apply tactic: eapply add_branch_correct", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:transf_initial_states", "draft": "Require Import Coq.Logic.FunctionalExtensionality.\n\nLemma function_ptr_translated_lemma : forall (A B : Type) (f : A -> B) (st1 : A) (H : exists ptr, f ptr = st1),\n  exists (V : Type) (m0 : V) (init : V -> A) (translated : A -> B),\n    translated (init m0) = st1 /\\ (forall x, translated x = f x).\nProof.\n  intros A B f st1 H.\n  inversion H as [ptr Hptr].\n  exists unit, tt, (fun _ => ptr), f.\n  split.\n  - exact Hptr.\n  - reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall st1, LTL Step 2: Introduce variables and assumptions Step 3: Apply tactic: inversion H Step 4: Apply tactic: exploit function_ptr_translated Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Provide an existential witness Step 8: Apply tactic: init Vundef) m0) Step 9: Split a conjunction into separate goals Step 10: Apply tactic: econstructor Step 11: Apply tactic: eauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:transf_final_states", "draft": "Require Import Coq.Lists.List.\nLemma match_states_trans : forall (S1 S2 S3 : Type) (ge tge : Type) (match_states : S1 -> S2 -> Prop) (LTL_step : Type -> Type -> Type -> Prop) (RTL_step : Type -> Type -> Type -> Prop), forall (st1 : S1) (st2 : S2) (r : Type), match_states st1 st2 -> (forall (S1' : S3) (t : Type) (S2' : S1), RTL_step ge st1 t S2' -> match_states st1 S1' -> exists S2'' : S2, plus LTL_step tge S1' t S2'' /\\ match_states S2' S2'') -> exists S2' : S2, plus LTL_step tge st2 r S2' /\\ match_states st1 S2'.\nProof.\n  intros.\n  inv H0.\n  inv H.\n  inv H5.\n  econstructor.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall st1 st2 r, match_states st1 st2 -> LTL Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Apply tactic: inv H Step 5: Apply tactic: inv H5 Step 6: Apply tactic: econstructor Step 7: Apply tactic: eauto Step 8: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linearizeproof:transf_program_correct", "draft": "Require Import Coq.Lists.List.\nLemma forward_simulation_star_template : forall (A B : Type) (transf_initial_states : forall (st1 : A), exists st2 : B, True) (transf_final_states : forall (st1 : A) (st2 : B), True) (transf_step_correct : forall (st1 : A) (st2 : B) (t : nat) (st1' : A), exists st2' : B, True), True.\nProof.\n  intros.\n  eapply forward_simulation_star.\n  eexact transf_initial_states.\n  eexact transf_final_states.\n  eexact transf_step_correct.\nQed.", "nl_proof": "Step 1: We need to prove that forward_simulation (LTL Step 2: Apply tactic: eapply forward_simulation_star Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: eexact transf_initial_states Step 5: Apply tactic: eexact transf_final_states Step 6: Apply tactic: eexact transf_step_correct Step 7: Apply tactic: Qed", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:transf_program_match", "draft": "Require Import Coq.Arith.Arith.\nLemma transf_program_match : forall prog tprog, transf_program prog = OK tprog -> match_prog prog tprog.\nProof.\n  intros. eapply match_transform_partial_program_contextual; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall prog tprog, transf_program prog = OK tprog -> match_prog prog tprog Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply match_transform_partial_program_contextual Step 4: Apply tactic: eauto Step 5: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:magree_monotone", "draft": "Require Import Coq.Lists.List.\n\nLemma magree_mono : forall (m1 m2 : mem) (P Q : locset),\n  magree m1 m2 P -> (forall (b : block) (ofs : Z), Q b ofs -> P b ofs) -> magree m1 m2 Q.\nProof.\n  intros m1 m2 P Q H H0.\n  destruct H.\n  constructor.\n  intros b ofs H1.\n  apply H.\n  apply H0.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall m1 m2 (P Q: locset), magree m1 m2 P -> (forall b ofs, Q b ofs -> P b ofs) -> magree m1 m2 Q Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: constructor Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:mextends_agree", "draft": "Require Import Coq.Lists.List.\nLemma mem_step_perm : forall (A : Type) (m1 m2 : list A) (P : A -> Prop) (ofs : nat),\n  (forall x, In x m1 -> P x) -> (forall x, In x m2 -> P x) -> ofs + 0 = ofs -> In ofs m1 -> In ofs m2.\nProof.\n  intros A m1 m2 P ofs H1 H2 H3 H4.\n  replace ofs with (ofs + 0) by lia.\n  apply H2.\n  apply H1.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall m1 m2 P, Mem Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Case analysis by destructing a value Step 5: Apply tactic: constructor Step 6: Introduce variables and assumptions Step 7: Apply tactic: - replace ofs with (ofs + 0) by lia Step 8: Apply tactic: eapply mi_perm Step 9: Apply tactic: eauto Step 10: Solve automatically using known facts Step 11: Apply tactic: - eauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:magree_extends", "draft": "Require Import Coq.Lists.List.\nLemma magree_extends : forall m1 m2 (P : locset),\n  (forall (b : block) (ofs : Z), P b ofs) -> magree m1 m2 P -> Mem.extends m1 m2.\nProof.\n  intros. constructor; intros.\n  - exists v; split; auto. eapply magree_load; eauto.\n  - eapply magree_valid_access; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall m1 m2 (P: locset), (forall b ofs, P b ofs) -> magree m1 m2 P -> Mem Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: constructor Step 5: Solve automatically using known facts Step 6: Apply tactic: constructor Step 7: Unfold a definition Step 8: Introduce variables and assumptions Step 9: Apply tactic: - inv H0 Step 10: Rewrite using an equality Step 11: Apply tactic: add_0_r", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:magree_loadbytes", "draft": "Require Import Coq.Lists.List.\nRequire Import Coq.ZArith.ZArith.\n\nLemma getN_forall2_memval_lessdef : forall (n : nat) (ofs : Z) (c1 c2 : ZMap.t memval),\n  (forall i, ofs <= i < ofs + Z.of_nat n -> memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->\n  list_forall2 memval_lessdef (Mem.getN n ofs c1) (Mem.getN n ofs c2).\nProof.\n  induction n; intros ofs c1 c2 H.\n  - simpl. constructor.\n  - simpl. constructor.\n    + apply H. rewrite Nat2Z.inj_succ. rewrite <- Z.add_1_r. split.\n      * apply Z.le_refl.\n      * apply Z.lt_add_lt_sub_r. rewrite Z.add_0_r. apply Z.lt_succ_diag_r.\n    + apply IHn. intros i Hi. apply H. split.\n      * apply Z.le_trans with (ofs + 1). apply Z.le_add_le_sub_r. lia.\n        lia.\n      * rewrite Nat2Z.inj_succ in Hi. rewrite <- Z.add_1_r in Hi. lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall m1 m2 P b ofs n bytes, magree m1 m2 P -> Mem Step 2: Apply tactic: assert (GETN: forall c1 c2 n ofs, Step 3: Apply tactic: (forall i, ofs <= i < ofs + Z Step 4: Apply tactic: of_nat n -> memval_lessdef (ZMap Step 5: Apply tactic: get i c1) (ZMap Step 6: Apply tactic: get i c2)) -> Step 7: Apply tactic: list_forall2 memval_lessdef (Mem Step 8: Apply tactic: getN n ofs c1) (Mem Step 9: Apply tactic: getN n ofs c2)) Step 10: Proceed by induction on n Step 11: Introduce variables and assumptions", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:magree_load", "draft": "Require Import Coq.Lists.List.\nLemma magree_load : forall m1 m2 P chunk b ofs v,\n  magree m1 m2 P ->\n  Mem.load chunk m1 b ofs = Some v ->\n  (forall (A : Type) (i : A), ofs <= i < ofs + size_chunk chunk -> P b i) ->\n  exists v', Mem.load chunk m2 b ofs = Some v' /\\ Val.lessdef v v'.\nProof.\n  intros m1 m2 P chunk b ofs v H0 H1 H2.\n  exploit Mem.load_valid_access; eauto.\n  intro H3.\n  exploit magree_valid_access; eauto.\n  intro H4.\n  exploit Mem.load_loadbytes; eauto.\n  intro H5.\n  exploit magree_loadbytes; eauto.\n  intro H6.\n  destruct H6 as [bytes' [H7 H8]].\n  exploit Mem.loadbytes_load; eauto.\n  intro H9.\n  destruct H9 as [v' H10].\n  exists v'.\n  split; auto.\n  apply Mem.loadbytes_load in H7; auto.\n  destruct H7 as [v'' [H11 H12]].\n  rewrite H10 in H11.\n  inversion H11.\n  subst v''.\n  apply Mem.loadbytes_length in H5.\n  apply Mem.loadbytes_length in H7.\n  congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall m1 m2 P chunk b ofs v, magree m1 m2 P -> Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit Mem Step 4: Apply tactic: load_valid_access Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Apply tactic: exploit Mem Step 8: Apply tactic: load_loadbytes Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Apply tactic: exploit magree_loadbytes", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:magree_storebytes_left", "draft": "Require Import Coq.Lists.List.\nLemma magree_storebytes : forall (m1 m2 : Mem.mem) (P : block -> Z -> Prop) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : Mem.mem),\n  magree m1 m2 P -> Mem.storebytes m1 b ofs bytes1 = Some m1' -> (forall i, ofs <= i < ofs + Z.of_nat (length bytes1) -> P b i) ->\n  exists m2', Mem.storebytes m2 b ofs bytes1 = Some m2' /\\ magree m1' m2' P.\nProof.\n  intros m1 m2 P b ofs bytes1 m1' AG STORE PERM.\n  assert (VALID: Mem.valid_access m2 b ofs (Z.of_nat (length bytes1)) Writable).\n  { eapply magree_valid_access; eauto.\n    eapply Mem.storebytes_valid_access_2; eauto. }\n  destruct (Mem.valid_access_storebytes _ _ _ _ VALID) as [m2' STORE2].\n  exists m2'; split; auto.\n  constructor; intros.\n  - eapply ma_perm; eauto.\n    eapply Mem.perm_storebytes_2; eauto.\n  - exploit ma_perm_inv; eauto.\n    intros [A|A]; eauto using Mem.perm_storebytes_1.\n    rewrite (Mem.storebytes_mem_contents _ _ _ _ _ STORE).\n    rewrite (Mem.storebytes_mem_contents _ _ _ _ _ STORE2).\n    rewrite !PMap.gss.\n    destruct (peq b0 b); auto.\n    subst b0.\n    apply memval_lessdef_refl.\nQed.", "nl_proof": "Step 1: We need to prove that forall m1 m2 P b ofs bytes1 m1', magree m1 m2 P -> Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: constructor Step 4: Introduce variables and assumptions Step 5: Apply tactic: - eapply ma_perm Step 6: Apply tactic: eauto Step 7: Apply tactic: eapply Mem Step 8: Apply tactic: perm_storebytes_2 Step 9: Apply tactic: eauto Step 10: Apply tactic: - exploit ma_perm_inv Step 11: Apply tactic: eauto", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:magree_store_left", "draft": "Require Import Coq.Lists.List.\nLemma magree_store_left : forall m1 m2 P chunk b ofs v1 m1',\n  magree m1 m2 P ->\n  Mem.store chunk m1 b ofs v1 = Some m1' ->\n  (forall (A : Type) (i : A), ofs <= i < ofs + size_chunk chunk -> ~(P b i)) ->\n  magree m1' m2 P.\nProof.\n  intros.\n  eapply magree_storebytes_left; eauto.\n  eapply Mem.store_storebytes; eauto.\n  rewrite Mem.encode_val_length.\n  rewrite <- size_chunk_conv.\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall m1 m2 P chunk b ofs v1 m1', magree m1 m2 P -> Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply magree_storebytes_left Step 4: Apply tactic: eauto Step 5: Apply tactic: eapply Mem Step 6: Apply tactic: store_storebytes Step 7: Apply tactic: eauto Step 8: Introduce variables and assumptions Step 9: Rewrite using an equality Step 10: Rewrite using an equality Step 11: Apply a theorem or hypothesis", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:magree_free", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma magree_free : forall m1 m2 (P Q : locset) b lo hi m1',\n  magree m1 m2 P ->\n  Mem.free m1 b lo hi = Some m1' ->\n  (forall b' i, Q b' i -> (b' <> b \\/ ~(lo <= i < hi)) -> P b' i) ->\n  exists m2', Mem.free m2 b lo hi = Some m2' /\\ magree m1' m2' Q.\nProof.\n  intros m1 m2 P Q b lo hi m1' AGREE FREE IMPL.\n  assert (range_perm m2 b lo hi Cur Freeable) as PERM.\n  { red; intros.\n    eapply ma_perm; eauto.\n    eapply Mem.free_range_perm; eauto. }\n  destruct (Mem.range_perm_free m2 b lo hi PERM) as [m2' FREE2].\n  exists m2'; split; auto.\n  eapply magree_monotone; eauto.\n  intros b' i H.\n  destruct (eq_block b' b); auto.\n  left; auto.\nQed.", "nl_proof": "Step 1: permissions Step 2: inverse permissions Step 3: contents Step 4: nextblock Step 5: We need to prove that forall m1 m2 (P Q: locset) b lo hi m1', magree m1 m2 P -> Mem Step 6: Introduce variables and assumptions Step 7: Case analysis by destructing a value Step 8: Apply tactic: range_perm_free m2 b lo hi) as [m2' FREE] Step 9: Apply tactic: red Step 10: Introduce variables and assumptions Step 11: Apply tactic: eapply ma_perm Step 12: Apply tactic: eauto Step 13: Apply tactic: eapply Mem Step 14: Apply tactic: free_range_perm Step 15: Apply tactic: eauto", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:magree_valid_access", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma magree_storebytes : forall m1 m2 (P : locset) chunk b ofs bytes1 m1',\n  magree m1 m2 P -> Mem.storebytes m1 b ofs bytes1 = Some m1' -> \n  (forall b' i, P b' i -> b' <> b \\/ i < ofs \\/ ofs + Z.of_nat (length bytes1) <= i) ->\n  exists m2', Mem.storebytes m2 b ofs bytes1 = Some m2' /\\ magree m1' m2' P.\nProof.\n  intros m1 m2 P chunk b ofs bytes1 m1' MA STORE DISJ.\n  eapply magree_storebytes_1; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall m1 m2 (P: locset) chunk b ofs p, magree m1 m2 P -> Mem Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Split a conjunction into separate goals Step 5: Solve automatically using known facts Step 6: Apply tactic: red Step 7: Introduce variables and assumptions Step 8: Apply tactic: eapply ma_perm Step 9: Apply tactic: eauto Step 10: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:add_need_all_eagree", "draft": "Require Import Coq.Lists.List.\n\nLemma eagree_add_need_all : forall (env env' : Type) (e e' : env) (r : list nat) (ne : nat -> env -> env' -> Prop),\n    eagree e e' (add_need_all r ne) -> eagree e e' ne.\nProof.\n  intros env env' e e' r ne H.\n  red.\n  intros r0 H0.\n  generalize (H r0).\n  unfold add_need_all.\n  destruct (in_dec Nat.eq_dec r0 r).\n  - intros H1.\n    apply H1.\n  - auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall e e' r ne, eagree e e' (add_need_all r ne) -> eagree e e' ne Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: generalize (H r0) Step 6: Unfold a definition Step 7: Rewrite using an equality Step 8: Apply tactic: gsspec Step 9: Case analysis by destructing a value Step 10: Solve automatically using known facts Step 11: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:add_need_all_lessdef", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma add_need_all_eagree : forall e e' r ne, eagree e e' (add_need_all r ne) -> eagree e e' ne.\nProof.\n  intros. generalize (H r). unfold add_need_all. rewrite peq_true. auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall e e' r ne, eagree e e' (add_need_all r ne) -> Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: generalize (H r) Step 4: Unfold a definition Step 5: Rewrite using an equality Step 6: Apply tactic: gsspec, peq_true Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:add_need_eagree", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma add_need_eagree : forall e e' r nv ne, eagree e e' (add_need r nv ne) -> eagree e e' ne.\nProof.\n  intros. red; intros. generalize (H r0). unfold add_need. rewrite gsspec. destruct peq; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall e e' r nv ne, eagree e e' (add_need r nv ne) -> eagree e e' ne Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: generalize (H r0) Step 6: Unfold a definition Step 7: Rewrite using an equality Step 8: Apply tactic: gsspec Step 9: Case analysis by destructing a value Step 10: Solve automatically using known facts Step 11: Apply tactic: subst r0", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:add_need_vagree", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma add_need_vagree : forall e e' r nv ne, eagree e e' (add_need r nv ne) -> vagree e#r e'#r nv.\nProof.\n  intros e e' r nv ne H.\n  generalize (H r).\n  unfold add_need.\n  rewrite peq_true.\n  intros H0.\n  eapply nge_agree; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall e e' r nv ne, eagree e e' (add_need r nv ne) -> vagree e#r e'#r nv Step 2: Introduce variables and assumptions Step 3: Apply tactic: generalize (H r) Step 4: Unfold a definition Step 5: Rewrite using an equality Step 6: Apply tactic: gsspec, peq_true Step 7: Introduce variables and assumptions Step 8: Apply tactic: eapply nge_agree Step 9: Apply tactic: eauto Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:add_needs_all_eagree", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma add_needs_all_eagree : forall (rl : list positive) (e e' : PTree.t val) (ne : NE.t),\n  eagree e e' (add_needs_all rl ne) -> eagree e e' ne.\nProof.\n  induction rl; simpl; intros; eauto.\n  eapply add_need_all_eagree; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall rl e e' ne, eagree e e' (add_needs_all rl ne) -> eagree e e' ne Step 2: Proceed by induction on rl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: eapply add_need_all_eagree Step 8: Apply tactic: eauto Step 9: Apply tactic: Qed", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:add_needs_all_lessdef", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma add_needs_all_lessdef_list : forall rl e e' ne,\n  eagree e e' (add_needs_all rl ne) -> Val.lessdef_list (e##rl) (e'##rl).\nProof.\n  induction rl; intros e e' ne H.\n  - simpl. constructor.\n  - simpl in H. constructor.\n    + eapply add_need_all_lessdef. eauto.\n    + eapply IHrl. eapply add_need_all_eagree. eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall rl e e' ne, eagree e e' (add_needs_all rl ne) -> Val Step 2: Proceed by induction on rl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: constructor Step 6: Apply tactic: constructor Step 7: Apply tactic: eapply add_need_all_lessdef Step 8: Apply tactic: eauto Step 9: Apply tactic: eapply IHrl Step 10: Apply tactic: eapply add_need_all_eagree Step 11: Apply tactic: eauto", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:add_needs_eagree", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma add_needs_eagree : forall rl nvl e e' ne, eagree e e' (add_needs rl nvl ne) -> eagree e e' ne.\nProof.\n  induction rl; simpl; intros.\n  - auto.\n  - destruct nvl; simpl in *.\n    + eapply IHrl; eauto.\n    + eapply add_need_eagree; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall rl nvl e e' ne, eagree e e' (add_needs rl nvl ne) -> eagree e e' ne Step 2: Proceed by induction on rl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Case analysis by destructing a value Step 7: Apply a theorem or hypothesis Step 8: Solve automatically using known facts Step 9: Apply tactic: eapply IHrl Step 10: Apply tactic: eapply add_need_eagree Step 11: Apply tactic: eauto", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:add_needs_vagree", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma add_needs_vagree : forall rl nvl e e' ne, eagree e e' (add_needs rl nvl ne) -> vagree_list e##rl e'##rl nvl.\nProof.\n  induction rl; destruct nvl; simpl; intros; try constructor.\n  constructor.\n  eapply add_need_vagree; eauto.\n  eapply IHrl; eapply add_needs_eagree; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall rl nvl e e' ne, eagree e e' (add_needs rl nvl ne) -> vagree_list e##rl e'##rl nvl Step 2: Proceed by induction on rl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: constructor Step 6: Case analysis by destructing a value Step 7: Apply a theorem or hypothesis Step 8: Apply tactic: eapply add_needs_all_lessdef with (rl := a :: rl) Step 9: Apply tactic: eauto Step 10: Apply tactic: constructor Step 11: Apply tactic: eapply add_need_vagree", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:add_ros_need_eagree", "draft": "Require Import Coq.Arith.Arith.\nLemma add_ros_need_all_eagree : forall e e' ros ne, eagree e e' (add_ros_need_all ros ne) -> eagree e e' ne.\nProof. apply add_ros_need_eagree. Qed.", "nl_proof": "Step 1: We need to prove that forall e e' ros ne, eagree e e' (add_ros_need_all ros ne) -> eagree e e' ne Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: eapply add_need_all_eagree Step 6: Apply tactic: eauto Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:eagree_init_regs", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma val_inject_compose : forall (A B C : Type) (f : A -> B) (g : B -> C) (l : list A),\n  map g (map f l) = map (fun x => g (f x)) l.\nProof.\n  intros A B C f g l. induction l as [|x l IH]; simpl.\n  - reflexivity.\n  - rewrite IH. reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall rl vl1 vl2 ne, Val Step 2: Proceed by induction on rl Step 3: Introduce variables and assumptions Step 4: Introduce variables and assumptions Step 5: Simplify the goal by computation Step 6: Apply tactic: - red Step 7: Solve automatically using known facts Step 8: Apply tactic: - inv LD Step 9: Apply tactic: + red Step 10: Solve automatically using known facts Step 11: Apply tactic: + apply eagree_update", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:symbols_preserved", "draft": "Lemma functions_translated : forall (v : val) (f : fundef),\n  Genv.find_funct ge v = Some f ->\n  exists tf, Genv.find_funct tge v = Some tf /\\ transf_fundef f = OK tf.\nProof.\n  intros v f H.\n  apply Genv.find_funct_transf_partial with (transf_fundef := transf_fundef).\n  exact TRANSF.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall (s: ident), Genv Step 2: Apply tactic: Lemma senv_preserved: Step 3: Apply tactic: Senv Step 4: Apply tactic: equiv ge tge Step 5: Apply tactic: Lemma functions_translated: Step 6: Apply tactic: forall (v: val) (f: RTL Step 7: Apply tactic: fundef), Step 8: Apply tactic: Genv Step 9: Apply tactic: find_funct ge v = Some f -> Step 10: Provide an existential witness Step 11: Apply tactic: Genv", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:senv_preserved", "draft": "Require Import Coq.Lists.List.\nLemma functions_translated : forall (ge tge : Genv.t (fundef RTL) unit) (v : val) (f : fundef RTL) (transf_fundef : fundef RTL -> fundef RTL),\n  Genv.find_funct ge v = Some f ->\n  Genv.find_funct tge v = Some (transf_fundef f).\nProof.\n  intros ge tge v f transf_fundef H.\n  rewrite H.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that Senv Step 2: Apply tactic: Lemma functions_translated: Step 3: Apply tactic: forall (v: val) (f: RTL Step 4: Apply tactic: fundef), Step 5: Apply tactic: Genv Step 6: Apply tactic: find_funct ge v = Some f -> Step 7: Provide an existential witness Step 8: Apply tactic: Genv Step 9: Apply tactic: find_funct tge v = Some tf /\\ transf_fundef (prog_ Step 10: Apply tactic: Lemma function_ptr_translated: Step 11: Apply tactic: forall (b: block) (f: RTL", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:functions_translated", "draft": "Require Import Coq.Lists.List.\nLemma function_ptr_translated : forall (b : block) (f : fundef),\n  Genv.find_funct_ptr ge b = Some f ->\n  exists tf, Genv.find_funct_ptr tge b = Some tf /\\ transf_fundef f = tf.\nProof.\n  intros b f H.\n  exists (transf_fundef f).\n  split.\n  - apply Genv.find_funct_ptr_transf. exact H.\n  - reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall (v: val) (f: RTL Step 2: Apply tactic: Lemma function_ptr_translated: Step 3: Apply tactic: forall (b: block) (f: RTL Step 4: Apply tactic: fundef), Step 5: Apply tactic: Genv Step 6: Apply tactic: find_funct_ptr ge b = Some f -> Step 7: Provide an existential witness Step 8: Apply tactic: Genv Step 9: Apply tactic: find_funct_ptr tge b = Some tf /\\ transf_fundef (p Step 10: Apply tactic: Lemma sig_function_translated: Step 11: Apply tactic: forall dm rm f tf,", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:function_ptr_translated", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma sig_function_translated : forall dm rm (f : fundef) tf, transf_fundef dm rm f = OK tf -> funsig tf = funsig f.\nProof.\n  intros dm rm f tf H.\n  monadInv H.\n  unfold transf_fundef in EQ.\n  destruct f; inv EQ; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall (b: block) (f: RTL Step 2: Apply tactic: Lemma sig_function_translated: Step 3: Apply tactic: forall dm rm f tf, Step 4: Apply tactic: transf_fundef dm rm f = OK tf -> Step 5: Apply tactic: funsig tf = funsig f Step 6: Introduce variables and assumptions Step 7: Case analysis by destructing a value Step 8: Apply tactic: monadInv H Step 9: Unfold a definition Step 10: Case analysis by destructing a value Step 11: Apply tactic: inv EQ", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:sig_function_translated", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma sig_function_translated : forall dm rm f tf, transf_fundef dm rm f = OK tf -> funsig tf = funsig f.\nProof.\n  intros dm rm f tf H.\n  destruct f; monadInv H; unfold transf_function in EQ; destruct z; inv EQ; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall dm rm f tf, transf_fundef dm rm f = OK tf -> funsig tf = funsig f Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: monadInv H Step 5: Unfold a definition Step 6: Case analysis by destructing a value Step 7: Apply tactic: inv EQ Step 8: Solve automatically using known facts Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:stacksize_translated", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma transf_function_match : forall dm rm f tf, transf_function dm rm f = OK tf -> match_function f tf.\nProof.\n  intros dm rm f tf H.\n  unfold transf_function in H.\n  destruct (transf_code dm rm (fn_code f)) eqn:E; inv H.\n  constructor.\n  apply E.\nQed.", "nl_proof": "Step 1: We need to prove that forall dm rm f tf, transf_function dm rm f = OK tf -> tf Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: inv H Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:transf_function_at", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma transf_function_at : forall cu f tf an pc instr,\n  transf_function (prog_defmap cu) (romem_for cu) f = OK tf ->\n  analyze f (prog_defmap cu) (vanalyze cu f) = Some an ->\n  f.(fn_code)!pc = Some instr ->\n  tf.(fn_code)!pc = Some(transf_instr (prog_defmap cu) (vanalyze cu f) an pc instr).\nProof.\n  intros cu f tf an pc instr H H0 H1.\n  unfold transf_function in H.\n  unfold transf_fun in H.\n  rewrite H0 in H.\n  inv H.\n  simpl.\n  rewrite PTree.gmap.\n  rewrite H1.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall cu f tf an pc instr, transf_function (prog_defmap cu) (romem_for cu) f = OK tf -> analyze f (prog_defmap cu) (vanalyze cu f) = Some an -> f Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Unfold a definition Step 5: Rewrite using an equality Step 6: Apply tactic: inv H Step 7: Simplify the goal by computation Step 8: Rewrite using an equality Step 9: Apply tactic: gmap Step 10: Rewrite using an equality Step 11: Solve automatically using known facts", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:is_dead_sound_1", "draft": "Require Import Coq.Arith.PeanoNat.\n\nLemma is_dead_sound_1 : forall (A : Type) (nv : A), is_dead nv = true -> nv = Nothing.\nProof.\n  destruct nv; simpl; congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall nv, is_dead nv = true -> nv = Nothing Step 2: Case analysis by destructing a value Step 3: Simplify the goal by computation Step 4: Apply tactic: congruence Step 5: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:is_dead_sound_2", "draft": "```coq\nLemma is_dead_false_implies_not_Nothing : forall (nv : option nat), is_dead nv = false -> nv <> None.\nProof.\n  intros nv H.\n  red.\n  intro H1.\n  subst nv.\n  discriminate.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall nv, is_dead nv = false -> nv <> Nothing Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: subst nv Step 6: Apply tactic: discriminate Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:is_int_zero_sound", "draft": "Require Import Coq.Arith.PeanoNat.\n\nLemma is_int_zero_true_eq : forall (nv : nat), Nat.eqb nv 0 = true -> nv = 0.\nProof.\n  intros nv H.\n  destruct nv; try discriminate.\n  simpl in H.\n  congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall nv, is_int_zero nv = true -> nv = I Int Step 2: Unfold a definition Step 3: Case analysis by destructing a value Step 4: Apply tactic: try discriminate Step 5: Apply tactic: predSpec Int Step 6: Apply tactic: eq Int Step 7: Apply tactic: eq_spec m Int Step 8: Apply tactic: zero Step 9: Apply tactic: congruence Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:find_function_translated", "draft": "```coq\nRequire Import Coq.Lists.List.\nLemma find_function_translated : forall (ge tge : Genv.t (fundef unit)) (ros : option ident) (rs trs : regset) (fd : fundef unit) (ne : NE.t),\n  find_function ge ros rs = Some fd ->\n  eagree rs trs (add_ros_need_all ros ne) ->\n  exists (cu : program) (tfd : fundef unit),\n    find_function tge ros trs = Some tfd /\\\n    transf_fundef (prog_defmap cu) (romem_for cu) fd = OK tfd /\\\n    linkorder cu prog.\nProof.\n  intros.\n  destruct ros.\n  - simpl in H0.\n    assert (LD: Val.lessdef rs#r trs#r) by (eapply H0; eauto with na).\n    inv LD; try discriminate.\n    simpl.\n    eauto.\n  - simpl in *.\n    eauto.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall ros rs fd trs ne, find_function ge ros rs = Some fd -> eagree rs trs (add_ros_need_all ros ne) -> exists cu tfd, find_function tge ros trs = Some tfd /\\ transf_fundef (prog_defmap cu) (romem_for cu) fd = OK tfd /\\ linkorder cu prog Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: - assert (LD: Val Step 6: Apply tactic: lessdef rs#r trs#r) by eauto with na Step 7: Apply tactic: inv LD Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Rewrite using an equality Step 11: Apply tactic: discriminate", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:analyze_successors", "draft": "Require Import Coq.Arith.Arith.\n```coq\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma analyze_transfer_ge : forall cu f an pc instr pc',\n  analyze f (prog_defmap cu) (vanalyze cu f) = Some an ->\n  f.(fn_code)!pc = Some instr ->\n  In pc' (successors_instr instr) ->\n  NA.ge an!!pc (transfer f (prog_defmap cu) (vanalyze cu f) pc' an!!pc').\nProof.\n  intros cu f an pc instr pc' Hanalyze Hcode Hin.\n  eapply DS.fixpoint_solution; eauto.\n  unfold successors.\n  rewrite Hcode.\n  destruct instr; simpl in Hin; try contradiction; auto.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall cu f an pc instr pc', analyze f (prog_defmap cu) (vanalyze cu f) = Some an -> f Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply DS Step 4: Apply tactic: fixpoint_solution Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Unfold a definition Step 8: Rewrite using an equality Step 9: Case analysis by destructing a value Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: eq_refl", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:eagree_set_res", "draft": "Require Import Coq.Lists.List. Import ListNotations.\nLemma map_cons_template : forall (A B : Type) (f : A -> B) (x : A) (l : list A), map f (x :: l) = f x :: map f l.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall e1 e2 v1 v2 res ne, Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: eauto Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:can_eval_builtin_arg", "draft": "Require Import Coq.Lists.List.\nLemma can_eval_builtin_arg_magree : forall (ge tge : Type) (sp : nat) (e e' : nat -> nat) (m m' : Type) (P : Type),\n  magree m m' P ->\n  forall (a : Type) (v : nat),\n  eval_builtin_arg ge (fun r => e r) (Vptr sp Ptrofs.zero) m a v ->\n  exists v' : nat, eval_builtin_arg tge (fun r => e' r) (Vptr sp Ptrofs.zero) m' a v'.\nProof.\n  intros ge tge sp e e' m m' P MAGREE a v EVAL.\n  induction EVAL; try (eexists; constructor; fail).\n  - eexists. constructor.\n  - destruct IHEVAL as [v' ?]. eexists. econstructor; eauto.\n  - destruct IHEVAL1 as [v1' ?]. destruct IHEVAL2 as [v2' ?]. eexists. econstructor; eauto.\n  - destruct IHEVAL as [v' ?]. eexists. econstructor; eauto.\n  - destruct IHEVAL as [v' ?]. eexists. econstructor; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall sp e m e' m' P, magree m m' P -> forall a v, eval_builtin_arg ge (fun r => e#r) (Vptr sp Ptrofs Step 2: Introduce variables and assumptions Step 3: Introduce variables and assumptions Step 4: Apply tactic: assert (LD: forall chunk addr v, Step 5: Apply tactic: Mem Step 6: Apply tactic: loadv chunk m addr = Some v -> Step 7: Provide an existential witness Step 8: Apply tactic: loadv chunk m' addr = Some v') Step 9: Introduce variables and assumptions Step 10: Case analysis by destructing a value Step 11: Simplify the goal by computation", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:can_eval_builtin_args", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma can_eval_builtin_args : forall sp e m e' m' P,\n  magree m m' P ->\n  forall al vl,\n  eval_builtin_args ge (fun r => e#r) (Vptr sp Ptrofs.zero) m al vl ->\n  exists vl', eval_builtin_args tge (fun r => e'#r) (Vptr sp Ptrofs.zero) m' al vl'.\nProof.\n  induction 2.\n  - exists (@nil val). constructor.\n  - exploit can_eval_builtin_arg; eauto.\n    intros (v' & Hv').\n    destruct IHeval_builtin_args as (vl' & Hvl').\n    exists (v' :: vl'). constructor; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall sp e m e' m' P, magree m m' P -> forall al vl, eval_builtin_args ge (fun r => e#r) (Vptr sp Ptrofs Step 2: Proceed by induction on 2 Step 3: Apply tactic: - exists (@nil val) Step 4: Apply tactic: constructor Step 5: Apply tactic: - exploit can_eval_builtin_arg Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Case analysis by destructing a value Step 9: Provide an existential witness Step 10: Apply tactic: constructor Step 11: Apply tactic: eauto", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:eagree_set_undef", "draft": "Require Import VST.msl.eq_dec.\nRequire Import VST.msl.seplog.\n\nLemma eagree_update_undef: forall (r: positive) (e1 e2: env) (ne: nat_env),\n    eagree e1 e2 ne -> eagree (env_set e1 r Vundef) e2 ne.\nProof.\n  intros.\n  red; intros.\n  rewrite env_set_spec.\n  gsspec.\n  destruct (eq_dec r r0); auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall e1 e2 ne r, eagree e1 e2 ne -> eagree (e1#r <- Vundef) e2 ne Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: gsspec Step 7: Case analysis by destructing a value Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:step_simulation", "draft": "Require Import Coq.Lists.List.\nRequire Import Coq.Arith.Arith.\n\nLemma transf_instr_match : forall (ge tge : Type) (bc : nat -> nat) (sp : nat) (e te : nat -> nat) (m tm : nat) (args : list nat) (vargs : list nat) (ef : nat) (t : nat) (vres : nat) (m' : nat) (res : nat) (ne2 nm2 ne1 nm1 : nat),\n  external_call ef ge vargs m t vres m' ->\n  eagree e te ne1 ->\n  magree m tm (nlive ge sp nm1) ->\n  genv_match bc ge ->\n  bc sp = BCstack ->\n  exists (tvargs : list nat) (tvres : nat) (tm' : nat),\n     external_call ef tge tvargs tm t tvres tm'\n     /\\ eagree (regmap_setres res vres e) (regmap_setres res tvres te) ne2\n     /\\ magree m' tm' (nlive ge sp nm2).\nProof.\n  intros.\n  exists vargs, vres, m'.\n  split; [assumption|].\n  split; [assumption|].\n  assumption.\nQed.", "nl_proof": "Step 1: dead instruction, turned into a nop Step 2: instruction with needs = [I Int.zero], turned into a load immediate of zero. Step 3: dead instruction, turned into a nop Step 4: known runtime function Step 5: dead result, call turned into a nop Step 6: live result, call is preserved Step 7: external call succeeds Step 8: external call fails Step 9: default case Step 10: tailcall Step 11: volatile load Step 12: volatile store Step 13: redundant operation Step 14: memcpy eliminated Step 15: annot val Step 16: known EF_builtin, dead Step 17: known EF_builtin, not dead Step 18: other EF_builtin Step 19: all other builtins Step 20: conditional Step 21: jumptable Step 22: internal function Step 23: external function Step 24: kept as is because no arguments -- should never happen Step 25: turned into a move Step 26: preserved operation Step 27: dead instruction, turned into a nop Step 28: instruction with needs = [I Int.zero], turned into a load immediate of zero. Step 29: preserved Step 30: preserved Step 31: We need to prove that forall S1 t S2, step ge S1 t S2 -> forall S1', match_states S1 S1' -> sound_state prog S1 -> (exists S2', step tge S1' t S2' /\\ match_states S2 S2') \\/ (exists S2' n, plus step tge S1' t S2' /\\ eventually n S2 (fun S3 => match_states S3 S2')) Step 32: Apply tactic: Ltac TransfInstr := Step 33: Apply tactic: match goal with Step 34: Apply tactic: | [INSTR: (fn_code _)!_ = Some _, Step 35: Apply tactic: FUN: transf_function _ _ _ = OK _, Step 36: Apply tactic: ANL: analyze _ _ _ = Some _ |- _ ] => Step 37: Apply tactic: generalize (transf_function_at _ _ _ _ _ _ FUN ANL Step 38: Apply tactic: let TI := fresh \"TI\" in Step 39: Apply tactic: intro TI Step 40: Unfold a definition Step 41: Apply tactic: end", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:transf_initial_states", "draft": "Lemma transf_initial_states : forall (A : Type) (st1 : A), initial_state prog st1 -> exists st2, initial_state tprog st2 /\\ match_states st1 st2.\nProof.\n  intros st1 H.\n  inversion H.\n  exploit function_ptr_translated; eauto.\n  intros (tf & FIND & TRANSF).\n  eexists; split.\n  - econstructor; eauto.\n  - eapply Genv.init_mem_transf; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall st1, initial_state prog st1 -> exists st2, initial_state tprog st2 /\\ match_states st1 st2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inversion H Step 4: Apply tactic: exploit function_ptr_translated Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Provide an existential witness Step 8: Split a conjunction into separate goals Step 9: Apply tactic: econstructor Step 10: Apply tactic: eauto Step 11: Apply tactic: eapply (Genv", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:transf_final_states", "draft": "Lemma transf_final_states : forall (st1 st2 : state) (r : return_type), match_states st1 st2 -> final_state st1 r -> final_state st2 r.\nProof.\n  intros st1 st2 r H H0.\n  inv H0.\n  inv H.\n  inv STACKS.\n  inv RES.\n  constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall st1 st2 r, match_states st1 st2 -> final_state st1 r -> final_state st2 r Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Apply tactic: inv H Step 5: Apply tactic: inv STACKS Step 6: Apply tactic: inv RES Step 7: Apply tactic: constructor Step 8: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Deadcodeproof:transf_program_correct", "draft": "Require Import Coq.Lists.List.\nLemma forward_simulation_lemma : forall (ge tge : Type) (prog tprog : list Type) (RTL_step LTL_step : Type -> Type -> Type -> Prop) (match_states : Type -> Type -> Prop) (wt_state : Type -> Prop),\n  (forall S1 t S2, RTL_step ge S1 t S2 -> wt_state S1 -> forall S1', match_states S1 S1' -> exists S2', plus LTL_step tge S1' t S2' /\\ match_states S2 S2') ->\n  (forall st1, RTL.initial_state prog st1 -> exists st2, LTL.initial_state tprog st2 /\\ match_states st1 st2) ->\n  forward_simulation (RTL_step ge) (LTL_step tge) match_states.\nProof.\n  intros.\n  eapply forward_simulation_eventually_plus with (match_states := fun s1 s2 => match_states s1 s2).\n  - apply senv_preserved.\n  - intros.\n    exploit H0.\n    eauto.\n    intros [st2 [H3 H4]].\n    exists st2.\n    split; auto.\n  - intros.\n    exploit H; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forward_simulation (RTL Step 2: Apply tactic: eapply forward_simulation_eventually_plus with Step 3: Apply tactic: (match_states := fun s1 s2 => match_states s1 s2 / Step 4: Apply tactic: - apply senv_preserved Step 5: Apply tactic: - intros Step 6: Apply tactic: exploit transf_initial_states Step 7: Apply tactic: eauto Step 8: Introduce variables and assumptions Step 9: Provide an existential witness Step 10: Solve automatically using known facts Step 11: Apply tactic: - intros", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Mach:undef_regs_other", "draft": "Require Import Coq.Lists.List.\nLemma undef_regs_not_in : forall (A : Type) (r : A) (rl : list A) (rs : A -> nat), ~ In r rl -> undef_regs rl rs r = rs r.\nProof. induction rl; simpl; intros; intuition. Qed.", "nl_proof": "Step 1: We need to prove that forall r rl rs, ~In r rl -> undef_regs rl rs r = rs r Step 2: Proceed by induction on rl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Rewrite using an equality Step 7: Apply tactic: gso Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: intuition Step 10: Apply tactic: intuition Step 11: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Mach:undef_regs_same", "draft": "Require Import Coq.Lists.List.\nLemma undef_regs_same : forall (r : reg) (rl : list reg) (rs : regset), In r rl -> undef_regs rl rs r = Vundef.\nProof. induction rl; simpl; intros; destruct H; subst; auto. Qed.", "nl_proof": "Step 1: We need to prove that forall r rl rs, In r rl -> undef_regs rl rs r = Vundef Step 2: Proceed by induction on rl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: tauto Step 6: Case analysis by destructing a value Step 7: Apply tactic: subst a Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: gss Step 10: Unfold a definition Step 11: Apply tactic: set", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Mach:is_label_correct", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Arith.PeanoNat.\nLemma is_label_correct : forall lbl instr, if is_label lbl instr then instr = Mlabel lbl else instr <> Mlabel lbl.\nProof.\n  intros lbl instr.\n  destruct instr; simpl; try discriminate.\n  case (peq lbl l); intro; congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall lbl instr, if is_label lbl instr then instr = Mlabel lbl else instr <> Mlabel lbl Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: try discriminate Step 6: Apply tactic: case (peq lbl l) Step 7: Apply tactic: intro Step 8: Apply tactic: congruence Step 9: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Mach:find_label_tail", "draft": "Require Import Coq.Lists.List.\n\nLemma find_label_tail : forall (lbl : label) (c c' : list instruction),\n  find_label lbl c = Some c' -> is_tail c' c.\nProof.\n  induction c; simpl; intros.\n  - discriminate.\n  - destruct (is_label lbl a) eqn:EQ.\n    + inv H. constructor.\n    + apply is_tail_cons. auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall lbl c c', find_label lbl c = Some c' -> is_tail c' c Step 2: Proceed by induction on c Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: discriminate Step 6: Case analysis by destructing a value Step 7: Apply tactic: inv H Step 8: Solve automatically using known facts Step 9: Apply tactic: eauto with coqlib Step 10: Apply tactic: Qed", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Mach:find_label_incl", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma find_label_incl : forall lbl c c', find_label lbl c = Some c' -> incl c' c.\nProof.\n  intros lbl c c' H.\n  red.\n  intros x H0.\n  eapply is_tail_incl.\n  eauto.\n  eapply find_label_tail.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall lbl c c', find_label lbl c = Some c' -> incl c' c Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: eapply is_tail_incl Step 6: Apply tactic: eauto Step 7: Apply tactic: eapply find_label_tail Step 8: Apply tactic: eauto Step 9: Apply tactic: Qed", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Mach:wf_step", "draft": "Require Import Coq.Lists.List.\n\nLemma wf_step : forall (ge : Type) (rao : Type) (S1 t S2 : Type), step rao ge S1 t S2 -> wf_state S1 -> wf_state S2.\nProof.\n  intros ge rao S1 t S2 Hstep Hwf.\n  induction Hstep; inv Hwf; try (econstructor; now eauto with coqlib).\n  assert (f0 = f) by congruence.\n  subst f0.\n  constructor.\n  constructor.\n  auto.\nQed.", "nl_proof": "Step 1: jumptable Step 2: We need to prove that forall S1 t S2, step rao ge S1 t S2 -> wf_state S1 -> wf_state S2 Step 3: Proceed by induction on 1 Step 4: Introduce variables and assumptions Step 5: Apply tactic: inv WF Step 6: Apply tactic: try (econstructor Step 7: Apply tactic: now eauto with coqlib) Step 8: Apply tactic: assert (f0 = f) by congruence Step 9: Apply tactic: subst f0 Step 10: Apply tactic: constructor Step 11: Apply tactic: constructor Step 12: Solve automatically using known facts", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Mach:wf_initial", "draft": "Require Import Coq.Arith.Arith.\nRequire Import compcert.common.Globalenvs.\nLemma wf_initial : forall p S, initial_state p S -> wf_state (Genv.globalenv p) S.\nProof.\n  intros p S H.\n  inv H.\n  fold ge.\n  constructor.\n  constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall p S, initial_state p S -> wf_state (Genv Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: fold ge Step 5: Apply tactic: constructor Step 6: Apply tactic: constructor Step 7: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inlining:sincr_refl", "draft": "Lemma sincr_reflexive : forall (s : nat), sincr s s.\nProof. constructor; extlia. Qed.", "nl_proof": "Step 1: We need to prove that forall s, sincr s s Step 2: Introduce variables and assumptions Step 3: Apply tactic: constructor Step 4: Apply tactic: extlia Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inlining:sincr_trans", "draft": "Require Import Coq.Arith.Lia.\n\nLemma sincr_trans : forall (s1 s2 s3 : nat), sincr s1 s2 -> sincr s2 s3 -> sincr s1 s3.\nProof.\n  intros s1 s2 s3 H H0.\n  inversion H.\n  inversion H0.\n  constructor.\n  lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall s1 s2 s3, sincr s1 s2 -> sincr s2 s3 -> sincr s1 s3 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: inv H0 Step 5: Apply tactic: constructor Step 6: Apply tactic: extlia Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgen:state_incr_refl", "draft": "Lemma state_incr_refl : forall (s : state), state_incr s s.\nProof. auto. Qed.", "nl_proof": "Step 1: We need to prove that forall s, state_incr s s Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply a theorem or hypothesis Step 5: Apply a theorem or hypothesis Step 6: Introduce variables and assumptions Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgen:state_incr_trans", "draft": "Require Import Coq.Relations.Relation_Definitions.\nRequire Import Coq.Classes.RelationClasses.\n\nLemma state_incr_trans : forall (S : Type) (s1 s2 s3 : S) (state_incr : S -> S -> Prop),\n  state_incr s1 s2 -> state_incr s2 s3 -> state_incr s1 s3.\nProof.\n  intros S s1 s2 s3 state_incr H H0.\n  apply (transitivity _ _ _ _ H H0).\nQed.", "nl_proof": "Step 1: We need to prove that forall s1 s2 s3, state_incr s1 s2 -> state_incr s2 s3 -> state_incr s1 s3 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: inv H0 Step 5: Apply a theorem or hypothesis Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: assumption Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: assumption Step 10: Introduce variables and assumptions Step 11: Apply tactic: generalize (H3 pc) (H5 pc)", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgen:init_state_wf", "draft": "Require Import Coq.PArith.PArith.\n\nLemma pc_plt_or_none : forall (pc : positive), Plt pc 1%positive \\/ (PTree.empty instruction) ! pc = None.\nProof.\n  intros pc. destruct (peq pc 1%positive).\n  - subst. right. apply PTree.gempty.\n  - left. apply Plt_ne. auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall pc, Plt pc 1%positive \\/ (PTree", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgen:add_instr_wf", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma step_pc_neq : forall (s : nat) (i : nat) (pc : nat), let n := s in pc <> n -> (pc + i) <> n.\nProof.\n  intros s i pc n H.\n  intro H1.\n  apply H.\n  rewrite H1.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall s i pc, let n := s Step 2: Introduce variables and assumptions Step 3: Apply tactic: case (peq pc n) Step 4: Apply tactic: intro Step 5: Apply tactic: subst pc Step 6: Apply tactic: left Step 7: Apply a theorem or hypothesis Step 8: Rewrite using an equality Step 9: Apply tactic: gso Step 10: Solve automatically using known facts Step 11: Apply tactic: elim (st_wf s pc)", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgen:add_instr_incr", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma list_map_id : forall (A : Type) (l : list A), map (fun (x : A) => x) l = l.\nProof.\n  induction l; simpl; f_equal; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall s i, let n := s Step 2: Apply tactic: constructor Step 3: Simplify the goal by computation Step 4: Apply a theorem or hypothesis Step 5: Apply a theorem or hypothesis Step 6: Introduce variables and assumptions Step 7: Case analysis by destructing a value Step 8: Apply tactic: right Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: gso Step 11: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgen:reserve_instr_wf", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma step_lemma : forall (s : nat) (pc : nat), Plt pc (Pos.succ s) -> Plt pc s \\/ pc = s.\nProof.\n  intros s pc H.\n  elim (st_wf s pc).\n  intro H1.\n  left.\n  apply H1.\n  intro H2.\n  right.\n  apply H2.\nQed.", "nl_proof": "Step 1: We need to prove that forall s pc, Plt pc (Pos Step 2: Introduce variables and assumptions Step 3: Apply tactic: elim (st_wf s pc) Step 4: Apply tactic: intro Step 5: Apply tactic: left Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Apply tactic: right Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgen:reserve_instr_incr", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma forall_s_n_s : forall (s : nat), let n := s in n = s.\nProof. intros s n. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall s, let n := s Step 2: Introduce variables and assumptions Step 3: Apply tactic: constructor Step 4: Simplify the goal by computation Step 5: Apply a theorem or hypothesis Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgen:update_instr_wf", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma step_plt_proof : forall (s n pc : nat), Plt n s -> Plt pc s -> (pc = n \\/ Plt pc n) \\/ Plt pc s.\nProof.\n  intros s n pc H1 H2.\n  case (peq pc n); intro.\n  - subst pc. left. left. reflexivity.\n  - left. right. apply Plt_ne in H. apply Nat.lt_lt_eq_dec in H2. destruct H2; [assumption | contradiction].\nQed.", "nl_proof": "Step 1: We need to prove that forall s n i, Plt n s Step 2: Introduce variables and assumptions Step 3: Apply tactic: case (peq pc n) Step 4: Apply tactic: intro Step 5: Apply tactic: subst pc Step 6: Apply tactic: left Step 7: Apply tactic: assumption Step 8: Rewrite using an equality Step 9: Apply tactic: gso Step 10: Solve automatically using known facts Step 11: Apply tactic: exact (st_wf s pc)", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgen:update_instr_incr", "draft": "Require Import Coq.Arith.Arith.\nLemma step_lt_proof : forall (s n i : nat) (LT: n < s), (i + n) < (i + s).\nProof. intros. apply Nat.add_lt_mono_r. assumption. Qed.", "nl_proof": "Step 1: We need to prove that forall s n i (LT: Plt n s Step 2: Introduce variables and assumptions Step 3: Apply tactic: constructor Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Apply a theorem or hypothesis Step 7: Apply a theorem or hypothesis Step 8: Rewrite using an equality Step 9: Apply tactic: gsspec Step 10: Case analysis by destructing a value Step 11: Apply tactic: left", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgen:new_reg_incr", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma state_incr_mkstate : forall (s : nat), s <= Pos.succ s.\nProof. intros s. apply Nat.le_succ_diag_r. Qed.", "nl_proof": "Step 1: We need to prove that forall s, state_incr s (mkstate (Pos Step 2: Apply tactic: constructor Step 3: Simplify the goal by computation Step 4: Apply a theorem or hypothesis Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:slot_eq", "draft": "Require Import Coq.Arith.Peano_dec.\n\nLemma slot_eq : forall (p q : slot), {p = q} + {p <> q}.\nProof. decide equality. Defined.\nQed.", "nl_proof": "Step 1: We need to prove that forall (p q: slot), {p = q} + {p <> q} Step 2: Apply tactic: decide equality Step 3: Apply tactic: Defined", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:typesize_pos", "draft": "Require Import Coq.Arith.Arith.\n\nLemma typesize_positive : forall (ty : typ), typesize ty > 0.\nProof.\n  destruct ty; compute; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall (ty: typ), typesize ty > 0 Step 2: Case analysis by destructing a value Step 3: Apply tactic: compute Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:typealign_pos", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma typealign_positive : forall (ty : nat), ty > 0.\nProof. destruct ty; compute; auto. Qed.", "nl_proof": "Step 1: We need to prove that forall (ty: typ), typealign ty > 0 Step 2: Case analysis by destructing a value Step 3: Apply tactic: compute Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:typealign_typesize", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import Coq.Arith.PeanoNat.\n\nLemma typealign_divides_typesize : forall (ty : nat), (typealign ty | typesize ty).\nProof.\n  intros ty.\n  exists (typesize ty / typealign ty).\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall (ty: typ), (typealign ty | typesize ty) Step 2: Introduce variables and assumptions Step 3: Provide an existential witness Step 4: Case analysis by destructing a value Step 5: The goal is true by reflexivity Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:eq", "draft": "Require Import Coq.Arith.Peano_dec.\nLemma loc_dec : forall (p q : nat), {p = q} + {p <> q}.\nProof. apply eq_nat_dec. Qed.", "nl_proof": "Step 1: We need to prove that forall (p q: loc), {p = q} + {p <> q} Step 2: Apply tactic: decide equality Step 3: Apply a theorem or hypothesis Step 4: Apply a theorem or hypothesis Step 5: Apply a theorem or hypothesis Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: Defined", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:same_not_diff", "draft": "Require Import Coq.Arith.Lia.\n\nLemma diff_irreflexive : forall (l : nat), ~(l <> l).\nProof.\n  intro l.\n  red.\n  intro H.\n  apply H.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall l, ~(diff l l) Step 2: Case analysis by destructing a value Step 3: Unfold a definition Step 4: Solve automatically using known facts Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Case analysis by destructing a value Step 8: Solve automatically using known facts Step 9: Apply tactic: generalize (typesize_pos ty) Step 10: Apply tactic: lia Step 11: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:diff_not_eq", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma diff_neq : forall (A : Type) (l1 l2 : list A), diff l1 l2 -> l1 <> l2.\nProof.\n  intros A l1 l2 H. intro H_eq. subst l2. elim (same_not_diff l1 H).\nQed.", "nl_proof": "Step 1: We need to prove that forall l1 l2, diff l1 l2 -> l1 <> l2 Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: subst l2 Step 5: Apply tactic: elim (same_not_diff l1 H) Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:diff_sym", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma diff_symmetric : forall (A : Type) (l1 l2 : list A), diff l1 l2 -> diff l2 l1.\nProof.\n  intros A l1 l2 H.\n  destruct H.\n  destruct H.\n  unfold diff.\n  intuition.\nQed.", "nl_proof": "Step 1: We need to prove that forall l1 l2, diff l1 l2 -> diff l2 l1 Step 2: Case analysis by destructing a value Step 3: Case analysis by destructing a value Step 4: Unfold a definition Step 5: Solve automatically using known facts Step 6: Apply tactic: intuition Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:notin_iff", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma notin_spec : forall (A : Type) (l : A) (ll : list A), \n  (forall (l' : A), In l' ll -> l <> l') <-> ~ In l ll.\nProof.\n  induction ll; simpl; split; intros; try tauto.\n  - intuition. apply H; auto.\n  - intros l' [H1|H1]; subst; intuition.\nQed.", "nl_proof": "Step 1: We need to prove that forall l ll, notin l ll <-> (forall l', In l' ll -> Loc Step 2: Proceed by induction on ll Step 3: Simplify the goal by computation Step 4: Apply tactic: tauto Step 5: Rewrite using an equality Step 6: Apply tactic: intuition Step 7: Apply tactic: subst a Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:notin_not_in", "draft": "Require Import Coq.Lists.List.\nImport ListNotations.\n\nLemma notin_not_in : forall (A : Type) (l : A) (ll : list A), notin l ll -> ~ In l ll.\nProof.\n  intros A l ll H.\n  red.\n  intro H1.\n  rewrite in_equiv in H1.\n  elim (diff_not_eq l l).\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall l ll, notin l ll -> ~(In l ll) Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: elim (diff_not_eq l l) Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:notin_dec", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nDefinition notin {A : Type} (x : A) (l : list A) := ~ In x l.\n\nLemma notin_dec_template : forall (A : Type) (eq_dec : forall (x y : A), {x = y} + {x <> y}) (l : A) (ll : list A), {notin l ll} + {~ notin l ll}.\nProof.\n  intros A eq_dec l ll.\n  induction ll as [|x xs IHxs].\n  - left. unfold notin. intros H. inversion H.\n  - destruct IHxs as [H|H].\n    + destruct (eq_dec l x) as [Heq|Hneq].\n      * right. unfold notin. intros H1. apply H1. left. auto.\n      * left. unfold notin. intros H1. destruct H1 as [H2|H3].\n        apply Hneq. auto.\n        apply H. auto.\n    + right. unfold notin. intros H1. apply H. intros H2. apply H1. right. auto.\nQed.", "nl_proof": "Step 1: We need to prove that l: loc) (ll: list loc) : {notin l ll} + {~notin l ll} Step 2: Proceed by induction on ll Step 3: Simplify the goal by computation Step 4: Apply tactic: left Step 5: Solve automatically using known facts Step 6: Case analysis by destructing a value Step 7: Case analysis by destructing a value Step 8: Apply tactic: left Step 9: Solve automatically using known facts Step 10: Apply tactic: right Step 11: Apply tactic: tauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:disjoint_cons_left", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma disjoint_cons_l : forall (A : Type) (a : A) (l1 l2 : list A), disjoint (a :: l1) l2 -> disjoint l1 l2.\nProof.\n  intros A a l1 l2 H.\n  unfold disjoint in *.\n  intros x H1 H2.\n  apply H.\n  right; assumption.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall a l1 l2, disjoint (a :: l1) l2 -> disjoint l1 l2 Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:disjoint_cons_right", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma disjoint_cons_r : forall (A : Type) (a : A) (l1 l2 : list A), disjoint l1 (a :: l2) -> disjoint l1 l2.\nProof.\n  intros A a l1 l2 H.\n  unfold disjoint in *.\n  intros x H1 H2.\n  apply H; auto.\n  right; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall a l1 l2, disjoint l1 (a :: l2) -> disjoint l1 l2 Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:disjoint_sym", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma disjoint_sym : forall (A : Type) (l1 l2 : list A), (forall x, In x l1 -> ~ In x l2) -> (forall x, In x l2 -> ~ In x l1).\nProof.\n  intros A l1 l2 H x H1 H2.\n  apply (H x H2 H1).\nQed.", "nl_proof": "Step 1: We need to prove that forall l1 l2, disjoint l1 l2 -> disjoint l2 l1 Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply a theorem or hypothesis Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:in_notin_diff", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma notin_in_diff : forall (A : Type) (l1 l2 : A) (ll : list A), ~ In l1 ll -> In l2 ll -> l1 <> l2.\nProof.\n  intros A l1 l2 ll H1 H2.\n  intro H3.\n  rewrite H3 in H1.\n  contradiction.\nQed.", "nl_proof": "Step 1: We need to prove that forall l1 l2 ll, notin l1 ll -> In l2 ll -> diff l1 l2 Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:notin_disjoint", "draft": "Require Import Coq.Lists.List.\nImport ListNotations.\n\nLemma disjoint_intro : forall (A : Type) (l1 l2 : list A), (forall (x : A), In x l1 -> ~ In x l2) -> disjoint l1 l2.\nProof.\n  intros A l1 l2 H.\n  red.\n  intros x H1 H2.\n  apply H with x; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall l1 l2, (forall x, In x l1 -> notin x l2) -> disjoint l1 l2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: exploit H Step 6: Apply tactic: eauto Step 7: Rewrite using an equality Step 8: Introduce variables and assumptions Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:disjoint_notin", "draft": "Require Import Coq.Lists.List.\nImport ListNotations.\n\nLemma disjoint_notin : forall (A : Type) (l1 l2 : list A) (x : A), \n  (forall x, In x l1 -> ~ In x l2) -> In x l1 -> ~ In x l2.\nProof.\n  intros A l1 l2 x H H0.\n  apply H; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall l1 l2 x, disjoint l1 l2 -> In x l1 -> notin x l2 Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Introduce variables and assumptions Step 5: Apply tactic: red in H Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:norepet_dec", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma list_norepet_dec_template : forall (A : Type) (eq_dec : forall (x y : A), {x = y} + {x <> y}) (l : list A), {List.NoDup l} + {~List.NoDup l}.\nProof.\n  induction l as [|x l IH].\n  - left; constructor.\n  - destruct IH as [H|H].\n    + destruct (In_dec eq_dec x l) as [Hin|Hin].\n      * right; intro H'; inversion H'; contradiction.\n      * left; constructor; assumption.\n    + right; intro H'; inversion H'; contradiction.\nQed.", "nl_proof": "Step 1: We need to prove that ll: list loc) : {norepet ll} + {~norepet ll} Step 2: Proceed by induction on ll Step 3: Apply tactic: left Step 4: Apply tactic: constructor Step 5: Case analysis by destructing a value Step 6: Case analysis by destructing a value Step 7: Apply tactic: left Step 8: Apply tactic: constructor Step 9: Solve automatically using known facts Step 10: Apply tactic: right Step 11: Apply tactic: red", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:gss", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma set_spec : forall (A : Type) (l : list A) (v : A) (m : list A), \n  (set l v m) l = match l with\n  | nil => v\n  | cons h t => v\n  end.\nProof.\n  intros A l v m. unfold set. destruct l; reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall l v m, (set l v m) l = match l with R r => v | S sl ofs ty => Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply a theorem or hypothesis Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:gss_reg", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma set_same_reg : forall (reg : Type) (r : reg) (v : nat) (m : reg -> nat), (fun (r' : reg) => if eq_dec r r' then v else m r') r = v.\nProof.\n  intros reg r v m.\n  unfold eq_dec.\n  destruct (eq_dec r r) as [H|H].\n  - reflexivity.\n  - exfalso; apply H; reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall r v m, (set (R r) v m) (R r) = v Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Rewrite using an equality Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:gss_typed", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma load_result_same_template : forall (l : list nat) (v m : nat), nth m l v = v.\nProof.\n  intros l v m.\n  destruct (lt_dec m (length l)); [apply nth_indep; auto|].\n  rewrite nth_overflow by auto.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall l v m, Val Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Case analysis by destructing a value Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: load_result_same Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:gso", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma loc_step_elim : forall (l v m p : nat), l = p -> l <> p -> False.\nProof. intros l v m p H1 H2. apply H2 in H1. contradiction. Qed.", "nl_proof": "Step 1: We need to prove that forall l v m p, Loc Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Apply tactic: eq l p) Step 6: Apply tactic: subst p Step 7: Apply tactic: elim (Loc Step 8: Apply tactic: same_not_diff _ H) Step 9: Case analysis by destructing a value Step 10: Apply tactic: diff_dec l p) Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:guo", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma loc_step_lemma : forall (A : Type) (ll l m : list A), \n  (forall x, In x ll -> In x l) -> (forall x, In x ll -> In x m) -> \n  (forall x, In x ll -> In x l /\\ In x m).\nProof.\n  intros A ll l m H1 H2 x H3.\n  split; [apply H1 | apply H2]; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall ll l m, Loc Step 2: Proceed by induction on ll Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Case analysis by destructing a value Step 7: Rewrite using an equality Step 8: Solve automatically using known facts Step 9: Apply a theorem or hypothesis Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: diff_sym", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:gus", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma undef_in : forall (A : Type) (ll : list (A -> nat)) (l : A) (m : A -> nat),\n  In l (map (fun f x => f x) ll) -> (fold_left (fun acc f => fun x => if eq_dec x l then Vundef else acc x) ll m) l = Vundef.\nProof.\n  induction ll as [|f ll IH]; simpl; intros l m H.\n  - contradiction.\n  - destruct H as [H|H].\n    + subst. destruct (eq_dec l l); [reflexivity|contradiction].\n    + apply IH. assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall ll l m, In l ll -> (undef ll m) l = Vundef Step 2: Apply tactic: assert (P: forall ll l m, m l = Vundef -> (undef l Step 3: Proceed by induction on ll Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Solve automatically using known facts Step 7: Apply a theorem or hypothesis Step 8: Unfold a definition Step 9: Case analysis by destructing a value Step 10: Apply tactic: eq a l) Step 11: Case analysis by destructing a value", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:getpair_exten", "draft": "Require Import Coq.Lists.List.\n\nLemma getpair_exten : forall (A : Type) (p : A) (ls1 ls2 : A -> A),\n    (forall l, In l (regs_of_rpair p) -> ls2 l = ls1 l) ->\n    getpair p ls2 = getpair p ls1.\nProof.\n  intros A p ls1 ls2 H.\n  destruct p; simpl.\n  - f_equal. apply H. simpl. auto.\n  - f_equal.\n    + apply H. simpl. auto.\n    + apply H. simpl. auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall p ls1 ls2, (forall l, In l (regs_of_rpair p) -> ls2 l = ls1 l) -> getpair p ls2 = getpair p ls1 Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply a theorem or hypothesis Step 6: Simplify the goal by computation Step 7: Solve automatically using known facts Step 8: Apply tactic: f_equal Step 9: Apply a theorem or hypothesis Step 10: Simplify the goal by computation Step 11: Solve automatically using known facts", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:gpo", "draft": "Require Import Coq.Lists.List.\nLemma setpair_diff : forall p v m l,\n  forall_rpair (fun r => Loc.diff l (R r)) p -> setpair p v m l = m l.\nProof. apply gpo. Qed.", "nl_proof": "Step 1: We need to prove that forall p v m l, forall_rpair (fun r => Loc Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: - apply gso Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: diff_sym Step 8: Solve automatically using known facts Step 9: Apply tactic: - destruct H Step 10: Rewrite using an equality Step 11: Apply tactic: diff_sym", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:index_inj", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma index_inj : forall (x y : nat), index x = index y -> x = y.\nProof. apply Nat.index_inj. Qed.", "nl_proof": "Step 1: We need to prove that forall x y, index x = index y -> x = y Step 2: We need to prove that forall x y, index x = index y -> x = y", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:eq_refl", "draft": "Require Import Coq.Classes.RelationClasses.\n\nLemma eq_trans_poly : forall (A : Type) (x y z : A), eq x y -> eq y z -> eq x z.\nProof. apply eq_trans. Qed.", "nl_proof": "Step 1: We need to prove that forall x : t, eq x x Step 2: Apply tactic: Lemma eq_sym : forall x y : t, eq x y -> eq y x Step 3: Apply tactic: Lemma eq_trans : forall x y z : t, eq x y -> eq y Step 4: Apply tactic: Lemma lt_trans : forall x y z : t, lt x y -> lt y Step 5: Unfold a definition Step 6: Introduce variables and assumptions Step 7: Case analysis by destructing a value Step 8: Case analysis by destructing a value Step 9: Case analysis by destructing a value Step 10: Apply tactic: try tauto Step 11: Apply tactic: eapply Plt_trans", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:eq_sym", "draft": "Require Import Coq.Classes.RelationClasses.\n\nLemma eq_sym : forall (t : Type) (x y : t), eq x y -> eq y x.\nProof. apply eq_symmetry. Qed.", "nl_proof": "Step 1: We need to prove that forall x y : t, eq x y -> eq y x Step 2: Apply tactic: Lemma eq_trans : forall x y z : t, eq x y -> eq y Step 3: Apply tactic: Lemma lt_trans : forall x y z : t, lt x y -> lt y Step 4: Unfold a definition Step 5: Introduce variables and assumptions Step 6: Case analysis by destructing a value Step 7: Case analysis by destructing a value Step 8: Case analysis by destructing a value Step 9: Apply tactic: try tauto Step 10: Apply tactic: eapply Plt_trans Step 11: Apply tactic: eauto", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:eq_trans", "draft": "Lemma eq_trans : forall (t : Type) (x y z : t), eq x y -> eq y z -> eq x z.\nProof. intros t x y z H1 H2; rewrite H1; exact H2. Qed.", "nl_proof": "Step 1: We need to prove that forall x y z : t, eq x y -> eq y z -> eq x z Step 2: Apply tactic: Lemma lt_trans : forall x y z : t, lt x y -> lt y Step 3: Unfold a definition Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Case analysis by destructing a value Step 7: Case analysis by destructing a value Step 8: Apply tactic: try tauto Step 9: Apply tactic: eapply Plt_trans Step 10: Apply tactic: eauto Step 11: Case analysis by destructing a value", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:lt_trans", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma lt_trans : forall (x y z : nat), x < y -> y < z -> x < z.\nProof. apply Nat.lt_trans. Qed.", "nl_proof": "Step 1: We need to prove that forall x y z : t, lt x y -> lt y z -> lt x z Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Case analysis by destructing a value Step 6: Case analysis by destructing a value Step 7: Apply tactic: try tauto Step 8: Apply tactic: eapply Plt_trans Step 9: Apply tactic: eauto Step 10: Case analysis by destructing a value Step 11: Case analysis by destructing a value", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:lt_not_eq", "draft": "Require Import Coq.Classes.RelationClasses.\n\nLemma lt_neq : forall (A : Type) (eq lt : A -> A -> Prop)\n  (H1 : StrictOrder lt) (H2 : Equivalence eq) (H3 : subrelation lt (complement eq)),\n  forall (x y : A), lt x y -> ~ eq x y.\nProof.\n  intros A eq lt H1 H2 H3 x y H4 H5.\n  apply H3 in H4.\n  contradiction.\nQed.", "nl_proof": "Step 1: We need to prove that forall x y : t, lt x y -> ~ eq x y Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: red Step 5: Introduce variables and assumptions Step 6: Apply tactic: subst y Step 7: Case analysis by destructing a value Step 8: Apply tactic: eelim Plt_strict Step 9: Apply tactic: eauto Step 10: Case analysis by destructing a value Step 11: Apply tactic: eelim OrderedSlot", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:outside_interval_diff", "draft": "Require Import Coq.Arith.Arith.\nLemma loc_step_diff_bound : forall (l l' : Loc) (mr mr' : mreg),\n  (l' < diff_low_bound l \\/ diff_high_bound l < l') -> Loc.diff l l'.\nProof.\n  intros l l' mr mr' H.\n  destruct l as [r1|r1]; destruct l' as [r2|r2]; simpl in *; auto.\n  destruct H; [left|right]; omega.\nQed.", "nl_proof": "Step 1: We need to prove that forall l l', lt l' (diff_low_bound l) \\/ lt (diff_high_bound l) l' -> Loc Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Solve automatically using known facts Step 7: Apply tactic: - assert (IndexedMreg Step 8: Apply tactic: index mr <> IndexedMreg Step 9: Apply tactic: index mr') Step 10: Apply tactic: { destruct H Step 11: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Locations:diff_outside_interval", "draft": "Require Import Coq.Arith.Compare_dec.\nRequire Import Coq.Program.Basics.\n\nLemma indexed_compare_eq : forall (A : Type) (mr mr' : A) (index : A -> nat),\n  (compare (index mr) (index mr')%nat eqn) = Eq -> mr = mr'.\nProof.\n  intros A mr mr' index H.\n  unfold compare in H.\n  destruct (lt_eq_lt_dec (index mr) (index mr')) as [[Hlt|Heq]|Hgt].\n  - inversion H.\n  - f_equal. apply Nat.compare_eq_iff. assumption.\n  - inversion H.\nQed.", "nl_proof": "Step 1: We need to prove that forall l l', Loc Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Solve automatically using known facts Step 7: Apply tactic: - unfold Plt, Pos Step 8: Case analysis by destructing a value Step 9: Apply tactic: compare (IndexedMreg Step 10: Apply tactic: index mr) (IndexedMreg Step 11: Apply tactic: index mr')) eqn:C", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEdomain:rhs_compat_sym", "draft": "Lemma rhs_compat_sym : forall (rh1 rh2 : Type), rhs_compat rh1 rh2 -> rhs_compat rh2 rh1.\nProof. intros rh1 rh2 H. destruct H. constructor. Qed.", "nl_proof": "Step 1: We need to prove that forall rh1 rh2, rhs_compat rh1 rh2 -> rhs_compat rh2 rh1 Step 2: Case analysis by destructing a value Step 3: Apply tactic: constructor Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEdomain:compat_rhs_sound", "draft": "Require Import Coq.Bool.Bool.\n\nLemma compat_rhs_implies_rhs_compat : forall (r1 r2 : bool), compat_rhs r1 r2 = true -> rhs_compat r1 r2.\nProof.\n  intros r1 r2 H.\n  unfold compat_rhs in H.\n  destruct r1; destruct r2; try discriminate; InvBooleans; subst; constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall r1 r2, compat_rhs r1 r2 = true -> rhs_compat r1 r2 Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: try discriminate Step 6: Apply tactic: InvBooleans Step 7: Apply tactic: subst Step 8: Apply tactic: constructor Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEdomain:rhs_eval_to_compat", "draft": "Require Import compcert.backend.RTL.\nLemma rhs_eval_compat : forall (valu : valnum -> val) (ge : genv) (sp : val) (m : mem) (rh rh' : rhs) (v : val), rhs_eval_to valu ge sp m rh v -> rhs_compat rh rh' -> rhs_eval_to valu ge sp m rh' v.\nProof.\n  intros.\n  inv H.\n  inv H0.\n  econstructor.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall valu ge sp m rh v rh', rhs_eval_to valu ge sp m rh v -> rhs_compat rh rh' -> rhs_eval_to valu ge sp m rh' v Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: inv H0 Step 5: Apply tactic: econstructor Step 6: Apply tactic: eauto Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEdomain:empty_numbering_holds", "draft": "Lemma empty_numbering_holds : forall (valu : valnum -> value) (ge : genv) (sp : val) (rs : regset) (m : mem), numbering_holds valu ge sp rs m empty_numbering.\nProof.\n  intros.\n  unfold numbering_holds.\n  split.\n  - intros.\n    unfold empty_numbering in H.\n    simpl in H.\n    contradiction.\n  - intros.\n    unfold empty_numbering in H.\n    rewrite PTree.gempty in H.\n    discriminate.\nQed.", "nl_proof": "Step 1: We need to prove that forall valu ge sp rs m, numbering_holds valu ge sp rs m empty_numbering Step 2: Introduce variables and assumptions Step 3: Split a conjunction into separate goals Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Apply tactic: - split Step 7: Simplify the goal by computation Step 8: Introduce variables and assumptions Step 9: Apply tactic: + contradiction Step 10: Apply tactic: + rewrite PTree Step 11: Apply tactic: gempty in H", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEdomain:combine_comparison_cmp_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma combine_comparison_cmp_sound : forall (valu: valnum -> val) (c : comparison) (x y : valnum) (res res' : bool), combine_comparison c x y = Some res' -> Val.cmp_bool c (valu x) (valu y) = Some res -> res = res'.\nProof.\n  intros valu c x y res res' H H0.\n  destruct (combine_comparison c x y) eqn:E.\n  - inv H.\n    destruct (Val.cmp_bool c (valu x) (valu y)) eqn:F.\n    + inv H0. reflexivity.\n    + inv H0.\n  - inv H.\nQed.", "nl_proof": "Step 1: We need to prove that forall (valu: valnum -> val) c x y res res', combine_comparison c x y = Some res' -> Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: inv H Step 6: Case analysis by destructing a value Step 7: Simplify the goal by computation Step 8: Apply tactic: inv H0 Step 9: Case analysis by destructing a value Step 10: Simplify the goal by computation Step 11: Unfold a definition", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEdomain:combine_comparison_cmpu_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma combine_comparison_cmpu_sound : forall (valu: valnum -> val) (m : mem) (c : comparison) (x y : valnum) (res res' : bool),\n  combine_comparison c x y = Some res' ->\n  Val.cmpu_bool (Mem.valid_pointer m) c (valu x) (valu y) = Some res ->\n  res = res'.\nProof.\n  intros valu m c x y res res' H H0.\n  unfold combine_comparison in H.\n  destruct (valnum_eq x y).\n  - inv H.\n    destruct c; simpl in H0; try discriminate; inv H0; reflexivity.\n  - destruct (valnum_eq x y); try discriminate.\n    destruct c; simpl in H0; try discriminate; inv H0; reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall (valu: valnum -> val) m c x y res res', combine_comparison c x y = Some res' -> Val Step 2: Unfold a definition Step 3: Apply tactic: cmpu_bool Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: inv H Step 7: Case analysis by destructing a value Step 8: Apply tactic: - discriminate Step 9: Apply tactic: - inv H0 Step 10: Case analysis by destructing a value Step 11: Simplify the goal by computation", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEdomain:combine_comparison_cmpl_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma combine_comparison_cmp_sound : forall (valu: valnum -> val) (c : comparison) (x y : valnum) (res res' : bool), combine_comparison c x y = Some res' -> Val.cmp_bool c (valu x) (valu y) = Some res -> res = res'.\nProof.\n  intros valu c x y res res' H H0.\n  destruct (combine_comparison c x y) eqn:E; [|discriminate].\n  injection H as H.\n  rewrite H in *.\n  destruct (Val.cmp_bool c (valu x) (valu y)) eqn:F; [|discriminate].\n  injection H0 as H0.\n  rewrite H0.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall (valu: valnum -> val) c x y res res', combine_comparison c x y = Some res' -> Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: inv H Step 6: Case analysis by destructing a value Step 7: Simplify the goal by computation Step 8: Apply tactic: inv H0 Step 9: Case analysis by destructing a value Step 10: Simplify the goal by computation Step 11: Unfold a definition", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEdomain:combine_comparison_cmplu_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma combine_comparison_cmplu_sound : forall (valu : valnum -> val) (m : mem) (c : comparison) (x y : valnum) (res res' : bool),\n  combine_comparison c x y = Some res' -> Val.cmplu_bool (Mem.valid_pointer m) c (valu x) (valu y) = Some res -> res = res'.\nProof.\n  intros valu m c x y res res' H H0.\n  destruct (valu x) eqn:?; destruct (valu y) eqn:?; try discriminate.\n  inv H0.\nQed.", "nl_proof": "Step 1: We need to prove that forall (valu: valnum -> val) m c x y res res', combine_comparison c x y = Some res' -> Val Step 2: Unfold a definition Step 3: Apply tactic: cmplu_bool Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: inv H Step 7: Case analysis by destructing a value Step 8: Apply tactic: - discriminate Step 9: Apply tactic: - discriminate Step 10: Apply tactic: - inv H0 Step 11: Case analysis by destructing a value", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningspec:funenv_program_compat", "draft": "Require Import Coq.Lists.List.\nRequire Import Coq.MSets.MSetPositive.\nRequire Import Coq.PArith.PArith.\nRequire Import Coq.FSets.FMapPositive.\n\nLemma fenv_compat_update : forall (dm : PTree.t (globdef fundef unit)) (fenv : PTree.t function) (id : positive) (g : globdef fundef unit),\n  (forall id f, fenv!id = Some f -> dm!id = Some (Gfun (Internal f))) ->\n  forall id' f', (PTree.remove id fenv)!id' = Some f' -> (PTree.set id g dm)!id' = Some (Gfun (Internal f')).\nProof.\n  intros dm fenv id g H id' f'.\n  rewrite PTree.gsspec.\n  destruct (peq id' id).\n  - subst id'.\n    rewrite PTree.grs in H0.\n    congruence.\n  - rewrite PTree.gro by assumption.\n    rewrite PTree.gro in H0 by assumption.\n    apply H; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall p, fenv_compat p (funenv_program p) Step 2: Apply tactic: set (P := fun (dm: PTree Step 3: Apply tactic: t (globdef fundef unit)) (fenv: funenv) => Step 4: Apply tactic: forall id f, Step 5: Apply tactic: fenv!id = Some f -> dm!id = Some (Gfun (Internal f Step 6: Apply tactic: assert (REMOVE: forall dm fenv id g, Step 7: Apply tactic: P dm fenv -> Step 8: Apply tactic: P (PTree Step 9: Apply tactic: set id g dm) (PTree Step 10: Apply tactic: remove id fenv)) Step 11: Apply tactic: { unfold P", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningspec:fenv_compat_linkorder", "draft": "Require Import compcert.common.Globalenvs.\nLemma fenv_compat_linkorder : forall (cunit prog : program) (fenv : funenv), linkorder cunit prog -> fenv_compat cunit fenv -> fenv_compat prog fenv.\nProof.\n  intros cunit prog fenv H H0.\n  red.\n  intros id fd H1.\n  destruct (find_funct_ptr_inv _ _ _ H1) as [b [H2 H3]].\n  inv H3.\n  inv H0.\n  apply H4 with (b := b).\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall cunit prog fenv, linkorder cunit prog -> fenv_compat cunit fenv -> fenv_compat prog fenv Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply a theorem or hypothesis Step 6: Case analysis by destructing a value Step 7: Apply tactic: inv Q Step 8: Apply tactic: inv H3 Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningspec:shiftpos_eq", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import Coq.PArith.BinPos.\n\nLemma shiftpos_eq : forall (x y : positive), Z.pos (shiftpos x y) = (Z.pos x + Z.pos y) - 1.\nProof.\n  intros x y.\n  unfold shiftpos.\n  zify.\n  rewrite ?Pos2Z.inj_add.\n  rewrite ?Pos2Z.inj_sub.\n  lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall x y, Zpos (shiftpos x y) = (Zpos x + Zpos y) - 1 Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: zify Step 5: Apply tactic: try rewrite Pos2Z Step 6: Apply tactic: inj_sub Step 7: Solve automatically using known facts Step 8: Apply tactic: zify Step 9: Apply tactic: lia Step 10: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningspec:shiftpos_inj", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import Lia.\n\nLemma shiftpos_injective : forall (x y : positive) (n : positive), shiftpos x n = shiftpos y n -> x = y.\nProof.\n  intros x y n H.\n  assert (Zpos (shiftpos x n) = Zpos (shiftpos y n)) by (rewrite H; reflexivity).\n  rewrite !shiftpos_eq in H0.\n  assert (Zpos x = Zpos y) by lia.\n  congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall x y n, shiftpos x n = shiftpos y n -> x = y Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (Zpos (shiftpos x n) = Zpos (shiftpos y n)) Step 4: Rewrite using an equality Step 5: Apply tactic: assert (Z Step 6: Apply tactic: pos x = Z Step 7: Apply tactic: pos y) by lia Step 8: Apply tactic: congruence Step 9: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningspec:shiftpos_diff", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma shiftpos_neq : forall (x y n : nat), x <> y -> shiftpos x n <> shiftpos y n.\nProof. intros x y n H. red. intros H0. apply H. eapply shiftpos_inj. eauto. Qed.", "nl_proof": "Step 1: We need to prove that forall x y n, x <> y -> shiftpos x n <> shiftpos y n Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: elim H Step 6: Apply tactic: eapply shiftpos_inj Step 7: Apply tactic: eauto Step 8: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningspec:shiftpos_above", "draft": "Lemma shiftpos_ple : forall (x n : positive), Ple n (shiftpos x n).\nProof.\n  intros x n.\n  unfold Ple.\n  zify.\n  rewrite Pos2Z.inj_add.\n  extlia.\nQed.", "nl_proof": "Step 1: We need to prove that forall x n, Ple n (shiftpos x n) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: zify Step 5: Rewrite using an equality Step 6: Apply tactic: extlia Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningspec:shiftpos_not_below", "draft": "Require Import Coq.PArith.BinPos.\nLemma shiftpos_not_below : forall (x n : positive), Plt (shiftpos x n) n -> False.\nProof. intros x n H. generalize (shiftpos_above x n). intros H0. extlia. Qed.", "nl_proof": "Step 1: We need to prove that forall x n, Plt (shiftpos x n) n -> False Step 2: Introduce variables and assumptions Step 3: Apply tactic: generalize (shiftpos_above x n) Step 4: Apply tactic: extlia Step 5: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningspec:shiftpos_below", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import Coq.Program.Basics.\n\nLemma shiftpos_below : forall (x n : positive), Plt (shiftpos x n) (Pos.add x n).\nProof.\n  intros x n.\n  unfold shiftpos.\n  zify.\n  rewrite Pos2Z.inj_add.\n  lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall x n, Plt (shiftpos x n) (Pos Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: zify Step 5: Rewrite using an equality Step 6: Apply tactic: lia Step 7: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningspec:shiftpos_le", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import Coq.omega.Omega.\n\nLemma shiftpos_ple_monotone : forall (x y n : positive), Ple x y -> Ple (shiftpos x n) (shiftpos y n).\nProof.\n  intros x y n H.\n  unfold Ple, shiftpos in *.\n  zify.\n  rewrite !Pos2Z.inj_add.\n  omega.\nQed.", "nl_proof": "Step 1: We need to prove that forall x y n, Ple x y -> Ple (shiftpos x n) (shiftpos y n) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: zify Step 5: Rewrite using an equality Step 6: Apply tactic: lia Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningspec:bind_inversion", "draft": "Require Import Coq.Lists.List.\nLemma bind_inversion : forall (A B : Type) (f : mon A) (g : A -> mon B) (y : B) (s1 s3 : state) (i : sincr s1 s3), bind f g s1 = R y s3 i -> exists (x : A) (s2 : state) (i1 : sincr s1 s2) (i2 : sincr s2 s3), f s1 = R x s2 i1 /\\ g x s2 = R y s3 i2.\nProof.\n  intros A B f g y s1 s3 i H.\n  destruct (f s1) eqn:E.\n  - destruct (g a s0) eqn:E2.\n    + inversion H; subst.\n      exists a, s0, s1, s2.\n      split; auto.\n    + inversion H.\n  - inversion H.\nQed.", "nl_proof": "Step 1: We need to prove that forall (A B: Type) (f: mon A) (g: A -> mon B) (y: B) (s1 s3: state) (i: sincr s1 s3), bind f g s1 = R y s3 i -> exists x, exists s2, exists i1, exists i2, f s1 = R x s2 i1 /\\ g x s2 = R y s3 i2 Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Provide an existential witness Step 6: Provide an existential witness Step 7: Provide an existential witness Step 8: Case analysis by destructing a value Step 9: Apply tactic: inv H Step 10: Provide an existential witness Step 11: Solve automatically using known facts", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningspec:mlist_iter2_fold", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma mlist_iter2_fold : forall (A B : Type) (f : A -> B -> mon unit) (l : list (A * B)) (s : S),\n  exists (i : I), mlist_iter2 f l s = R tt (fold_left (fun a p => match f (fst p) (snd p) a with R _ s2 _ => s2 end) l s) i.\nProof.\n  induction l; intros s; simpl.\n  - exists i0. reflexivity.\n  - destruct a as [a b]. simpl.\n    destruct (f a b s) as [ [] s' | ] eqn:H.\n    + destruct (IHl s') as [i' IH].\n      exists i'. rewrite IH. reflexivity.\n    + destruct (IHl s) as [i' IH].\n      exists i'. rewrite IH. reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall (A B: Type) (f: A -> B -> mon unit) l s, exists i, mlist_iter2 f l s = R tt (fold_left (fun a p => match f (fst p) (snd p) a with R _ s2 _ => s2 end) l s) i Step 2: Proceed by induction on l Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Provide an existential witness Step 6: Solve automatically using known facts Step 7: Case analysis by destructing a value Step 8: Unfold a definition Step 9: Simplify the goal by computation Step 10: Case analysis by destructing a value Step 11: Case analysis by destructing a value", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningspec:ptree_mfold_spec", "draft": "Require Import Coq.PArith.BinPos.\nRequire Import Coq.Structures.Orders.\nRequire Import Coq.FSets.FMapInterface.\nRequire Import Coq.FSets.FMapPositive.\n\nLemma ptree_mfold_spec : forall (A : Type) (f : positive -> A -> mon unit) t s x s' i,\n  ptree_mfold f t s = R x s' i ->\n  exists i', mlist_iter2 f (PTree.elements t) s = R tt s' i'.\nProof.\n  intros A f t s x s' i H.\n  destruct (mlist_iter2_fold A unit f (PTree.elements t) s) as [i' EQ].\n  unfold ptree_mfold in H.\n  rewrite EQ in H.\n  inversion H.\n  subst.\n  eexists.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall (A: Type) (f: positive -> A -> mon unit) t s x s' i, ptree_mfold f t s = R x s' i -> exists i', mlist_iter2 f (PTree Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: elements t) s) as [i' EQ] Step 5: Unfold a definition Step 6: Apply tactic: inv H Step 7: Rewrite using an equality Step 8: Apply tactic: fold_spec Step 9: Apply tactic: econstructor Step 10: Apply tactic: eexact EQ Step 11: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningspec:add_moves_unchanged", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nRequire Import Coq.Arith.PeanoNat.\n\nLemma add_moves_plt : forall srcs dsts pc2 s pc1 s' i pc,\n  add_moves srcs dsts pc2 s = R pc1 s' i ->\n  Plt pc (st_nextnode s) ->\n  Plt pc (st_nextnode s').\nProof.\n  induction srcs; intros dsts pc2 s pc1 s' i pc H H0.\n  - simpl in H. monadInv H. auto.\n  - simpl in H. destruct dsts.\n    + monadInv H. auto.\n    + monadInv H. eapply IHsrcs in EQ0.\n      * eapply Plt_trans; eauto.\n      * eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall srcs dsts pc2 s pc1 s' i pc, add_moves srcs dsts pc2 s = R pc1 s' i -> Plt pc s Step 2: Proceed by induction on srcs Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: monadInv H Step 6: Solve automatically using known facts Step 7: Case analysis by destructing a value Step 8: Apply tactic: monadInv H Step 9: Solve automatically using known facts Step 10: Apply tactic: transitivity (st_code s0)!pc Step 11: Apply tactic: eapply IHsrcs", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningspec:add_moves_spec", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nRequire Import Coq.Arith.PeanoNat.\n\nLemma add_moves_unchanged_spec : forall srcs dsts pc2 s pc1 s' i pc,\n  add_moves srcs dsts pc2 s = R pc1 s' i ->\n  Plt pc s.(st_nextnode) \\/ Ple s'.(st_nextnode) pc ->\n  s'.(st_code)!pc = s.(st_code)!pc.\nProof.\n  induction srcs; intros dsts pc2 s pc1 s' i pc H H0.\n  - simpl in H. monadInv H. auto.\n  - simpl in H. destruct dsts; try discriminate.\n    monadInv H. apply IHsrcs with (dsts := dsts) (pc2 := pc2) in EQ.\n    + rewrite EQ. apply H1. destruct H0; [left|right]; auto.\n    + destruct H0; [left|right]; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall srcs dsts pc2 s pc1 s' i c, add_moves srcs dsts pc2 s = R pc1 s' i -> (forall pc, Ple s Step 2: Proceed by induction on srcs Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: monadInv H Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Case analysis by destructing a value Step 9: Apply tactic: monadInv H Step 10: Apply a theorem or hypothesis Step 11: Solve automatically using known facts", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningspec:set_instr_other", "draft": "Require Import compcert.common.Errors.\nRequire Import compcert.lib.Maps.\n\nLemma set_instr_other : forall pc instr s x s' i pc',\n  set_instr pc instr s = R x s' i -> pc' <> pc -> (st_code s') ! pc' = (st_code s) ! pc'.\nProof.\n  intros pc instr s x s' i pc' H H0.\n  monadInv H.\n  simpl.\n  apply gso.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall pc instr s x s' i pc', set_instr pc instr s = R x s' i -> pc' <> pc -> s' Step 2: Introduce variables and assumptions Step 3: Apply tactic: monadInv H Step 4: Simplify the goal by computation Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: gso Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningspec:set_instr_same", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma set_instr_same_pc : forall pc instr s x s' i c,\n  set_instr pc instr s = R x s' i -> c!(pc) = s'.(st_code)!(pc).\nProof.\n  intros pc instr s x s' i c H.\n  monadInv H.\n  simpl.\n  rewrite gss.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall pc instr s x s' i c, set_instr pc instr s = R x s' i -> c!(pc) = s' Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Apply tactic: monadInv H Step 5: Simplify the goal by computation Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: gss Step 8: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningspec:expand_instr_unchanged", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma expand_instr_unchanged_spec : forall ctx pc instr s x s' i pc',\n  expand_instr fe rec ctx pc instr s = R x s' i ->\n  Ple (dpc ctx) (st_nextnode s) ->\n  Plt pc' (st_nextnode s) ->\n  pc' <> spc ctx pc ->\n  s'.(st_code)!pc' = s.(st_code)!pc'.\nProof.\n  intros ctx pc instr s x s' i pc' H H0 H1 H2.\n  generalize (set_instr_other pc' (spc ctx pc) _ _ H2).\n  unfold expand_instr in H.\n  destruct instr; try monadInv H; eauto.\nQed.", "nl_proof": "Step 1: tailcall Step 2: We need to prove that forall ctx pc instr s x s' i pc', expand_instr fe rec ctx pc instr s = R x s' i -> Ple ctx Step 3: Apply tactic: generalize set_instr_other Step 4: Introduce variables and assumptions Step 5: Introduce variables and assumptions Step 6: Unfold a definition Step 7: Case analysis by destructing a value Step 8: Apply tactic: eauto Step 9: Case analysis by destructing a value Step 10: Apply tactic: eauto Step 11: Apply tactic: monadInv H Step 12: Unfold a definition", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningspec:iter_expand_instr_unchanged", "draft": "Require Import Coq.Lists.List.\nLemma mlist_iter2_expand_instr_unchanged : forall (ctx : positive) (pc : positive) (l : list (positive * positive)) (s : state) (x : unit) (s' : state) (i : unit),\n  mlist_iter2 (expand_instr fe rec ctx) l s = R x s' i ->\n  Ple (dpc ctx) (st_nextnode s) ->\n  Plt pc (st_nextnode s) ->\n  ~In pc (List.map (spc ctx) (List.map (@fst positive positive) l)) ->\n  list_norepet (List.map (@fst positive positive) l) ->\n  (st_code s') ! pc = (st_code s) ! pc.\nProof.\n  induction l; intros; simpl in *; monadInv H.\n  - reflexivity.\n  - destruct a as [pc0 instr0]. simpl in *.\n    inv H3.\n    assert (pc <> spc ctx pc0) by (intro; subst; apply H2; left; auto).\n    rewrite <- IHl with (s := s0) (x := x) (s' := s') (i := i); auto.\n    eapply expand_instr_unchanged; eauto.\nQed.", "nl_proof": "Step 1: base case Step 2: inductive case Step 3: We need to prove that forall ctx pc l s x s' i, mlist_iter2 (expand_instr fe rec ctx) l s = R x s' i -> Ple ctx Step 4: Proceed by induction on l Step 5: Simplify the goal by computation Step 6: Introduce variables and assumptions Step 7: Apply tactic: monadInv H Step 8: Solve automatically using known facts Step 9: Case analysis by destructing a value Step 10: Simplify the goal by computation Step 11: Apply tactic: monadInv H Step 12: Apply tactic: inv H3 Step 13: Apply tactic: transitivity ((st_code s0)!pc)", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningspec:expand_cfg_rec_unchanged", "draft": "Require Import Coq.Lists.List.\nRequire Import Coq.Arith.Arith.\nRequire Import Coq.micromega.Lia.\n\nLemma expand_cfg_rec_unchanged : forall ctx f s x s' i pc,\n  expand_cfg_rec fe rec ctx f s = R x s' i ->\n  Ple ctx.(dpc) s.(st_nextnode) ->\n  Plt pc ctx.(dpc) ->\n  s'.(st_code)!pc = s.(st_code)!pc.\nProof.\n  intros ctx f s x s' i pc H H0 H1.\n  unfold expand_cfg_rec in H.\n  monadInv H.\n  inversion EQ.\n  transitivity ((st_code s0)!pc).\n  - exploit ptree_mfold_spec; eauto.\n  - eapply iter_expand_instr_unchanged; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall ctx f s x s' i pc, expand_cfg_rec fe rec ctx f s = R x s' i -> Ple ctx Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: monadInv H Step 5: Apply tactic: inversion EQ Step 6: Apply tactic: transitivity ((st_code s0)!pc) Step 7: Apply tactic: exploit ptree_mfold_spec Step 8: Apply tactic: eauto Step 9: Introduce variables and assumptions Step 10: Apply tactic: eapply iter_expand_instr_unchanged Step 11: Apply tactic: eauto", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningspec:min_alignment_pos", "draft": "```coq\nRequire Import Lia.\n\nLemma min_alignment_positive : forall (sz : nat), min_alignment sz > 0.\nProof.\n  intro sz.\n  unfold min_alignment.\n  destruct sz.\n  - lia.\n  - destruct n.\n    + lia.\n    + destruct n.\n      * lia.\n      * lia.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall sz, min_alignment sz > 0 Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Apply tactic: lia Step 6: Case analysis by destructing a value Step 7: Apply tactic: lia Step 8: Case analysis by destructing a value Step 9: Apply tactic: lia Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningspec:expand_cfg_unchanged", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma expand_cfg_unchanged_general : forall fe ctx f s x s' i pc,\n  expand_cfg fe ctx f s = R x s' i ->\n  Ple (dpc ctx) (st_nextnode s) ->\n  Plt pc (dpc ctx) ->\n  (st_code s') ! pc = (st_code s) ! pc.\nProof.\n  intros.\n  pattern fe.\n  eapply expand_cfg_rec_unchanged.\n  eauto.\n  assumption.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall fe ctx f s x s' i pc, expand_cfg fe ctx f s = R x s' i -> Ple ctx Step 2: Introduce variables and assumptions Step 3: Apply tactic: pattern fe0 Step 4: Apply a theorem or hypothesis Step 5: Apply a theorem or hypothesis Step 6: Introduce variables and assumptions Step 7: Unfold a definition Step 8: Rewrite using an equality Step 9: Apply tactic: eapply expand_cfg_rec_unchanged Step 10: Apply tactic: eauto Step 11: Apply tactic: assumption", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningspec:tr_function_linkorder", "draft": "Require Import Coq.Lists.List.\nLemma tr_function_linkorder : forall (cunit prog : Type) (f f' : Type), linkorder cunit prog -> tr_function cunit f f' -> tr_function prog f f'.\nProof.\n  intros.\n  inv H0.\n  econstructor.\n  eauto.\n  eapply fenv_compat_linkorder.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall cunit prog f f', linkorder cunit prog -> tr_function cunit f f' -> tr_function prog f f' Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Apply tactic: econstructor Step 5: Apply tactic: eauto Step 6: Apply tactic: eapply fenv_compat_linkorder Step 7: Apply tactic: eauto Step 8: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningspec:transf_function_spec", "draft": "Require Import Coq.Lists.List.\nLemma transf_function_tr_function : forall (cunit : Type) (f f' : Type), transf_function (funenv_program cunit) f = OK f' -> tr_function cunit f f'.\nProof.\n  intros cunit f f' H.\n  set (fenv := funenv_program cunit) in *.\n  unfold transf_function in H.\n  destruct (zlt _ _); try discriminate.\n  destruct (zle _ _); try discriminate.\n  monadInv H.\n  set (ctx := initcontext _ _ (max_reg_function f)) in *.\n  Opaque initstate.\n  constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall cunit f f', transf_function (funenv_program cunit) f = OK f' -> tr_function cunit f f' Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: set (fenv := funenv_program cunit) in * Step 5: Case analysis by destructing a value Step 6: Case analysis by destructing a value Step 7: Apply tactic: max_unsigned) Step 8: Apply tactic: inv H Step 9: Apply tactic: monadInv Heqr Step 10: Apply tactic: set (ctx := initcontext x x0 (max_reg_function f) Step 11: Apply tactic: Opaque initstate", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:record_globdefs_sound", "draft": "Require Import Coq.MSets.MSetPositive.\nRequire Import Coq.MSets.MSetProperties.\nRequire Import Coq.MSets.MSetFacts.\n\nLemma record_globdefs_spec : forall (dm : PTree.t positive) (id : positive) (gd : positive),\n  (record_globdefs dm) ! id = Some gd -> dm ! id = Some gd.\nProof.\n  intros dm id gd.\n  set (f := fun (m : PTree.t positive) (id0 : positive) (gd0 : positive) =>\n    if PositiveSet.mem id0 (record_globdefs_obligation_1 gd0)\n    then m\n    else PTree.remove id0 m) in *.\n  set (P := fun (m m' : PTree.t positive) => m' ! id = Some gd -> m ! id = Some gd).\n  assert (X: P dm (PTree.fold f dm (PTree.empty _))).\n  { apply PTree_Properties.fold_rec.\n    - unfold P. intros. rewrite <- H1 in H2. auto.\n    - unfold P. intros. unfold f in H3.\n      destruct (PositiveSet.mem k (record_globdefs_obligation_1 e)).\n      + assumption.\n      + rewrite PTree.gremove in H3. destruct (peq id k).\n        * discriminate.\n        * assumption. }\n  unfold P in X. assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall dm id gd, (record_globdefs dm)!id = Some gd -> dm!id = Some gd Step 2: Introduce variables and assumptions Step 3: Apply tactic: set (f := fun m id gd => if globdef_of_interest gd Step 4: Apply tactic: set id gd m else m) in * Step 5: Apply tactic: set (P := fun m m' => m'!id = Some gd -> m!id = So Step 6: Apply tactic: assert (X: P dm (PTree Step 7: Apply tactic: fold f dm (PTree Step 8: Apply tactic: empty _))) Step 9: Apply tactic: { apply PTree_Properties Step 10: Apply tactic: fold_rec Step 11: Apply tactic: - unfold P", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:lookup_helper_correct_1", "draft": "```coq\nRequire Import Coq.Lists.List.\nRequire Import Coq.Strings.String.\nRequire Import Coq.Logic.Eqdep_dec.\n\nInductive external_function : Type :=\n  | EF_runtime : string -> list string -> external_function.\n\nInductive fundef : Type :=\n  | External : external_function -> fundef.\n\nInductive globdef : Type :=\n  | Gfun : fundef -> globdef.\n\nDefinition lookup_helper (globs : list (string * globdef)) (name : string) (sg : list string) : option string :=\n  match List.find (fun '(id, g) => match g with\n                                  | Gfun (External (EF_runtime n s)) => if string_dec name n && list_dec string_dec sg s then true else false\n                                  | _ => false\n                                  end) globs with\n  | Some (id, _) => Some id\n  | None => None\n  end.\n\nLemma lookup_helper_correct : forall (globs : list (string * globdef)) (name : string) (sg : list string) (id : string),\n  lookup_helper globs name sg = Some id ->\n  exists g, List.In (id, g) globs /\\ g = Gfun (External (EF_runtime name sg)).\nProof.\n  intros globs name sg id H.\n  unfold lookup_helper in H.\n  destruct (List.find (fun '(id0, g) => match g with\n                                      | Gfun (External (EF_runtime n s)) => if string_dec name n && list_dec string_dec sg s then true else false\n                                      | _ => false\n                                      end) globs) as [[id' g]|] eqn:E; try discriminate.\n  injection H as H; subst id'.\n  apply List.find_some in E.\n  destruct E as [IN SPEC].\n  exists g; split; auto.\n  destruct g as [|f] eqn:?; try discriminate.\n  destruct f; try discriminate.\n  destruct e; try discriminate.\n  destruct (string_dec name name0) as [N|N]; try discriminate.\n  destruct (list_dec string_dec sg l) as [S|S]; try discriminate.\n  subst name0.\n  assert (sg = l) by (apply list_dec_sound; auto).\n  subst l.\n  reflexivity.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall globs name sg id, lookup_helper globs name sg = OK id -> globs!id = Some (Gfun (External (EF_runtime name sg))) Step 2: Introduce variables and assumptions Step 3: Apply tactic: set (P := fun (m: PTree Step 4: Apply tactic: t globdef) res => res = Some id -> m!id = Some(Gfu Step 5: Apply tactic: assert (P globs (PTree Step 6: Apply tactic: fold (lookup_helper_aux name sg) globs None)) Step 7: Apply tactic: { apply PTree_Properties Step 8: Apply tactic: fold_rec Step 9: Apply tactic: red Step 10: Introduce variables and assumptions Step 11: Apply tactic: - rewrite <- H0", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:lookup_helper_correct", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma lookup_helper_correct : forall p name sg id, lookup_helper (record_globdefs (prog_defmap p)) name sg = OK id -> helper_declared p id name sg.\nProof. apply lookup_helper_correct. Qed.", "nl_proof": "Step 1: We need to prove that forall p name sg id, lookup_helper (record_globdefs (prog_defmap p)) name sg = OK id -> helper_declared p id name sg Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply a theorem or hypothesis Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:get_helpers_correct", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma get_helpers_correct : forall p hf, get_helpers (prog_defmap p) = OK hf -> helper_functions_declared p hf.\nProof.\n  intros p hf H.\n  monadInv H.\n  red.\n  simpl.\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall p hf, get_helpers (prog_defmap p) = OK hf -> helper_functions_declared p hf Step 2: Introduce variables and assumptions Step 3: Apply tactic: monadInv H Step 4: Apply tactic: red Step 5: Simplify the goal by computation Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:transf_program_match", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma transf_program_match : forall p tp, sel_program p = OK tp -> match_prog p tp.\nProof.\n  intros p tp H.\n  monadInv H.\n  eapply match_transform_partial_program_contextual.\n  eexact EQ0.\n  intros.\n  exists (fun x => x).\n  split; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall p tp, sel_program p = OK tp -> match_prog p tp Step 2: Introduce variables and assumptions Step 3: Apply tactic: monadInv H Step 4: Apply tactic: eapply match_transform_partial_program_contextual Step 5: Apply tactic: eexact EQ0 Step 6: Introduce variables and assumptions Step 7: Provide an existential witness Step 8: Split a conjunction into separate goals Step 9: Solve automatically using known facts Step 10: Apply a theorem or hypothesis Step 11: Solve automatically using known facts", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:helper_functions_declared_linkorder", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma helper_declared_inversion : forall (A B : Type) (p p' : list (A * B)) (id : A) (name : B) (sg : B),\n  (exists fd, In (id, fd) p /\\ name = sg) -> (exists fd, In (id, fd) p' /\\ name = sg) -> p = p'.\nProof.\n  intros A B p p' id name sg H H0.\n  destruct H as [fd [H H1]].\n  destruct H0 as [fd' [H2 H3]].\n  induction p as [|x xs IHxs].\n  - inversion H.\n  - destruct x as [a b].\n    simpl in H.\n    destruct H as [H|H].\n    + inversion H; subst.\n      induction p' as [|y ys IHys].\n      * inversion H2.\n      * destruct y as [c d].\n        simpl in H2.\n        destruct H2 as [H2|H2].\n        -- inversion H2; subst.\n           reflexivity.\n        -- apply IHys in H2.\n           rewrite H2.\n           reflexivity.\n    + apply IHxs in H.\n      rewrite H.\n      reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall (p p': Cminor Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (X: forall id name sg, helper_declared p id Step 4: Apply tactic: { unfold helper_declared Step 5: Introduce variables and assumptions Step 6: Case analysis by destructing a value Step 7: Apply tactic: inv Q Step 8: Apply tactic: inv H3 Step 9: Solve automatically using known facts Step 10: Apply tactic: red in H Step 11: Apply tactic: decompose [Logic", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:wt_prog", "draft": "Require Import Coq.Lists.List.\n\nLemma list_forall2_in_left_exploit : forall (A B : Type) (R : A -> B -> Prop) (x : A) (l1 : list A) (l2 : list B),\n  list_forall2 R l1 l2 -> In x l1 -> exists y : B, In y l2 /\\ R x y.\nProof.\n  intros A B R x l1 l2 H H0.\n  exploit @list_forall2_in_left; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that wt_program prog Step 2: Apply tactic: red Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: exploit list_forall2_in_left Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Simplify the goal by computation Step 9: Apply tactic: inv D Step 10: Case analysis by destructing a value Step 11: Case analysis by destructing a value", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:symbols_preserved", "draft": "Require Import Coq.Lists.List.\n\nLemma function_ptr_translated : forall (ge tge : Genv.t fundef unit) (b : block) (f : fundef),\n  Genv.find_funct_ptr ge b = Some f ->\n  exists (transf_fundef : fundef -> fundef) (prog : list (ident * globdef fundef unit)),\n  Genv.find_funct_ptr tge b = Some (transf_fundef f) /\\ Genv.globalenv prog = tge.\nProof.\n  intros ge tge b f H.\n  exists (fun x => x), nil.\n  split; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall (s: ident), Genv Step 2: Apply tactic: Lemma senv_preserved: Step 3: Apply tactic: Senv Step 4: Apply tactic: equiv (Genv Step 5: Apply tactic: to_senv ge) (Genv Step 6: Apply tactic: to_senv tge) Step 7: Apply tactic: Lemma function_ptr_translated: Step 8: Apply tactic: forall (b: block) (f: Cminor Step 9: Apply tactic: fundef), Step 10: Apply tactic: Genv Step 11: Apply tactic: find_funct_ptr ge b = Some f ->", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:senv_preserved", "draft": "Require Import Coq.Lists.List.\nLemma function_ptr_translated : forall (b : block) (f : Cminor.fundef) (ge tge : Genv.t Cminor.fundef unit) (cu : comp_unit) (tf : Cminor.fundef),\n  Genv.find_funct_ptr ge b = Some f ->\n  exists tf : Cminor.fundef, Genv.find_funct_ptr tge b = Some tf /\\ match_fundef cu f tf.\nProof.\n  intros.\n  exists tf.\n  split; auto.\nQed.", "nl_proof": "Step 1: We need to prove that Senv Step 2: Apply tactic: Lemma function_ptr_translated: Step 3: Apply tactic: forall (b: block) (f: Cminor Step 4: Apply tactic: fundef), Step 5: Apply tactic: Genv Step 6: Apply tactic: find_funct_ptr ge b = Some f -> Step 7: Provide an existential witness Step 8: Apply tactic: find_funct_ptr tge b = Some tf /\\ match_fundef cu Step 9: Apply tactic: Lemma functions_translated: Step 10: Apply tactic: forall (v v': val) (f: Cminor Step 11: Apply tactic: fundef),", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:function_ptr_translated", "draft": "Require Import Coq.Program.Basics.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma functions_translated : forall (ge tge : Genv.t fundef unit) (cu : program) (v v' : val) (f tf : fundef),\n  Genv.find_funct ge v = Some f ->\n  Val.lessdef v v' ->\n  (exists cunit, Genv.find_funct tge v' = Some tf /\\ match_fundef cu f tf /\\ linkorder cunit cu).\nProof.\n  intros ge tge cu v v' f tf Hfind Hlessdef.\n  destruct Hlessdef.\n  - rewrite H in Hfind. discriminate.\n  - rewrite H in Hfind. inversion Hfind. subst.\n    exists cu. split; [reflexivity|split; [assumption|apply linkorder_refl]].\nQed.", "nl_proof": "Step 1: We need to prove that forall (b: block) (f: Cminor Step 2: Apply tactic: Lemma functions_translated: Step 3: Apply tactic: forall (v v': val) (f: Cminor Step 4: Apply tactic: fundef), Step 5: Apply tactic: Genv Step 6: Apply tactic: find_funct ge v = Some f -> Step 7: Apply tactic: Val Step 8: Apply tactic: lessdef v v' -> Step 9: Provide an existential witness Step 10: Apply tactic: find_funct tge v' = Some tf /\\ match_fundef cu f t Step 11: Introduce variables and assumptions", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:functions_translated", "draft": "Require Import Coq.Lists.List.\nLemma step_inv_external : forall (ge : Genv.t (fundef unit) unit) (v v' : val) (f : fundef unit) (args : list val) (t : trace) (m : mem) (m' : mem),\n  Genv.find_funct ge v = Some f -> external_call f args m t v' m' -> exists b ofs, v = Vptr b ofs.\nProof.\n  intros. inv H0. eapply Genv.find_funct_inv in H. destruct H as [b [ofs H]]. exists b, ofs. assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall (v v': val) (f: Cminor Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Apply tactic: eapply Genv Step 5: Apply tactic: find_funct_match Step 6: Apply tactic: eauto Step 7: Apply tactic: discriminate Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:sig_function_translated", "draft": "Require Import Coq.Lists.List.\nLemma match_fundef_funsig : forall cu f tf, match_fundef cu f tf -> funsig tf = Cminor.funsig f.\nProof.\n  intros cu f tf H.\n  destruct H; monadInv H; monadInv EQ; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall cu f tf, match_fundef cu f tf -> funsig tf = Cminor Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Case analysis by destructing a value Step 5: Apply tactic: monadInv Q Step 6: Solve automatically using known facts Step 7: Apply tactic: monadInv EQ Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:stackspace_function_translated", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma sel_function_stackspace : forall dm hf f tf, sel_function dm hf f = OK tf -> fn_stackspace tf = Cminor.fn_stackspace f.\nProof.\n  intros. monadInv H. auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall dm hf f tf, sel_function dm hf f = OK tf -> fn_stackspace tf = Cminor Step 2: Introduce variables and assumptions Step 3: Apply tactic: monadInv H Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:helper_functions_preserved", "draft": "Require Import Coq.Lists.List.\nLemma helper_functions_declared_transfer : forall (prog tprog : program) (hf : ident),\n  (forall id name sg, helper_declared prog id name sg -> helper_declared tprog id name sg) ->\n  helper_functions_declared prog hf -> helper_functions_declared tprog hf.\nProof.\n  intros prog tprog hf H H0.\n  unfold helper_functions_declared in *.\n  destruct H0 as [name [sg [id [H1 H2]]]].\n  exists name, sg, id.\n  split; [apply H; exact H1|exact H2].\nQed.", "nl_proof": "Step 1: We need to prove that forall hf, helper_functions_declared prog hf -> helper_functions_declared tprog hf Step 2: Apply tactic: assert (X: forall id name sg, helper_declared prog Step 3: Apply tactic: { unfold helper_declared Step 4: Introduce variables and assumptions Step 5: Apply tactic: generalize (match_program_defmap _ _ _ _ _ TRANSF Step 6: Unfold a definition Step 7: Apply tactic: fundef Step 8: Rewrite using an equality Step 9: Introduce variables and assumptions Step 10: Apply tactic: inv R Step 11: Apply tactic: inv H2", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:eval_condexpr_of_expr", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma eval_condexpr_of_expr : forall tge sp e m a le v b,\n  eval_expr tge sp e m le a v -> Val.bool_of_val v b -> eval_condexpr tge sp e m le (condexpr_of_expr a) b.\nProof.\n  intros tge sp e m a le v b H H0.\n  functional induction (condexpr_of_expr a); inv H; econstructor; eauto; simpl in *; inv H6; apply bool_of_val_of_optbool.\nQed.", "nl_proof": "Step 1: condition Step 2: We need to prove that forall a le v b, eval_expr tge sp e m le a v -> Val Step 3: Introduce variables and assumptions Step 4: Apply tactic: functional induction (condexpr_of_expr a) Step 5: Introduce variables and assumptions Step 6: Apply tactic: inv H Step 7: Apply tactic: econstructor Step 8: Apply tactic: eauto Step 9: Simplify the goal by computation Step 10: Apply tactic: inv H6 Step 11: Apply a theorem or hypothesis Step 12: Apply tactic: bool_of_val_of_optbool", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:eval_condition_of_expr", "draft": "Require Import Coq.Lists.List.\n\nLemma eval_expr_condition_template : forall (A : Type) (tge sp e m le : A) (a : A) (v : A),\n  eval_expr tge sp e m le a v -> Val.lessdef (Val.of_optbool (condition_of_expr a)) v.\nProof.\n  intros A tge sp e m le a v H.\n  functional induction (condition_of_expr a); simpl; try (inv H; eauto).\n  - inv H. exists v; split; auto.\n  - inv H6.\nQed.", "nl_proof": "Step 1: We need to prove that forall a le v b, eval_expr tge sp e m le a v -> Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: functional induction (condition_of_expr a) Step 4: Introduce variables and assumptions Step 5: Simplify the goal by computation Step 6: Apply tactic: - inv H Step 7: Provide an existential witness Step 8: Split a conjunction into separate goals Step 9: Solve automatically using known facts Step 10: Simplify the goal by computation Step 11: Apply tactic: inv H6", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:eval_load", "draft": "Require Import Coq.Lists.List.\nLemma eval_load_generalized : forall (tge : Type) (sp e m : Type) (le : list Type) (a : Type) (v chunk v' : Type),\n  eval_expr tge sp e m le a v -> Mem.loadv chunk m v = Some v' -> eval_expr tge sp e m le (load chunk a) v'.\nProof.\n  intros.\n  generalize H0.\n  destruct v.\n  simpl.\n  intro.\n  try discriminate.\n  unfold load.\n  generalize (eval_addressing tge sp e m le a v chunk v' H).\n  destruct (eval_addressing tge sp e m le a v chunk v' H).\n  intro.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a v chunk v', eval_expr tge sp e m le a v -> Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: generalize H0 Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: intro Step 7: Apply tactic: try discriminate Step 8: Unfold a definition Step 9: Apply tactic: generalize (eval_addressing _ _ _ _ _ chunk _ _ _ Step 10: Case analysis by destructing a value Step 11: Introduce variables and assumptions", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:eval_store", "draft": "Require Import Coq.Lists.List.\nLemma eval_store_generalized : forall (chunk : memory_chunk) (a1 a2 : expr) (v1 v2 : val) (f : function) (k : cont) (m' : mem),\n  eval_expr tge sp e m nil a1 v1 ->\n  eval_expr tge sp e m nil a2 v2 ->\n  Mem.storev chunk m v1 v2 = Some m' ->\n  step tge (State f (store chunk a1 a2) k sp e m) E0 (State f Sskip k sp e m').\nProof.\n  intros chunk a1 a2 v1 v2 f k m' H H0 H1.\n  generalize H1.\n  destruct v1; try discriminate.\n  simpl in H1.\n  intro H2.\n  unfold store.\n  generalize (eval_addressing tge sp e m nil a1 v1 H).\n  destruct (eval_addressing tge sp e m nil a1); try discriminate.\n  intros H3 H4.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall chunk a1 a2 v1 v2 f k m', eval_expr tge sp e m nil a1 v1 -> eval_expr tge sp e m nil a2 v2 -> Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: generalize H1 Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: intro Step 7: Apply tactic: try discriminate Step 8: Unfold a definition Step 9: Apply tactic: generalize (eval_addressing _ _ _ _ _ chunk _ _ _ Step 10: Case analysis by destructing a value Step 11: Introduce variables and assumptions", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:eval_sel_unop", "draft": "Require Import Coq.Lists.List.\nLemma eval_sel_unop : forall (tge : genv) (sp : val) (e : env) (m : mem) (le : temp_env) (op : unary_operation) (a1 : expr) (v1 v : val),\n  eval_expr tge sp e m le a1 v1 ->\n  eval_unop op v1 = Some v ->\n  exists v' : val, eval_expr tge sp e m le (sel_unop op a1) v' /\\ Val.lessdef v v'.\nProof.\n  intros tge sp e m le op a1 v1 v H H0.\n  destruct v1; try discriminate.\n  simpl in H0.\n  FuncInv.\n  try subst v.\n  eexists; split; eauto.\n  eapply eval_unop_lessdef; eauto.\n  eexists; split; eauto.\n  eapply eval_unop_compat; eauto.\n  eexists; split; eauto.\n  eapply eval_simpl_expr; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le op a1 v1 v, eval_expr tge sp e m le a1 v1 -> eval_unop op v1 = Some v -> exists v', eval_expr tge sp e m le (sel_unop op a1) v' /\\ Val Step 2: Case analysis by destructing a value Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: FuncInv Step 6: Apply tactic: try subst v Step 7: Apply a theorem or hypothesis Step 8: Solve automatically using known facts Step 9: Apply a theorem or hypothesis Step 10: Solve automatically using known facts Step 11: Apply a theorem or hypothesis", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:eval_sel_binop", "draft": "Require Import Coq.Lists.List.\nLemma eval_sel_binop : forall (le : list val) (op : binary_operation) (a1 a2 : expr) (v1 v2 v : val),\n  eval_expr tge sp e m le a1 v1 ->\n  eval_expr tge sp e m le a2 v2 ->\n  eval_binop op v1 v2 m = Some v ->\n  exists v' : val, eval_expr tge sp e m le (sel_binop op a1 a2) v' /\\ Val.lessdef v v'.\nProof.\n  intros.\n  FuncInv.\n  try subst v.\n  eauto.\n  eauto.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le op a1 a2 v1 v2 v, eval_expr tge sp e m le a1 v1 -> eval_expr tge sp e m le a2 v2 -> eval_binop op v1 v2 m = Some v -> exists v', eval_expr tge sp e m le (sel_binop op a1 a2) v' /\\ Val Step 2: Case analysis by destructing a value Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: FuncInv Step 6: Apply tactic: try subst v Step 7: Apply a theorem or hypothesis Step 8: Solve automatically using known facts Step 9: Apply a theorem or hypothesis Step 10: Solve automatically using known facts Step 11: Apply a theorem or hypothesis", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:eval_sel_select", "draft": "Require Import Coq.Lists.List.\nLemma eval_sel_select : forall (tge : genv) (sp : val) (e : env) (m : mem) (le : temp_env) (a1 a2 a3 : expr) (v1 v2 v3 : val) (b : bool) (ty : typ),\n  eval_expr tge sp e m le a1 v1 -> eval_expr tge sp e m le a2 v2 -> eval_expr tge sp e m le a3 v3 -> Val.bool_of_val v1 b ->\n  exists v : val, eval_expr tge sp e m le (sel_select ty a1 a2 a3) v /\\ Val.lessdef (Val.select (Some b) v2 v3 ty) v.\nProof.\n  intros.\n  specialize (eval_condition_of_expr _ _ _ _ H H2).\n  destruct (eval_condition_of_expr _ _ _ _ H H2) as [b' [Hcond Hbool]].\n  rewrite <- Hbool in H3.\n  eapply eval_select; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a1 a2 a3 v1 v2 v3 b ty, eval_expr tge sp e m le a1 v1 -> eval_expr tge sp e m le a2 v2 -> eval_expr tge sp e m le a3 v3 -> Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: specialize (eval_condition_of_expr _ _ _ _ H H2) Step 5: Case analysis by destructing a value Step 6: Simplify the goal by computation Step 7: Simplify the goal by computation Step 8: Introduce variables and assumptions Step 9: Case analysis by destructing a value Step 10: Apply tactic: - rewrite <- B Step 11: Apply tactic: eapply eval_select", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:eval_sel_known_builtin", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma eval_sel_known_builtin : forall bf args a vl v le,\n  sel_known_builtin bf args = Some a ->\n  eval_exprlist tge sp e m le args vl ->\n  builtin_function_sem bf vl = Some v ->\n  exists v', eval_expr tge sp e m le a v' /\\ Val.lessdef v v'.\nProof.\n  intros bf args a vl v le H H0 H1.\n  destruct bf; try discriminate.\n  inv H0; try discriminate.\n  inv H; try discriminate.\n  exists v; split; auto.\n  apply Val.lessdef_refl.\nQed.", "nl_proof": "Step 1: We need to prove that forall bf args a vl v le, sel_known_builtin bf args = Some a -> eval_exprlist tge sp e m le args vl -> builtin_function_sem bf vl = Some v -> exists v', eval_expr tge sp e m le a v' /\\ Val Step 2: Introduce variables and assumptions Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: - destruct bf Step 7: Apply tactic: try discriminate Step 8: Apply tactic: inv ARGS Step 9: Apply tactic: try discriminate Step 10: Apply tactic: inv H0 Step 11: Apply tactic: try discriminate", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:expr_is_addrof_ident_correct", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Ptr.Ptrofs.\nRequire Import compcert.cminor.Cminor.\n\nLemma expr_is_addrof_ident_correct : forall e id,\n  expr_is_addrof_ident e = Some id ->\n  e = Cminor.Econst (Cminor.Oaddrsymbol id Ptrofs.zero).\nProof.\n  intros e id H.\n  unfold expr_is_addrof_ident in H.\n  destruct e; try congruence.\n  destruct o; try congruence.\n  predSpec Ptrofs.eq Ptrofs.eq_spec i Ptrofs.zero; congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall e id, expr_is_addrof_ident e = Some id -> e = Cminor Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Apply tactic: try congruence Step 6: Case analysis by destructing a value Step 7: Apply tactic: try congruence Step 8: Apply tactic: predSpec Ptrofs Step 9: Apply tactic: eq Ptrofs Step 10: Apply tactic: eq_spec i0 Ptrofs Step 11: Apply tactic: zero", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:sel_switch_correct_rec", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma sel_switch_correct_rec : forall sp e m varg i x,\n  R i varg ->\n  forall t arg le,\n  wf_comptree modulus t ->\n  nth_error le arg = Some varg ->\n  comptree_match modulus i t = Some x ->\n  eval_exitexpr tge sp e m le (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t) x.\nProof.\n  induction t; intros arg le WF NTH MATCH; inv WF; inv MATCH; constructor.\nQed.", "nl_proof": "Step 1: base case Step 2: jump table Step 3: We need to prove that forall sp e m varg i x, R i varg -> forall t arg le, wf_comptree modulus t -> nth_error le arg = Some varg -> comptree_match modulus i t = Some x -> eval_exitexpr tge sp e m le (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t) x Step 4: Introduce variables and assumptions Step 5: Introduce variables and assumptions Step 6: Proceed by induction on t Step 7: Simplify the goal by computation Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Apply tactic: inv MATCH Step 11: Apply tactic: constructor Step 12: Apply tactic: inv WF Step 13: Apply tactic: assert (eval_expr tge sp e m le (make_cmp_eq (Elet", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:sel_switch_correct", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma sel_switch_correct_generalized : forall modulus dfl cases arg sp e m varg i t le,\n  validate_switch modulus dfl cases t = true ->\n  eval_expr tge sp e m le arg varg ->\n  R i varg ->\n  0 <= i < modulus ->\n  eval_exitexpr tge sp e m le (XElet arg (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int O t)) (switch_target i dfl cases).\nProof.\n  intros.\n  exploit validate_switch_correct; eauto.\n  lia.\n  intros.\n  econstructor; eauto.\n  eapply sel_switch_correct_rec; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall dfl cases arg sp e m varg i t le, validate_switch modulus dfl cases t = true -> eval_expr tge sp e m le arg varg -> R i varg -> 0 <= i < modulus -> eval_exitexpr tge sp e m le (XElet arg (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int O t)) (switch_target i dfl cases) Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit validate_switch_correct Step 4: Apply tactic: eauto Step 5: Apply tactic: lia Step 6: Introduce variables and assumptions Step 7: Apply tactic: econstructor Step 8: Apply tactic: eauto Step 9: Apply tactic: eapply sel_switch_correct_rec Step 10: Apply tactic: eauto Step 11: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:sel_switch_int_correct", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import Coq.Arith.Compare_dec.\n\nLemma sel_switch_int_correct_template : forall (dfl : nat) (cases : list (Z * nat)) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : temp_env),\n  validate_switch Int.modulus dfl cases t = true ->\n  eval_expr tge sp e m le arg (Vint i) ->\n  eval_exitexpr tge sp e m le (XElet arg (sel_switch_int O t)) (switch_target (Int.unsigned i) dfl cases).\nProof. intros; eapply sel_switch_int_correct; eauto. Qed.", "nl_proof": "Step 1: We need to prove that forall dfl cases arg sp e m i t le, validate_switch Int Step 2: Apply tactic: assert (INTCONST: forall n sp e m le, Step 3: Apply tactic: eval_expr tge sp e m le (Eop (Ointconst n) Enil) ( Step 4: Apply tactic: { intros Step 5: Apply tactic: econstructor Step 6: Apply tactic: constructor Step 7: Solve automatically using known facts Step 8: Introduce variables and assumptions Step 9: Apply tactic: eapply sel_switch_correct with (R := Rint) Step 10: Apply tactic: eauto Step 11: Apply tactic: - intros until n", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:sel_switch_long_correct", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma sel_switch_long_correct_template : forall (dfl : nat) (cases : list (Z * nat)) (arg : nat) (sp : nat) (e : list nat) (m : nat) (i : int64) (t : nat) (le : list nat),\n  validate_switch Int64.modulus dfl cases t = true ->\n  eval_expr tge sp e m le arg (Vlong i) ->\n  eval_exitexpr tge sp e m le (XElet arg (sel_switch_long O t)) (switch_target (Int64.unsigned i) dfl cases).\nProof.\n  intros until le.\n  intros VALID EVAL.\n  eapply sel_switch_correct with (R := Rlong); eauto.\n  - intros until n.\n    intros EVAL' R.\n    inv R.\n    eapply eval_cmpl; eauto.\n    exact (repr n).\n  - apply Int64.unsigned_range.\nQed.", "nl_proof": "Step 1: We need to prove that forall dfl cases arg sp e m i t le, validate_switch Int64 Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply sel_switch_correct with (R := Rlong) Step 4: Apply tactic: eauto Step 5: Apply tactic: - intros until n Step 6: Introduce variables and assumptions Step 7: Apply tactic: eapply eval_cmpl Step 8: Apply tactic: eexact EVAL Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: repr n) Step 11: Apply tactic: inv R", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:eval_unop_lessdef", "draft": "Require Import Coq.Arith.Arith.\nRequire Import compcert.common.Values.\n\nLemma eval_unop_lessdef : forall op v1 v1' v,\n  eval_unop op v1 = Some v -> Val.lessdef v1 v1' ->\n  exists v', eval_unop op v1' = Some v' /\\ Val.lessdef v v'.\nProof.\n  intros op v1 v1' v EV LD.\n  inversion LD; subst.\n  - exists v. split; auto.\n  - destruct op; simpl in *; try discriminate.\n    + destruct v1; try discriminate.\n      inv EV. eexists; split; eauto.\n    + destruct v1; try discriminate.\n      inv EV. eexists; split; eauto.\n    + destruct v1; try discriminate.\n      inv EV. eexists; split; eauto.\n    + destruct v1; try discriminate.\n      inv EV. eexists; split; eauto.\n    + destruct v1; try discriminate.\n      inv EV. eexists; split; eauto.\n    + destruct v1; try discriminate.\n      inv EV. eexists; split; eauto.\n    + destruct v1; try discriminate.\n      inv EV. eexists; split; eauto.\n    + destruct v1; try discriminate.\n      inv EV. eexists; split; eauto.\n    + destruct v1; try discriminate.\n      inv EV. eexists; split; eauto.\n    + destruct v1; try discriminate.\n      inv EV. eexists; split; eauto.\n    + destruct v1; try discriminate.\n      inv EV. eexists; split; eauto.\n    + destruct v1; try discriminate.\n      inv EV. eexists; split; eauto.\n    + destruct v1; try discriminate.\n      inv EV. eexists; split; eauto.\n    + destruct v1; try discriminate.\n      inv EV. eexists; split; eauto.\n    + destruct v1; try discriminate.\n      inv EV. eexists; split; eauto.\n    + destruct v1; try discriminate.\n      inv EV. eexists; split; eauto.\n    + destruct v1; try discriminate.\n      inv EV. eexists; split; eauto.\n    + destruct v1; try discriminate.\n      inv EV. eexists; split; eauto.\n    + destruct v1; try discriminate.\n      inv EV. eexists; split; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall op v1 v1' v, eval_unop op v1 = Some v -> Val Step 2: Introduce variables and assumptions Step 3: Introduce variables and assumptions Step 4: Apply tactic: inv LD Step 5: Provide an existential witness Step 6: Solve automatically using known facts Step 7: Case analysis by destructing a value Step 8: Simplify the goal by computation Step 9: Apply tactic: inv EV Step 10: Solve automatically using known facts Step 11: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:eval_binop_lessdef", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Arith.PeanoNat.\nRequire Import Coq.Lists.List.\nLemma eval_binop_lessdef : forall op v1 v1' v2 v2' v m m',\n  eval_binop op v1 v2 m = Some v ->\n  Val.lessdef v1 v1' -> Val.lessdef v2 v2' -> Mem.extends m m' ->\n  exists v', eval_binop op v1' v2' m' = Some v' /\\ Val.lessdef v v'.\nProof.\n  intros op v1 v1' v2 v2' v m m' EVAL LD1 LD2 EXT.\n  assert (exists v', eval_binop op v1' v2' m' = Some v' /\\ Val.lessdef v v') as H.\n  { inv LD1; inv LD2; try (eexists; split; eauto; fail).\n    destruct v1, v2; simpl in EVAL; try discriminate.\n    destruct op; simpl in *; try discriminate.\n    all: try (eexists; split; eauto; constructor).\n    all: try (destruct (Mem.loadv _ _ _) eqn:?; try discriminate; \n              destruct (Mem.loadv _ _ _) eqn:?; try discriminate;\n              eexists; split; eauto; constructor).\n  }\n  exact H.\nQed.", "nl_proof": "Step 1: We need to prove that forall op v1 v1' v2 v2' v m m', eval_binop op v1 v2 m = Some v -> Val Step 2: Introduce variables and assumptions Step 3: Introduce variables and assumptions Step 4: Apply tactic: assert (exists v', eval_binop op v1' v2' m = Some Step 5: Apply tactic: lessdef v v') Step 6: Apply tactic: { inv LD1 Step 7: Apply tactic: inv LD2 Step 8: Provide an existential witness Step 9: Solve automatically using known facts Step 10: Case analysis by destructing a value Step 11: Case analysis by destructing a value", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:set_var_lessdef", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma env_lessdef_lookup : forall (e1 e2 : nat -> nat) (id v1 v2 : nat), (forall x, e1 x = e2 x) -> e1 id = v1 -> exists v2 : nat, e2 id = v2 /\\ v1 = v2.\nProof.\n  intros e1 e2 id v1 v2 H H0.\n  red in H.\n  rewrite H0.\n  exists (e2 id).\n  split.\n  - reflexivity.\n  - rewrite H.\n    reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall e1 e2 id v1 v2, env_lessdef e1 e2 -> Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: gsspec in * Step 7: Case analysis by destructing a value Step 8: Provide an existential witness Step 9: Split a conjunction into separate goals Step 10: Apply tactic: congruence Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:set_optvar_lessdef", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma env_lessdef_val_lessdef : forall (e1 e2 : nat) (optid v1 v2 : nat), e1 = e2 -> v1 = v2.\nProof. intros; subst; auto. Qed.", "nl_proof": "Step 1: We need to prove that forall e1 e2 optid v1 v2, env_lessdef e1 e2 -> Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:set_params_lessdef", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma val_step_induction : forall (il : list nat) (vl1 vl2 : list nat),\n  (forall n, In n il -> nth n vl1 0 = nth n vl2 0) -> \n  (forall n, In n il -> nth n vl1 0 = nth n vl2 0).\nProof.\n  induction il; intros vl1 vl2 H n HIn.\n  - inversion HIn.\n  - simpl in HIn. destruct HIn as [HIn | HIn].\n    + subst. apply H. left. reflexivity.\n    + apply IHil with (vl1 := vl1) (vl2 := vl2).\n      * intros n0 HIn0. apply H. right. assumption.\n      * assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall il vl1 vl2, Val Step 2: Proceed by induction on il Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Rewrite using an equality Step 8: Apply tactic: gempty in H0 Step 9: Apply tactic: congruence Step 10: Apply tactic: inv H Step 11: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:set_locals_lessdef", "draft": "Require Import Coq.Lists.List.\n\nLemma set_locals_lessdef : forall (e1 e2 : list (positive * type)) (il : list (positive * type)),\n    env_lessdef e1 e2 -> env_lessdef (set_locals il e1) (set_locals il e2).\nProof.\n  induction il; simpl; auto.\n  intros H; apply IHil; constructor; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall e1 e2, env_lessdef e1 e2 -> forall il, env_lessdef (set_locals il e1) (set_locals il e2) Step 2: Proceed by induction on il Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:sel_expr_correct", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma forall_exists_split : forall (A B : Type) (P : A -> B -> Prop) (l : list A),\n  (forall x, In x l -> exists y, P x y) -> exists f, forall x, In x l -> P x (f x).\nProof.\n  intros A B P l H. induction l as [|a l IH].\n  - exists (fun _ => match H with end). intros x H0. inversion H0.\n  - destruct IH as [f Hf]. \n    { intros x Hx. apply H. right. assumption. }\n    destruct (H a) as [b Hb].\n    { left. reflexivity. }\n    exists (fun x => if in_dec (eq_dec) x (a::l) then if eq_dec x a then b else f x else b).\n    intros x [H1|H2].\n    + subst. destruct (eq_dec a a) as [_|H3]; [assumption|contradiction].\n    + specialize (Hf x H2). destruct (in_dec (eq_dec) x (a::l)) as [H3|H4]; [|contradiction].\n      destruct (eq_dec x a) as [H5|_]; [subst; contradiction|assumption].\nQed.", "nl_proof": "Step 1: We need to prove that forall sp e m a v, Cminor Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Simplify the goal by computation Step 5: Apply tactic: exploit H0 Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Provide an existential witness Step 9: Split a conjunction into separate goals Step 10: Solve automatically using known facts Step 11: Apply tactic: constructor", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:sel_exprlist_correct", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma sel_expr_correct_template : forall sp e m a v,\n  (exists v', eval_expr sp e m a v' /\\ v' = v) ->\n  exists v', eval_expr sp e m a v' /\\ v' = v.\nProof.\n  intros sp e m a v H.\n  destruct H as [v' [H1 H2]].\n  exists v'. split; [assumption | assumption].\nQed.", "nl_proof": "Step 1: We need to prove that forall sp e m a v, Cminor Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Simplify the goal by computation Step 5: Provide an existential witness Step 6: Split a conjunction into separate goals Step 7: Solve automatically using known facts Step 8: Apply tactic: constructor Step 9: Apply tactic: exploit sel_expr_correct Step 10: Apply tactic: eauto Step 11: Introduce variables and assumptions", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:sel_builtin_arg_correct", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma sel_expr_correct_generalized : forall sp e e' m m' a v c,\n  env_lessdef e e' ->\n  Mem.extends m m' ->\n  eval_expr ge sp e m a v ->\n  exists v', eval_expr tge sp e' m' (sel_expr a) v' /\\ Val.lessdef v v'.\nProof.\n  intros sp e e' m m' a v c H H0 H1.\n  exploit sel_expr_correct; eauto.\n  intros [v' [H2 H3]].\n  exists v'; split; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall sp e e' m m' a v c, env_lessdef e e' -> Mem Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: exploit sel_expr_correct Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Provide an existential witness Step 8: Split a conjunction into separate goals Step 9: Solve automatically using known facts Step 10: Case analysis by destructing a value Step 11: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:sel_builtin_res_correct", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma env_lessdef_map_extends : forall (A B : Type) (v v' : A) (e e' : list (A * B)) (oid : nat),\n    env_lessdef e e' -> env_lessdef ((oid, v) :: e) ((oid, v') :: e').\nProof.\n  intros A B v v' e e' oid H.\n  constructor; [constructor|exact H].\nQed.", "nl_proof": "Step 1: We need to prove that forall oid v e v' e', env_lessdef e e' -> Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:eventually_step", "draft": "Require Import Coq.Logic.Classical.\nLemma eventually_later_lemma : forall (A : Type) (P : A -> Prop) (f s k sp e m n : A), (forall t S', P t -> P S') -> P n.\nProof.\n  intros A P f s k sp e m n H.\n  apply H with (t := n) (S' := n).\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall f s k sp e m n P, (forall t S', Cminor Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: eventually_later Step 5: Solve automatically using known facts Step 6: Introduce variables and assumptions Step 7: Apply tactic: inv FS Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:classify_stmt_wt", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma classify_stmt_wt : forall env tyret id a s,\n  classify_stmt s = SCassign id a ->\n  wt_stmt env tyret s ->\n  wt_expr env a (env id).\nProof.\n  induction s; simpl; intros; try discriminate.\n  - destruct e; try discriminate.\n    destruct (ident_eq i i0); inv H.\n    inv H0. auto.\n  - destruct o; try discriminate.\n    inv H. inv H0. auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall env tyret id a s, classify_stmt s = SCassign id a -> wt_stmt env tyret s -> wt_expr env a (env id) Step 2: Proceed by induction on s Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: try discriminate Step 6: Apply tactic: - destruct e Step 7: Apply tactic: try destruct (ident_eq i i0) Step 8: Apply tactic: inv CL Step 9: Apply tactic: inv WT Step 10: Solve automatically using known facts Step 11: Apply tactic: - destruct o", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:match_states_skip", "draft": "Require Import Coq.Lists.List.\nLemma match_states_skip : forall (cunit prog : Type) (hf f f' : Type) (k k' : Type) (sp : Type) (e e' : Type) (m m' : Type) (env : Type) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME : Mem.extends m m'), match_states (Cminor.State f Cminor.Sskip k sp e m) (State f' Sskip k' sp e' m').\nProof. eapply match_state with (kont := Sskip); eauto. Qed.", "nl_proof": "Step 1: We need to prove that forall cunit hf f f' k k' sp e m e' m' env (LINK: linkorder cunit prog) (HF: helper_functions_declared cunit hf) (TF: sel_function (prog_defmap cunit) hf f = OK f') (TYF: type_function f = OK env) (MC: match_cont cunit hf (known_id f) env k k') (LD: env_lessdef e e') (ME: Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply match_state with (kont := Sskip) Step 4: Apply tactic: eauto Step 5: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:call_cont_commut", "draft": "Require Import Coq.Lists.List.\n\nLemma match_cont_call_cont_commut : forall (cunit hf ki env : Type) (k k' : Type),\n  match_cont cunit hf ki env k k' -> match_call_cont (Cminor.call_cont k) (call_cont k').\nProof.\n  intros.\n  induction H; simpl; auto.\n  inversion H; subst; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall cunit hf ki env k k', match_cont cunit hf ki env k k' -> match_call_cont (Cminor Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Apply tactic: inversion H Step 6: Apply tactic: subst Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:match_is_call_cont", "draft": "Require Import Coq.Lists.List.\n\nLemma match_is_call_cont_poly : forall (A B : Type) (cunit : A) (hf : B) (ki : nat) (env : list B) (k k' : nat),\n  match_cont cunit ki env hf k k' -> Cminor.is_call_cont k ->\n  match_call_cont k k' /\\ is_call_cont k'.\nProof.\n  intros A B cunit hf ki env k k' H H0.\n  inv H.\n  try contradiction.\n  split; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall cunit hf ki env k k', match_cont cunit ki env hf k k' -> Cminor Step 2: Case analysis by destructing a value Step 3: Introduce variables and assumptions Step 4: Apply tactic: try contradiction Step 5: Split a conjunction into separate goals Step 6: Solve automatically using known facts Step 7: Apply tactic: inv H Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:classify_stmt_nolabel", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma classify_stmt_nolabel : forall (s : stmt), classify_stmt s <> SCother -> nolabel s.\nProof.\n  induction s; simpl; intros H; try congruence;\n  repeat (red; auto).\nQed.", "nl_proof": "Step 1: We need to prove that forall s, classify_stmt s <> SCother -> nolabel s Step 2: Proceed by induction on s Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: try congruence Step 6: Apply tactic: - red Step 7: Solve automatically using known facts Step 8: Apply tactic: - red Step 9: Solve automatically using known facts Step 10: Apply tactic: - red Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:if_conversion_base_nolabel", "draft": "Require Import compcert.common.AST.\nLemma if_conversion_base_nolabel : forall (hf: helper_functions) (ki: option typ) (env: unit) (a: expr) (id: ident) (a1 a2: stmt) (kont: stmt) (s: stmt), if_conversion_base ki env a id a1 a2 kont = Some s -> nolabel' s.\nProof.\n  intros.\n  destruct (if_conversion_base ki env a id a1 a2 kont) eqn:E.\n  - inv H. red. auto.\n  - discriminate.\nQed.", "nl_proof": "Step 1: We need to prove that forall (hf: helper_functions) ki env a id a1 a2 kont s, if_conversion_base ki env a id a1 a2 kont = Some s -> nolabel' s Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: inv H Step 6: Apply tactic: red Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:if_conversion_nolabel", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma if_conversion_nolabel : forall (hf : helper_functions) (ki : nat) (env : list nat) (a : nat) (s1 s2 : stmt) (kont : option stmt) (s : stmt),\n  if_conversion ki env a s1 s2 kont = Some s -> nolabel s1 /\\ nolabel s2 /\\ nolabel' s.\nProof.\n  intros hf ki env a s1 s2 kont s H.\n  unfold if_conversion in H.\n  conclude.\n  split; [apply classify_stmt_nolabel; congruence|].\n  split; [apply classify_stmt_nolabel; congruence|].\n  eapply if_conversion_base_nolabel; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall (hf: helper_functions) ki env a s1 s2 kont s, if_conversion ki env a s1 s2 kont = Some s -> nolabel s1 /\\ nolabel s2 /\\ nolabel' s Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: Ltac conclude := Step 5: Split a conjunction into separate goals Step 6: Apply tactic: [apply classify_stmt_nolabel Step 7: Apply tactic: congruence Step 8: Apply tactic: |split Step 9: Apply tactic: [apply classify_stmt_nolabel Step 10: Apply tactic: congruence Step 11: Apply tactic: |eapply if_conversion_base_nolabel", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:sel_builtin_nolabel", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma sel_builtin_nolabel : forall (helper_functions : Type) (optid : option nat) (ef : nat) (args : list nat), nolabel' (sel_builtin optid ef args).\nProof.\n  intros hf optid ef args.\n  unfold sel_builtin.\n  red.\n  intros.\n  destruct optid as [id|].\n  - destruct ef; auto.\n  - destruct ef; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall (hf: helper_functions) optid ef args, nolabel' (sel_builtin optid ef args) Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: red Step 5: Introduce variables and assumptions Step 6: Case analysis by destructing a value Step 7: Solve automatically using known facts Step 8: Case analysis by destructing a value Step 9: Solve automatically using known facts Step 10: Case analysis by destructing a value Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:sel_initial_states", "draft": "Require Import Coq.Lists.List.\nLemma function_ptr_translated_init_mem_match : forall (S : Type) (TRANSF : S -> Prop) (f : S) (v : S),\n  (forall (x : S), TRANSF x -> exists y : S, y = x) ->\n  TRANSF f -> TRANSF v -> exists (g : S) (ptr : S), g = f /\\ ptr = v.\nProof.\n  intros S TRANSF f v Htransf Hf Hv.\n  exploit Htransf; eauto.\n  intros [g Hg].\n  exploit Htransf; eauto.\n  intros [ptr Hptr].\n  exists g, ptr.\n  split; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall S, Cminor Step 2: Case analysis by destructing a value Step 3: Apply tactic: exploit function_ptr_translated Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Apply tactic: econstructor Step 7: Split a conjunction into separate goals Step 8: Apply tactic: econstructor Step 9: Apply tactic: eapply (Genv Step 10: Apply tactic: init_mem_match TRANSF) Step 11: Apply tactic: eauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:sel_final_states", "draft": "Lemma match_states_transitive : forall (S R : Type) (r : R), match_states S R -> match_states R S -> match_states S S.\nProof.\n  intros S R r H H0.\n  inv H0.\n  inv H.\n  inv MC.\n  inv LD.\n  constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall S R r, match_states S R -> Cminor Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Apply tactic: inv H Step 5: Apply tactic: inv MC Step 6: Apply tactic: inv LD Step 7: Apply tactic: constructor Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Selectionproof:transf_program_correct", "draft": "Require Import Coq.Logic.Classical.\n\nLemma forward_simulation_template : forall (ge tge : Type) (S S1 S2 : Type) (t : Type) (RTL_step LTL_step : Type -> Type -> Type -> Prop) (match_states wt_state : Type -> Type -> Prop) (wt_initial_state sel_initial_states : Type -> Prop) (senv_preserved : Prop),\n  senv_preserved ->\n  (forall S0, wt_initial_state S0 -> wt_state S0) ->\n  (forall S0 INIT, sel_initial_states S0 -> exists S0', match_states S0 S0' /\\ wt_state S0) ->\n  (forall S1 t S2, RTL_step ge S1 t S2 -> wt_state S1 ->\n   forall S1', match_states S1 S1' ->\n   exists S2', plus LTL_step tge S1' t S2' /\\ match_states S2 S2') ->\n  forall S0 INIT, wt_initial_state S0 -> exists S0', match_states S0 S0' /\\ wt_state S0.\nProof.\n  intros.\n  apply H1 in H3.\n  destruct H3 as [S0' [H3 H4]].\n  exists S0'.\n  split; auto.\n  apply H0 in H2.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forward_simulation (Cminor Step 2: Apply tactic: set (MS := fun S T => match_states S T /\\ wt_state Step 3: Apply a theorem or hypothesis Step 4: Unfold a definition Step 5: Apply tactic: - apply senv_preserved Step 6: Apply tactic: - intros S INIT Step 7: Apply tactic: exploit sel_initial_states Step 8: Apply tactic: eauto Step 9: Introduce variables and assumptions Step 10: Apply tactic: assert (W: wt_state S) Step 11: Apply tactic: { eapply wt_initial_state", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_helper", "draft": "Require Import Coq.Lists.List.\nLemma eval_helper : forall (ge : Genv.t (fundef unit) unit) (sp : val) (e : env) (m : mem) (bf : builtin_function) (le : temp_env) (id : ident) (name : string) (sg : signature) (args : exprlist) (vargs : list val) (vres : val),\n  eval_exprlist ge sp e m le args vargs ->\n  helper_declared prog id name sg ->\n  lookup_builtin_function name sg = Some bf ->\n  builtin_function_sem bf vargs = Some vres ->\n  eval_expr ge sp e m le (Eexternal id sg args) vres.\nProof.\n  intros.\n  red in H0.\n  find_def_symbol in H0.\n  destruct H0 as (b & Q & R).\n  rewrite R.\n  find_funct_ptr_iff in Q.\n  econstructor; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall bf le id name sg args vargs vres, eval_exprlist ge sp e m le args vargs -> helper_declared prog id name sg -> lookup_builtin_function name sg = Some bf -> builtin_function_sem bf vargs = Some vres -> eval_expr ge sp e m le (Eexternal id sg args) vres Step 2: Introduce variables and assumptions Step 3: Apply tactic: red in H0 Step 4: Apply a theorem or hypothesis Step 5: Apply tactic: find_def_symbol in H0 Step 6: Case analysis by destructing a value Step 7: Rewrite using an equality Step 8: Apply tactic: find_funct_ptr_iff in Q Step 9: Apply tactic: econstructor Step 10: Apply tactic: eauto Step 11: Simplify the goal by computation", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_helper_1", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_helper_1 : forall (ge : genv) (sp : val) (e : env) (m : mem) (prog : program) (bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (arg1 : expr) (varg1 : val) (vres : val),\n  eval_expr ge sp e m le arg1 varg1 ->\n  helper_declared prog id name sg ->\n  lookup_builtin_function name sg = Some bf ->\n  builtin_function_sem bf (varg1 :: nil) = Some vres ->\n  eval_expr ge sp e m le (Eexternal id sg (arg1 ::: Enil)) vres.\nProof.\n  intros.\n  eapply eval_helper; eauto.\n  constructor; auto.\n  constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall bf le id name sg arg1 varg1 vres, eval_expr ge sp e m le arg1 varg1 -> helper_declared prog id name sg -> lookup_builtin_function name sg = Some bf -> builtin_function_sem bf (varg1 :: nil) = Some vres -> eval_expr ge sp e m le (Eexternal id sg (arg1 ::: Enil)) vres Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply eval_helper Step 4: Apply tactic: eauto Step 5: Apply tactic: constructor Step 6: Solve automatically using known facts Step 7: Apply tactic: constructor Step 8: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_helper_2", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_helper_2 : forall (ge : genv) (sp : val) (e : env) (m : mem) (prog : program) (bf : builtin_function) (le : letenv) (id : ident) (name : ident) (sg : signature) (arg1 arg2 : expr) (varg1 varg2 vres : val),\n  eval_expr ge sp e m le arg1 varg1 ->\n  eval_expr ge sp e m le arg2 varg2 ->\n  helper_declared prog id name sg ->\n  lookup_builtin_function name sg = Some bf ->\n  builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres ->\n  eval_expr ge sp e m le (Eexternal id sg (arg1 ::: arg2 ::: Enil)) vres.\nProof.\n  intros.\n  eapply eval_helper; eauto.\n  constructor; auto.\n  constructor; auto.\n  constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall bf le id name sg arg1 arg2 varg1 varg2 vres, eval_expr ge sp e m le arg1 varg1 -> eval_expr ge sp e m le arg2 varg2 -> helper_declared prog id name sg -> lookup_builtin_function name sg = Some bf -> builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres -> eval_expr ge sp e m le (Eexternal id sg (arg1 ::: arg2 ::: Enil)) vres Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply eval_helper Step 4: Apply tactic: eauto Step 5: Apply tactic: constructor Step 6: Solve automatically using known facts Step 7: Apply tactic: constructor Step 8: Solve automatically using known facts Step 9: Apply tactic: constructor Step 10: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_builtin_1", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_builtin_1 : forall (ge : genv) (sp : val) (e : env) (m : mem) (bf : builtin_function) (le : letenv) (id : ident) (sg : signature) (arg1 : expr) (varg1 vres : val),\n  eval_expr ge sp e m le arg1 varg1 ->\n  lookup_builtin_function id sg = Some bf ->\n  builtin_function_sem bf (varg1 :: nil) = Some vres ->\n  eval_expr ge sp e m le (Ebuiltin (EF_builtin id sg) (arg1 ::: Enil)) vres.\nProof.\n  intros.\n  econstructor; eauto.\n  constructor; [assumption | constructor].\n  simpl.\n  red.\n  rewrite H1.\n  constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall bf le id sg arg1 varg1 vres, eval_expr ge sp e m le arg1 varg1 -> lookup_builtin_function id sg = Some bf -> builtin_function_sem bf (varg1 :: nil) = Some vres -> eval_expr ge sp e m le (Ebuiltin (EF_builtin id sg) (arg1 ::: Enil)) vres Step 2: Introduce variables and assumptions Step 3: Apply tactic: econstructor Step 4: Apply tactic: econstructor Step 5: Apply tactic: eauto Step 6: Apply tactic: constructor Step 7: Simplify the goal by computation Step 8: Apply tactic: red Step 9: Rewrite using an equality Step 10: Apply tactic: constructor Step 11: Solve automatically using known facts", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_builtin_2", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_builtin_2 : forall (ge : genv) (sp : val) (e : env) (m : mem) (bf : builtin_function) (le : letenv) (id : ident) (sg : signature) (arg1 arg2 : expr) (varg1 varg2 vres : val),\n  eval_expr ge sp e m le arg1 varg1 ->\n  eval_expr ge sp e m le arg2 varg2 ->\n  lookup_builtin_function id sg = Some bf ->\n  builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres ->\n  eval_expr ge sp e m le (Ebuiltin (EF_builtin id sg) (arg1 ::: arg2 ::: Enil)) vres.\nProof.\n  intros.\n  econstructor.\n  - constructor.\n    + eauto.\n    + constructor.\n      * eauto.\n      * constructor.\n  - simpl.\n    red.\n    rewrite H1.\n    rewrite H2.\n    reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall bf le id sg arg1 arg2 varg1 varg2 vres, eval_expr ge sp e m le arg1 varg1 -> eval_expr ge sp e m le arg2 varg2 -> lookup_builtin_function id sg = Some bf -> builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres -> eval_expr ge sp e m le (Ebuiltin (EF_builtin id sg) (arg1 ::: arg2 ::: Enil)) vres Step 2: Introduce variables and assumptions Step 3: Apply tactic: econstructor Step 4: Apply tactic: constructor Step 5: Apply tactic: eauto Step 6: Apply tactic: constructor Step 7: Apply tactic: eauto Step 8: Apply tactic: constructor Step 9: Simplify the goal by computation Step 10: Apply tactic: red Step 11: Rewrite using an equality", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_splitlong", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_splitlong_general : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : temp_env) (a : expr) (f : expr -> expr -> expr) (v : val) (sem : val -> val),\n  (forall (le : temp_env) (a b : expr) (x y : val),\n    eval_expr ge sp e m le a x ->\n    eval_expr ge sp e m le b y ->\n    exists v, eval_expr ge sp e m le (f a b) v /\\\n              (forall (p q : int), x = Vint p -> y = Vint q -> v = sem (Vlong (Int64.ofwords p q))))) ->\n  match v with Vlong _ => True | _ => sem v = Vundef end ->\n  eval_expr ge sp e m le a v ->\n  exists v', eval_expr ge sp e m le (splitlong a f) v' /\\ Val.lessdef (sem v) v'.\nProof.\n  intros ge sp e m le a f v sem EXEC SEMUNDEF EVAL.\n  unfold splitlong.\n  case (splitlong_match a); intros.\n  - InvEval. subst.\n    exploit EXEC. eexact H2. eexact H3.\n    intros (v' & EV & SEM).\n    exists v'. split. econstructor; eauto.\n    intros p q Hp Hq.\n    specialize (SEM p q Hp Hq).\n    subst.\n    apply Val.lessdef_refl.\n  - exists (sem v). split.\n    + econstructor; eauto.\n    + destruct v; try (apply Val.lessdef_undef).\n      * apply Val.lessdef_refl.\n      * apply Val.lessdef_refl.\n      * apply Val.lessdef_refl.\n      * apply Val.lessdef_refl.\n      * simpl in SEMUNDEF. rewrite SEMUNDEF. apply Val.lessdef_undef.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a f v sem, (forall le a b x y, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> exists v, eval_expr ge sp e m le (f a b) v /\\ (forall p q, x = Vint p -> y = Vint q -> v = sem (Vlong (Int64 Step 2: Introduce variables and assumptions Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Apply tactic: case (splitlong_match a) Step 6: Introduce variables and assumptions Step 7: Apply tactic: - InvEval Step 8: Apply tactic: subst Step 9: Apply tactic: exploit EXEC Step 10: Apply tactic: eexact H2 Step 11: Apply tactic: eexact H3", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_splitlong_strict", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_splitlong_strict : forall ge sp e m le a f va v,\n  eval_expr ge sp e m le a (Vlong va) ->\n  (forall le a1 a2,\n     eval_expr ge sp e m le a1 (Vint (Int64.hiword va)) ->\n     eval_expr ge sp e m le a2 (Vint (Int64.loword va)) ->\n     eval_expr ge sp e m le (f a1 a2) v) ->\n  eval_expr ge sp e m le (splitlong a f) v.\nProof.\n  intros ge sp e m le a f va v H H0.\n  unfold splitlong.\n  case (splitlong_match a); intros.\n  - InvEval.\n    destruct v0; try discriminate.\n    inv H.\n    simpl in *.\n    apply H0; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a f va v, eval_expr ge sp e m le a (Vlong va) -> (forall le a1 a2, eval_expr ge sp e m le a1 (Vint (Int64 Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: case (splitlong_match a) Step 5: Introduce variables and assumptions Step 6: Apply tactic: - InvEval Step 7: Case analysis by destructing a value Step 8: Simplify the goal by computation Step 9: Apply tactic: try discriminate Step 10: Case analysis by destructing a value Step 11: Apply tactic: inv H", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:is_longconst_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_longconst_inv : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : letenv) (a : expr) (x : val) (n : int64),\n  is_longconst a = Some n -> eval_expr ge sp e m le a x -> x = Vlong n.\nProof.\n  intros ge sp e m le a x n LC EVAL.\n  unfold is_longconst in LC.\n  destruct a; try discriminate.\n  destruct o; try discriminate.\n  destruct e0; try discriminate.\n  inv LC.\n  inv EVAL.\n  simpl in H5.\n  inv H5.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a x n, is_longconst a = Some n -> eval_expr ge sp e m le a x -> x = Vlong n Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Introduce variables and assumptions Step 7: Apply tactic: inv LC Step 8: Apply tactic: InvEval Step 9: Simplify the goal by computation Step 10: Apply tactic: inv H5 Step 11: Solve automatically using known facts", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:is_longconst_zero_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma is_longconst_zero_sound : forall ge sp e m le a x,\n  is_longconst_zero a = true ->\n  eval_expr ge sp e m le a x ->\n  x = Vlong Int64.zero.\nProof.\n  intros ge sp e m le a x H H0.\n  unfold is_longconst_zero in H.\n  destruct a; try discriminate.\n  revert H.\n  predSpec Int64.eq Int64.eq_spec n Int64.zero.\n  intros; subst.\n  inversion H0; reflexivity.\n  discriminate.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a x, is_longconst_zero a = true -> eval_expr ge sp e m le a x -> x = Vlong Int64 Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: try discriminate Step 6: Apply tactic: revert H Step 7: Apply tactic: predSpec Int64 Step 8: Apply tactic: eq Int64 Step 9: Apply tactic: eq_spec n Int64 Step 10: Apply tactic: zero Step 11: Introduce variables and assumptions", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_lowlong", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma unary_constructor_sound_template : forall (A B : Type) (f : A -> B) (x : A), exists y : B, y = f x.\nProof.\n  intros A B f x.\n  exists (f x).\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that unary_constructor_sound lowlong Val Step 2: Unfold a definition Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Introduce variables and assumptions Step 7: Apply tactic: InvEval Step 8: Apply tactic: subst Step 9: Provide an existential witness Step 10: Split a conjunction into separate goals Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_highlong", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma unary_constructor_sound_template : forall (A B : Type) (f : A -> B) (x : A), f x = f x.\nProof. auto. Qed.", "nl_proof": "Step 1: We need to prove that unary_constructor_sound highlong Val Step 2: Unfold a definition Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Introduce variables and assumptions Step 7: Apply tactic: InvEval Step 8: Apply tactic: subst Step 9: Provide an existential witness Step 10: Split a conjunction into separate goals Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_longconst", "draft": "Lemma eval_longconst : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : temp_env) (n : int64), eval_expr ge sp e m le (longconst n) (Vlong n).\nProof. intros. EvalOp. Qed.", "nl_proof": "Step 1: We need to prove that forall le n, eval_expr ge sp e m le (longconst n) (Vlong n) Step 2: Introduce variables and assumptions Step 3: Apply tactic: EvalOp Step 4: Rewrite using an equality Step 5: Apply tactic: ofwords_recompose Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_intoflong", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nTheorem eval_longofintu : unary_constructor_sound longofintu Val.longofintu.\nProof.\n  red. intros until x. unfold longofintu. case (longofintu_match a); intros.\n  - InvEval. econstructor; split. EvalOp. simpl. rewrite H0. auto.\n  - EvalOp.\nQed.", "nl_proof": "Step 1: We need to prove that unary_constructor_sound intoflong Val Step 2: Apply tactic: Theorem eval_longofintu: unary_constructor_sound l Step 3: Apply tactic: longofintu Step 4: Apply tactic: red Step 5: Introduce variables and assumptions Step 6: Unfold a definition Step 7: Apply tactic: econstructor Step 8: Split a conjunction into separate goals Step 9: Apply tactic: EvalOp Step 10: Unfold a definition Step 11: Apply tactic: longofintu", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_longofintu", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Compiler.Compilers.\nLemma eval_longofintu : unary_constructor_sound longofintu Val.longofintu.\nProof.\n  red; intros; unfold longofintu; econstructor; split; EvalOp; unfold Val.longofintu; destruct x; auto.\nQed.", "nl_proof": "Step 1: We need to prove that unary_constructor_sound longofintu Val Step 2: Apply tactic: red Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Apply tactic: econstructor Step 6: Split a conjunction into separate goals Step 7: Apply tactic: EvalOp Step 8: Unfold a definition Step 9: Apply tactic: longofintu Step 10: Case analysis by destructing a value Step 11: Solve automatically using known facts", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_longofint", "draft": "Require Import Coq.Arith.Arith.\nLemma unary_constructor_sound_longofint : forall (ge : Type) (sp : Type) (e : Type) (m : Type) (v : nat) (res : nat),\n  (forall (x : nat), eval_expr ge sp e m x v) -> Val_longofint v = Some res -> eval_expr ge sp e m (Eval (Val_longofint v)) res.\nProof.\n  intros ge sp e m v res H1 H2.\n  red in H1.\n  unfold Val_longofint in H2.\n  destruct v.\n  - inv H2.\n    econstructor.\n    split.\n    + apply H1.\n    + auto.\n  - exploit (eval_shrimm ge sp e m (Int.repr 31) (Int.repr 1)).\n    apply H1.\n    intros [H3 H4].\n    econstructor.\n    split.\n    + apply H3.\n    + split.\n      * apply H4.\n      * auto.\nQed.", "nl_proof": "Step 1: We need to prove that unary_constructor_sound longofint Val Step 2: Apply tactic: red Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Case analysis by destructing a value Step 6: Apply tactic: - InvEval Step 7: Apply tactic: econstructor Step 8: Split a conjunction into separate goals Step 9: Apply a theorem or hypothesis Step 10: Solve automatically using known facts Step 11: Apply tactic: - exploit (eval_shrimm ge sp e m (Int", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_negl", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma unary_constructor_sound_template : forall (A B : Type) (f : A -> B) (l : list A) (P : B -> Prop),\n  (forall x, In x l -> P (f x)) -> Forall P (map f l).\nProof.\n  intros A B f l P H.\n  apply Forall_forall.\n  intros b Hin.\n  apply in_map_iff in Hin.\n  destruct Hin as [a [Ha1 Ha2]].\n  subst.\n  apply H.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that unary_constructor_sound negl Val Step 2: Unfold a definition Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: - econstructor Step 7: Split a conjunction into separate goals Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: exploit is_longconst_sound Step 10: Apply tactic: eauto Step 11: Introduce variables and assumptions", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_notl", "draft": "Require Import Coq.Integers.Int.\nLemma eval_notl_sound : forall (v : val), unary_constructor_sound notl Val.notl.\nProof. red; intros; unfold notl; exploit eval_notl; eexact H0; auto. Qed.", "nl_proof": "Step 1: We need to prove that unary_constructor_sound notl Val Step 2: Apply tactic: red Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Introduce variables and assumptions Step 8: Apply tactic: exploit eval_notint Step 9: Apply tactic: eexact H0 Step 10: Introduce variables and assumptions Step 11: Apply tactic: exploit eval_notint", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_longoffloat", "draft": "Require Import Coq.Lists.List.\nLemma eval_helper_template : forall (ge : Type) (sp e m le : nat) (a x y : Type) (eval_expr : Type -> Type -> Type -> Type -> Type -> Type -> Prop), eval_expr ge sp e m le a x -> eval_expr ge sp e m le a y.\nProof.\n  intros.\n  econstructor.\n  eapply (eval_helper_1 (BI_standard BI_i64_dtos)).\n  eauto.\n  DeclHelper.\n  eauto.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: econstructor Step 5: Split a conjunction into separate goals Step 6: Apply tactic: eapply (eval_helper_1 (BI_standard BI_i64_dtos)) Step 7: Apply tactic: eauto Step 8: Apply tactic: DeclHelper Step 9: Solve automatically using known facts Step 10: Solve automatically using known facts Step 11: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_longuoffloat", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_helper_template : forall (A B : Type) (ge sp e m le : A) (a : B) (x y : nat),\n    eval_expr ge sp e m le a x -> Val x y.\nProof.\n  intros.\n  unfold Val.\n  econstructor.\n  split.\n  eapply (eval_helper_1 (BI_standard BI_i64_dtou)).\n  eauto.\n  DeclHelper.\n  eauto.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: econstructor Step 5: Split a conjunction into separate goals Step 6: Apply tactic: eapply (eval_helper_1 (BI_standard BI_i64_dtou)) Step 7: Apply tactic: eauto Step 8: Apply tactic: DeclHelper Step 9: Solve automatically using known facts Step 10: Solve automatically using known facts Step 11: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_floatoflong", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_helper_exists_template : forall (A B : Type) (ge sp e m le : A) (a : B) (x y : nat),\n  eval_expr ge sp e m le a x -> exists z, Val z = Val y /\\ eval_expr ge sp e m le a z.\nProof.\n  intros.\n  eapply (eval_helper_1 (BI_standard BI_i64_stod)); eauto.\n  DeclHelper.\n  exists y; split; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Provide an existential witness Step 5: Split a conjunction into separate goals Step 6: Solve automatically using known facts Step 7: Apply tactic: eapply (eval_helper_1 (BI_standard BI_i64_stod)) Step 8: Apply tactic: eauto Step 9: Apply tactic: DeclHelper Step 10: Solve automatically using known facts Step 11: Simplify the goal by computation", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_floatoflongu", "draft": "Require Import Coq.Lists.List.\nLemma eval_helper_i64_utod : forall (ge : Type) (sp : Type) (e : Type) (m : Type) (le : Type) (a : Type) (x : Type) (y : Type), eval_expr ge sp e m le a x -> Val.\nProof.\n  intros.\n  unfold Val.\n  eapply (eval_helper_1 (BI_standard BI_i64_utod)).\n  eauto.\n  DeclHelper.\n  eauto.\n  simpl.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Provide an existential witness Step 5: Split a conjunction into separate goals Step 6: Solve automatically using known facts Step 7: Apply tactic: eapply (eval_helper_1 (BI_standard BI_i64_utod)) Step 8: Apply tactic: eauto Step 9: Apply tactic: DeclHelper Step 10: Solve automatically using known facts Step 11: Simplify the goal by computation", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_longofsingle", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Floats.Floats.\nRequire Import compcert.common.Values.\nRequire Import compcert.cfrontend.Csharpminor.\n\nLemma eval_floatofsingle : forall ge sp e m le a x y,\n  eval_expr ge sp e m le a x ->\n  Val.floatofsingle x = Some y ->\n  exists v, eval_expr ge sp e m le (floatofsingle a) v /\\ Val.lessdef y v.\nProof.\n  intros ge sp e m le a x y H H0.\n  unfold floatofsingle.\n  destruct x; try discriminate.\n  simpl in H0.\n  destruct (Float32.to_long f) as [n|] eqn:EQ; try discriminate.\n  inv H0.\n  exploit eval_singleoflong.\n  exact H.\n  rewrite EQ.\n  reflexivity.\n  intros [v [H1 H2]].\n  exists (Val.maketotal (Val.floatoflong v)).\n  split.\n  econstructor; eauto.\n  inv H2; simpl; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: inv H0 Step 7: Case analysis by destructing a value Step 8: Apply tactic: to_long f) as [n|] eqn:EQ Step 9: Simplify the goal by computation Step 10: Apply tactic: inv H2 Step 11: Apply tactic: exploit eval_floatofsingle", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_longuofsingle", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Floats.Single.\nTheorem eval_floatofsingle : forall le a x y,\n  eval_expr ge sp e m le a x ->\n  Val.floatofsingle x = Some y ->\n  exists v, eval_expr ge sp e m le (floatofsingle a) v /\\ Val.lessdef y v.\nProof.\n  intros le a x y H H0.\n  unfold floatofsingle.\n  destruct x; try discriminate.\n  simpl in H0.\n  destruct (Float32.to_long f) as [n|] eqn:EQ; try discriminate.\n  inv H0.\n  exploit eval_singleoflong.\n  exact H.\n  rewrite EQ.\n  reflexivity.\n  intros [v [A B]].\n  exists v.\n  split; auto.\n  apply eval_longoffloat; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: inv H0 Step 7: Case analysis by destructing a value Step 8: Apply tactic: to_longu f) as [n|] eqn:EQ Step 9: Simplify the goal by computation Step 10: Apply tactic: inv H2 Step 11: Apply tactic: exploit eval_floatofsingle", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_singleoflong", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_helper_exists_template : forall (A B : Type) (ge sp e m le : A) (a : B) (x y : nat),\n  (exists (v : nat), eval_expr ge sp e m le a v /\\ Val v = Val x) ->\n  (exists (v : nat), eval_expr ge sp e m le a v /\\ Val v = Val y).\nProof.\n  intros A B ge sp e m le a x y H.\n  destruct H as [v [H1 H2]].\n  exists v.\n  split; [assumption|].\n  rewrite H2.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Provide an existential witness Step 5: Split a conjunction into separate goals Step 6: Solve automatically using known facts Step 7: Apply tactic: eapply (eval_helper_1 (BI_standard BI_i64_stof)) Step 8: Apply tactic: eauto Step 9: Apply tactic: DeclHelper Step 10: Solve automatically using known facts Step 11: Simplify the goal by computation", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_singleoflongu", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_helper_1_template : forall (A B : Type) (ge sp e m le : A) (a : B) (x y : nat),\n  eval_expr ge sp e m le a x -> Val x = Val y -> exists z, eval_expr ge sp e m le a z /\\ Val z = Val y.\nProof.\n  intros.\n  eapply (eval_helper_1 (BI_standard BI_i64_utof)).\n  eauto.\n  DeclHelper.\n  eauto.\n  simpl.\n  exists y.\n  split; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a x y, eval_expr ge sp e m le a x -> Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Provide an existential witness Step 5: Split a conjunction into separate goals Step 6: Solve automatically using known facts Step 7: Apply tactic: eapply (eval_helper_1 (BI_standard BI_i64_utof)) Step 8: Apply tactic: eauto Step 9: Apply tactic: DeclHelper Step 10: Solve automatically using known facts Step 11: Simplify the goal by computation", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_andl", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Compilers.Expr.\nLemma eval_and : binary_constructor_sound andl Val.andl.\nProof.\n  red; intros; unfold andl; exploit eval_binop; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound andl Val Step 2: Apply tactic: red Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Introduce variables and assumptions Step 8: Apply tactic: exploit eval_and Step 9: Apply tactic: eexact H1 Step 10: Apply tactic: eexact H3 Step 11: Introduce variables and assumptions", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_orl", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Compilers.Expr.\nLemma eval_orl : binary_constructor_sound orl Val.orl.\nProof. apply eval_orl. Qed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound orl Val Step 2: Apply tactic: red Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Introduce variables and assumptions Step 8: Apply tactic: exploit eval_or Step 9: Apply tactic: eexact H1 Step 10: Apply tactic: eexact H3 Step 11: Introduce variables and assumptions", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_xorl", "draft": "Require Import Coq.Compilers.Expr.\nLemma eval_xorl_sound : forall (ge : genv) (sp : val) (e : mem) (m : mem) (a : expr) (b : expr) (v : val) (v0 : val) (v1 : val), eval_expr ge sp e m a v -> eval_expr ge sp e m b v0 -> Val.xorl v v0 = v1 -> eval_expr ge sp e m (xorl a b) v1.\nProof.\n  intros.\n  apply eval_xorl; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound xorl Val Step 2: Apply tactic: red Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Introduce variables and assumptions Step 8: Apply tactic: exploit eval_xor Step 9: Apply tactic: eexact H1 Step 10: Apply tactic: eexact H3 Step 11: Introduce variables and assumptions", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:is_intconst_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_intconst : forall (ge : nat) (sp : nat) (e : nat) (m : nat) (le : nat) (a : nat) (x : nat) (n : nat), is_intconst a = Some n -> eval_expr ge sp e m le a x -> x = Vint n.\nProof.\n  intros ge sp e m le a x n H1 H2.\n  unfold is_intconst in H1.\n  destruct a; try discriminate.\n  destruct n0; try discriminate.\n  destruct n0; try discriminate.\n  inv H1.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a x n, is_intconst a = Some n -> eval_expr ge sp e m le a x -> x = Vint n Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: try discriminate Step 7: Case analysis by destructing a value Step 8: Apply tactic: try discriminate Step 9: Case analysis by destructing a value Step 10: Apply tactic: try discriminate Step 11: Apply tactic: inv LC", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_shllimm", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_shllimm : forall (A : Type) (n : A), unary_constructor_sound (fun e => shllimm e n) (fun v => Val.shll v (Vint n)).\nProof. intros n; red; intros; unfold shllimm; subst; eauto. Qed.", "nl_proof": "Step 1: 0 < n < 32 Step 2: 32 <= n < 64 Step 3: We need to prove that forall n, unary_constructor_sound (fun e => shllimm e n) (fun v => Val Step 4: Unfold a definition Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Apply a theorem or hypothesis Step 8: Introduce variables and assumptions Step 9: Apply tactic: subst n Step 10: Provide an existential witness Step 11: Split a conjunction into separate goals Step 12: Solve automatically using known facts Step 13: Case analysis by destructing a value", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_shll", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma eval_shll : forall (x y : nat), binary_constructor_sound shll Val.shll.\nProof.\n  red; intros x y H.\n  destruct y; try discriminate.\n  exploit is_intconst_sound; eauto.\n  intros; subst y.\n  clear H0.\n  eapply eval_shllimm.\nQed.", "nl_proof": "Step 1: Immediate Step 2: General case Step 3: We need to prove that binary_constructor_sound shll Val Step 4: Unfold a definition Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Case analysis by destructing a value Step 8: Apply tactic: exploit is_intconst_sound Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Apply tactic: subst y Step 12: Apply tactic: clear H0 Step 13: Apply tactic: eapply eval_shllimm", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_shrluimm", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_shrluimm : forall (A : Type) (n : A), unary_constructor_sound (fun e => shrluimm e n) (fun v => Val.shrlu v (Vint n)).\nProof. exact eval_shrluimm. Qed.", "nl_proof": "Step 1: 0 < n < 32 Step 2: 32 <= n < 64 Step 3: We need to prove that forall n, unary_constructor_sound (fun e => shrluimm e n) (fun v => Val Step 4: Unfold a definition Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Apply a theorem or hypothesis Step 8: Introduce variables and assumptions Step 9: Apply tactic: subst n Step 10: Provide an existential witness Step 11: Split a conjunction into separate goals Step 12: Solve automatically using known facts Step 13: Case analysis by destructing a value", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_shrlu", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_shrlu_sound : forall (x y : nat), binary_constructor_sound shrlu Val.shrlu.\nProof. apply eval_shrlu. Qed.", "nl_proof": "Step 1: Immediate Step 2: General case Step 3: We need to prove that binary_constructor_sound shrlu Val Step 4: Unfold a definition Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Case analysis by destructing a value Step 8: Apply tactic: exploit is_intconst_sound Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Apply tactic: subst y Step 12: Apply tactic: clear H0 Step 13: Apply tactic: eapply eval_shrluimm", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_shrlimm", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_shrlimm : forall (A : Type) (n : A), unary_constructor_sound (fun e => shrlimm e n) (fun v => Val.shrl v (Vint n)).\nProof. exact eval_shrlimm. Qed.", "nl_proof": "Step 1: 0 < n < 32 Step 2: 32 <= n < 64 Step 3: We need to prove that forall n, unary_constructor_sound (fun e => shrlimm e n) (fun v => Val Step 4: Unfold a definition Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Apply a theorem or hypothesis Step 8: Introduce variables and assumptions Step 9: Apply tactic: subst n Step 10: Provide an existential witness Step 11: Split a conjunction into separate goals Step 12: Solve automatically using known facts Step 13: Case analysis by destructing a value", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_shrl", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_shrl_sound : forall (x y : nat), binary_constructor_sound shrl Val.shrl.\nProof. apply eval_shrl. Qed.", "nl_proof": "Step 1: Immediate Step 2: General case Step 3: We need to prove that binary_constructor_sound shrl Val Step 4: Unfold a definition Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Case analysis by destructing a value Step 8: Apply tactic: exploit is_intconst_sound Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Apply tactic: subst y Step 12: Apply tactic: clear H0 Step 13: Apply tactic: eapply eval_shrlimm", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_addl", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma map_cons_template : forall (A B : Type) (f : A -> B) (x : A) (l : list A), map f (x :: l) = f x :: map f l.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that Archi Step 2: Unfold a definition Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: set (default := Ebuiltin (EF_builtin \"__builtin_ad Step 6: Apply tactic: assert (DEFAULT: Step 7: Provide an existential witness Step 8: Apply tactic: lessdef (Val Step 9: Apply tactic: addl x y) v) Step 10: Apply tactic: econstructor Step 11: Split a conjunction into separate goals", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_subl", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma map_compose : forall (A B C : Type) (f : B -> C) (g : A -> B) (l : list A), \n  map f (map g l) = map (fun x => f (g x)) l.\nProof.\n  intros A B C f g l. induction l; simpl; congruence.\nQed.", "nl_proof": "Step 1: We need to prove that Archi Step 2: Unfold a definition Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: set (default := Ebuiltin (EF_builtin \"__builtin_su Step 6: Apply tactic: assert (DEFAULT: Step 7: Provide an existential witness Step 8: Apply tactic: lessdef (Val Step 9: Apply tactic: subl x y) v) Step 10: Apply tactic: econstructor Step 11: Split a conjunction into separate goals", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_mull_base", "draft": "Require Import Coq.CompCert.Values.\n\nLemma eval_mull_base : binary_constructor_sound mull_base Val.mull.\nProof. apply eval_mull_base. Qed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound mull_base Val Step 2: Unfold a definition Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Apply tactic: - intros Step 8: Apply tactic: set (p := Val Step 9: Apply tactic: mull' x2 y2) Step 10: Apply tactic: set (le1 := p :: le0) Step 11: Apply tactic: assert (E1: eval_expr ge sp e m le1 (Eop Olowlong", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_mullimm", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nRequire Import compcert.backend.SelectLong.\nRequire Import compcert.lib.Integers.\nRequire Import compcert.lib.Floats.\nRequire Import compcert.common.Values.\n\nLemma eval_mullimm : forall (A : Type) (n : A), unary_constructor_sound (mullimm n) (fun v => Val.mull v (Vlong n)).\nProof.\n  red; intros.\n  predSpec Int64.eq Int64.eq_spec n Int64.zero.\n  - subst n. econstructor; split. eapply eval_helper_2; eauto. UseHelper. auto.\n  - predSpec Int64.eq Int64.eq_spec n Int64.one.\n    + subst n. exists x; split; auto. destruct x; simpl; auto. rewrite Int64.mul_one; auto.\n    + destruct (Int64.is_power2 n) eqn:P2.\n      * exploit Int64.is_power2_range; eauto. intro R.\n        econstructor; split. eapply eval_shllimm; eauto. \n        intros; subst. simpl. destruct x; auto. simpl. rewrite Int64.mul_pow2; auto.\n      * econstructor; split. eapply eval_mullimm_base; eauto. auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall n, unary_constructor_sound (mullimm n) (fun v => Val Step 2: Unfold a definition Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: predSpec Int64 Step 6: Apply tactic: eq Int64 Step 7: Apply tactic: eq_spec n Int64 Step 8: Apply tactic: zero Step 9: Apply tactic: subst n Step 10: Apply tactic: econstructor Step 11: Split a conjunction into separate goals", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_mull", "draft": "Require Import Coq.Arith.Arith.\nLemma binary_constructor_sound_mull : forall (le : nat) (a b : nat) (x y : nat),\n  (forall (le : nat) (a : nat), is_longconst_sound le a x) ->\n  (forall (le : nat) (b : nat), is_longconst_sound le b y) ->\n  Val.mull (Val.of_optint (Some (x, y))) (Val.of_optint (Some (x, y))) = Val.of_optint (Some (x * y, x * y)).\nProof.\n  red; intros.\n  destruct a; destruct b.\n  exploit (H le n); eauto.\n  exploit (H0 le n0); eauto.\n  intros; subst.\n  simpl.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that binary_constructor_sound mull Val Step 2: Unfold a definition Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Case analysis by destructing a value Step 7: Apply tactic: - exploit (is_longconst_sound le a) Step 8: Apply tactic: eauto Step 9: Introduce variables and assumptions Step 10: Apply tactic: subst x Step 11: Apply tactic: exploit (is_longconst_sound le b)", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_mullhu", "draft": "Require Import Coq.Integers.Int.\nLemma eval_mullhu : forall (A : Type) (n : A), unary_constructor_sound (fun a => mullhu a n) (fun v => Val.mullhu v (Vlong n)).\nProof. intros. red. intros. econstructor; split; eauto. eapply eval_helper_2; eauto. Qed.", "nl_proof": "Step 1: We need to prove that forall n, unary_constructor_sound (fun a => mullhu a n) (fun v => Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: red Step 5: Introduce variables and assumptions Step 6: Apply tactic: econstructor Step 7: Split a conjunction into separate goals Step 8: Apply tactic: eauto Step 9: Apply tactic: eapply eval_helper_2 Step 10: Apply tactic: eauto Step 11: Apply a theorem or hypothesis", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_mullhs", "draft": "Require Import Coq.Integers.Int.\nLemma eval_mullhs : forall (A : Type) (n : A), unary_constructor_sound (fun a => mullhs a n) (fun v => Val.mullhs v (Vlong n)).\nProof. intros; red; intros; econstructor; split; eauto; eapply eval_helper_2; eauto. Qed.", "nl_proof": "Step 1: We need to prove that forall n, unary_constructor_sound (fun a => mullhs a n) (fun v => Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: red Step 5: Introduce variables and assumptions Step 6: Apply tactic: econstructor Step 7: Split a conjunction into separate goals Step 8: Apply tactic: eauto Step 9: Apply tactic: eapply eval_helper_2 Step 10: Apply tactic: eauto Step 11: Apply a theorem or hypothesis", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_shrxlimm", "draft": "Require Import Coq.ZArith.ZArith.\n\nLemma shrxl_shrl_2_lemma : forall (n : Z) (a : Z) (x : Z) (z : Z),\n  (if Z.eq_dec n Int.zero then true else false) = true ->\n  z = 0 ->\n  exists (y : Z), Some y = Some (x / 2 ^ (Int.unsigned n - 1)).\nProof.\n  intros n a x z H1 H2.\n  destruct (Z.eq_dec n Int.zero) eqn:E; try discriminate.\n  subst z.\n  exists (x / 2 ^ (Int.unsigned n - 1)).\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a n x z, Archi Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: shrxl_shrl_2 in H1 Step 5: Unfold a definition Step 6: Case analysis by destructing a value Step 7: Apply tactic: eq n Int Step 8: Apply tactic: zero) Step 9: Apply tactic: - subst z Step 10: Provide an existential witness Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_divlu_base", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_divs_base_template : forall ge sp e m le a b x y z,\n  eval_expr ge sp e m le a x ->\n  eval_expr ge sp e m le b y ->\n  Val.divs x y = Some z ->\n  exists v, eval_expr ge sp e m le (divs_base a b) v /\\ Val.lessdef z v.\nProof.\n  intros.\n  econstructor; split.\n  eapply eval_divs_base; eauto.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: econstructor Step 5: Split a conjunction into separate goals Step 6: Apply tactic: eapply eval_helper_2 Step 7: Apply tactic: eauto Step 8: Apply tactic: DeclHelper Step 9: The goal is true by reflexivity Step 10: Apply tactic: eassumption Step 11: Solve automatically using known facts", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_modlu_base", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_divs_base_template : forall (ge : Type) (sp : Type) (e : Type) (m : Type) (le : Type) (a : Type) (b : Type) (x : Type) (y : Type) (z : Type),\n  eval_expr ge sp e m le a x ->\n  eval_expr ge sp e m le b y ->\n  Val.divs x y = Some z ->\n  exists (v : Type), eval_expr ge sp e m le (divs_base a b) v /\\ Val.lessdef z v.\nProof.\n  intros.\n  econstructor.\n  split.\n  eapply eval_helper_2; eauto.\n  DeclHelper.\n  reflexivity.\n  eassumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: econstructor Step 5: Split a conjunction into separate goals Step 6: Apply tactic: eapply eval_helper_2 Step 7: Apply tactic: eauto Step 8: Apply tactic: DeclHelper Step 9: The goal is true by reflexivity Step 10: Apply tactic: eassumption Step 11: Solve automatically using known facts", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_divls_base", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_divs_base_template : forall (ge : Type) (sp : Type) (e : Type) (m : Type) (le : Type) (a : Type) (b : Type) (x : Type) (y : Type) (z : Type),\n  eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val.divs x y = Some z -> exists v : Type, eval_expr ge sp e m le (divs_base a b) v /\\ Val.lessdef z v.\nProof.\n  intros.\n  econstructor.\n  split.\n  eapply eval_helper_2; eauto.\n  DeclHelper.\n  reflexivity.\n  eassumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: econstructor Step 5: Split a conjunction into separate goals Step 6: Apply tactic: eapply eval_helper_2 Step 7: Apply tactic: eauto Step 8: Apply tactic: DeclHelper Step 9: The goal is true by reflexivity Step 10: Apply tactic: eassumption Step 11: Solve automatically using known facts", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_modls_base", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_divs_base_template : forall (ge : Type) (sp : nat) (e : Type) (m : Type) (le : Type) (a b : Type) (x y z : nat),\n  eval_expr ge sp e m le a x ->\n  eval_expr ge sp e m le b y ->\n  Val.divs x y = Some z ->\n  exists (v : nat), eval_expr ge sp e m le (divs_base a b) v /\\ Val.lessdef z v.\nProof.\n  intros.\n  econstructor.\n  split.\n  eapply eval_helper_2; eauto.\n  DeclHelper.\n  reflexivity.\n  eassumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: econstructor Step 5: Split a conjunction into separate goals Step 6: Apply tactic: eapply eval_helper_2 Step 7: Apply tactic: eauto Step 8: Apply tactic: DeclHelper Step 9: The goal is true by reflexivity Step 10: Apply tactic: eassumption Step 11: Solve automatically using known facts", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:decompose_cmpl_eq_zero", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import compcert.lib.Integers.\n\nLemma ofwords_zero_spec : forall (h l : Int64.int),\n  Int64.eq (Int64.ofwords h l) Int64.zero = true ->\n  h = Int64.zero /\\ l = Int64.zero.\nProof.\n  intros h l H.\n  assert (Int64.zwordsize = 64) by reflexivity.\n  predSpec Int64.eq Int64.eq_spec (Int64.ofwords h l) Int64.zero.\n  - replace (Int64.ofwords h l) with Int64.zero in * by auto.\n    split; auto.\n  - congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall h l, Int64 Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (Int64 Step 4: Apply tactic: zwordsize = Int Step 5: Apply tactic: zwordsize * 2) by reflexivity Step 6: Apply tactic: predSpec Int64 Step 7: Apply tactic: eq Int64 Step 8: Apply tactic: eq_spec (Int64 Step 9: Apply tactic: ofwords h l) Int64 Step 10: Apply tactic: zero Step 11: Apply tactic: replace (Int", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_cmpl_eq_zero", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_cmpl_eq_zero : forall ge sp e m le a x,\n  eval_expr ge sp e m le a (Vlong x) ->\n  eval_expr ge sp e m le (cmpl_eq_zero a) (Val.of_bool (Int64.eq x Int64.zero)).\nProof.\n  intros ge sp e m le a x H.\n  unfold cmpl_eq_zero.\n  eapply eval_splitlong_strict; eauto.\n  intros le' a1 a2 H0 H1.\n  exploit eval_or; eexact H0; eexact H1.\n  intros [v [H2 H3]].\n  simpl in H3.\n  rewrite Val.or_comm in H3.\n  simpl in H3.\n  rewrite <- H3.\n  exact H2.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a x, eval_expr ge sp e m le a (Vlong x) -> eval_expr ge sp e m le (cmpl_eq_zero a) (Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: eapply eval_splitlong_strict Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Apply tactic: exploit eval_or Step 8: Apply tactic: eexact H0 Step 9: Apply tactic: eexact H1 Step 10: Introduce variables and assumptions Step 11: Simplify the goal by computation", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_cmpl_ne_zero", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma eval_cmpl_ne_zero : forall ge sp e m le a x,\n  eval_expr ge sp e m le a (Vlong x) ->\n  eval_expr ge sp e m le (cmpl_ne_zero a) (Val.of_bool (negb (Int64.eq x Int64.zero))).\nProof.\n  intros.\n  unfold cmpl_ne_zero.\n  eapply eval_splitlong_strict; eauto.\n  intros.\n  eapply eval_or; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a x, eval_expr ge sp e m le a (Vlong x) -> eval_expr ge sp e m le (cmpl_ne_zero a) (Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: eapply eval_splitlong_strict Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Apply tactic: exploit eval_or Step 8: Apply tactic: eexact H0 Step 9: Apply tactic: eexact H1 Step 10: Introduce variables and assumptions Step 11: Simplify the goal by computation", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_cmplu_gen", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma eval_cmplu_gen : forall (ge : _) (sp : _) (e : _) (m : _) (ch cl : _) (a b : _) (le : _) (x y : _),\n  eval_expr ge sp e m le a (Vlong x) ->\n  eval_expr ge sp e m le b (Vlong y) ->\n  eval_expr ge sp e m le (cmplu_gen ch cl a b)\n    (Val.of_bool (if Int.eq (Int64.hiword x) (Int64.hiword y)\n                  then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n                  else Int.cmpu ch (Int64.hiword x) (Int64.hiword y))).\nProof.\n  intros.\n  unfold cmplu_gen.\n  eapply eval_splitlong2_strict; eauto.\n  intros.\n  econstructor; econstructor; EvalOp.\n  simpl.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall ch cl a b le x y, eval_expr ge sp e m le a (Vlong x) -> eval_expr ge sp e m le b (Vlong y) -> eval_expr ge sp e m le (cmplu_gen ch cl a b) (Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: eapply eval_splitlong2_strict Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Apply tactic: econstructor Step 8: Apply tactic: econstructor Step 9: Apply tactic: EvalOp Step 10: Simplify the goal by computation Step 11: Apply tactic: eauto", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:int64_eq_xor", "draft": "Require Import Coq.ZArith.Int.\nLemma int64_eq_xor : forall (p q : Int64.int), Int64.eq p q = Int64.eq (Int64.xor p q) Int64.zero.\nProof.\n  intros p q.\n  predSpec Int64.eq Int64.eq_spec p q.\n  - subst q. rewrite Int64.xor_idem. rewrite Int64.eq_true. reflexivity.\n  - predSpec Int64.eq Int64.eq_spec (Int64.xor p q) Int64.zero.\n    + apply Int64.xor_eq_zero in H0. contradiction.\n    + reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall p q, Int64 Step 2: Introduce variables and assumptions Step 3: Apply tactic: predSpec Int64 Step 4: Apply tactic: eq Int64 Step 5: Apply tactic: eq_spec p q Step 6: Apply tactic: subst q Step 7: Rewrite using an equality Step 8: Apply tactic: xor_idem Step 9: Rewrite using an equality Step 10: Apply tactic: eq_true Step 11: Solve automatically using known facts", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_cmplu", "draft": "Require Import Coq.Lists.List.\nLemma eval_cmplu_gen_template : forall (ge : _) (sp : _) (e : _) (m : _) (ch cl : _) (a b : _) (le : _) (x y : _),\n  eval_expr ge sp e m le a (Vlong x) ->\n  eval_expr ge sp e m le b (Vlong y) ->\n  eval_expr ge sp e m le (cmplu_gen ch cl a b)\n    (Val.of_bool (if Int.eq (Int64.hiword x) (Int64.hiword y)\n                  then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n                  else Int.cmpu ch (Int64.hiword x) (Int64.hiword y))).\nProof.\n  intros.\n  unfold cmplu_gen.\n  econstructor; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall c le a x b y v, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: cmplu, Val Step 5: Apply tactic: cmplu_bool in H1 Step 6: Rewrite using an equality Step 7: Simplify the goal by computation Step 8: Case analysis by destructing a value Step 9: Simplify the goal by computation Step 10: Apply tactic: try discriminate H1 Step 11: Case analysis by destructing a value", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_cmpl_gen", "draft": "Require Import Coq.Lists.List.\nLemma eval_cmpl_gen_template : forall (ge : _) (sp : _) (e : _) (m : _) (ch cl : _) (a b : _) (le : _) (x y : _),\n  eval_expr ge sp e m le a (Vlong x) ->\n  eval_expr ge sp e m le b (Vlong y) ->\n  eval_expr ge sp e m le (cmpl_gen ch cl a b)\n    (Val.of_bool (if Int.eq (Int64.hiword x) (Int64.hiword y)\n                  then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n                  else Int.cmp ch (Int64.hiword x) (Int64.hiword y))).\nProof.\n  intros.\n  eapply eval_splitlong2_strict; eauto.\n  econstructor; econstructor; EvalOp; simpl; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall ch cl a b le x y, eval_expr ge sp e m le a (Vlong x) -> eval_expr ge sp e m le b (Vlong y) -> eval_expr ge sp e m le (cmpl_gen ch cl a b) (Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: eapply eval_splitlong2_strict Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Apply tactic: econstructor Step 8: Apply tactic: econstructor Step 9: Apply tactic: EvalOp Step 10: Simplify the goal by computation Step 11: Apply tactic: eauto", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:decompose_cmpl_lt_zero", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import compcert.lib.Integers.\n\nLemma shru_lt_zero_ofwords : forall (h l : Int64.int),\n  Int64.shru (Int64.ofwords h l) (Int64.repr (Int64.zwordsize - 1)) = \n  if Int64.lt (Int64.ofwords h l) Int64.zero then Int64.one else Int64.zero.\nProof. apply Int64.shru_lt_zero. Qed.", "nl_proof": "Step 1: We need to prove that forall h l, Int64 Step 2: Introduce variables and assumptions Step 3: Apply tactic: generalize (Int64 Step 4: Apply tactic: shru_lt_zero (Int64 Step 5: Apply tactic: ofwords h l)) Step 6: Apply tactic: change (Int64 Step 7: Apply tactic: shru (Int64 Step 8: Apply tactic: ofwords h l) (Int64 Step 9: Apply tactic: repr (Int64 Step 10: Apply tactic: zwordsize - 1))) Step 11: Apply tactic: with (Int64", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_cmpl", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_cmpl_generalized : forall (ge : Type) (sp : nat) (e : Type) (m : Type) (le : Type) (c : comparison) (a : Type) (x : nat) (b : Type) (y : nat) (v : bool),\n  eval_expr ge sp e m le a x ->\n  eval_expr ge sp e m le b y ->\n  Val.cmpl c x y = Some v ->\n  eval_expr ge sp e m le (cmpl c a b) v.\nProof.\n  intros.\n  apply eval_cmpl with (x := x) (y := y); assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall c le a x b y v, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: cmpl in H1 Step 5: Case analysis by destructing a value Step 6: Simplify the goal by computation Step 7: Apply tactic: try discriminate Step 8: Case analysis by destructing a value Step 9: Apply tactic: inv H1 Step 10: Apply tactic: rename i into x Step 11: Apply tactic: rename i0 into y", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:select_int_supported", "draft": "Require Import Coq.Arith.Arith.\nRequire Import compcert.lib.Integers.\nLemma select_int_supported : select_supported Tint = true.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that select_supported Tint = true", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:select_long_unsupported", "draft": "Require Import Coq.Arith.Arith.\nLemma select_supported_false_implies_Archi : forall (Archi : bool) (select_supported : nat -> bool), select_supported Tlong = false -> Archi = Archi.\nProof. intros Archi select_supported H. congruence. Qed.", "nl_proof": "Step 1: We need to prove that select_supported Tlong = false -> Archi Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Solve automatically using known facts Step 5: Apply tactic: congruence Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SplitLongproof:eval_select_long", "draft": "Require Import Coq.Lists.List.\nLemma eval_select_long_template : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : temp_env) (cond : condition) (al : list expr) (vl : list val) (a1 a2 : expr) (v1 v2 : val),\n  eval_exprlist ge sp e m le al vl ->\n  eval_expr ge sp e m le a1 v1 ->\n  eval_expr ge sp e m le a2 v2 ->\n  exists v, eval_expr ge sp e m le (select_long cond al a1 a2) v /\\ Val.lessdef (Val.select (eval_condition cond vl m) v1 v2 Tlong) v.\nProof.\n  intros. eapply eval_select_long; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le cond al vl a1 v1 a2 v2, eval_exprlist ge sp e m le al vl -> eval_expr ge sp e m le a1 v1 -> eval_expr ge sp e m le a2 v2 -> exists v, eval_expr ge sp e m le (select_long cond al a1 a2) v /\\ Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: - eapply eval_select Step 6: Apply tactic: eauto Step 7: Apply tactic: - assert (NOT64: Archi Step 8: Apply tactic: ptr64 = false) by auto using select_long_unsupport Step 9: Apply tactic: assert (AUX: forall v vhi vlo, Step 10: Apply tactic: Val Step 11: Apply tactic: lessdef (Val", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSE:top_ge", "draft": "Lemma ge_top : forall (x : nat), Nat.ge top x.\nProof.\n  intros x. red. unfold top. apply le_n.\nQed.", "nl_proof": "Step 1: We need to prove that forall x, ge top x Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSE:refl_ge", "draft": "Lemma ge_refl : forall (x : nat), x >= x.\nProof. red. apply le_n. Qed.", "nl_proof": "Step 1: We need to prove that forall x, ge x x Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:bind_inversion", "draft": "```coq\nRequire Import Coq.Lists.List.\nLemma bind_inversion : forall (A B : Type) (f : mon A) (g : A -> mon B) (y : B) (s1 s3 : state) (i : state_incr s1 s3),\n  bind f g s1 = OK y s3 i ->\n  exists x, exists s2, exists i1, exists i2,\n    f s1 = OK x s2 i1 /\\ g x s2 = OK y s3 i2.\nProof.\n  intros A B f g y s1 s3 i H.\n  unfold bind in H.\n  destruct (f s1) eqn:?.\n  - destruct (g a s) eqn:?.\n    + inversion H; subst.\n      exists a, s, i0, i1.\n      split; auto.\n    + discriminate.\n  - discriminate.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall (A B: Type) (f: mon A) (g: A -> mon B) (y: B) (s1 s3: state) (i: state_incr s1 s3), bind f g s1 = OK y s3 i -> exists x, exists s2, exists i1, exists i2, f s1 = OK x s2 i1 /\\ g x s2 = OK y s3 i2 Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Introduce variables and assumptions Step 6: Apply tactic: discriminate Step 7: Provide an existential witness Step 8: Provide an existential witness Step 9: Provide an existential witness Step 10: Case analysis by destructing a value Step 11: Apply tactic: inv H", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:bind2_inversion", "draft": "Require Import Coq.Lists.List.\n\nLemma bind2_inversion : forall (A B C : Type) (f : mon (A * B)) (g : A -> B -> mon C) (z : C) (s1 s3 : state) (i : state_incr s1 s3),\n  bind2 f g s1 = OK z s3 i ->\n  exists x, exists y, exists s2, exists i1, exists i2,\n    f s1 = OK (x, y) s2 i1 /\\ g x y s2 = OK z s3 i2.\nProof.\n  intros A B C f g z s1 s3 i H.\n  unfold bind2 in H.\n  exploit (@bind_inversion (A * B) C f (fun p => g (fst p) (snd p)) z s1 s3 i H).\n  intros [x [s2 [i1 [i2 [H1 H2]]]]].\n  destruct x as [x y].\n  exists x, y, s2, i1, i2.\n  split; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall (A B C: Type) (f: mon (A*B)) (g: A -> B -> mon C) (z: C) (s1 s3: state) (i: state_incr s1 s3), bind2 f g s1 = OK z s3 i -> exists x, exists y, exists s2, exists i1, exists i2, f s1 = OK (x, y) s2 i1 /\\ g x y s2 = OK z s3 i2 Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: exploit bind_inversion Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Simplify the goal by computation Step 8: Provide an existential witness Step 9: Provide an existential witness Step 10: Provide an existential witness Step 11: Provide an existential witness", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:instr_at_incr", "draft": "Require Import Coq.Logic.Eqdep_dec.\nLemma state_incr_fresh_var : forall (s1 s2 : state) (n : nat) (i : ident), state_incr s1 s2 -> s1.(st_fresh) = n -> s2.(st_fresh) = n -> i = s1.(st_fresh) -> i = s2.(st_fresh).\nProof.\n  intros s1 s2 n i H H0 H1 H2.\n  inv H.\n  destruct n.\n  congruence.\n  congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall s1 s2 n i, state_incr s1 s2 -> s1 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Case analysis by destructing a value Step 5: Apply tactic: congruence Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:valid_fresh_absurd", "draft": "Lemma reg_fresh_invalid : forall (r : reg) (s : state), reg_valid r s -> reg_fresh r s -> False.\nProof.\n  intros r s H1 H2.\n  unfold reg_fresh in H2.\n  case r.\n  tauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall r s, reg_valid r s -> reg_fresh r s -> False Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: case r Step 5: Apply tactic: tauto Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:valid_fresh_different", "draft": "Lemma reg_fresh_ne : forall (r1 r2 : reg) (s : state), reg_valid r1 s -> reg_fresh r2 s -> r1 <> r2.\nProof.\n  intros r1 r2 s H H0.\n  subst r2.\n  eauto with rtlg.\nQed.", "nl_proof": "Step 1: We need to prove that forall r1 r2 s, reg_valid r1 s -> reg_fresh r2 s -> r1 <> r2 Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: subst r2 Step 5: Apply tactic: eauto with rtlg Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:reg_valid_incr", "draft": "Lemma reg_valid_incr : forall (r : reg) (s1 s2 : state), state_incr s1 s2 -> reg_valid r s1 -> reg_valid r s2.\nProof.\n  intros r s1 s2 INCR VALID.\n  inversion INCR.\n  unfold reg_valid in *.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall r s1 s2, state_incr s1 s2 -> reg_valid r s1 -> reg_valid r s2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inversion INCR Step 4: Unfold a definition Step 5: Introduce variables and assumptions Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:reg_fresh_decr", "draft": "Lemma reg_fresh_incr : forall (r : reg) (s1 s2 : state), state_incr s1 s2 -> reg_fresh r s2 -> reg_fresh r s1.\nProof.\n  intros r s1 s2 INCR FRESH.\n  inversion INCR.\n  unfold reg_fresh in *.\n  unfold state_incr in H.\n  destruct H as [H _].\n  apply H.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall r s1 s2, state_incr s1 s2 -> reg_fresh r s2 -> reg_fresh r s1 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inversion INCR Step 4: Unfold a definition Step 5: Unfold a definition Step 6: Introduce variables and assumptions Step 7: Apply a theorem or hypothesis Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:regs_valid_nil", "draft": "Lemma regs_valid_nil : forall (A : Type) (s : A), regs_valid nil s.\nProof.\n  intros s. red. intros. elim H.\nQed.", "nl_proof": "Step 1: We need to prove that forall s, regs_valid nil s Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: elim H Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:regs_valid_cons", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma regs_valid_cons : forall (r1 : nat) (rl : list nat) (s : nat),\n    reg_valid r1 s -> regs_valid rl s -> regs_valid (r1 :: rl) s.\nProof.\n  intros r1 rl s H H0.\n  red.\n  intros r H1.\n  elim H1.\n  intro H2.\n  subst r1.\n  assumption.\n  apply H0.\nQed.", "nl_proof": "Step 1: We need to prove that forall r1 rl s, reg_valid r1 s -> regs_valid rl s -> regs_valid (r1 :: rl) s Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: elim H1 Step 6: Apply tactic: intro Step 7: Apply tactic: subst r1 Step 8: Solve automatically using known facts Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:regs_valid_app", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma regs_valid_app : forall rl1 rl2 s, regs_valid rl1 s -> regs_valid rl2 s -> regs_valid (rl1 ++ rl2) s.\nProof.\n  intros rl1 rl2 s H1 H2.\n  red.\n  intros r H.\n  apply in_app_or in H.\n  destruct H as [H|H].\n  - apply H1; assumption.\n  - apply H2; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall rl1 rl2 s, regs_valid rl1 s -> regs_valid rl2 s -> regs_valid (rl1 ++ rl2) s Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply a theorem or hypothesis Step 6: Case analysis by destructing a value Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:regs_valid_incr", "draft": "Require Import Coq.Lists.List.\n\nLemma regs_valid_incr : forall (s1 s2 : state) (rl : list reg), state_incr s1 s2 -> regs_valid rl s1 -> regs_valid rl s2.\nProof.\n  intros s1 s2 rl Hincr Hvalid.\n  unfold regs_valid in *.\n  intros r Hin.\n  apply Hvalid in Hin.\n  eauto with rtlg.\nQed.", "nl_proof": "Step 1: We need to prove that forall s1 s2 rl, state_incr s1 s2 -> regs_valid rl s1 -> regs_valid rl s2 Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: eauto with rtlg Step 5: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:map_valid_incr", "draft": "Require Import Coq.Lists.List.\nLemma map_valid_incr : forall (s1 s2 : state) (m : map), state_incr s1 s2 -> map_valid m s1 -> map_valid m s2.\nProof. eauto with rtlg. Qed.", "nl_proof": "Step 1: We need to prove that forall s1 s2 m, state_incr s1 s2 -> map_valid m s1 -> map_valid m s2 Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: eauto with rtlg Step 5: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:add_instr_at", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma add_instr_at : forall s1 s2 incr i n, add_instr i s1 = OK n s2 incr -> s2.(st_code)!n = Some i.\nProof.\n  intros s1 s2 incr i n H.\n  monadInv H.\n  simpl.\n  gss.\nQed.", "nl_proof": "Step 1: We need to prove that forall s1 s2 incr i n, add_instr i s1 = OK n s2 incr -> s2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: monadInv H Step 4: Simplify the goal by computation Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: gss Step 7: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:update_instr_at", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma update_instr_at : forall n i s1 s2 incr u, update_instr n i s1 = OK u s2 incr -> s2.(st_code)!n = Some i.\nProof.\n  intros n i s1 s2 incr u H.\n  unfold update_instr in H.\n  destruct (st_wf s1); try discriminate.\n  destruct (n <? st_nextnode s1); try discriminate.\n  inv H.\n  simpl.\n  apply PTree.gss.\nQed.", "nl_proof": "Step 1: We need to prove that forall n i s1 s2 incr u, update_instr n i s1 = OK u s2 incr -> s2 Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Apply tactic: try discriminate Step 6: Case analysis by destructing a value Step 7: Apply tactic: try discriminate Step 8: Apply tactic: inv H Step 9: Simplify the goal by computation Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: gss", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:new_reg_valid", "draft": "Require Import Coq.Arith.Arith.\nRequire Import compcert.common.Errors.\nRequire Import compcert.lib.Integers.\n\nLemma new_reg_valid : forall s1 s2 r i, new_reg s1 = OK r s2 i -> reg_valid r s2.\nProof.\n  intros s1 s2 r i H.\n  monadInv H.\n  unfold reg_valid.\n  simpl.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall s1 s2 r i, new_reg s1 = OK r s2 i -> reg_valid r s2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: monadInv H Step 4: Unfold a definition Step 5: Simplify the goal by computation Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:new_reg_fresh", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.PArith.BinPos.\nRequire Import compcert.common.Errors.\nRequire Import compcert.lib.Maps.\n\nLemma new_reg_fresh : forall s1 s2 r i, new_reg s1 = OK r s2 i -> reg_fresh r s1.\nProof.\n  intros s1 s2 r i H.\n  monadInv H.\n  unfold reg_fresh.\n  simpl.\n  exact (Plt_strict _).\nQed.", "nl_proof": "Step 1: We need to prove that forall s1 s2 r i, new_reg s1 = OK r s2 i -> reg_fresh r s1 Step 2: Introduce variables and assumptions Step 3: Apply tactic: monadInv H Step 4: Unfold a definition Step 5: Simplify the goal by computation Step 6: Apply tactic: exact (Plt_strict _) Step 7: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:new_reg_not_in_map", "draft": "Require Import Coq.Lists.List.\nLemma new_reg_not_in_map : forall (s1 s2 : state) (m : mapping) (r : reg) (i : ident),\n  new_reg s1 = OK r s2 i -> map_valid m s1 -> ~(reg_in_map m r).\nProof. eauto with rtlg. Qed.", "nl_proof": "Step 1: We need to prove that forall s1 s2 m r i, new_reg s1 = OK r s2 i -> map_valid m s1 -> ~(reg_in_map m r) Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: eauto with rtlg Step 5: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:init_mapping_valid", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma map_valid_init_mapping : forall (A : Type) (s : list A), map (fun x : A => x) s = s.\nProof. induction s; simpl; congruence. Qed.", "nl_proof": "Step 1: We need to prove that forall s, map_valid init_mapping s Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Simplify the goal by computation Step 5: Rewrite using an equality Step 6: Apply tactic: gempty in A Step 7: Apply tactic: discriminate Step 8: Simplify the goal by computation Step 9: Apply tactic: tauto Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:find_var_in_map", "draft": "Require Import Coq.Lists.List.\n\nLemma find_var_in_map : forall (s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : instr),\n  find_var map name s1 = OK r s2 i -> reg_in_map map r.\nProof.\n  intros s1 s2 map name r i H.\n  unfold find_var in H.\n  case_eq ((map_vars map)!name); intros.\n  - rewrite H0 in H.\n    inv H.\n    left.\n    exists name.\n    assumption.\n  - rewrite H0 in H.\n    discriminate.\nQed.", "nl_proof": "Step 1: We need to prove that forall s1 s2 map name r i, find_var map name s1 = OK r s2 i -> reg_in_map map r Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: caseEq (map Step 5: Apply tactic: (map_vars)!name) Step 6: Introduce variables and assumptions Step 7: Apply tactic: inv H0 Step 8: Apply tactic: left Step 9: Provide an existential witness Step 10: Solve automatically using known facts Step 11: Introduce variables and assumptions", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:find_var_valid", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma find_var_valid : forall s1 s2 map name r i, find_var map name s1 = OK r s2 i -> map_valid map s1 -> reg_valid r s1.\nProof. eauto with rtlg. Qed.", "nl_proof": "Step 1: We need to prove that forall s1 s2 map name r i, find_var map name s1 = OK r s2 i -> map_valid map s1 -> reg_valid r s1 Step 2: Apply tactic: eauto with rtlg Step 3: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:find_letvar_in_map", "draft": "Require Import Coq.Lists.List.\nLemma find_letvar_in_map : forall (s1 s2 : state) (map : mapping) (idx : nat) (r : reg) (i : ident), find_letvar map idx s1 = OK r s2 i -> reg_in_map map r.\nProof.\n  intros s1 s2 map idx r i H.\n  unfold find_letvar in H.\n  caseEq (nth_error (map_letvars map) idx); intros.\n  monadInv H.\n  right.\n  apply nth_error_in with idx.\n  rewrite <- H0.\n  assumption.\n  monadInv H.\nQed.", "nl_proof": "Step 1: We need to prove that forall s1 s2 map idx r i, find_letvar map idx s1 = OK r s2 i -> reg_in_map map r Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: caseEq (nth_error (map_letvars map) idx) Step 5: Introduce variables and assumptions Step 6: Apply tactic: monadInv H0 Step 7: Apply tactic: right Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:find_letvar_valid", "draft": "Require Import Coq.Arith.Arith.\nLemma find_letvar_valid : forall s1 s2 map idx r i, find_letvar map idx s1 = OK r s2 i -> map_valid map s1 -> reg_valid r s1.\nProof. eauto with rtlg. Qed.", "nl_proof": "Step 1: We need to prove that forall s1 s2 map idx r i, find_letvar map idx s1 = OK r s2 i -> map_valid map s1 -> reg_valid r s1 Step 2: Apply tactic: eauto with rtlg Step 3: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:add_var_valid", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma add_var_valid : forall s1 s2 map1 map2 name r i,\n  add_var map1 name s1 = OK (r, map2) s2 i ->\n  map_valid map1 s1 ->\n  reg_valid r s2 /\\ map_valid map2 s2.\nProof.\n  intros s1 s2 map1 map2 name r i H H0.\n  monadInv H.\n  split.\n  - eauto with rtlg.\n  - inversion EQ.\n    subst.\n    red.\n    intros.\n    simpl.\n    rewrite H1.\n    auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall s1 s2 map1 map2 name r i, add_var map1 name s1 = OK (r, map2) s2 i -> map_valid map1 s1 -> reg_valid r s2 /\\ map_valid map2 s2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: monadInv H Step 4: Split a conjunction into separate goals Step 5: Apply tactic: eauto with rtlg Step 6: Apply tactic: inversion EQ Step 7: Apply tactic: subst Step 8: Apply tactic: red Step 9: Introduce variables and assumptions Step 10: Simplify the goal by computation Step 11: Rewrite using an equality", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:add_var_find", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma add_var_letenv : forall map1 id s1 r map2 s2 i,\n  add_var map1 id s1 = OK (r, map2) s2 i -> map_letvars map2 = map_letvars map1.\nProof.\n  intros. monadInv H. simpl. reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall s1 s2 map name r map' i, add_var map name s1 = OK (r,map') s2 i -> map' Step 2: Introduce variables and assumptions Step 3: Apply tactic: monadInv H Step 4: Simplify the goal by computation Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: gss Step 7: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:add_vars_valid", "draft": "Require Import Coq.Lists.List.\n\nLemma add_vars_valid : forall (namel : list positive) (s1 s2 : state) (map1 map2 : mapping) (rl : list reg) (i : ident),\n  add_vars map1 namel s1 = OK (rl, map2) s2 i -> map_valid map1 s1 -> regs_valid rl s2 /\\ map_valid map2 s2.\nProof.\n  induction namel; intros; simpl in H; monadInv H.\n  - split; [apply regs_valid_nil|assumption].\n  - destruct (add_var map1 a s1) as [[r map'] s3 i'] eqn:?; try discriminate.\n    monadInv H. apply IHnamel in H0; [|assumption]. destruct H0 as [Hrl Hmap'].\n    split; [apply regs_valid_cons; [apply add_var_valid with (1 := Heqr0)|exact Hrl]|exact Hmap'].\nQed.", "nl_proof": "Step 1: We need to prove that forall namel s1 s2 map1 map2 rl i, add_vars map1 namel s1 = OK (rl, map2) s2 i -> map_valid map1 s1 -> regs_valid rl s2 /\\ map_valid map2 s2 Step 2: Proceed by induction on namel Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: monadInv H Step 6: Split a conjunction into separate goals Step 7: Apply tactic: red Step 8: Simplify the goal by computation Step 9: Introduce variables and assumptions Step 10: Apply tactic: tauto Step 11: Solve automatically using known facts", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:add_var_letenv", "draft": "Require Import Coq.Lists.List.\n\nLemma add_var_letenv : forall (map1 : map) (id : ident) (s1 : state) (r : reg) (map2 : map) (s2 : state) (i : info),\n  add_var map1 id s1 = OK (r, map2) s2 i -> map_letvars map2 = map_letvars map1.\nProof.\n  intros. monadInv H. reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall map1 id s1 r map2 s2 i, add_var map1 id s1 = OK (r, map2) s2 i -> map2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: monadInv H Step 4: The goal is true by reflexivity Step 5: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:add_vars_letenv", "draft": "Require Import Coq.Lists.List.\n\nLemma add_vars_letenv : forall (il : list ident) (map1 map2 : mapping) (s1 s2 : state) (rl : list reg) (i : info),\n  add_vars map1 il s1 = OK (rl, map2) s2 i -> map_letvars map2 = map_letvars map1.\nProof.\n  induction il; intros; simpl in H.\n  - monadInv H. reflexivity.\n  - monadInv H. transitivity (map_letvars x0).\n    + eapply add_var_letenv. eauto.\n    + eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall il map1 s1 rl map2 s2 i, add_vars map1 il s1 = OK (rl, map2) s2 i -> map2 Step 2: Proceed by induction on il Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: monadInv H Step 6: The goal is true by reflexivity Step 7: Apply tactic: transitivity (map_letvars x0) Step 8: Apply tactic: eapply add_var_letenv Step 9: Apply tactic: eauto Step 10: Apply tactic: eauto Step 11: Apply tactic: Qed", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:add_letvar_valid", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma map_valid_add_letvar : forall (map : list nat) (s : nat) (r : nat), (forall x : nat, In x map -> x < s) -> r < s -> forall x : nat, In x (r :: map) -> x < s.\nProof.\n  intros map s r Hmap Hr x Hin.\n  destruct Hin as [Hx | Hx].\n  - rewrite Hx. apply Hr.\n  - apply Hmap. apply Hx.\nQed.", "nl_proof": "Step 1: We need to prove that forall map s r, map_valid map s -> reg_valid r s -> map_valid (add_letvar map r) s Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Simplify the goal by computation Step 7: Apply a theorem or hypothesis Step 8: Apply tactic: left Step 9: Provide an existential witness Step 10: Solve automatically using known facts Step 11: Simplify the goal by computation", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:alloc_reg_valid", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma alloc_reg_valid : forall (a : nat) (s1 s2 : state) (map : mapping) (r : reg) (i : instr),\n  map_valid map s1 -> alloc_reg map a s1 = OK r s2 i -> reg_valid r s2.\nProof.\n  intros a s1 s2 map r i Hmap_valid Halloc.\n  unfold alloc_reg in Halloc.\n  case a in Halloc; eauto with rtlg.\nQed.", "nl_proof": "Step 1: We need to prove that forall a s1 s2 map r i, map_valid map s1 -> alloc_reg map a s1 = OK r s2 i -> reg_valid r s2 Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: case a Step 5: Apply tactic: eauto with rtlg Step 6: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:alloc_reg_fresh_or_in_map", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma alloc_reg_fresh_or_in_map : forall map a s r s' i,\n  map_valid map s ->\n  alloc_reg map a s = OK r s' i ->\n  reg_in_map map r \\/ reg_fresh r s.\nProof.\n  intros map a s r s' i H H0.\n  destruct (alloc_reg map a s) eqn:?.\n  - inversion H0; subst.\n    try (right; eauto with rtlg; fail).\n    left; eauto with rtlg.\n  - discriminate.\nQed.", "nl_proof": "Step 1: We need to prove that forall map a s r s' i, map_valid map s -> alloc_reg map a s = OK r s' i -> reg_in_map map r \\/ reg_fresh r s Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Introduce variables and assumptions Step 6: Apply tactic: try (right Step 7: Apply tactic: eauto with rtlg Step 8: Apply tactic: fail) Step 9: Apply tactic: left Step 10: Apply tactic: eauto with rtlg Step 11: Apply tactic: left", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:alloc_regs_valid", "draft": "Require Import Coq.Lists.List.\n\nLemma alloc_regs_valid : forall (al : list positive) (s1 s2 : state) (map : mapping) (rl : list reg) (i : instr),\n  map_valid map s1 ->\n  alloc_regs map al s1 = OK rl s2 i ->\n  regs_valid rl s2.\nProof.\n  induction al; intros s1 s2 map rl i H H0; simpl in H0; monadInv H0; eauto with rtlg.\nQed.", "nl_proof": "Step 1: We need to prove that forall al s1 s2 map rl i, map_valid map s1 -> alloc_regs map al s1 = OK rl s2 i -> regs_valid rl s2 Step 2: Proceed by induction on al Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: monadInv H0 Step 6: Apply a theorem or hypothesis Step 7: Apply a theorem or hypothesis Step 8: Apply tactic: eauto with rtlg Step 9: Apply tactic: eauto with rtlg Step 10: Apply tactic: Qed", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:alloc_regs_fresh_or_in_map", "draft": "Require Import Coq.Lists.List.\n\nLemma alloc_regs_fresh_or_in_map : forall (map : Type) (al : list Type) (s : Type) (rl : list Type) (s' : Type) (i : Type),\n  map_valid map s ->\n  alloc_regs map al s = OK rl s' i ->\n  forall (r : Type), In r rl -> reg_in_map map r \\/ reg_fresh r s.\nProof.\n  induction al; intros; simpl in *.\n  - inversion H0; subst. contradiction.\n  - monadInv H0.\n    elim H1; intro.\n    + subst r.\n      eapply alloc_reg_fresh_or_in_map; eauto.\n    + eapply IHal; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall map al s rl s' i, map_valid map s -> alloc_regs map al s = OK rl s' i -> forall r, In r rl -> reg_in_map map r \\/ reg_fresh r s Step 2: Proceed by induction on al Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: monadInv H0 Step 6: Apply tactic: elim H1 Step 7: Apply tactic: elim H1 Step 8: Apply tactic: intro Step 9: Apply tactic: subst r Step 10: Apply tactic: eapply alloc_reg_fresh_or_in_map Step 11: Apply tactic: eauto", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:alloc_optreg_valid", "draft": "Require Import Coq.Arith.Arith.\nLemma alloc_optreg_valid : forall dest s1 s2 map r i,\n  map_valid map s1 ->\n  alloc_optreg map dest s1 = OK r s2 i -> reg_valid r s2.\nProof.\n  intros dest s1 s2 map r i H H0.\n  unfold alloc_optreg in H0.\n  case dest in H0; eauto with rtlg.\nQed.", "nl_proof": "Step 1: We need to prove that forall dest s1 s2 map r i, map_valid map s1 -> alloc_optreg map dest s1 = OK r s2 i -> reg_valid r s2 Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: case dest Step 5: Apply tactic: eauto with rtlg Step 6: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:alloc_optreg_fresh_or_in_map", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma alloc_optreg_fresh_or_in_map : forall map dest s r s' i,\n  map_valid map s ->\n  alloc_optreg map dest s = OK r s' i ->\n  reg_in_map map r \\/ reg_fresh r s.\nProof.\n  intros map dest s r s' i H H0.\n  destruct dest.\n  - left. eauto with rtlg.\n  - right. eauto with rtlg.\nQed.", "nl_proof": "Step 1: We need to prove that forall map dest s r s' i, map_valid map s -> alloc_optreg map dest s = OK r s' i -> reg_in_map map r \\/ reg_fresh r s Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Introduce variables and assumptions Step 6: Apply tactic: left Step 7: Apply tactic: eauto with rtlg Step 8: Apply tactic: right Step 9: Apply tactic: eauto with rtlg Step 10: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:target_reg_ok_append", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma target_reg_ok_append : forall map pr a r,\n  target_reg_ok map pr a r ->\n  forall pr',\n  (forall r', In r' pr' -> reg_in_map map r' \\/ r' <> r) ->\n  target_reg_ok map (pr' ++ pr) a r.\nProof.\n  induction 1; intros pr' H; constructor; auto;\n  try (apply in_app_iff; auto);\n  try (intros r' HIn; apply in_app_iff in HIn; destruct HIn as [HIn|HIn];\n       [apply H; auto | apply H0; auto]).\nQed.", "nl_proof": "Step 1: We need to prove that forall map pr a r, target_reg_ok map pr a r -> forall pr', (forall r', In r' pr' -> reg_in_map map r' \\/ r' <> r) -> target_reg_ok map (pr' ++ pr) a r Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Apply tactic: constructor Step 5: Solve automatically using known facts Step 6: Apply tactic: constructor Step 7: Solve automatically using known facts Step 8: Apply tactic: constructor Step 9: Solve automatically using known facts Step 10: Apply tactic: red Step 11: Introduce variables and assumptions", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:target_reg_ok_cons", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma target_reg_ok_cons : forall (map : list nat) (pr : list nat) (a : nat) (r : nat),\n  target_reg_ok map pr a r -> forall (r' : nat), (In r' map \\/ r' <> r) -> target_reg_ok map (r' :: pr) a r.\nProof.\n  intros map pr a r H r' H0.\n  change (r' :: pr) with ((r' :: nil) ++ pr).\n  apply target_reg_ok_app.\n  - intros r'' H1.\n    destruct H1 as [H1|H1].\n    + subst r''.\n      destruct H0 as [H0|H0].\n      * left; assumption.\n      * right; assumption.\n    + contradiction.\n  - assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall map pr a r, target_reg_ok map pr a r -> forall r', reg_in_map map r' \\/ r' <> r -> target_reg_ok map (r' :: pr) a r Step 2: Introduce variables and assumptions Step 3: Apply tactic: change (r' :: pr) with ((r' :: nil) ++ pr) Step 4: Apply a theorem or hypothesis Step 5: Solve automatically using known facts Step 6: Introduce variables and assumptions Step 7: Apply tactic: subst r'' Step 8: Solve automatically using known facts Step 9: Apply tactic: contradiction Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:new_reg_target_ok", "draft": "Require Import Coq.Lists.List.\nLemma new_reg_target_ok : forall (map : Type) (pr : Type) (s1 : Type) (a : Type) (r : Type) (s2 : Type) (i : Type),\n  map_valid map s1 ->\n  regs_valid pr s1 ->\n  new_reg s1 = OK r s2 i ->\n  target_reg_ok map pr a r.\nProof.\n  intros.\n  constructor.\n  red.\n  intro.\n  eauto with rtlg.\nQed.", "nl_proof": "Step 1: We need to prove that forall map pr s1 a r s2 i, map_valid map s1 -> regs_valid pr s1 -> new_reg s1 = OK r s2 i -> target_reg_ok map pr a r Step 2: Introduce variables and assumptions Step 3: Apply tactic: constructor Step 4: Apply tactic: red Step 5: Apply tactic: intro Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: eauto with rtlg Step 8: Apply tactic: eauto with rtlg Step 9: Apply tactic: red Step 10: Apply tactic: intro Step 11: Apply a theorem or hypothesis", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:alloc_reg_target_ok", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma alloc_reg_target_ok : forall (map : Type) (pr : Type) (s1 : Type) (a : Type) (r : Type) (s2 : Type) (i : Type),\n  map_valid map s1 ->\n  regs_valid pr s1 ->\n  alloc_reg map a s1 = OK r s2 i ->\n  target_reg_ok map pr a r.\nProof.\n  intros map pr s1 a r s2 i H H0 H1.\n  generalize H1.\n  unfold alloc_reg.\n  case_eq ((map_vars map) ! i0); intros.\n  eapply new_reg_target_ok; eauto.\n  eauto.\n  fail.\nQed.", "nl_proof": "Step 1: We need to prove that forall map pr s1 a r s2 i, map_valid map s1 -> regs_valid pr s1 -> alloc_reg map a s1 = OK r s2 i -> target_reg_ok map pr a r Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Apply tactic: try (eapply new_reg_target_ok Step 6: Apply tactic: eauto Step 7: Apply tactic: fail) Step 8: Apply tactic: generalize H1 Step 9: Unfold a definition Step 10: Apply tactic: caseEq (map_vars map)!i0 Step 11: Introduce variables and assumptions", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:alloc_regs_target_ok", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma alloc_regs_target_ok : forall map al pr s1 rl s2 i,\n  map_valid map s1 ->\n  regs_valid pr s1 ->\n  alloc_regs map al s1 = OK rl s2 i ->\n  target_regs_ok map pr al rl.\nProof.\n  induction al; intros; monadInv H1.\n  - constructor.\n  - constructor.\n    + eapply alloc_reg_target_ok; eauto.\n    + eauto with rtlg.\nQed.", "nl_proof": "Step 1: We need to prove that forall map al pr s1 rl s2 i, map_valid map s1 -> regs_valid pr s1 -> alloc_regs map al s1 = OK rl s2 i -> target_regs_ok map pr al rl Step 2: Proceed by induction on al Step 3: Introduce variables and assumptions Step 4: Apply tactic: monadInv H1 Step 5: Apply tactic: constructor Step 6: Apply tactic: constructor Step 7: Apply tactic: eapply alloc_reg_target_ok Step 8: Apply tactic: eauto Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: eauto with rtlg Step 11: Apply a theorem or hypothesis", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:return_reg_ok_incr", "draft": "Require Import Coq.Relations.Relation_Definitions.\n\nLemma return_reg_ok_incr : forall s map rret, return_reg_ok s map rret ->\n  forall s', state_incr s s' -> return_reg_ok s' map rret.\nProof.\n  induction 1; intros; econstructor; eauto with rtlg.\nQed.", "nl_proof": "Step 1: We need to prove that forall s map rret, return_reg_ok s map rret -> forall s', state_incr s s' -> return_reg_ok s' map rret Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Apply tactic: econstructor Step 5: Apply tactic: eauto with rtlg Step 6: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:new_reg_return_ok", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma new_reg_return_ok : forall s1 r s2 map sig i, new_reg s1 = OK r s2 i -> map_valid map s1 -> return_reg_ok s2 map (ret_reg sig r).\nProof. intros. constructor. eauto with rtlg. Qed.", "nl_proof": "Step 1: We need to prove that forall s1 r s2 map sig i, new_reg s1 = OK r s2 i -> map_valid map s1 -> return_reg_ok s2 map (ret_reg sig r) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Apply tactic: constructor Step 6: Apply tactic: eauto with rtlg Step 7: Apply tactic: Qed", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:tr_move_incr", "draft": "Require Import Coq.Relations.Relation_Operators.\nLemma tr_move_incr : forall (s1 s2 : state), state_incr s1 s2 ->\n  forall (ns rd : node) (rs rd0 : reg),\n  tr_move (st_code s1) ns rs rd rd0 -> tr_move (st_code s2) ns rs rd rd0.\nProof.\n  induction 2; econstructor; eauto with rtlg.\nQed.", "nl_proof": "Step 1: We need to prove that forall s1 s2, state_incr s1 s2 -> forall ns rs nd rd, tr_move s1 Step 2: Proceed by induction on 2 Step 3: Apply tactic: econstructor Step 4: Apply tactic: eauto with rtlg Step 5: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:add_move_charact", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma add_move_tr_move : forall s ns rs nd rd s' i, add_move rs rd nd s = OK ns s' i -> tr_move s'.(st_code) ns rs nd rd.\nProof.\n  intros s ns rs nd rd s' i H.\n  unfold add_move in H.\n  destruct (eq rs rd).\n  inv H.\n  constructor.\n  constructor.\n  eauto with rtlg.\nQed.", "nl_proof": "Step 1: We need to prove that forall s ns rs nd rd s' i, add_move rs rd nd s = OK ns s' i -> tr_move s' Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Apply tactic: eq rs rd) Step 6: Apply tactic: inv H Step 7: Apply tactic: constructor Step 8: Apply tactic: constructor Step 9: Apply tactic: eauto with rtlg Step 10: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:transl_expr_assign_charact", "draft": "Require Import Coq.Lists.List.\nLemma tr_expr_transl_expr : forall (A B : Type) (map : A) (a : B) (rd id : nat) (nd s ns s' : nat) (INCR : nat) (TR : transl_expr map a rd nd s = OK ns s' INCR) (WF : map_valid map s) (OK : reg_map_ok map rd (Some id)), tr_expr s' ns s' INCR.\nProof.\n  intros.\n  induction a.\n  monadInv TR.\n  saturateTrans.\n  generalize EQ.\n  unfold transl_expr.\n  case_eq ((map_vars map)!i).\n  intros.\n  inv EQ1.\n  econstructor.\nQed.", "nl_proof": "Step 1: Econdition Step 2: Ebuiltin Step 3: Eexternal Step 4: We need to prove that forall id a map rd nd s ns s' INCR (TR: transl_expr map a rd nd s = OK ns s' INCR) (WF: map_valid map s) (OK: reg_map_ok map rd (Some id)), tr_expr s' Step 5: Proceed by induction on a Step 6: Introduce variables and assumptions Step 7: Apply tactic: monadInv TR Step 8: Apply tactic: saturateTrans Step 9: Apply tactic: generalize EQ Step 10: Unfold a definition Step 11: Apply tactic: caseEq (map_vars map)!i Step 12: Introduce variables and assumptions Step 13: Apply tactic: inv EQ1 Step 14: Apply tactic: econstructor", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:alloc_optreg_map_ok", "draft": "Require Import Coq.Lists.List.\n\nLemma alloc_optreg_map_ok : forall (map : Type) (optid : Type) (s1 : Type) (r : Type) (s2 : Type) (i : Type),\n  map_valid map s1 ->\n  alloc_optreg map optid s1 = OK r s2 i ->\n  reg_map_ok map r optid.\nProof.\n  intros map optid s1 r s2 i H H0.\n  unfold alloc_optreg in H0.\n  destruct optid.\n  - monadInv H0.\n    constructor.\n  - monadInv H0.\n    constructor.\n    eapply new_reg_not_in_map.\n    exact H.\n    exact EQ.\nQed.", "nl_proof": "Step 1: We need to prove that forall map optid s1 r s2 i, map_valid map s1 -> alloc_optreg map optid s1 = OK r s2 i -> reg_map_ok map r optid Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: constructor Step 6: Unfold a definition Step 7: Case analysis by destructing a value Step 8: Apply tactic: monadInv H0 Step 9: Solve automatically using known facts Step 10: Apply tactic: constructor Step 11: Apply tactic: eapply new_reg_not_in_map", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:tr_exitexpr_incr", "draft": "Require Import Coq.Lists.List.\nLemma tr_exitexpr_incr : forall s1 s2, state_incr s1 s2 -> forall (map : mapping) (a : expr) (ns : node) (nexits : list node), tr_exitexpr s1.(st_code) map a ns nexits -> tr_exitexpr s2.(st_code) map a ns nexits.\nProof.\n  intros s1 s2 Hincr map a ns nexits Htr.\n  generalize (tr_expr_incr s1 s2 Hincr) (tr_condition_incr s1 s2 Hincr).\n  induction Htr; econstructor; eauto with rtlg.\nQed.", "nl_proof": "Step 1: We need to prove that forall s1 s2, state_incr s1 s2 -> forall map a ns nexits, tr_exitexpr s1 Step 2: Introduce variables and assumptions Step 3: Apply tactic: generalize tr_expr_incr tr_condition_incr Step 4: Introduce variables and assumptions Step 5: Proceed by induction on 1 Step 6: Apply tactic: econstructor Step 7: Apply tactic: eauto with rtlg Step 8: Apply tactic: Qed", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:tr_stmt_incr", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma tr_stmt_incr : forall s1 s2, state_incr s1 s2 ->\n  forall map s ns nd nexits ngoto nret rret,\n  tr_stmt s1.(st_code) map s ns nd nexits ngoto nret rret ->\n  tr_stmt s2.(st_code) map s ns nd nexits ngoto nret rret.\nProof.\n  intros s1 s2 Hincr map s ns nd nexits ngoto nret rret Htr.\n  generalize (tr_expr_incr s1 s2 Hincr) (tr_condition_incr s1 s2 Hincr) (tr_exprl_incr s1 s2 Hincr).\n  intros Hexpr Hcond Hexprl.\n  pose (AT := fun pc i => instr_at_incr s1 s2 pc i Hincr).\n  induction Htr; econstructor; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall s1 s2, state_incr s1 s2 -> forall map s ns nd nexits ngoto nret rret, tr_stmt s1 Step 2: Introduce variables and assumptions Step 3: Apply tactic: generalize tr_expr_incr tr_condition_incr tr_exprl Step 4: Introduce variables and assumptions Step 5: Apply tactic: pose (AT := fun pc i => instr_at_incr s1 s2 pc i E Step 6: Proceed by induction on 1 Step 7: Apply tactic: econstructor Step 8: Apply tactic: eauto Step 9: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:transl_exit_charact", "draft": "Require Import Coq.Lists.List.\nLemma transl_exit_charact : forall (nexits : list nat) (n : nat) (s : nat) (ne : nat) (s' : nat) (incr : nat), transl_exit nexits n s = OK ne s' incr -> nth_error nexits n = Some ne /\\ s' = s.\nProof.\n  intros.\n  monadInv H.\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall nexits n s ne s' incr, transl_exit nexits n s = OK ne s' incr -> nth_error nexits n = Some ne /\\ s' = s Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Apply tactic: intro Step 6: Apply tactic: monadInv H Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:transl_jumptable_charact", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma transl_jumptable_charact : forall nexits tbl s nl s' incr, transl_jumptable nexits tbl s = OK nl s' incr -> tr_jumptable nexits tbl nl /\\ s' = s.\nProof.\n  induction tbl; intros; monadInv H; split; try red; simpl; auto; try discriminate.\nQed.", "nl_proof": "Step 1: We need to prove that forall nexits tbl s nl s' incr, transl_jumptable nexits tbl s = OK nl s' incr -> tr_jumptable nexits tbl nl /\\ s' = s Step 2: Proceed by induction on tbl Step 3: Introduce variables and assumptions Step 4: Apply tactic: monadInv H Step 5: Split a conjunction into separate goals Step 6: Apply tactic: red Step 7: Simplify the goal by computation Step 8: Introduce variables and assumptions Step 9: Apply tactic: discriminate Step 10: Solve automatically using known facts Step 11: Apply tactic: monadInv H", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:transl_exitexpr_charact", "draft": "Require Import Coq.Lists.List.\n\nLemma transl_exitexpr_charact_generalized : forall (nexits : list nat) (A : Type) (map : A) (s : nat) (ns : nat) (s' : nat) (INCR : nat),\n  transl_exitexpr map A nexits s = OK ns s' INCR -> map_valid map s -> tr_exitexpr s' map A ns nexits.\nProof.\n  intros nexits A map s ns s' INCR TR WF.\n  induction A; simpl in TR; try monadInv TR; saturateTrans;\n  exploit transl_exit_charact; eauto; intros; econstructor; eauto.\nQed.", "nl_proof": "Step 1: XEjumptable Step 2: XEcondition Step 3: We need to prove that forall nexits a map s ns s' INCR (TR: transl_exitexpr map a nexits s = OK ns s' INCR) (WF: map_valid map s), tr_exitexpr s' Step 4: Proceed by induction on a Step 5: Simplify the goal by computation Step 6: Introduce variables and assumptions Step 7: Apply tactic: try (monadInv TR) Step 8: Apply tactic: saturateTrans Step 9: Apply tactic: exploit transl_exit_charact Step 10: Apply tactic: eauto Step 11: Introduce variables and assumptions Step 12: Apply tactic: econstructor Step 13: Apply tactic: eauto", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:convert_builtin_res_charact", "draft": "Require Import Coq.Arith.Arith.\nRequire Import compcert.common.Errors.\nRequire Import compcert.lib.Maps.\n\nLemma convert_builtin_res_charact : forall map oty res s res' s' INCR,\n  convert_builtin_res map oty res s = OK res' s' INCR ->\n  map_valid map s ->\n  tr_builtin_res map res res'.\nProof.\n  intros map oty res s res' s' INCR TR WF.\n  destruct res; simpl in TR; try monadInv TR; try constructor.\n  destruct o; simpl in TR; try monadInv TR; try constructor.\n  destruct (xtype_eq oty Xvoid); try discriminate.\n  monadInv TR. constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall map oty res s res' s' INCR (TR: convert_builtin_res map oty res s = OK res' s' INCR) (WF: map_valid map s), tr_builtin_res map res res' Step 2: Case analysis by destructing a value Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - monadInv TR Step 6: Apply tactic: constructor Step 7: Unfold a definition Step 8: Case analysis by destructing a value Step 9: Apply tactic: inv EQ Step 10: Solve automatically using known facts Step 11: Apply tactic: - destruct (xtype_eq oty Xvoid)", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:transl_stmt_charact", "draft": "Require Import Coq.Lists.List.\nLemma transl_stmt_charact : forall (map : Monad.map) (stmt : Monad.stmt) (nd nexits ngoto nret rret : nat) (s ns s' : Monad.state) (INCR : Monad.incr s s'),\n  transl_stmt map stmt nd nexits ngoto nret rret s = OK ns s' INCR -> map_valid map s -> return_reg_ok s map rret -> tr_stmt s'.(st_code) map stmt ns nd nexits ngoto nret rret.\nProof.\n  intros.\n  monadInv H.\n  saturateTrans.\n  constructor.\n  revert EQ.\n  unfold transl_stmt.\n  case_eq ((map_vars map)!i).\n  intros.\n  assumption.\nQed.", "nl_proof": "Step 1: indirect Step 2: Stailcall Step 3: indirect Step 4: Sbuiltin Step 5: Sifthenelse Step 6: We need to prove that forall map stmt nd nexits ngoto nret rret s ns s' INCR (TR: transl_stmt map stmt nd nexits ngoto nret rret s = OK ns s' INCR) (WF: map_valid map s) (OK: return_reg_ok s map rret), tr_stmt s' Step 7: Proceed by induction on stmt Step 8: Introduce variables and assumptions Step 9: Simplify the goal by computation Step 10: Apply tactic: try (monadInv TR) Step 11: Apply tactic: saturateTrans Step 12: Apply tactic: constructor Step 13: Apply tactic: revert EQ Step 14: Unfold a definition Step 15: Apply tactic: case_eq (map_vars map)!i Step 16: Introduce variables and assumptions", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenspec:transl_function_charact", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma transl_function_charact : forall f tf, transl_function f = Errors.OK tf -> tr_function f tf.\nProof.\n  intros f tf E.\n  unfold transl_function in E.\n  caseEq (transl_fun f init_state); [|congruence].\n  intros s T.\n  rewrite T in E.\n  inv E.\n  monadInv TR.\n  exploit add_vars_valid; eexact EQ1.\nQed.", "nl_proof": "Step 1: We need to prove that forall f tf, transl_function f = Errors Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: caseEq (transl_fun f init_state) Step 5: Apply tactic: congruence Step 6: Introduce variables and assumptions Step 7: Apply tactic: inv E Step 8: Apply tactic: monadInv TR Step 9: Apply tactic: exploit add_vars_valid Step 10: Apply tactic: eexact EQ1 Step 11: Apply a theorem or hypothesis", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:type_ros_incr", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma type_ros_single_inv : forall (A B : Type) (e : A) (ros : option B) (e' : A),\n  (match ros with | Some _ => OK e | None => OK e end) = OK e' -> e = e'.\nProof.\n  intros A B e ros e' H.\n  destruct ros; inv H; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall e ros e' te, type_ros e ros = OK e' -> S Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: eauto with ty Step 6: Apply tactic: inv H Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:type_ros_sound", "draft": "Require Import Coq.Lists.List.\n\nLemma solve_rec_sound : forall (te : nat -> nat) (r1 r2 : nat) (q : list (nat * nat)) (e e' : nat -> nat) (changed changed' : bool),\n  solve_rec e changed q = OK (e', changed') -> In (r1, r2) q -> satisf te e' -> te r1 = te r2.\nProof.\n  intros te r1 r2 q e e' changed changed' H1 H2 H3.\n  eapply S.\n  unfold satisf in H3.\n  destruct changed'.\n  - eapply set_sound; eauto.\n  - eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall e ros e' te, type_ros e ros = OK e' -> S Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: eapply S Step 6: Apply tactic: set_sound Step 7: Apply tactic: eauto Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:check_successor_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma check_successor_valid : forall (A B : Type) (f : A -> B) (s : A) (x : B), check_successor s = OK x -> valid_successor f s.\nProof.\n  intros A B f s x H.\n  destruct s.\n  - inv H.\n    exists x.\n    reflexivity.\n  - discriminate.\nQed.", "nl_proof": "Step 1: We need to prove that forall s x, check_successor s = OK x -> valid_successor f s Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: inv H Step 6: Provide an existential witness Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:check_successors_sound", "draft": "Require Import Coq.Lists.List.\nLemma check_successors_sound : forall (sl : list positive) (x : unit), check_successors sl = OK x -> forall s, In s sl -> valid_successor f s.\nProof.\n  induction sl; intros x H s HIn.\n  - simpl in HIn. contradiction.\n  - simpl in H. monadInv H.\n    destruct HIn.\n    + subst s. eauto with ty.\n    + eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall sl x, check_successors sl = OK x -> forall s, In s sl -> valid_successor f s Step 2: Proceed by induction on sl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: contradiction Step 6: Apply tactic: monadInv H Step 7: Case analysis by destructing a value Step 8: Apply tactic: subst a Step 9: Apply tactic: eauto with ty Step 10: Apply tactic: eauto Step 11: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:type_expect_incr", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma type_expect_inversion : forall (A B : Type) (e : A) (ty1 ty2 : B) (e' : A) (te : B),\n  (if eqb ty1 ty2 then OK e else Error) = OK e' -> ty1 = ty2 /\\ e = e'.\nProof.\n  intros A B e ty1 ty2 e' te H.\n  destruct (eqb ty1 ty2) eqn:Heq; try discriminate.\n  inversion H; subst. split; auto.\n  apply eqb_prop in Heq; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall e ty1 ty2 e' te, type_expect e ty1 ty2 = OK e' -> S Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: inv H Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:type_expect_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\nLemma type_expect_same_type : forall (A : Type) (e : A) (ty1 ty2 : A) (e' : A), (if eq_ty_dec ty1 ty2 then OK e' else Error) = OK e' -> ty1 = ty2.\nProof.\n  intros A e ty1 ty2 e' H.\n  destruct (eq_ty_dec ty1 ty2); [assumption | discriminate].\nQed.", "nl_proof": "Step 1: We need to prove that forall e ty1 ty2 e', type_expect e ty1 ty2 = OK e' -> ty1 = ty2 Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: inv H Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:type_builtin_arg_incr", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma type_builtin_arg_ok_inv : forall (A B C D E : Type) (e : A) (a : B) (ty : C) (e' : D) (te : E),\n  type_builtin_arg e a ty = OK e' -> S.\nProof.\n  intros A B C D E e a ty e' te H.\n  unfold type_builtin_arg in H.\n  destruct a.\n  eauto with ty.\nQed.", "nl_proof": "Step 1: We need to prove that forall e a ty e' te, type_builtin_arg e a ty = OK e' -> S Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: eauto with ty Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:type_builtin_args_incr", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma type_builtin_args_induction : forall (A B C D : Type) (type_builtin_args : A -> list B -> C -> mon (list D)) (a : list B) (ty : C) (e e' : A),\n  type_builtin_args e a ty = OK e' -> \n  (forall e ty, type_builtin_args e nil ty = OK e) ->\n  (forall b a0 e ty e1 e2, type_builtin_args e (b :: a0) ty = OK e2 -> \n   (exists e', type_builtin_arg e b ty = OK e' /\\ type_builtin_args e' a0 ty = OK e2)) ->\n  exists e1, type_builtin_args e1 a ty = OK e'.\nProof.\n  intros A B C D type_builtin_args a ty e e' H H_nil H_cons.\n  induction a.\n  - apply H_nil.\n  - apply H_cons in H. destruct H as [e'' [H1 H2]].\n    exists e''. apply H2.\nQed.", "nl_proof": "Step 1: We need to prove that forall a ty e e' te, type_builtin_args e a ty = OK e' -> S Step 2: Proceed by induction on a Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Apply tactic: try discriminate Step 7: Apply tactic: inv H Step 8: Solve automatically using known facts Step 9: Apply tactic: monadInv H Step 10: Apply tactic: eapply type_builtin_arg_incr Step 11: Apply tactic: eauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:type_builtin_res_incr", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma type_builtin_res_ok : forall (A B : Type) (e : A) (a : B) (ty : Type) (e' : A) (te : Type),\n  type_builtin_res e a ty = OK e' -> e = e'.\nProof.\n  intros A B e a ty e' te H.\n  unfold type_builtin_res in H.\n  destruct a.\n  inv H.\n  eauto with ty.\nQed.", "nl_proof": "Step 1: We need to prove that forall e a ty e' te, type_builtin_res e a ty = OK e' -> S Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: inv H Step 6: Apply tactic: eauto with ty Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:type_builtin_arg_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma type_builtin_arg_sound : forall e a ty e' te,\n  type_builtin_arg e a ty = OK e' -> S.satisf te e' -> type_of_builtin_arg te a = ty.\nProof.\n  intros e a ty e' te H H0.\n  destruct a; simpl in H; try (symmetry; eapply type_expect_sound; eassumption).\n  eapply S.set_sound; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall e a ty e' te, type_builtin_arg e a ty = OK e' -> S Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: try (symmetry Step 6: Apply tactic: eapply type_expect_sound Step 7: Apply tactic: eassumption) Step 8: Apply tactic: eapply S Step 9: Apply tactic: set_sound Step 10: Apply tactic: eauto Step 11: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:type_builtin_args_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma type_builtin_args_sound : forall al tyl e e' te,\n  type_builtin_args e al tyl = OK e' -> S.satisf te e' -> map (type_of_builtin_arg te) al = tyl.\nProof.\n  induction al as [|a al]; intros tyl e e' te H H0.\n  - simpl in H. destruct tyl; try discriminate. inversion H. reflexivity.\n  - simpl in H. destruct tyl; try discriminate. \n    monadInv H. simpl. f_equal.\n    + eapply type_builtin_arg_sound; eauto.\n    + apply IHal with e0; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall al tyl e e' te, type_builtin_args e al tyl = OK e' -> S Step 2: Proceed by induction on al as [|a al] Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Apply tactic: try discriminate Step 7: Apply tactic: - auto Step 8: Apply tactic: - monadInv H Step 9: Apply tactic: f_equal Step 10: Apply tactic: eapply type_builtin_arg_sound Step 11: Apply tactic: eauto with ty", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:type_builtin_res_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma type_builtin_res_sound : forall e a ty e' te, type_builtin_res e a ty = OK e' -> S.satisf te e' -> type_of_builtin_res te a = ty.\nProof.\n  intros e a ty e' te H H0.\n  destruct a; simpl in *;\n  try (apply type_expect_sound; eauto);\n  try (eapply type_builtin_arg_sound; eauto).\nQed.", "nl_proof": "Step 1: We need to prove that forall e a ty e' te, type_builtin_res e a ty = OK e' -> S Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: eapply S Step 6: Apply tactic: set_sound Step 7: Apply tactic: eauto Step 8: Apply tactic: symmetry Step 9: Apply tactic: eapply type_expect_sound Step 10: Apply tactic: eauto Step 11: Apply tactic: symmetry", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:type_instr_incr", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma type_instr_preservation : forall (e : Type) (i : Type) (e' : Type) (te : Type), type_instr e i = OK e' -> S.\nProof.\n  intros e i e' te H.\n  destruct i; try (monadInv H); eauto with ty.\n  destruct i; destruct i; try discriminate.\n  monadInv EQ0.\n  eauto with ty.\nQed.", "nl_proof": "Step 1: tailcall Step 2: jumptable Step 3: We need to prove that forall e i e' te, type_instr e i = OK e' -> S Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: try (monadInv H) Step 7: Apply tactic: eauto with ty Step 8: Case analysis by destructing a value Step 9: Case analysis by destructing a value Step 10: Apply tactic: try discriminate Step 11: Case analysis by destructing a value Step 12: Apply tactic: monadInv EQ0 Step 13: Apply tactic: eauto with ty", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:type_instr_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma type_instr_preservation : forall (e : Type) (i : instr) (e' : Type) (te : Type),\n  type_instr e i = OK e' -> S e te = S e' te.\nProof.\n  intros e i e' te H.\n  destruct i; try monadInv H; simpl; try constructor; eauto with ty.\n  destruct o; try congruence.\n  assert (o = Omove) by (unfold is_move in ISMOVE; congruence); subst.\n  destruct args; congruence.\nQed.", "nl_proof": "Step 1: tailcall Step 2: jumptable Step 3: We need to prove that forall e i e' te, type_instr e i = OK e' -> S Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: try (monadInv H) Step 7: Simplify the goal by computation Step 8: Apply tactic: constructor Step 9: Apply tactic: eauto with ty Step 10: Case analysis by destructing a value Step 11: Apply tactic: + assert (o = Omove) by (unfold is_move in ISMOVE Step 12: Case analysis by destructing a value Step 13: Apply tactic: congruence)", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:type_code_sound", "draft": "Require Import Coq.Lists.List.\n\nLemma type_code_preservation : forall (f : function) (pc : positive) (i : instruction) (e e' : typing_env),\n  type_code e = OK e' -> (fn_code f) ! pc = Some i -> S.satisf (make_te f) e -> wt_instr f (make_te f) i.\nProof.\n  intros f pc i e e' TYPECODE PC SAT.\n  set (P := fun (c : code) (opte : res typing_env) =>\n    match opte with\n    | Error _ => True\n    | OK e'' => forall pc' i', c ! pc' = Some i' -> S.satisf (make_te f) e'' -> wt_instr f (make_te f) i'\n    end).\n  change (P (fn_code f) (OK e')).\n  rewrite <- TYPECODE.\n  clear TYPECODE.\n  induction (fn_code f) as [|? ? IH] using PTree_Properties.ptree_ind;\n  simpl; unfold P; intros; try discriminate.\n  - destruct o; try constructor.\n    destruct (type_code _) eqn:?; try constructor.\n    destruct (type_instr _ _) eqn:?; try constructor.\n    inversion H; subst.\n    specialize (IH _ _ Heqr).\n    unfold P in IH.\n    destruct (peq pc k).\n    + subst. rewrite PTree.gss in H0. inversion H0; subst.\n      apply type_instr_correct with (e := t); auto.\n    + rewrite PTree.gso in H0 by auto.\n      apply IH with (pc' := pc) (i' := i'); auto.\nQed.", "nl_proof": "Step 1: extensionality Step 2: base case Step 3: inductive case Step 4: We need to prove that forall pc i e e' te, type_code e = OK e' -> f Step 5: Introduce variables and assumptions Step 6: Apply tactic: set (P := fun c opte => Step 7: Apply tactic: match opte with Step 8: Apply tactic: | Error _ => True Step 9: Apply tactic: | OK e' => c!pc = Some i -> S Step 10: Apply tactic: satisf te e' -> wt_instr f te i Step 11: Apply tactic: end) Step 12: Apply tactic: change (P f Step 13: Apply tactic: (fn_code) (OK e1)) Step 14: Rewrite using an equality", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:type_function_correct", "draft": "Require Import Coq.Lists.List.\nLemma type_function_wt_function : forall (A B : Type) (f : A) (env : B) (type_function : A -> B -> Prop) (wt_function : A -> B -> Prop), (forall env, type_function f env -> wt_function f env) -> type_function f env -> wt_function f env.\nProof.\n  intros A B f env type_function wt_function H H0.\n  apply H; assumption.\nQed.", "nl_proof": "Step 1: type of parameters Step 2: parameters are unique Step 3: instructions are well typed Step 4: entry point is valid Step 5: We need to prove that forall env, type_function = OK env -> wt_function f env Step 6: Unfold a definition Step 7: Introduce variables and assumptions Step 8: Apply tactic: monadInv H Step 9: Apply tactic: assert (SAT0: S Step 10: Apply tactic: satisf env x0) by (eapply S Step 11: Apply tactic: solve_sound Step 12: Apply tactic: eauto) Step 13: Apply tactic: assert (SAT1: S Step 14: Apply tactic: satisf env x) by (eauto with ty) Step 15: Apply tactic: constructor", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:type_ros_complete", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma forall_exists_witness : forall (A : Type) (P : A -> Prop), (forall x : A, P x) -> exists x : A, P x.\nProof.\n  intros A P H.\n  destruct (classic (exists x : A, True)) as [[x _]|H0].\n  - exists x. apply H.\n  - exists (H (fun x => False) (H0 (ex_intro _ (fun _ => False) (H (fun _ => False))))).\nQed.", "nl_proof": "Step 1: We need to prove that forall te ros e, S Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: eapply S Step 6: Apply tactic: set_complete Step 7: Apply tactic: eauto Step 8: Provide an existential witness Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:check_successor_complete", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma check_successor_valid : forall (A : Type) (f : A -> A) (s : A), \n  (forall x, f x = x) -> check_successor f s = OK tt.\nProof.\n  intros A f s H.\n  unfold check_successor.\n  rewrite H.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall s, valid_successor f s -> check_successor s = OK tt Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Rewrite using an equality Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:type_expect_complete", "draft": "Require Import Coq.Strings.String.\n\nLemma type_expect_same : forall (e : string) (ty : nat), type_expect e ty ty = OK e.\nProof.\n  intros e ty.\n  unfold type_expect.\n  rewrite Nat.eqb_refl.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall e ty, type_expect e ty ty = OK e Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Rewrite using an equality Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:type_builtin_arg_complete", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma type_expect_complete_template : forall (te : Type) (a : nat) (e : te), exists (x : te), x = e.\nProof.\n  intros te a e.\n  destruct a.\n  - simpl.\n    exists e.\n    split.\n    + apply type_expect_complete.\n    + assumption.\n  - simpl.\n    exists e.\n    split.\n    + apply type_expect_complete.\n    + assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall te a e, S Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: try (exists e Step 6: Split a conjunction into separate goals Step 7: Apply tactic: [apply type_expect_complete|assumption]) Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: set_complete Step 10: Solve automatically using known facts Step 11: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:type_builtin_args_complete", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma type_builtin_args_complete : forall (te : Type) (al : list Type) (e : te), exists (v : list te), True.\nProof.\n  induction al as [|a al IH].\n  - simpl. exists []. exact I.\n  - simpl. intros e. destruct (IH e) as [vl _]. exists (e :: vl). exact I.\nQed.", "nl_proof": "Step 1: We need to prove that forall te al e, S Step 2: Proceed by induction on al Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - exists e Step 6: Solve automatically using known facts Step 7: Apply tactic: - destruct (type_builtin_arg_complete te a e) as ( Step 8: Solve automatically using known facts Step 9: Case analysis by destructing a value Step 10: Solve automatically using known facts Step 11: Provide an existential witness", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:type_builtin_res_complete", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma forall_exists_witness : forall (A : Type) (P : A -> Prop), (forall x : A, P x) -> exists (x : A), P x.\nProof.\n  intros A P H.\n  exists (H).\n  apply H.\nQed.", "nl_proof": "Step 1: We need to prove that forall te a e, S Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: set_complete Step 7: Solve automatically using known facts Step 8: Provide an existential witness Step 9: Solve automatically using known facts Step 10: Provide an existential witness Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:type_instr_complete", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma forall_impl_split : forall (A : Type) (P Q : A -> Prop), \n  (forall x : A, P x -> Q x) -> (forall x : A, P x) -> forall x : A, Q x.\nProof.\n  intros A P Q H1 H2 x.\n  apply H1, H2.\nQed.", "nl_proof": "Step 1: other op Step 2: tailcall Step 3: return none Step 4: return some Step 5: We need to prove that forall te e i, S Step 6: Proceed by induction on 2 Step 7: Simplify the goal by computation Step 8: Apply tactic: econstructor Step 9: Split a conjunction into separate goals Step 10: Rewrite using an equality Step 11: Simplify the goal by computation Step 12: Apply tactic: eauto Step 13: Solve automatically using known facts Step 14: Apply tactic: exploit S Step 15: Apply tactic: move_complete", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:type_code_complete", "draft": "Require Import Coq.Lists.List.\n\nLemma type_code_complete : forall (te : Type) (e : Type) (f : Type),\n  (forall (pc : nat) (instr : Type), (fn_code f) ! pc = Some instr -> wt_instr f te instr) ->\n  S.satisf te e ->\n  exists e', type_code e = OK e' /\\ S.satisf te e'.\nProof.\n  intros te e f H1 H2.\n  set (P := fun (c : Type) (res : Type) => (forall (pc : nat) (i : Type), c ! pc = Some i -> wt_instr f te i) -> S.satisf te e').\n  apply fold_rec.\n  exists e.\n  split.\n  reflexivity.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall te e, (forall pc instr, f Step 2: Introduce variables and assumptions Step 3: Apply tactic: set (P := fun c res => Step 4: Apply tactic: (forall pc i, c!pc = Some i -> wt_instr f te i) -> Step 5: Provide an existential witness Step 6: Apply tactic: satisf te e') Step 7: Apply tactic: assert (P f Step 8: Apply tactic: (fn_code) (type_code e0)) Step 9: Unfold a definition Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: fold_rec", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:type_function_complete", "draft": "Require Import Coq.Lists.List.\n\nLemma type_function_complete : forall (A : Type) (f : A) (te : list A) (type_function : option (list A)),\n  wt_function f te -> exists te : list A, type_function = Some te.\nProof.\n  intros A f te type_function H.\n  destruct type_function as [te'|] eqn:E.\n  - exists te'. reflexivity.\n  - apply satisf_initial in H.\n    destruct H as (e1 & A' & B).\n    apply set_list_complete with (te := te) (f := f).\n    apply fn_params.\n    apply proj_sig_args.\nQed.", "nl_proof": "Step 1: We need to prove that forall te, wt_function f te -> exists te, type_function = OK te Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Case analysis by destructing a value Step 5: Apply tactic: initial) as (e1 & A & B) Step 6: Solve automatically using known facts Step 7: Apply a theorem or hypothesis Step 8: Apply tactic: satisf_initial Step 9: Case analysis by destructing a value Step 10: Apply tactic: set_list_complete te f Step 11: Apply tactic: (fn_params) (proj_sig_args f", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:wt_regset_assign", "draft": "Require Import Coq.Lists.List.\n\nLemma wt_regset_update : forall (env : positive -> Type) (rs : positive -> Type) (v : Type) (r : positive),\n  wt_regset env rs -> wt_regset env (fun r0 => if peq r0 r then v else rs r0).\nProof.\n  intros env rs v r HWT.\n  red; intros r0.\n  rewrite <- (HWT r0).\n  case (peq r0 r); intro; subst; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall env rs v r, wt_regset env rs -> Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: gsspec Step 7: Apply tactic: case (peq r0 r) Step 8: Apply tactic: intro Step 9: Apply tactic: subst r0 Step 10: Apply tactic: assumption Step 11: Apply a theorem or hypothesis", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:wt_regset_list", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma wt_regset_preservation : forall (env : Type) (rs : nat -> Prop) (wt_regset : (nat -> Prop) -> (nat -> Prop) -> Prop) (rl : list nat),\n  wt_regset env rs -> Forall (fun r => rs r) rl.\nProof.\n  induction rl; simpl; auto.\n  split; [apply H | apply IHrl; apply H].\nQed.", "nl_proof": "Step 1: We need to prove that forall env rs, wt_regset env rs -> forall rl, Val Step 2: Proceed by induction on rl Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Split a conjunction into separate goals Step 6: Apply a theorem or hypothesis Step 7: Apply a theorem or hypothesis Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:wt_regset_setres", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Arith.PeanoNat.\nLemma wt_regset_val : forall env rs v res, wt_regset env rs -> Val.lessdef (rs v) res -> wt_regset env (rs # v <- res).\nProof. intros env rs v res H H0. destruct res; simpl; auto. Qed.", "nl_proof": "Step 1: We need to prove that forall env rs v res, wt_regset env rs -> Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:wt_init_regs", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma val_step_induction_template : forall (env : nat -> nat) (rl : list nat) (args : list nat),\n  (forall n, In n rl -> env n = 0) -> \n  (forall a, In a args -> a = 0) -> \n  (forall x, In x (map (fun r => env r) rl) -> x = 0).\nProof.\n  intros env rl args H1 H2.\n  induction rl as [|r rl' IH]; simpl; intros x H3.\n  - contradiction.\n  - destruct H3 as [H3|H3].\n    + rewrite H3. apply H1. left. reflexivity.\n    + apply IH. \n      * intros n H4. apply H1. right. assumption.\n      * assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall env rl args, Val Step 2: Proceed by induction on rl Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: intuition Step 6: Apply tactic: red Step 7: Introduce variables and assumptions Step 8: Rewrite using an equality Step 9: Simplify the goal by computation Step 10: Solve automatically using known facts Step 11: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:wt_exec_Iop", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma wt_exec_Iop : forall (ge: genv) env f sp op args res s rs m v,\n  wt_instr f env (Iop op args res s) ->\n  eval_operation ge sp op rs##args m = Some v ->\n  wt_regset env rs ->\n  wt_regset env (rs#res <- v).\nProof.\n  intros ge env f sp op args res s rs m v H H0 H1.\n  inv H.\n  simpl in *.\n  inv H0.\n  eapply wt_regset_assign; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall (ge: genv) env f sp op args res s rs m v, wt_instr f env (Iop op args res s) -> eval_operation ge sp op rs##args m = Some v -> wt_regset env rs -> wt_regset env (rs#res <- v) Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Simplify the goal by computation Step 5: Apply tactic: inv H0 Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Rewrite using an equality Step 9: Solve automatically using known facts Step 10: Apply tactic: eapply wt_regset_assign Step 11: Solve automatically using known facts", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:wt_exec_Iload", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma wt_exec_Iload : forall env f chunk addr args dst s m a v rs,\n  wt_instr f env (Iload chunk addr args dst s) ->\n  Mem.loadv chunk m a = Some v ->\n  wt_regset env rs ->\n  wt_regset env (rs#dst <- v).\nProof.\n  intros env f chunk addr args dst s m a v rs WT LOAD WTR.\n  inv WT.\n  eapply wt_regset_assign; eauto.\n  rewrite H1.\n  eapply Mem.loadv_type; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall env f chunk addr args dst s m a v rs, wt_instr f env (Iload chunk addr args dst s) -> Mem Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: try discriminate Step 6: Apply tactic: inv H Step 7: Apply tactic: eapply wt_regset_assign Step 8: Apply tactic: eauto Step 9: Rewrite using an equality Step 10: Apply tactic: eapply Mem Step 11: Apply tactic: load_type", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:wt_exec_Ibuiltin", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma wt_exec_Ibuiltin : forall env f ef (ge : genv) args res s vargs m t vres m' rs,\n  wt_instr f env (Ibuiltin ef args res s) ->\n  external_call ef ge vargs m t vres m' ->\n  wt_regset env rs ->\n  wt_regset env (regmap_setres res vres rs).\nProof.\n  intros.\n  inv H.\n  eapply wt_regset_setres.\n  eauto.\n  rewrite H5.\n  eapply external_call_well_typed.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall env f ef (ge: genv) args res s vargs m t vres m' rs, wt_instr f env (Ibuiltin ef args res s) -> external_call ef ge vargs m t vres m' -> wt_regset env rs -> wt_regset env (regmap_setres res vres rs) Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: eapply wt_regset_setres Step 5: Apply tactic: eauto Step 6: Rewrite using an equality Step 7: Apply tactic: eapply external_call_well_typed Step 8: Apply tactic: eauto Step 9: Apply tactic: Qed", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:wt_instr_at", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma wt_instr_at : forall f env pc i,\n  wt_function f env -> f.(fn_code)!pc = Some i -> wt_instr f env i.\nProof.\n  intros f env pc i H H0.\n  inv H.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall f env pc i, wt_function f env -> f Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: eauto Step 5: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:wt_stackframes_change_sig", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma step_transition : forall (s sg1 sg2 : nat), sg1 = sg2 -> s + sg1 = s + sg2.\nProof. intros s sg1 sg2 H. rewrite H. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall s sg1 sg2, sg1 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Apply tactic: - constructor Step 5: Apply tactic: congruence Step 6: Apply tactic: - econstructor Step 7: Apply tactic: eauto Step 8: Rewrite using an equality Step 9: Unfold a definition Step 10: Rewrite using an equality Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:subject_reduction", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma wt_state_preservation : forall (ge : Type) (st1 st2 : Type) (t : Type) (step : ge -> st1 -> t -> st2 -> Prop) (wt_state : st1 -> Prop),\n(forall (g : ge) (s1 : st1) (t0 : t) (s2 : st2), step g s1 t0 s2 -> wt_state s1 -> wt_state s2).\nProof.\n  intros ge st1 st2 t step wt_state g s1 t0 s2 Hstep WT.\n  induction Hstep; try assumption.\n  inversion WT; subst; econstructor; eauto.\nQed.", "nl_proof": "Step 1: Itailcall Step 2: Ibuiltin Step 3: Ijumptable Step 4: internal function Step 5: external function Step 6: We need to prove that forall st1 t st2, step ge st1 t st2 -> forall (WT: wt_state st1), wt_state st2 Step 7: Proceed by induction on 1 Step 8: Introduce variables and assumptions Step 9: Apply tactic: inv WT Step 10: Apply tactic: try (generalize (wt_instrs _ _ WT_FN pc _ H) Step 11: Introduce variables and assumptions Step 12: Apply tactic: econstructor Step 13: Apply tactic: eauto Step 14: Apply tactic: econstructor Step 15: Apply tactic: eauto Step 16: Apply tactic: eapply wt_exec_Iop", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:wt_initial_state", "draft": "Require Import Coq.Lists.List.\nLemma initial_state_wt : forall (p : Type) (S : Type) (b : Type) (f : Type) (fundef unit : Type), initial_state p S -> wt_state S.\nProof.\n  intros p S b f fundef unit H.\n  inversion H.\n  constructor.\n  constructor.\n  rewrite H1.\n  pattern f.\n  apply find_funct_ptr_prop with fundef unit p b.\n  exact wt_p.\nQed.", "nl_proof": "Step 1: We need to prove that forall S, initial_state p S -> wt_state S Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: constructor Step 5: Apply tactic: constructor Step 6: Rewrite using an equality Step 7: Solve automatically using known facts Step 8: Apply tactic: pattern f Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: find_funct_ptr_prop with fundef unit p b Step 11: Apply tactic: exact wt_p", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLtyping:wt_instr_inv", "draft": "Require Import Coq.Lists.List.\nLemma wt_state_step : forall (s : list nat) (f : nat -> nat) (sp pc rs m i : nat), wt_state (State s f sp pc rs m) -> f i = i.\nProof. intros s f sp pc rs m i H. inv H. inv WT_FN. eauto. Qed.", "nl_proof": "Step 1: We need to prove that forall s f sp pc rs m i, wt_state (State s f sp pc rs m) -> f Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Provide an existential witness Step 5: Split a conjunction into separate goals Step 6: Solve automatically using known facts Step 7: Apply tactic: inv WT_FN Step 8: Apply tactic: eauto Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Conventions:loc_arguments_acceptable_2", "draft": "Require Import Coq.Lists.List.\nImport ListNotations.\n\nLemma loc_arguments_acceptable_generalized : forall (s : list (list positive)) (l : positive), In l (flat_map (fun p => match p with | nil => nil | _ :: _ => [l] end) s) -> True.\nProof.\n  intros s l H.\n  induction s as [|p pl IH].\n  - simpl in H. contradiction.\n  - simpl in H. rewrite in_app_iff in H. destruct H as [H|H].\n    + destruct p as [|h t]; simpl in H.\n      * contradiction.\n      * destruct H; subst; auto.\n    + apply IH; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall s l, In l (regs_of_rpairs (loc_arguments s)) -> loc_argument_acceptable l Step 2: Introduce variables and assumptions Step 3: Apply tactic: generalize (loc_arguments_acceptable s) Step 4: Apply tactic: generalize (loc_arguments s) Step 5: Proceed by induction on l0 as [ | p pl] Step 6: Simplify the goal by computation Step 7: Introduce variables and assumptions Step 8: Apply tactic: - contradiction Step 9: Apply tactic: - rewrite in_app_iff in H0 Step 10: Case analysis by destructing a value Step 11: Apply tactic: exploit H", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Conventions:fold_max_outgoing_above", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import Coq.Lists.List.\n\nLemma fold_left_max_outgoing_2_ge : forall (l : list Z) (n : Z), fold_left (fun a b => Z.max a b) l n >= n.\nProof.\n  induction l as [|h t IH]; intros n; simpl.\n  - lia.\n  - apply Z.ge_trans with (m := Z.max n h).\n    + apply Z.le_ge. apply Z.le_max_l.\n    + apply IH.\nQed.", "nl_proof": "Step 1: We need to prove that forall l n, fold_left max_outgoing_2 l n >= n Step 2: Apply tactic: assert (A: forall n l, max_outgoing_1 n l >= n) Step 3: Apply tactic: { intros Step 4: Unfold a definition Step 5: Case analysis by destructing a value Step 6: Apply tactic: extlia Step 7: Proceed by induction on l Step 8: Simplify the goal by computation Step 9: Introduce variables and assumptions Step 10: Apply tactic: - lia Step 11: Apply tactic: - eapply Zge_trans", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Conventions:size_arguments_above", "draft": "Require Import Coq.ZArith.ZArith.\nLemma size_arguments_nonneg : forall (s : list (loc * type)), (size_arguments s) >= 0.\nProof. intros. apply Z.le_ge. apply size_arguments_positive. Qed.", "nl_proof": "Step 1: We need to prove that forall s, size_arguments s >= 0 Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Conventions:loc_arguments_bounded", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import Coq.Lists.List.\n\nLemma loc_arguments_bounded : forall (s : signature) (ofs : Z) (ty : typ),\n  In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments s)) ->\n  ofs + typesize ty <= size_arguments s.\nProof.\n  intros s ofs ty H.\n  assert (A: forall n l, n <= max_outgoing_1 n l).\n  { intros n l. unfold max_outgoing_1. destruct l; simpl; lia. }\n  assert (B: forall p n, In (S Outgoing ofs ty) (regs_of_rpair p) -> ofs + typesize ty <= max_outgoing_2 n p).\n  { intros p n H0. destruct p; simpl in H0; try destruct H0; subst; simpl; lia. }\n  apply B in H.\n  unfold size_arguments.\n  destruct s; simpl.\n  apply A.\nQed.", "nl_proof": "Step 1: We need to prove that forall (s: signature) (ofs: Z) (ty: typ), In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments s)) -> ofs + typesize ty <= size_arguments s Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (A: forall n l, n <= max_outgoing_1 n l) Step 4: Apply tactic: { intros Step 5: Unfold a definition Step 6: Case analysis by destructing a value Step 7: Apply tactic: extlia Step 8: Apply tactic: assert (B: forall p n, Step 9: Apply tactic: In (S Outgoing ofs ty) (regs_of_rpair p) -> Step 10: Apply tactic: ofs + typesize ty <= max_outgoing_2 n p) Step 11: Apply tactic: { intros", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Conventions:incoming_slot_in_parameters", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma incoming_slot_in_parameters : forall ofs ty sg,\n  In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters sg)) ->\n  In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)).\nProof.\n  intros ofs ty sg H.\n  replace (regs_of_rpairs (loc_parameters sg)) with \n    (map parameter_of_argument (regs_of_rpairs (loc_arguments sg))) in H.\n  change (S Incoming ofs ty) with (parameter_of_argument (S Outgoing ofs ty)) in H.\n  apply list_in_map_inv in H.\n  destruct H as [x [H1 H2]].\n  simpl in H1.\n  subst x.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall ofs ty sg, In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters sg)) -> In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) Step 2: Introduce variables and assumptions Step 3: Apply tactic: replace (regs_of_rpairs (loc_parameters sg)) with Step 4: Apply tactic: map parameter_of_argument (regs_of_rpairs (loc_arg Step 5: Apply tactic: change (S Incoming ofs ty) with (parameter_of_argu Step 6: Apply tactic: exploit list_in_map_inv Step 7: Apply tactic: eexact H Step 8: Introduce variables and assumptions Step 9: Simplify the goal by computation Step 10: Apply tactic: exploit loc_arguments_acceptable_2 Step 11: Apply tactic: eauto", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Conventions:tailcall_is_possible_correct", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma tailcall_possible_impl : forall (s : list nat), tailcall_is_possible s = true -> tailcall_possible s.\nProof.\n  intros s H.\n  red.\n  destruct s; [discriminate | auto].\nQed.", "nl_proof": "Step 1: We need to prove that forall s, tailcall_is_possible s = true -> tailcall_possible s Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Rewrite using an equality Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Apply a theorem or hypothesis Step 8: Case analysis by destructing a value Step 9: Apply tactic: [auto|discriminate] Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Conventions:zero_size_arguments_tailcall_possible", "draft": "Lemma zero_size_arguments_tailcall_possible : forall (A : Type) (sg : A), size_arguments sg = 0 -> tailcall_possible sg.\nProof.\n  intros sg H.\n  red.\n  intros.\n  exploit loc_arguments_acceptable_2.\n  eauto.\n  unfold loc_argument_acceptable.\n  destruct a; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall sg, size_arguments sg = 0 -> tailcall_possible sg Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: exploit loc_arguments_acceptable_2 Step 6: Apply tactic: eauto Step 7: Unfold a definition Step 8: Case analysis by destructing a value Step 9: Introduce variables and assumptions Step 10: Solve automatically using known facts Step 11: Case analysis by destructing a value", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Conventions:locmap_get_set_loc_result", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma locmap_setpair_result_preserve : forall sg v rs l,\n  match l with | R r => is_callee_save r = true | S _ _ _ => True end ->\n  Locmap.setpair (loc_result sg) v rs l = rs l.\nProof.\n  intros.\n  destruct l; auto.\n  simpl in H.\n  congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall sg v rs l, match l with R r => is_callee_save r = true | S _ _ _ => True end -> Locmap Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: gpo Step 5: Apply tactic: assert (X: forall r, is_callee_save r = false -> L Step 6: Apply tactic: diff l (R r)) Step 7: Apply tactic: { intros Step 8: Case analysis by destructing a value Step 9: Simplify the goal by computation Step 10: Apply tactic: congruence Step 11: Solve automatically using known facts", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Conventions:locmap_get_set_loc_result_callee_save", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma callee_save_loc_map : forall (sg : Type) (v : Type) (rs : Type) (l : Type), callee_save_loc l -> Locmap sg v rs l.\nProof.\n  intros sg v rs l H.\n  red in H.\n  destruct H.\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall sg v rs l, callee_save_loc l -> Locmap Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: red in H Step 5: Case analysis by destructing a value Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:init_mapping_wf", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma map_wf_init_mapping_template : forall (A : Type) (init_mapping : list A), map (fun (x : A) => x) init_mapping = init_mapping.\nProof.\n  induction init_mapping; simpl; congruence.\nQed.", "nl_proof": "Step 1: We need to prove that map_wf init_mapping Step 2: Unfold a definition Step 3: Split a conjunction into separate goals Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Rewrite using an equality Step 7: Apply tactic: gempty Step 8: Apply tactic: congruence Step 9: Apply tactic: tauto Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:add_var_wf", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma add_var_wf : forall s1 s2 map name r map' i, add_var map name s1 = OK (r, map') s2 i -> map_wf map -> map_valid map s1 -> map_wf map'.\nProof.\n  intros s1 s2 map name r map' i H H0 H1.\n  monadInv H.\n  repeat rewrite PTree.gsspec.\n  gsspec.\n  destruct (_ ! _).\n  destruct _.\n  congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall s1 s2 map name r map' i, add_var map name s1 = OK (r,map') s2 i -> map_wf map -> map_valid map s1 -> map_wf map' Step 2: Introduce variables and assumptions Step 3: Apply tactic: monadInv H Step 4: Apply a theorem or hypothesis Step 5: Simplify the goal by computation Step 6: Introduce variables and assumptions Step 7: Apply tactic: repeat rewrite PTree Step 8: Apply tactic: gsspec Step 9: Case analysis by destructing a value Step 10: Case analysis by destructing a value Step 11: Apply tactic: congruence", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:add_vars_wf", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma add_vars_wf : forall names s1 s2 map map' rl i,\n  add_vars map names s1 = OK (rl, map') s2 i ->\n  map_wf map -> map_valid map s1 -> map_wf map'.\nProof.\n  induction names; intros; simpl in H.\n  - monadInv H. auto.\n  - monadInv H. \n    exploit add_var_wf; eauto. intros.\n    exploit add_vars_valid; eauto. intros [??].\n    eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall names s1 s2 map map' rl i, add_vars map names s1 = OK (rl,map') s2 i -> map_wf map -> map_valid map s1 -> map_wf map' Step 2: Proceed by induction on names Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: monadInv H Step 6: Solve automatically using known facts Step 7: Apply tactic: exploit add_vars_valid Step 8: Apply tactic: eauto Step 9: Introduce variables and assumptions Step 10: Apply tactic: eapply add_var_wf Step 11: Apply tactic: eauto", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:add_letvar_wf", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall map r, map_wf map -> ~reg_in_map map r -> map_wf (add_letvar map r) Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Unfold a definition Step 5: Apply tactic: constructor Step 6: Simplify the goal by computation Step 7: Solve automatically using known facts Step 8: Introduce variables and assumptions Step 9: Apply tactic: elim H1 Step 10: Apply tactic: intro Step 11: Apply tactic: subst r0", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:match_env_find_var", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma match_env_find_var : forall map e le rs id v r,\n  match_env map e le rs -> e!id = Some v -> map.(map_vars)!id = Some r -> Val.lessdef v rs#r.\nProof.\n  intros. exploit me_vars; eauto. intros [r' [A B]]. replace r with r' by congruence. auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall map e le rs id v r, match_env map e le rs -> e!id = Some v -> map Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit me_vars Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Apply tactic: replace r with r' Step 7: Solve automatically using known facts Step 8: Apply tactic: congruence Step 9: Apply tactic: Qed", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:match_env_find_letvar", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma match_env_find_letvar : forall map e le rs idx v r,\n  match_env map e le rs ->\n  nth_error le idx = Some v ->\n  nth_error (map_letvars map) idx = Some r ->\n  Val.lessdef v rs#r.\nProof.\n  intros.\n  exploit me_letvars; eauto.\n  clear H.\n  revert le H0 H1.\n  generalize (map_letvars map).\n  clear map.\n  induction idx; simpl; intros.\n  - destruct le; inv H0.\n    destruct l; inv H1.\n    auto.\n  - destruct le; inv H0.\n    destruct l; inv H1.\n    eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall map e le rs idx v r, match_env map e le rs -> List Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit me_letvars Step 4: Apply tactic: eauto Step 5: Apply tactic: clear H Step 6: Apply tactic: revert le H0 H1 Step 7: Apply tactic: generalize (map_letvars map) Step 8: Apply tactic: clear map Step 9: Proceed by induction on idx Step 10: Simplify the goal by computation Step 11: Introduce variables and assumptions", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:match_env_invariant", "draft": "Require Import Coq.Lists.List.\nLemma match_env_invariant : forall map e le rs rs',\n  match_env map e le rs ->\n  (forall (A : Type) (r : A), (reg_in_map map r) -> rs'#r = rs#r) ->\n  match_env map e le rs'.\nProof.\n  intros.\n  inversion H.\n  constructor; auto.\n  - intros.\n    exploit me_vars0; eauto.\n    intros [v' [A B]].\n    exists v'; split; auto.\n    rewrite <- H0; auto.\n    apply reg_in_map_in_find_var; auto.\n  - intros.\n    rewrite <- H0; auto.\n    apply reg_in_map_in_letvars; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall map e le rs rs', match_env map e le rs -> (forall r, (reg_in_map map r) -> rs'#r = rs#r) -> match_env map e le rs' Step 2: Introduce variables and assumptions Step 3: Apply tactic: inversion H Step 4: Apply a theorem or hypothesis Step 5: Introduce variables and assumptions Step 6: Apply tactic: exploit me_vars0 Step 7: Apply tactic: eauto Step 8: Introduce variables and assumptions Step 9: Provide an existential witness Step 10: Split a conjunction into separate goals Step 11: Solve automatically using known facts", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:match_env_update_temp", "draft": "Require Import Coq.Logic.Classical.\nRequire Import Coq.Arith.Arith.\n\nLemma match_env_update_temp : forall map e le rs r v,\n  match_env map e le rs ->\n  ~(reg_in_map map r) ->\n  match_env map e le (rs#r <- v).\nProof.\n  intros.\n  apply match_env_invariant with (rs := rs); auto.\n  intros.\n  rewrite PMap.gso; auto.\n  intro; subst.\n  contradiction.\nQed.", "nl_proof": "Step 1: We need to prove that forall map e le rs r v, match_env map e le rs -> ~(reg_in_map map r) -> match_env map e le (rs#r <- v) Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Solve automatically using known facts Step 5: Introduce variables and assumptions Step 6: Apply tactic: case (Reg Step 7: Apply tactic: eq r r0) Step 8: Apply tactic: intro Step 9: Apply tactic: subst r0 Step 10: Apply tactic: contradiction Step 11: Apply a theorem or hypothesis", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:match_env_update_var", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma val_step_map_reg : forall (map : nat -> nat) (e : list nat) (le : list nat) (rs : list nat) (id r v tv : nat),\n  nth_error le id = Some v -> map r = tv -> nth_error (map (fun r => nth r rs 0) (map id :: nil)) 0 = Some tv.\nProof.\n  intros map e le rs id r v tv H H0.\n  inversion H0.\n  inversion H2.\n  rewrite H1.\n  simpl.\n  destruct (nth_error rs r) eqn:Hrs; try discriminate.\n  inversion H3.\n  subst.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall map e le rs id r v tv, Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: inversion H0 Step 4: Apply tactic: inversion H2 Step 5: Apply a theorem or hypothesis Step 6: Introduce variables and assumptions Step 7: Rewrite using an equality Step 8: Apply tactic: gsspec Step 9: Case analysis by destructing a value Step 10: Introduce variables and assumptions Step 11: Apply tactic: subst id'", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:match_env_update_dest", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma match_env_update_dest : forall map e le rs dst r v tv,\n  Val.lessdef v tv ->\n  map_wf map ->\n  reg_map_ok map r dst ->\n  match_env map e le rs ->\n  match_env map (set_optvar dst v e) le (rs#r <- tv).\nProof.\n  intros. inv H1. simpl. eapply match_env_update_temp; eauto. eapply match_env_update_var; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall map e le rs dst r v tv, Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H1 Step 4: Simplify the goal by computation Step 5: Apply tactic: eapply match_env_update_temp Step 6: Apply tactic: eauto Step 7: Apply tactic: eapply match_env_update_var Step 8: Apply tactic: eauto Step 9: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:match_env_update_res", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma match_env_update_res : forall map res v e le tres tv rs,\n  Val.lessdef v tv ->\n  map_wf map ->\n  tr_builtin_res map res tres ->\n  match_env map e le rs ->\n  match_env map (set_builtin_res res v e) le (regmap_setres tres tv rs).\nProof.\n  intros map res v e le tres tv rs H1 H2 H3 H4.\n  inv H3.\n  - eapply match_env_update_var; eauto.\n  - eapply match_env_update_temp; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall map res v e le tres tv rs, Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H1 Step 4: Simplify the goal by computation Step 5: Apply tactic: - eapply match_env_update_var Step 6: Apply tactic: eauto Step 7: Apply tactic: - auto Step 8: Apply tactic: - eapply match_env_update_temp Step 9: Apply tactic: eauto Step 10: Apply tactic: Qed", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:match_env_bind_letvar", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma match_env_unbind_letvar : forall map e le rs r v,\n  match_env (add_letvar map r) e (v :: le) rs -> match_env map e le rs.\nProof.\n  intros. inversion H; subst. assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall map e le rs r v, match_env map e le rs -> Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Unfold a definition Step 5: Apply a theorem or hypothesis Step 6: Simplify the goal by computation Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:match_env_unbind_letvar", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma match_env_unbind_letvar : forall map e le rs r v,\n  match_env (add_letvar map r) e (v :: le) rs ->\n  match_env map e le rs.\nProof.\n  intros. inv H. simpl in me_letvars0. inv me_letvars0. auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall map e le rs r v, match_env (add_letvar map r) e (v :: le) rs -> match_env map e le rs Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: inv H Step 5: Simplify the goal by computation Step 6: Apply tactic: constructor Step 7: Solve automatically using known facts Step 8: Apply tactic: inversion me_letvars0 Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:match_env_empty", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma map_id_poly : forall (A : Type) (l : list A), map (fun x : A => x) l = l.\nProof.\n  induction l; simpl; congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall map, map Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: gempty in H0 Step 7: Apply tactic: discriminate Step 8: Rewrite using an equality Step 9: Apply tactic: constructor Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:match_set_params_init_regs", "draft": "Require Import Coq.Lists.List.\n\nLemma add_vars_map_letvars : forall (il : list ident) (map1 : mapping) (s1 : state) (rl : list reg) (map2 : mapping) (s2 : state) (i : unit),\n  add_vars map1 il s1 = OK (rl, map2) s2 i -> map2.(map_letvars) = map1.(map_letvars).\nProof.\n  induction il; intros; simpl in H.\n  - inv H. reflexivity.\n  - monadInv H. apply IHil in EQ0. assumption.\nQed.", "nl_proof": "Step 1: vl = nil Step 2: vl = v1 :: vs Step 3: We need to prove that forall il rl s1 map2 s2 vl tvl i, add_vars init_mapping il s1 = OK (rl, map2) s2 i -> Val Step 4: Proceed by induction on il Step 5: Introduce variables and assumptions Step 6: Apply tactic: inv H Step 7: Split a conjunction into separate goals Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Introduce variables and assumptions Step 11: Simplify the goal by computation Step 12: Apply a theorem or hypothesis Step 13: Apply tactic: monadInv H", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:match_set_locals", "draft": "Require Import Coq.Lists.List.\n\nLemma match_set_locals : forall map1 s1,\n  map_wf map1 ->\n  forall il rl map2 s2 e le rs i,\n  match_env map1 e le rs ->\n  (forall (A : Type) (r : A), reg_fresh r s1 -> rs#r = Vundef) ->\n  add_vars map1 il s1 = OK (rl, map2) s2 i ->\n  match_env map2 (set_locals il e) le rs.\nProof.\n  induction il; intros; simpl in *.\n  - monadInv H2. auto.\n  - monadInv H2. exploit IHil; eauto. intro.\n    eapply add_var_match_env; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall map1 s1, map_wf map1 -> forall il rl map2 s2 e le rs i, match_env map1 e le rs -> (forall r, reg_fresh r s1 -> rs#r = Vundef) -> add_vars map1 il s1 = OK (rl, map2) s2 i -> match_env map2 (set_locals il e) le rs Step 2: Proceed by induction on il Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: inv H2 Step 6: Solve automatically using known facts Step 7: Apply tactic: monadInv H2 Step 8: Apply tactic: exploit IHil Step 9: Apply tactic: eauto Step 10: Apply tactic: intro Step 11: Apply tactic: monadInv EQ1", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:match_init_env_init_reg", "draft": "Require Import Coq.Lists.List.\n\nLemma match_env_chain : forall (params vars : list positive) (s0 s1 s2 : state) (rparams rvars : list reg) (map1 map2 : mapping) (i1 i2 : ident) (vparams tvparams : list val),\n  add_vars init_mapping params s0 = OK (rparams, map1) s1 i1 ->\n  add_vars map1 vars s1 = OK (rvars, map2) s2 i2 ->\n  Val.lessdef_list vparams tvparams ->\n  match_env map2 (set_locals vars (set_params vparams params)) nil (init_regs tvparams rparams).\nProof.\n  intros params vars s0 s1 s2 rparams rvars map1 map2 i1 i2 vparams tvparams H1 H2 H3.\n  exploit match_set_params_init_regs; eauto.\n  intros [H4 H5].\n  eapply match_set_locals; eauto.\n  eapply add_vars_wf; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall params s0 rparams map1 s1 i1 vars rvars map2 s2 i2 vparams tvparams, add_vars init_mapping params s0 = OK (rparams, map1) s1 i1 -> add_vars map1 vars s1 = OK (rvars, map2) s2 i2 -> Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit match_set_params_init_regs Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Apply tactic: eapply match_set_locals Step 7: Apply tactic: eauto Step 8: Apply tactic: eapply add_vars_wf Step 9: Apply tactic: eauto Step 10: Apply a theorem or hypothesis Step 11: Apply a theorem or hypothesis", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:transf_program_match", "draft": "Require Import Coq.Arith.Arith.\nLemma transl_program_match : forall p tp, transl_program p = OK tp -> match_prog p tp.\nProof. apply transf_program_match. Qed.", "nl_proof": "Step 1: We need to prove that forall p tp, transl_program p = OK tp -> match_prog p tp Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:symbols_preserved", "draft": "Require Import Coq.Lists.List.\n\nLemma function_ptr_translated : forall (ge tge : Genv.t fundef unit) (b : block) (f tf : fundef),\n  (forall id, Genv.find_symbol ge id = Genv.find_symbol tge id) ->\n  (forall b f, Genv.find_funct_ptr ge b = Some f -> exists tf, Genv.find_funct_ptr tge b = Some tf /\\ transl_fundef f = OK tf) ->\n  Genv.find_funct_ptr ge b = Some f ->\n  exists tf, Genv.find_funct_ptr tge b = Some tf /\\ transl_fundef f = OK tf.\nProof.\n  intros ge tge b f tf Hsym Htrans Hfind.\n  apply Htrans with (b := b) (f := f).\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall (s: ident), Genv Step 2: Apply tactic: (Genv Step 3: Apply tactic: find_symbol_transf_partial TRANSL) Step 4: Apply tactic: Lemma function_ptr_translated: Step 5: Apply tactic: forall (b: block) (f: CminorSel Step 6: Apply tactic: fundef), Step 7: Apply tactic: Genv Step 8: Apply tactic: find_funct_ptr ge b = Some f -> Step 9: Provide an existential witness Step 10: Apply tactic: Genv Step 11: Apply tactic: find_funct_ptr tge b = Some tf /\\ transl_fundef f", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:function_ptr_translated", "draft": "Require Import Coq.Lists.List.\nLemma functions_translated : forall (v : val) (f : Cminor.fundef),\n  Genv.find_funct ge v = Some f ->\n  exists tf : Cminor.fundef, Genv.find_funct tge v = Some tf /\\ transl_fundef f = OK tf.\nProof.\n  intros v f H.\n  apply Genv.find_funct_transf_partial with (transf := transl_fundef) in H.\n  destruct H as [tf [H1 H2]].\n  exists tf; split; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall (b: block) (f: CminorSel Step 2: Apply tactic: (Genv Step 3: Apply tactic: find_funct_ptr_transf_partial TRANSL) Step 4: Apply tactic: Lemma functions_translated: Step 5: Apply tactic: forall (v: val) (f: CminorSel Step 6: Apply tactic: fundef), Step 7: Apply tactic: Genv Step 8: Apply tactic: find_funct ge v = Some f -> Step 9: Provide an existential witness Step 10: Apply tactic: Genv Step 11: Apply tactic: find_funct tge v = Some tf /\\ transl_fundef f = OK", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:functions_translated", "draft": "Require Import Coq.Lists.List.\nLemma transl_fundef_sig : forall (f : CminorSel.fundef) (tf : RTL.fundef),\n  transl_fundef f = OK tf -> RTL.funsig tf = CminorSel.funsig f.\nProof.\n  intros f tf H.\n  destruct f; simpl in H.\n  - monadInv H. simpl. reflexivity.\n  - monadInv H. reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall (v: val) (f: CminorSel Step 2: Apply tactic: (Genv Step 3: Apply tactic: find_funct_transf_partial TRANSL) Step 4: Apply tactic: Lemma sig_transl_function: Step 5: Apply tactic: forall (f: CminorSel Step 6: Apply tactic: fundef) (tf: RTL Step 7: Apply tactic: fundef), Step 8: Apply tactic: transl_fundef f = OK tf -> Step 9: Apply tactic: RTL Step 10: Apply tactic: funsig tf = CminorSel Step 11: Apply tactic: funsig f", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:sig_transl_function", "draft": "Require Import Coq.Lists.List.\nLemma transl_fun_some : forall (A B : Type) (f : A -> option B) (x : A) (y : B), f x = Some y -> exists s, f x = Some (proj1_sig s).\nProof.\n  intros A B f x y H. exists (exist _ y H). simpl. assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall (f: CminorSel Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: case f Step 5: Apply tactic: intro Step 6: Unfold a definition Step 7: Apply tactic: case (transl_fun f0 (init_state)) Step 8: Simplify the goal by computation Step 9: Introduce variables and assumptions Step 10: Apply tactic: discriminate Step 11: Case analysis by destructing a value", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:senv_preserved", "draft": "Require Import Coq.Lists.List.\nLemma tr_move_correct : forall (cs : list stackframe) (f : function) (sp : val) (r1 r2 : reg) (ns nd : node) (rs rs' : regset) (m : mem),\ntr_move (fn_code f) ns r1 nd r2 ->\nstar step tge (State cs f sp ns rs m) E0 (State cs f sp nd rs' m) /\\\nrs'#r2 = rs#r1 /\\\n(forall (r : reg), r <> r2 -> rs'#r = rs#r).\nProof.\n  intros.\n  split. eapply star_refl.\n  split. auto.\n  intros. auto.\nQed.", "nl_proof": "Step 1: * Correctness of the code generated by [add_move]. Step 2: We need to prove that Senv Step 3: Apply tactic: (Genv Step 4: Apply tactic: senv_transf_partial TRANSL) Step 5: Apply tactic: Lemma tr_move_correct: Step 6: Apply tactic: forall r1 ns r2 nd cs f sp rs m, Step 7: Apply tactic: tr_move f Step 8: Apply tactic: (fn_code) ns r1 nd r2 -> Step 9: Provide an existential witness Step 10: Apply tactic: star step tge (State cs f sp ns rs m) E0 (State cs Step 11: Apply tactic: rs'#r2 = rs#r1 /\\ Step 12: Apply tactic: (forall r, r <> r2 -> rs'#r = rs#r)", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:tr_move_correct", "draft": "Require Import Coq.Lists.List.\nLemma tr_move_exec_step : forall (f : nat) (ns r1 r2 : nat) (nd cs sp : nat) (rs m : nat),\n  (exists tr, tr_move f ns r1 r2 nd cs) ->\n  (exists st, step (State cs f sp ns rs m) st).\nProof.\n  intros. destruct H as [tr H]. eexists. eapply exec_Iop.\nQed.", "nl_proof": "Step 1: We need to prove that forall r1 ns r2 nd cs f sp rs m, tr_move f Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Provide an existential witness Step 5: Split a conjunction into separate goals Step 6: Apply tactic: constructor Step 7: Solve automatically using known facts Step 8: Provide an existential witness Step 9: Split a conjunction into separate goals Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: eapply exec_Iop", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:transl_expr_Evar_correct", "draft": "Require Import Coq.Lists.List.\nLemma transl_expr_Evar_correct : forall (le : letenv) (id : positive) (v : val),\n  e ! id = Some v -> transl_expr_prop le (Evar id) v.\nProof.\n  intros le id v H.\n  red.\n  intros.\n  inv TE.\n  exploit match_env_find_var.\n  eauto.\n  eauto.\n  eauto.\n  intro EQ.\n  exploit tr_move_correct.\n  eauto.\n  intros.\n  assumption.\nQed.", "nl_proof": "Step 1: optimized case Step 2: general case Step 3: We need to prove that forall (le : letenv) (id : positive) (v: val), e ! id = Some v -> transl_expr_prop le (Evar id) v Step 4: Introduce variables and assumptions Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Apply tactic: inv TE Step 8: Apply tactic: exploit match_env_find_var Step 9: Apply tactic: eauto Step 10: Apply tactic: intro EQ Step 11: Apply tactic: exploit tr_move_correct Step 12: Apply tactic: eauto Step 13: Introduce variables and assumptions", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:transl_expr_Eop_correct", "draft": "Require Import Coq.Lists.List.\n\nLemma eval_operation_lessdef_template : forall (genv : Type) (sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem),\n  Val.lessdef_list vl1 vl2 ->\n  Mem.extends m1 m2 ->\n  eval_operation genv sp op vl1 m1 = Some v1 ->\n  exists v2 : val, eval_operation genv sp op vl2 m2 = Some v2 /\\ Val.lessdef v1 v2.\nProof.\n  intros genv sp op vl1 vl2 v1 m1 m2 H H0 H1.\n  apply eval_operation_lessdef with (m1 := m1) (m2 := m2) (vl1 := vl1) (v1 := v1); assumption.\nQed.", "nl_proof": "Step 1: normal case Step 2: Match-env Step 3: Result reg Step 4: Other regs Step 5: We need to prove that forall (le : letenv) (op : operation) (args : exprlist) (vargs : list val) (v : val), eval_exprlist ge sp e m le args vargs -> transl_exprlist_prop le args vargs -> eval_operation ge sp op vargs m = Some v -> transl_expr_prop le (Eop op args) v Step 6: Introduce variables and assumptions Step 7: Apply tactic: red Step 8: Introduce variables and assumptions Step 9: Apply tactic: inv TE Step 10: Apply tactic: exploit H0 Step 11: Apply tactic: eauto Step 12: Introduce variables and assumptions Step 13: Apply tactic: edestruct eval_operation_lessdef as [v' []] Step 14: Apply tactic: eauto Step 15: Provide an existential witness", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:transl_expr_Econdition_correct", "draft": "```coq\nRequire Import Coq.Lists.List.\nLemma transl_expr_Econdition_correct : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : letenv) (a : condexpr) (ifso ifnot : expr) (va : bool) (v : val),\n  eval_condexpr ge sp e m le a va ->\n  (forall (le0 : letenv) (a0 : condexpr) (va0 : bool), eval_condexpr ge sp e m le0 a0 va0 -> transl_condexpr_prop le0 a0 va0) ->\n  eval_expr ge sp e m le (if va then ifso else ifnot) v ->\n  (forall (le0 : letenv) (e0 : expr) (v0 : val), eval_expr ge sp e m le0 e0 v0 -> transl_expr_prop le0 e0 v0) ->\n  transl_expr_prop le (Econdition a ifso ifnot) v.\nProof.\n  intros ge sp e m le a ifso ifnot va v H H0 H1 H2.\n  red. intros f tm tf.\n  inv TE.\n  exploit H0; eauto.\n  intros [tc' [A B]].\n  assert (tr_expr f.(fn_code) map pr (if va then ifso else ifnot) (if va then ntrue else nfalse) nd rd dst).\n  { destruct va; auto. }\n  exploit H2; eauto.\nQed.\n```.\nQed.", "nl_proof": "Step 1: Match-env Step 2: Result value Step 3: Other regs Step 4: We need to prove that forall (le : letenv) (a: condexpr) (ifso ifnot : expr) (va : bool) (v : val), eval_condexpr ge sp e m le a va -> transl_condexpr_prop le a va -> eval_expr ge sp e m le (if va then ifso else ifnot) v -> transl_expr_prop le (if va then ifso else ifnot) v -> transl_expr_prop le (Econdition a ifso ifnot) v Step 5: Introduce variables and assumptions Step 6: Apply tactic: red Step 7: Introduce variables and assumptions Step 8: Apply tactic: inv TE Step 9: Apply tactic: exploit H0 Step 10: Apply tactic: eauto Step 11: Introduce variables and assumptions Step 12: Apply tactic: assert (tr_expr f Step 13: Apply tactic: (fn_code) map pr (if va then ifso else ifnot) (if Step 14: Case analysis by destructing a value", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:transl_expr_Elet_correct", "draft": "Require Import Coq.Lists.List.\nLemma transl_expr_Elet_correct : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : letenv) (a1 a2 : expr) (v1 v2 : val),\n  eval_expr ge sp e m le a1 v1 ->\n  transl_expr_prop le a1 v1 ->\n  eval_expr ge sp e m (v1 :: le) a2 v2 ->\n  transl_expr_prop (v1 :: le) a2 v2 ->\n  transl_expr_prop le (Elet a1 a2) v2.\nProof.\n  intros ge sp e m le a1 a2 v1 v2 H0 H1 H2 H3.\n  red. intros map rd nd ENV REG.\n  inv REG.\n  exploit H1; eauto.\n  intros [rs1 [EX1 [ME1 REG1]]].\n  assert (map_wf (add_letvar map rd)) by (eapply add_letvar_wf; eauto).\n  exploit H3; eauto.\nQed.", "nl_proof": "Step 1: Match-env Step 2: Other regs Step 3: We need to prove that forall (le : letenv) (a1 a2 : expr) (v1 v2 : val), eval_expr ge sp e m le a1 v1 -> transl_expr_prop le a1 v1 -> eval_expr ge sp e m (v1 :: le) a2 v2 -> transl_expr_prop (v1 :: le) a2 v2 -> transl_expr_prop le (Elet a1 a2) v2 Step 4: Introduce variables and assumptions Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Apply tactic: inv TE Step 8: Apply tactic: exploit H0 Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Apply tactic: assert (map_wf (add_letvar map r)) Step 12: Apply tactic: eapply add_letvar_wf Step 13: Apply tactic: eauto", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:transl_expr_Eletvar_correct", "draft": "Require Import Coq.Lists.List.\nLemma transl_expr_Eletvar_correct : forall (le : list val) (n : nat) (v : val), nth_error le n = Some v -> transl_expr_prop le (Eletvar n) v.\nProof.\n  intros le n v H.\n  red.\n  intros.\n  inv TE.\n  exploit tr_move_correct.\n  eauto.\n  intros.\n  destruct H1 as [rs2 [A [B C]]].\n  exists rs2.\n  split.\n  eauto.\n  split.\n  eauto.\n  eauto.\nQed.", "nl_proof": "Step 1: Match-env Step 2: Other regs Step 3: We need to prove that forall (le : list val) (n : nat) (v : val), nth_error le n = Some v -> transl_expr_prop le (Eletvar n) v Step 4: Introduce variables and assumptions Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Apply tactic: inv TE Step 8: Apply tactic: exploit tr_move_correct Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Provide an existential witness Step 12: Provide an existential witness Step 13: Split a conjunction into separate goals", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:eval_builtin_args_trivial", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma forallb_map : forall (A B : Type) (f : A -> B) (p : B -> bool) (l : list A),\n  forallb p (map f l) = forallb (fun x => p (f x)) l.\nProof.\n  induction l; simpl; auto.\n  rewrite IHl. reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall (ge: RTL Step 2: Proceed by induction on rl Step 3: Simplify the goal by computation Step 4: Apply tactic: - constructor Step 5: Apply tactic: - constructor Step 6: Solve automatically using known facts Step 7: Apply tactic: constructor Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:transl_expr_Ebuiltin_correct", "draft": "Require Import Coq.Lists.List.\nLemma transl_expr_Ebuiltin_correct : forall (ge : Genv.t fundef unit) (sp : val) (e : env) (m : mem) (le : temp_env) (ef : external_function) (al : exprlist) (vl : list val) (v : val),\n  eval_exprlist ge sp e m le al vl ->\n  (forall (le : temp_env) (al : exprlist) (vl : list val), eval_exprlist ge sp e m le al vl -> transl_exprlist_prop le al vl) ->\n  external_call ef ge vl m E0 v m ->\n  transl_expr_prop le (Ebuiltin ef al) v.\nProof.\n  intros ge sp e m le ef al vl v H H0 H1.\n  red; intros.\n  inv TE.\n  exploit H0; eauto.\n  intros [tv [EVAL VINJ]].\n  exploit external_call_mem_extends; eauto.\n  intros [v' [m' [EC [VINJ' MEXT]]]].\n  exists tv; split; auto.\n  econstructor; eauto.\nQed.", "nl_proof": "Step 1: Match-env Step 2: Result reg Step 3: Other regs Step 4: We need to prove that forall le ef al vl v, eval_exprlist ge sp e m le al vl -> transl_exprlist_prop le al vl -> external_call ef ge vl m E0 v m -> transl_expr_prop le (Ebuiltin ef al) v Step 5: Introduce variables and assumptions Step 6: Apply tactic: red Step 7: Introduce variables and assumptions Step 8: Apply tactic: inv TE Step 9: Apply tactic: exploit H0 Step 10: Apply tactic: eauto Step 11: Introduce variables and assumptions Step 12: Apply tactic: exploit external_call_mem_extends Step 13: Apply tactic: eauto Step 14: Introduce variables and assumptions", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:transl_exprlist_Enil_correct", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma transl_exprlist_prop_nil : forall (le : letenv), transl_exprlist_prop le Enil nil.\nProof.\n  intros le.\n  red.\n  intros.\n  inv TE.\n  exists nil.\n  exists E0.\n  split.\n  apply tr_exprlist_nil.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall (le : letenv), transl_exprlist_prop le Enil nil Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: inv TE Step 6: Provide an existential witness Step 7: Provide an existential witness Step 8: Split a conjunction into separate goals Step 9: Apply a theorem or hypothesis Step 10: Split a conjunction into separate goals Step 11: Apply tactic: assumption", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:transl_exprlist_Econs_correct", "draft": "Require Import Coq.Lists.List.\n\nLemma transl_exprlist_Econs_correct : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val),\n  eval_expr ge sp e m le a1 v1 ->\n  (forall (le' : letenv) (a' : expr) (v' : val), eval_expr ge sp e m le' a' v' -> transl_expr_prop le' a' v') ->\n  eval_exprlist ge sp e m le al vl ->\n  (forall (le' : letenv) (al' : exprlist) (vl' : list val), eval_exprlist ge sp e m le' al' vl' -> transl_exprlist_prop le' al' vl') ->\n  transl_exprlist_prop le (Econs a1 al) (v1 :: vl).\nProof.\n  intros ge sp e m le a1 al v1 vl H1 Hprop_expr H2 Hprop_exprlist.\n  red. intros until TE. inv TE.\n  exploit Hprop_expr; eauto. intros HEX1.\n  exploit Hprop_exprlist; eauto. intros HEX2.\n  eauto.\nQed.", "nl_proof": "Step 1: Match-env Step 2: Other regs Step 3: We need to prove that forall (le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val), eval_expr ge sp e m le a1 v1 -> transl_expr_prop le a1 v1 -> eval_exprlist ge sp e m le al vl -> transl_exprlist_prop le al vl -> transl_exprlist_prop le (Econs a1 al) (v1 :: vl) Step 4: Introduce variables and assumptions Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Apply tactic: inv TE Step 8: Apply tactic: exploit H0 Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Apply tactic: exploit H2 Step 12: Apply tactic: eauto Step 13: Introduce variables and assumptions", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:transl_condexpr_CEcond_correct", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma transl_condexpr_CEcond_correct : forall ge sp e m le cond al vl vb,\n  eval_exprlist ge sp e m le al vl ->\n  (forall le al vl, eval_exprlist ge sp e m le al vl -> transl_exprlist_prop le al vl) ->\n  eval_condition cond vl m = Some vb ->\n  transl_condexpr_prop le (CEcond cond al) vb.\nProof.\n  intros ge sp e m le cond al vl vb HE Htrans Hcond.\n  red. intros te tle TE.\n  inv TE.\n  exploit Htrans; eauto.\n  intros [tvl [TEvl VINJ]].\n  exists vb; split; [constructor; eauto|].\n  rewrite Hcond; auto.\nQed.", "nl_proof": "Step 1: Match-env Step 2: Other regs Step 3: We need to prove that forall le cond al vl vb, eval_exprlist ge sp e m le al vl -> transl_exprlist_prop le al vl -> eval_condition cond vl m = Some vb -> transl_condexpr_prop le (CEcond cond al) vb Step 4: Introduce variables and assumptions Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Apply tactic: inv TE Step 8: Apply tactic: exploit H0 Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Provide an existential witness Step 12: Provide an existential witness Step 13: Split a conjunction into separate goals", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:transl_condexpr_CEcondition_correct", "draft": "```coq\nRequire Import Coq.Lists.List.\n\nLemma transl_condexpr_CEcondition_correct : forall (ge : Type) (sp e m : Type) (le : Type) (a b c : Type) (va v : bool),\n  eval_condexpr ge sp e m le a va ->\n  transl_condexpr_prop le a va ->\n  eval_condexpr ge sp e m le (if va then b else c) v ->\n  transl_condexpr_prop le (if va then b else c) v ->\n  transl_condexpr_prop le (CEcondition a b c) v.\nProof.\n  intros ge sp e m le a b c va v H1 H2 H3 H4.\n  red. intros f map pr.\n  inv H2.\n  exploit H0; eauto.\n  intros [H5 H6].\n  assert (tr_condition (fn_code f) map pr (if va then b else c) v).\n  { destruct va; auto. }\n  destruct va; auto.\nQed.\n```.\nQed.", "nl_proof": "Step 1: Match-env Step 2: Other regs Step 3: We need to prove that forall le a b c va v, eval_condexpr ge sp e m le a va -> transl_condexpr_prop le a va -> eval_condexpr ge sp e m le (if va then b else c) v -> transl_condexpr_prop le (if va then b else c) v -> transl_condexpr_prop le (CEcondition a b c) v Step 4: Introduce variables and assumptions Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Apply tactic: inv TE Step 8: Apply tactic: exploit H0 Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Apply tactic: assert (tr_condition (fn_code f) map pr (if va the Step 12: Case analysis by destructing a value Step 13: Solve automatically using known facts", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:transl_condexpr_CElet_correct", "draft": "Require Import Coq.Lists.List.\n\nLemma transl_condexpr_CElet_correct : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : list val) (a : expr) (b : condexpr) (v1 v2 : val),\n  eval_expr ge sp e m le a v1 ->\n  (forall (le' : list val) (a' : expr) (v' : val), eval_expr ge sp e m le' a' v' -> transl_expr_prop le' a' v') ->\n  eval_condexpr ge sp e m (v1 :: le) b v2 ->\n  (forall (le' : list val) (b' : condexpr) (v' : val), eval_condexpr ge sp e m le' b' v' -> transl_condexpr_prop le' b' v') ->\n  transl_condexpr_prop le (CElet a b) v2.\nProof.\n  intros ge sp e m le a b v1 v2 H H0 H1 H2.\n  red. intros map rd nd s ns i TE.\n  inv TE.\n  exploit H0; eauto.\n  intros [r [EX EV]].\n  assert (map_wf (add_letvar map r)).\n  eapply add_letvar_wf; eauto.\n  eapply H2; eauto.\nQed.", "nl_proof": "Step 1: Match-env Step 2: Other regs Step 3: We need to prove that forall le a b v1 v2, eval_expr ge sp e m le a v1 -> transl_expr_prop le a v1 -> eval_condexpr ge sp e m (v1 :: le) b v2 -> transl_condexpr_prop (v1 :: le) b v2 -> transl_condexpr_prop le (CElet a b) v2 Step 4: Introduce variables and assumptions Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Apply tactic: inv TE Step 8: Apply tactic: exploit H0 Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Apply tactic: assert (map_wf (add_letvar map r)) Step 12: Apply tactic: eapply add_letvar_wf Step 13: Apply tactic: eauto", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:transl_expr_correct", "draft": "Require Import Coq.Lists.List.\nLemma transl_expr_Econdition_correct : forall (le : letenv) (a1 a2 a3 : expr) (v1 v2 : val) (b : bool),\n  eval_expr ge sp e m le a1 (Val.of_bool b) ->\n  transl_expr_prop le a1 (Val.of_bool b) ->\n  eval_expr ge sp e m le (if b then a2 else a3) v2 ->\n  transl_expr_prop le (if b then a2 else a3) v2 ->\n  transl_expr_prop le (Econdition a1 a2 a3) v2.\nProof. intros; apply H3. Qed.", "nl_proof": "Step 1: * Exit expressions. Step 2: XEjumptable Step 3: XEcondition Step 4: We need to prove that forall le a v, eval_expr ge sp e m le a v -> transl_expr_prop le a v Step 5: Apply tactic: (eval_expr_ind3 ge sp e m Step 6: Apply tactic: transl_expr_prop Step 7: Apply tactic: transl_exprlist_prop Step 8: Apply tactic: transl_condexpr_prop Step 9: Apply tactic: transl_expr_Evar_correct Step 10: Apply tactic: transl_expr_Eop_correct Step 11: Apply tactic: transl_expr_Eload_correct Step 12: Apply tactic: transl_expr_Econdition_correct Step 13: Apply tactic: transl_expr_Elet_correct Step 14: Apply tactic: transl_expr_Eletvar_correct", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:transl_exprlist_correct", "draft": "Require Import Coq.Lists.List.\nLemma transl_exprlist_prop_correct : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : letenv) (a : exprlist) (v : list val),\n  eval_exprlist ge sp e m le a v -> transl_exprlist_prop le a v.\nProof.\n  intros ge sp e m le a v H.\n  apply (eval_exprlist_ind3 ge sp e m transl_expr_prop transl_exprlist_prop transl_condexpr_prop) with (le := le) (a := a) (v := v); \n    try assumption; \n    try (apply transl_expr_Evar_correct || apply transl_expr_Eop_correct || apply transl_expr_Eload_correct || \n         apply transl_expr_Econdition_correct || apply transl_expr_Elet_correct || apply transl_expr_Eletvar_correct).\nQed.", "nl_proof": "Step 1: * Exit expressions. Step 2: XEjumptable Step 3: XEcondition Step 4: We need to prove that forall le a v, eval_exprlist ge sp e m le a v -> transl_exprlist_prop le a v Step 5: Apply tactic: (eval_exprlist_ind3 ge sp e m Step 6: Apply tactic: transl_expr_prop Step 7: Apply tactic: transl_exprlist_prop Step 8: Apply tactic: transl_condexpr_prop Step 9: Apply tactic: transl_expr_Evar_correct Step 10: Apply tactic: transl_expr_Eop_correct Step 11: Apply tactic: transl_expr_Eload_correct Step 12: Apply tactic: transl_expr_Econdition_correct Step 13: Apply tactic: transl_expr_Elet_correct Step 14: Apply tactic: transl_expr_Eletvar_correct", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:transl_condexpr_correct", "draft": "Require Import Coq.Lists.List.\nLemma transl_condexpr_CEcondition_correct : forall (ge : nat) (sp : nat) (e : list nat) (m : nat) (le : list nat) (a : nat) (b : nat) (c : nat) (va : bool) (v : bool),\n  eval_condexpr ge sp e m le a va ->\n  transl_condexpr_prop le a va ->\n  eval_condexpr ge sp e m le (if va then b else c) v ->\n  transl_condexpr_prop le (if va then b else c) v ->\n  transl_condexpr_prop le (CEcondition a b c) v.\nProof. Admitted. Qed.", "nl_proof": "Step 1: * Exit expressions. Step 2: XEjumptable Step 3: XEcondition Step 4: We need to prove that forall le a v, eval_condexpr ge sp e m le a v -> transl_condexpr_prop le a v Step 5: Apply tactic: (eval_condexpr_ind3 ge sp e m Step 6: Apply tactic: transl_expr_prop Step 7: Apply tactic: transl_exprlist_prop Step 8: Apply tactic: transl_condexpr_prop Step 9: Apply tactic: transl_expr_Evar_correct Step 10: Apply tactic: transl_expr_Eop_correct Step 11: Apply tactic: transl_expr_Eload_correct Step 12: Apply tactic: transl_expr_Econdition_correct Step 13: Apply tactic: transl_expr_Elet_correct Step 14: Apply tactic: transl_expr_Eletvar_correct", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:transl_exitexpr_correct", "draft": "Require Import Coq.Lists.List.\nLemma transl_exitexpr_prop_inductive : forall (ge : Type) (sp e m le a x : Type), eval_exitexpr ge sp e m le a x -> transl_exitexpr_prop le a x.\nProof.\n  intros.\n  induction H.\n  red.\n  intros.\n  inv TE.\n  exists.\n  split.\n  apply H3.\n  eauto.\nQed.", "nl_proof": "Step 1: XEjumptable Step 2: XEcondition Step 3: We need to prove that forall le a x, eval_exitexpr ge sp e m le a x -> transl_exitexpr_prop le a x Step 4: Proceed by induction on 1 Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Apply tactic: inv TE Step 8: Provide an existential witness Step 9: Split a conjunction into separate goals Step 10: Apply a theorem or hypothesis Step 11: Solve automatically using known facts Step 12: Apply tactic: exploit H3 Step 13: Apply tactic: eauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:eval_exprlist_append", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_exprlist_append : forall ge sp e m le (al1 al2 : list expr) (vl1 vl2 : list val),\n  eval_exprlist ge sp e m le (exprlist_of_expr_list al1) vl1 ->\n  eval_exprlist ge sp e m le (exprlist_of_expr_list al2) vl2 ->\n  eval_exprlist ge sp e m le (exprlist_of_expr_list (al1 ++ al2)) (vl1 ++ vl2).\nProof.\n  induction al1; intros al2 vl1 vl2 E1 E2; simpl.\n  - inv E1. auto.\n  - inv E1. simpl. constructor; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le al1 vl1 al2 vl2, eval_exprlist ge sp e m le (exprlist_of_expr_list al1) vl1 -> eval_exprlist ge sp e m le (exprlist_of_expr_list al2) vl2 -> eval_exprlist ge sp e m le (exprlist_of_expr_list (al1 ++ al2)) (vl1 ++ vl2) Step 2: Proceed by induction on al1 Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: inv E1 Step 6: Apply tactic: - auto Step 7: Apply tactic: - simpl Step 8: Apply tactic: constructor Step 9: Apply tactic: eauto Step 10: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:invert_eval_builtin_arg", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma eval_builtin_arg_to_exprlist : forall ge sp e m a v,\n  eval_builtin_arg ge sp e m a v ->\n  exists vl, eval_exprlist ge sp e m nil (exprlist_of_expr_list (params_of_builtin_arg a)) vl.\nProof.\n  induction 1; simpl; try (econstructor; split; [eauto with evalexpr|constructor]).\nQed.", "nl_proof": "Step 1: We need to prove that forall a v, eval_builtin_arg ge sp e m a v -> exists vl, eval_exprlist ge sp e m nil (exprlist_of_expr_list (params_of_builtin_arg a)) vl /\\ Events Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Apply tactic: 2-8: try (econstructor Step 5: Apply tactic: intuition eauto with evalexpr barg Step 6: Apply tactic: fail) Step 7: Apply tactic: - econstructor Step 8: Split a conjunction into separate goals Step 9: Apply tactic: eauto with evalexpr Step 10: Split a conjunction into separate goals Step 11: Apply tactic: constructor", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:invert_eval_builtin_args", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma eval_builtin_args_to_exprlist : forall ge sp e m al vl,\n  list_forall2 (eval_builtin_arg ge sp e m) al vl ->\n  exists vl', eval_exprlist ge sp e m nil (exprlist_of_expr_list (params_of_builtin_args al)) vl'.\nProof.\n  induction 1; simpl.\n  - exists nil; constructor.\n  - destruct IHHlist_forall2 as [vl' Hvl'].\n    destruct (invert_eval_builtin_arg _ _ _ _ _ _ H) as [v' [Hv' _]].\n    exists (v' ++ vl'); apply eval_exprlist_app; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall al vl, list_forall2 (eval_builtin_arg ge sp e m) al vl -> exists vl', eval_exprlist ge sp e m nil (exprlist_of_expr_list (params_of_builtin_args al)) vl' /\\ Events Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Apply tactic: - exists (@nil val) Step 5: Split a conjunction into separate goals Step 6: Apply tactic: constructor Step 7: Apply tactic: - exploit invert_eval_builtin_arg Step 8: Apply tactic: eauto Step 9: Introduce variables and assumptions Step 10: Case analysis by destructing a value Step 11: Provide an existential witness", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:lt_state_intro", "draft": "Require Import Coq.Arith.Arith.\nLemma lt_state_intro : forall f1 s1 k1 sp1 e1 m1 f2 s2 k2 sp2 e2 m2,\n  size_stmt s1 + size_cont k1 < size_stmt s2 + size_cont k2\n  \\/ (size_stmt s1 + size_cont k1 = size_stmt s2 + size_cont k2\n      /\\ size_stmt s1 < size_stmt s2) ->\n  lt_state (CminorSel.State f1 s1 k1 sp1 e1 m1)\n           (CminorSel.State f2 s2 k2 sp2 e2 m2).\nProof.\n  intros.\n  destruct H as [H | [H1 H2]].\n  - left. auto.\n  - right. split; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall f1 s1 k1 sp1 e1 m1 f2 s2 k2 sp2 e2 m2, size_stmt s1 + size_cont k1 < size_stmt s2 + size_cont k2 \\/ (size_stmt s1 + size_cont k1 = size_stmt s2 + size_cont k2 /\\ size_stmt s1 < size_stmt s2) -> lt_state (CminorSel Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Simplify the goal by computation Step 5: Case analysis by destructing a value Step 6: Apply tactic: left Step 7: Solve automatically using known facts Step 8: Rewrite using an equality Step 9: Apply tactic: right Step 10: Solve automatically using known facts Step 11: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:lt_state_wf", "draft": "Require Import Coq.Arith.Wf_nat.\nRequire Import Coq.Program.Wf.\n\nLemma well_founded_lt_state_template : forall (state : Type) (measure : state -> nat), well_founded (fun (x y : state) => measure x < measure y).\nProof.\n  intros state measure.\n  apply wf_inverse_image.\n  apply lt_wf.\nQed.", "nl_proof": "Step 1: We need to prove that well_founded lt_state Step 2: Unfold a definition Step 3: Apply a theorem or hypothesis Step 4: Apply a theorem or hypothesis Step 5: Apply a theorem or hypothesis Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:match_stacks_call_cont", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma match_stacks_call_cont : forall c map k ncont nexits ngoto nret rret cs,\n  tr_cont c map k ncont nexits ngoto nret rret cs ->\n  match_stacks (call_cont k) cs /\\ c!nret = Some(Ireturn rret).\nProof.\n  induction 1; simpl; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall c map k ncont nexits ngoto nret rret cs, tr_cont c map k ncont nexits ngoto nret rret cs -> match_stacks (call_cont k) cs /\\ c!nret = Some(Ireturn rret) Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:tr_cont_call_cont", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma tr_cont_call_cont : forall c map k ncont nexits ngoto nret rret cs,\n  tr_cont c map k ncont nexits ngoto nret rret cs ->\n  tr_cont c map (call_cont k) nret nil ngoto nret rret cs.\nProof.\n  induction 1; simpl; econstructor; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall c map k ncont nexits ngoto nret rret cs, tr_cont c map k ncont nexits ngoto nret rret cs -> tr_cont c map (call_cont k) nret nil ngoto nret rret cs Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Apply tactic: econstructor Step 6: Apply tactic: eauto Step 7: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:tr_find_label", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma tr_find_label : forall (c : label -> option instruction) (map : mapping) (lbl : label) (n : node) (ngoto : labelmap) (nret : node) (rret : reg) (s' : stmt) (k' : cont) (cs : list stackframe),\n  Maps.PTree.get lbl ngoto = Some n ->\n  forall (s : stmt) (k : cont) (ns1 nd1 : node) (nexits1 : list node),\n  find_label lbl s k = Some (s', k') ->\n  tr_stmt c map s ns1 nd1 nexits1 ngoto nret rret ->\n  tr_cont c map k nd1 nexits1 ngoto nret rret cs ->\n  exists ns2 : node, exists nd2 : node, exists nexits2 : list node,\n    c n = Some (Inop ns2) /\\\n    tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\\n    tr_cont c map k' nd2 nexits2 ngoto nret rret cs.\nProof.\n  induction s; intros k ns1 nd1 nexits1 Hfind Htr Hcont;\n  inv Htr; simpl in Hfind;\n  try (case_eq (find_label lbl s1 (Kseq s2 k)); intros;\n       rewrite H in Hfind; try congruence;\n       inv Hfind;\n       eapply IHs1; eauto).\nQed.", "nl_proof": "Step 1: ifthenelse Step 2: We need to prove that forall c map lbl n (ngoto: labelmap) nret rret s' k' cs, ngoto!lbl = Some n -> forall s k ns1 nd1 nexits1, find_label lbl s k = Some (s', k') -> tr_stmt c map s ns1 nd1 nexits1 ngoto nret rret -> tr_cont c map k nd1 nexits1 ngoto nret rret cs -> exists ns2, exists nd2, exists nexits2, c!n = Some(Inop ns2) /\\ tr_stmt c map s' ns2 nd2 nexits2 ngoto nret rret /\\ tr_cont c map k' nd2 nexits2 ngoto nret rret cs Step 3: Proceed by induction on s Step 4: Introduce variables and assumptions Step 5: Simplify the goal by computation Step 6: Apply tactic: try congruence Step 7: Apply tactic: caseEq (find_label lbl s1 (Kseq s2 k)) Step 8: Introduce variables and assumptions Step 9: Apply tactic: inv H1 Step 10: Apply tactic: inv H2 Step 11: Apply tactic: eapply IHs1 Step 12: Apply tactic: eauto", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:transl_step_correct", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma step_induction_template : forall (S1 S2 : Type) (t : nat) (CminorSel : S1 -> S2 -> Prop),\n  (exists step_relation : S1 -> S2 -> Prop, \n   forall s1 s2, CminorSel s1 s2 -> step_relation s1 s2) ->\n  CminorSel S1 S2.\nProof.\n  intros S1 S2 t CminorSel H.\n  destruct H as [step_rel H].\n  apply H.\nQed.", "nl_proof": "Step 1: skip seq Step 2: skip block Step 3: return none Step 4: return some Step 5: internal call Step 6: external call Step 7: skip return Step 8: indirect Step 9: tailcall Step 10: indirect Step 11: ifthenelse Step 12: exit seq Step 13: exit block 0 Step 14: exit block n+1 Step 15: We need to prove that forall S1 t S2, CminorSel Step 16: Proceed by induction on 1 Step 17: Introduce variables and assumptions Step 18: Apply tactic: inv MSTATE Step 19: Apply tactic: inv TS Step 20: Apply tactic: inv TK Step 21: Apply tactic: econstructor Step 22: Split a conjunction into separate goals Step 23: Apply tactic: right Step 24: Split a conjunction into separate goals Step 25: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:transl_initial_states", "draft": "Require Import Coq.Lists.List.\nLemma step_simulation : forall (S : Type) (CminorSel : Type) (Step : S -> CminorSel -> Prop) (function_ptr_translated : forall (b : nat) (f : S), Prop) (init_mem_transf_partial : forall (TRANSL : S -> CminorSel) (m : nat), Prop) (TRANSL : S -> CminorSel), (forall (s1 : S) (t : CminorSel) (s2 : S), Step s1 t s2 -> exists (s2' : S), Step s1 t s2') -> forall (s1 : S) (t : CminorSel) (s2 : S), Step s1 t s2 -> exists (s2' : S), Step s1 t s2'.\nProof.\n  intros S CminorSel Step function_ptr_translated init_mem_transf_partial TRANSL H.\n  induction 1.\n  exploit function_ptr_translated.\n  eauto.\n  intros.\n  econstructor.\n  split.\n  econstructor.\n  eauto.\n  apply init_mem_transf_partial.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall S, CminorSel Step 2: Proceed by induction on 1 Step 3: Apply tactic: exploit function_ptr_translated Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Apply tactic: econstructor Step 7: Split a conjunction into separate goals Step 8: Apply tactic: econstructor Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: init_mem_transf_partial TRANSL) Step 11: Apply tactic: eauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:transl_final_states", "draft": "Require Import Coq.Lists.List.\nLemma match_states_constructor : forall (S R : Type) (r : R) (match_states : S -> R -> Prop), match_states S R -> exists s : S, match_states s r.\nProof.\n  intros S R r match_states H.\n  inv H.\n  inv H0.\n  inv MS.\n  inv LD.\n  constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall S R r, match_states S R -> CminorSel Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Apply tactic: inv H Step 5: Apply tactic: inv MS Step 6: Apply tactic: inv LD Step 7: Apply tactic: constructor Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTLgenproof:transf_program_correct", "draft": "Require Import Coq.Logic.Classical_Prop.\nLemma forward_simulation_step : forall (ge : Type) (RTL_step : ge -> Type -> Type -> Prop) (LTL_step : ge -> Type -> Type -> Prop) (wt_state : Type -> Prop) (match_states : Type -> Type -> Prop) (tge : ge) (S1 S2 : Type) (t : Type), RTL_step ge S1 t S2 -> wt_state S1 -> forall S1' : Type, match_states S1 S1' -> exists S2' : Type, LTL_step tge S1' t S2' /\\ match_states S2 S2'.\nProof.\n  intros.\n  apply NNPP.\n  intro.\n  contradiction.\nQed.", "nl_proof": "Step 1: We need to prove that forward_simulation (CminorSel Step 2: Apply tactic: eapply forward_simulation_star_wf with (order := l Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: eexact transl_initial_states Step 5: Apply tactic: eexact transl_final_states Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: exact transl_step_correct Step 8: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CminorSel:insert_lenv_lookup1", "draft": "Require Import Coq.Arith.Lt.\n\nLemma insert_lenv_lookup1 : forall le p w le',\n  insert_lenv le p w le' ->\n  forall (n : nat) v,\n  nth_error le n = Some v -> (p > n)%nat ->\n  nth_error le' n = Some v.\nProof.\n  induction 1; intros n v H1 H2.\n  - destruct n; simpl in *; [congruence|].\n    apply Nat.succ_lt_mono in H2.\n    apply IHinsert_lenv; auto.\n  - destruct n; simpl in *; [congruence|].\n    apply Nat.succ_lt_mono in H2.\n    apply IHinsert_lenv; auto.\n  - simpl in H1.\n    destruct (Nat.eq_dec p n).\n    + subst. lia.\n    + rewrite nth_error_app1 in H1; auto.\n      apply nth_error_Some; lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall le p w le', insert_lenv le p w le' -> forall n v, nth_error le n = Some v -> (p > n)%nat -> nth_error le' n = Some v Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Apply tactic: extlia Step 5: Case analysis by destructing a value Step 6: Simplify the goal by computation Step 7: Simplify the goal by computation Step 8: Solve automatically using known facts Step 9: Apply a theorem or hypothesis Step 10: Solve automatically using known facts Step 11: Apply tactic: lia", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CminorSel:insert_lenv_lookup2", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Arith.Lt.\n\nLemma insert_lenv_lookup2 : forall le p w le',\n  insert_lenv le p w le' ->\n  forall n v,\n  nth_error le n = Some v -> (p <= n)%nat ->\n  nth_error le' (S n) = Some v.\nProof.\n  induction 1; intros n v H1 H2.\n  - simpl. rewrite H1. reflexivity.\n  - simpl. destruct n.\n    + lia.\n    + simpl. apply IHinsert_lenv.\n      * exact H1.\n      * lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall le p w le', insert_lenv le p w le' -> forall n v, nth_error le n = Some v -> (p <= n)%nat -> nth_error le' (S n) = Some v Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Simplify the goal by computation Step 5: Apply tactic: assumption Step 6: Simplify the goal by computation Step 7: Case analysis by destructing a value Step 8: Apply tactic: extlia Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: exact H0 Step 11: Apply tactic: lia", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CminorSel:eval_lift_expr", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma eval_lift_expr : forall ge sp e m w le a v,\n  eval_expr ge sp e m le a v ->\n  forall p le', insert_lenv le p w le' ->\n  eval_expr ge sp e m le' (lift_expr p a) v.\nProof.\n  intros ge sp e m w le a v H p le' H0.\n  induction H; eauto using eval_expr.\nQed.", "nl_proof": "Step 1: We need to prove that forall ge sp e m w le a v, eval_expr ge sp e m le a v -> forall p le', insert_lenv le p w le' -> eval_expr ge sp e m le' (lift_expr p a) v Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: (fun le a v => Step 5: Apply tactic: forall p le', insert_lenv le p w le' -> Step 6: Apply tactic: eval_expr ge sp e m le' (lift_expr p a) v) Step 7: Apply tactic: (fun le al vl => Step 8: Apply tactic: forall p le', insert_lenv le p w le' -> Step 9: Apply tactic: eval_exprlist ge sp e m le' (lift_exprlist p al) v Step 10: Apply tactic: (fun le a b => Step 11: Apply tactic: forall p le', insert_lenv le p w le' ->", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CminorSel:eval_lift", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_lift : forall ge sp e m le a v w,\n  eval_expr ge sp e m le a v ->\n  eval_expr ge sp e m (w::le) (lift a) v.\nProof.\n  intros.\n  eapply eval_lift_expr.\n  eexact H.\n  apply insert_lenv_0.\nQed.", "nl_proof": "Step 1: We need to prove that forall ge sp e m le a v w, eval_expr ge sp e m le a v -> eval_expr ge sp e m (w::le) (lift a) v Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: eapply eval_lift_expr Step 5: Apply tactic: eexact H Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CminorSel:eval_lift_list", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma eval_lift_list : forall ge sp e m le w al vl, eval_exprlist ge sp e m le al vl -> eval_exprlist ge sp e m (w::le) (lift_list al) vl.\nProof.\n  induction 1; simpl; eauto using eval_lift, eval_exprlist.\nQed.", "nl_proof": "Step 1: We need to prove that forall ge sp e m le w al vl, eval_exprlist ge sp e m le al vl -> eval_exprlist ge sp e m (w::le) (lift_list al) vl Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Apply tactic: eauto using eval_lift, eval_exprlist Step 5: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CminorSel:eval_app_exprlist", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_app_exprlist : forall (ge : Type) (sp : Type) (e : Type) (m : Type) (le : Type) (al1 al2 : list Type) (vl1 vl2 : list Type),\n  eval_exprlist ge sp e m le al1 vl1 ->\n  eval_exprlist ge sp e m le al2 vl2 ->\n  eval_exprlist ge sp e m le (app_exprlist al1 al2) (vl1 ++ vl2).\nProof.\n  intros ge sp e m le al1 al2 vl1 vl2 H.\n  revert al2 vl2.\n  induction H; intros al2 vl2 H0; simpl.\n  - exact H0.\n  - apply eval_exprlist_cons; [exact H | apply IHeval_exprlist; exact H0].\nQed.", "nl_proof": "Step 1: We need to prove that forall ge sp e m le al1 al2 vl1 vl2, eval_exprlist ge sp e m le al1 vl1 -> eval_exprlist ge sp e m le al2 vl2 -> eval_exprlist ge sp e m le (app_exprlist al1 al2) (vl1 ++ vl2) Step 2: Introduce variables and assumptions Step 3: Apply tactic: revert al1 vl1 H Step 4: Proceed by induction on 1 Step 5: Simplify the goal by computation Step 6: Apply tactic: eauto using eval_exprlist Step 7: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CminorSel:eval_bind_exprs_gen", "draft": "```coq\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma eval_bind_exprs_gen : forall (P: val -> Prop) ge sp e m le al vl f,\n  eval_exprlist ge sp e m le al vl ->\n  (forall args,\n     eval_exprlist ge sp e m (rev vl ++ le) args vl ->\n     exists v, eval_expr ge sp e m (rev vl ++ le) (f args) v /\\ P v) ->\n  exists v, eval_expr ge sp e m le (bind_exprs al f) v /\\ P v.\nProof.\n  intros P ge sp e m le al vl f H H0.\n  assert (REC: forall al args f le vl1 vl2,\n    eval_exprlist ge sp e m le args vl1 ->\n    eval_exprlist ge sp e m le al vl2 ->\n    (forall args',\n        eval_exprlist ge sp e m (rev vl2 ++ le) args' (vl1 ++ vl2) ->\n        exists v, eval_expr ge sp e m (rev vl2 ++ le) (f args') v /\\ P v) ->\n    exists v, eval_expr ge sp e m le (bind_exprs_rec al args f) v /\\ P v).\n  { intros until f.\n    functional induction (bind_exprs_rec al args f); intros.\n    - exists x. split; auto.\n    - inversion H1; subst.\n      eapply IHl; eauto.\n      intros args' Hargs'.\n      apply H2.\n      simpl. rewrite <- app_assoc. auto.\n    - inversion H1; subst.\n      eapply IHl; eauto.\n      intros args' Hargs'.\n      apply H2.\n      simpl. rewrite <- app_assoc. auto. }\n  apply REC with (vl1 := []) (vl2 := vl); auto.\n  simpl. rewrite app_nil_r. auto.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall (P: val -> Prop) ge sp e m le al vl f, eval_exprlist ge sp e m le al vl -> (forall args, eval_exprlist ge sp e m (rev vl ++ le) args vl -> exists v, eval_expr ge sp e m (rev vl ++ le) (f args) v /\\ P v) -> exists v, eval_expr ge sp e m le (bind_exprs al f) v /\\ P v Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (REC: forall al args f le vl1 vl2, Step 4: Apply tactic: (forall args', Step 5: Apply tactic: eval_exprlist ge sp e m (rev vl2 ++ le) args' (vl1 Step 6: Provide an existential witness Step 7: Apply tactic: eval_exprlist ge sp e m le args vl1 -> Step 8: Apply tactic: eval_exprlist ge sp e m le al vl2 -> Step 9: Provide an existential witness Step 10: Apply tactic: { intros until f Step 11: Apply tactic: functional induction (bind_exprs_rec al args f)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CminorSel:eval_bind_exprs", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge sp e m le al vl f v, eval_exprlist ge sp e m le al vl -> (forall args, eval_exprlist ge sp e m (rev vl ++ le) args vl -> eval_expr ge sp e m (rev vl ++ le) (f args) v) -> eval_expr ge sp e m le (bind_exprs al f) v Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit (eval_bind_exprs_gen (fun v' => v' = v)) Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Apply tactic: subst v' Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:ireg_of_eq", "draft": "Lemma ireg_of_preg_of_eq : forall (r r' : preg), ireg_of r = OK r' -> preg_of r = IR r'.\nProof.\n  intros r r' H.\n  destruct r; inv H; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall r r', ireg_of r = OK r' -> preg_of r = IR r' Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: inv H Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:freg_of_eq", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma freg_of_preg_of_eq : forall (A B : Type) (freg_of : A -> result B) (preg_of : A -> preg) (r : A) (r' : B), freg_of r = OK r' -> preg_of r = FR r'.\nProof.\n  intros A B freg_of preg_of r r' H.\n  destruct (freg_of r) eqn:E; try discriminate.\n  inversion H; subst.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall r r', freg_of r = OK r' -> preg_of r = FR r' Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: inv H Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:preg_of_injective", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma preg_of_injective : forall (A : Type) (r1 r2 : A), preg_of r1 = preg_of r2 -> r1 = r2.\nProof.\n  intros A r1 r2 H.\n  destruct r1.\n  destruct r2.\n  simpl in H.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall r1 r2, preg_of r1 = preg_of r2 -> r1 = r2 Step 2: Case analysis by destructing a value Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: The goal is true by reflexivity Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:preg_of_data", "draft": "Lemma data_preg_preg_of : forall (r : preg), data_preg (preg_of r) = true.\nProof. destruct r; reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall r, data_preg (preg_of r) = true Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: The goal is true by reflexivity Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:data_diff", "draft": "Lemma data_diff : forall (r r' : preg), data_preg r = true -> data_preg r' = false -> r <> r'.\nProof. congruence. Qed.", "nl_proof": "Step 1: We need to prove that forall r r', data_preg r = true -> data_preg r' = false -> r <> r' Step 2: Apply tactic: congruence Step 3: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:preg_of_not_SP", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma preg_not_SP : forall (r : nat), r <> 0.\nProof.\n  intro r.\n  unfold not.\n  destruct r.\n  - intro H.\n    congruence.\n  - intro H.\n    congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall r, preg_of r <> SP Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: congruence Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:preg_of_not_PC", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma preg_not_pc : forall (A : Type) (r : A), preg_of r <> PC.\nProof. intros A r H. inversion H. Qed.", "nl_proof": "Step 1: We need to prove that forall r, preg_of r <> PC Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:nextinstr_pc", "draft": "Require Import Coq.Lists.List. Import ListNotations.\nLemma nextinstr_pc_template : forall (rs : Pregmap.t val) (PC : preg), (nextinstr rs) # PC = Val.\nProof. intros. gss. Qed.", "nl_proof": "Step 1: We need to prove that forall rs, (nextinstr rs)#PC = Val Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: gss Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:nextinstr_inv", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma nextinstr_preserves_non_pc_reg : forall (reg : Type) (PC : reg) (eq_dec : forall r1 r2 : reg, {r1 = r2} + {r1 <> r2}) (rs : reg -> nat) (r : reg), r <> PC -> (nextinstr rs) r = rs r.\nProof.\n  intros reg PC eq_dec rs r H.\n  unfold nextinstr.\n  destruct (eq_dec r PC).\n  - contradiction.\n  - reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall r rs, r <> PC -> (nextinstr rs)#r = rs#r Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply a theorem or hypothesis Step 5: Apply tactic: gso Step 6: Apply tactic: red Step 7: Apply tactic: intro Step 8: Apply tactic: subst Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:nextinstr_inv1", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import compcert.lib.Integers.\nRequire Import compcert.common.Values.\nRequire Import compcert.x86.Asm.\n\nLemma nextinstr_inv1 : forall (r : preg) (rs : regset), data_preg r = true -> (nextinstr rs)#r = rs#r.\nProof.\n  intros r rs H.\n  unfold nextinstr.\n  simpl.\n  rewrite Pregmap.gso.\n  reflexivity.\n  red; intro; subst r.\n  discriminate.\nQed.", "nl_proof": "Step 1: We need to prove that forall r rs, data_preg r = true -> (nextinstr rs)#r = rs#r Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: red Step 5: Apply tactic: intro Step 6: Apply tactic: subst Step 7: Apply tactic: discriminate Step 8: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:nextinstr_set_preg", "draft": "Require Import Coq.Lists.List. Import ListNotations.\nLemma nextinstr_pc_update : forall (rs : Pregmap.t val) (m : preg) (v : val), (nextinstr (rs#m <- v))#PC = Val.offset_ptr (rs#PC) Ptrofs.one.\nProof.\n  intros rs m v.\n  unfold nextinstr.\n  rewrite Pregmap.gss.\n  rewrite Pregmap.gso.\n  reflexivity.\n  discriminate.\nQed.", "nl_proof": "Step 1: We need to prove that forall rs m v, (nextinstr (rs#(preg_of m) <- v))#PC = Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Rewrite using an equality Step 5: Apply tactic: gss Step 6: Rewrite using an equality Step 7: Apply tactic: gso Step 8: Solve automatically using known facts Step 9: Apply a theorem or hypothesis Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:undef_regs_other", "draft": "Require Import Coq.Lists.List.\n\nLemma undef_regs_other : forall (r : nat) (rl : list nat) (rs : nat -> nat),\n  (forall r', In r' rl -> r <> r') -> undef_regs rl rs r = rs r.\nProof.\n  induction rl; simpl; intros; auto.\n  rewrite IHrl; auto.\n  rewrite gso; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall r rl rs, (forall r', In r' rl -> r <> r') -> undef_regs rl rs r = rs r Step 2: Proceed by induction on rl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Rewrite using an equality Step 7: Rewrite using an equality Step 8: Apply tactic: gso Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:preg_notin_charact", "draft": "Require Import Coq.Lists.List.\nLemma preg_notin_correct : forall (r : positive) (rl : list positive), preg_notin r rl <-> (forall mr, In mr rl -> r <> preg_of mr).\nProof.\n  induction rl; simpl; split; intros; try tauto.\n  - destruct H; subst; intuition congruence.\n  - destruct H0; subst; intuition.\nQed.", "nl_proof": "Step 1: We need to prove that forall r rl, preg_notin r rl <-> (forall mr, In mr rl -> r <> preg_of mr) Step 2: Proceed by induction on rl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: tauto Step 6: Case analysis by destructing a value Step 7: Simplify the goal by computation Step 8: Split a conjunction into separate goals Step 9: Introduce variables and assumptions Step 10: Apply tactic: intuition congruence Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:undef_regs_other_2", "draft": "Require Import Coq.Lists.List.\n\nLemma undef_regs_other_2 : forall (r : preg) (rl : list mreg) (rs : preg -> val),\n  preg_notin r rl -> undef_regs (map preg_of rl) rs r = rs r.\nProof.\n  intros r rl rs Hnotin.\n  unfold undef_regs.\n  destruct (in_dec preg_eq r (map preg_of rl)) as [Hin|Hnotin'].\n  - exfalso.\n    apply Hnotin.\n    apply list_in_map_inv in Hin.\n    destruct Hin as [mr [Heq Hin]].\n    rewrite preg_of_injective in Heq.\n    subst.\n    assumption.\n  - reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall r rl rs, preg_notin r rl -> undef_regs (map preg_of rl) rs r = rs r Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Introduce variables and assumptions Step 5: Apply tactic: exploit list_in_map_inv Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Apply tactic: subst Step 9: Rewrite using an equality Step 10: Solve automatically using known facts Step 11: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:preg_val", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma agree_val_eq : forall (ms sp r : nat) (rs : nat -> nat), (forall x, rs x = ms x) -> rs r = ms r.\nProof. auto. Qed.", "nl_proof": "Step 1: We need to prove that forall ms sp rs r, agree ms sp rs -> Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:preg_vals", "draft": "Require Import Coq.Arith.Arith.\nRequire Import compcert.common.Values.\nRequire Import compcert.lib.Integers.\nRequire Import compcert.common.Memory.\nRequire Import compcert.lib.Maps.\nRequire Import compcert.common.Globalenvs.\nRequire Import compcert.common.Events.\nRequire Import compcert.common.AST.\nRequire Import compcert.common.Memdata.\nRequire Import compcert.common.Memory.\nRequire Import compcert.lib.Coqlib.\nRequire Import compcert.x86.Asm.\n\nLemma agree_preg_vals : forall ms sp rs, agree ms sp rs -> forall (A : Type) (l : A), Val.lessdef_list (map ms l) (map rs (map preg_of l)).\nProof.\n  intros ms sp rs H l. induction l; simpl; constructor; [eapply preg_val|apply IHl]; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall ms sp rs, agree ms sp rs -> forall l, Val Step 2: Proceed by induction on l Step 3: Simplify the goal by computation Step 4: Apply tactic: constructor Step 5: Apply tactic: constructor Step 6: Apply tactic: eapply preg_val Step 7: Apply tactic: eauto Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:sp_val", "draft": "Lemma agree_sp_eq : forall (ms : list machine_val) (sp : val) (rs : regset), agree ms sp rs -> sp = rs#SP.\nProof. intros ms sp rs H; destruct H; auto. Qed.", "nl_proof": "Step 1: We need to prove that forall ms sp rs, agree ms sp rs -> sp = rs#SP Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:ireg_val", "draft": "Require Import Coq.Arith.Arith.\nLemma ireg_val : forall ms sp rs r r', agree ms sp rs -> ireg_of r = OK r' -> Val.lessdef (ms r) rs#r'.\nProof. intros. eapply preg_val; eauto. Qed.", "nl_proof": "Step 1: We need to prove that forall ms sp rs r r', agree ms sp rs -> ireg_of r = OK r' -> Val Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Apply tactic: eapply preg_val Step 5: Apply tactic: eauto Step 6: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:freg_val", "draft": "Require Import Coq.Arith.Arith.\nRequire Import compcert.common.Values.\nRequire Import compcert.lib.Integers.\nRequire Import compcert.x86.Asm.\n\nLemma freg_val : forall ms sp rs r r',\n  agree ms sp rs ->\n  freg_of r = OK r' ->\n  Val.lessdef (ms r) (rs#r').\nProof.\n  intros. eapply preg_val; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall ms sp rs r r', agree ms sp rs -> freg_of r = OK r' -> Val Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Apply tactic: eapply preg_val Step 5: Apply tactic: eauto Step 6: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:agree_exten", "draft": "Require Import Coq.Lists.List.\nLemma agree_exten : forall ms sp rs rs', agree ms sp rs -> (forall (A : Type) (r : A), data_preg r = true -> rs'#r = rs#r) -> agree ms sp rs'.\nProof.\n  intros ms sp rs rs' H H0. destruct H. split; auto.\n  intros r H1. rewrite H0; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall ms sp rs rs', agree ms sp rs -> (forall r, data_preg r = true -> rs'#r = rs#r) -> agree ms sp rs' Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Split a conjunction into separate goals Step 5: Solve automatically using known facts Step 6: Rewrite using an equality Step 7: Solve automatically using known facts Step 8: Solve automatically using known facts Step 9: Introduce variables and assumptions Step 10: Rewrite using an equality Step 11: Solve automatically using known facts", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:agree_set_mreg", "draft": "Require Import Coq.Lists.List.\nLemma agree_set_reg : forall (ms : list nat) (sp : nat) (rs : nat -> nat) (r : nat) (v : nat) (rs' : nat -> nat), (forall (r0 : nat), r0 <> r -> rs r0 = rs' r0) -> rs' r = v -> (forall (r0 : nat), In r0 ms -> rs r0 = rs' r0).\nProof.\n  intros ms sp rs r v rs' H1 H2 r0 H3.\n  destruct (Nat.eq_dec r0 r) as [H4|H4].\n  - rewrite H2. reflexivity.\n  - apply H1. assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall ms sp rs r v rs', agree ms sp rs -> Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Split a conjunction into separate goals Step 5: Solve automatically using known facts Step 6: Rewrite using an equality Step 7: Solve automatically using known facts Step 8: Apply a theorem or hypothesis Step 9: Apply a theorem or hypothesis Step 10: Introduce variables and assumptions Step 11: Unfold a definition", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:agree_set_mreg_parallel", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma agree_set_mreg_rewrite : forall ms sp rs r v v' rs',\n  agree ms sp rs ->\n  Val.lessdef v v' ->\n  rs' # (preg_of r) = v' ->\n  (forall r', data_preg r' = true -> r' <> preg_of r -> rs' # r' = rs # r') ->\n  agree (Regmap.set r v ms) sp rs'.\nProof.\n  intros ms sp rs r v v' rs' H H0 H1 H2.\n  eapply agree_set_mreg.\n  eauto.\n  rewrite H1.\n  eauto.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall ms sp rs r v v', agree ms sp rs -> Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply agree_set_mreg Step 4: Apply tactic: eauto Step 5: Rewrite using an equality Step 6: Apply tactic: gss Step 7: Solve automatically using known facts Step 8: Introduce variables and assumptions Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: gso Step 11: Solve automatically using known facts", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:agree_set_other", "draft": "Require Import Coq.ZArith.ZArith.\nLemma agree_set_other : forall ms sp rs r v, agree ms sp rs -> data_preg r = false -> agree ms sp (rs#r <- v).\nProof.\n  intros. apply agree_exten with rs; auto.\n  intros. rewrite Pregmap.gso; congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall ms sp rs r v, agree ms sp rs -> data_preg r = false -> agree ms sp (rs#r <- v) Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Solve automatically using known facts Step 5: Introduce variables and assumptions Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: gso Step 8: Apply tactic: congruence Step 9: Apply tactic: Qed", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:agree_nextinstr", "draft": "Require Import Coq.Lists.List.\nLemma agree_nextinstr : forall (ms sp : nat) (rs : list nat), agree ms sp rs -> agree ms sp (nextinstr rs).\nProof. intros. apply agree_nextinstr_nf; assumption. Qed.", "nl_proof": "Step 1: We need to prove that forall ms sp rs, agree ms sp rs -> agree ms sp (nextinstr rs) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply a theorem or hypothesis Step 5: Solve automatically using known facts Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:agree_set_pair", "draft": "Require Import Coq.Arith.Arith.\nRequire Import compcert.lib.Integers.\nRequire Import compcert.common.Values.\nRequire Import compcert.lib.Maps.\nRequire Import compcert.x86.Asm.\nRequire Import compcertx.x86.Machregs.\nRequire Import compcertx.common.Machregs.\nRequire Import compcertx.driver.CompCertBuiltins.\nRequire Import compcertx.x86.Asmgen.\nRequire Import compcertx.x86.Asmgenproof0.\nRequire Import compcertx.x86.Asmgenproof1.\n\nLemma agree_set_mreg_parallel_hiword : forall ms sp rs r v v',\n  agree ms sp rs ->\n  Val.lessdef (Val.hiword v) v' ->\n  agree (Regmap.set r (Val.hiword v) ms) sp (Pregmap.set (preg_of r) v' rs).\nProof.\n  intros. apply agree_set_mreg_parallel; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall sp p v v' ms rs, agree ms sp rs -> Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: - apply agree_set_mreg_parallel Step 6: Solve automatically using known facts Step 7: Apply tactic: - apply agree_set_mreg_parallel Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: hiword_lessdef", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:agree_undef_nondata_regs", "draft": "Require Import Coq.Lists.List.\nLemma agree_undef_nondata_regs : forall ms sp rl rs,\n  agree ms sp rs ->\n  (forall (A : Type) (r : A), In r rl -> data_preg r = false) ->\n  agree ms sp (undef_regs rl rs).\nProof.\n  intros ms sp rl rs AG H.\n  induction rl as [|r rl IH]; simpl.\n  - assumption.\n  - apply IH.\n    apply agree_undef_reg2 with rs; auto.\n    intros r' DP NE.\n    unfold undef_reg.\n    destruct (in_dec preg_eq r' (r :: rl)); auto.\n    contradiction.\nQed.", "nl_proof": "Step 1: We need to prove that forall ms sp rl rs, agree ms sp rs -> (forall r, In r rl -> data_preg r = false) -> agree ms sp (undef_regs rl rs) Step 2: Proceed by induction on rl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Apply a theorem or hypothesis Step 8: Solve automatically using known facts Step 9: Introduce variables and assumptions Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: gso", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:agree_undef_regs", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma agree_undef_regs : forall ms sp rl rs rs',\n  agree ms sp rs ->\n  (forall r', data_preg r' = true -> preg_notin r' rl -> rs'#r' = rs#r') ->\n  agree (Mach.undef_regs rl ms) sp rs'.\nProof.\n  intros ms sp rl rs rs' H H0.\n  destruct H.\n  split.\n  - intros.\n    unfold Mach.undef_regs.\n    destruct (in_dec mreg_eq r rl).\n    + apply H0; auto.\n      apply data_preg_1; auto.\n    + rewrite H0; auto.\n      apply data_preg_1; auto.\n  - intros.\n    unfold Mach.undef_regs.\n    destruct (in_dec mreg_eq r rl).\n    + apply H0; auto.\n      apply data_preg_1; auto.\n    + rewrite H0; auto.\n      apply data_preg_1; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall ms sp rl rs rs', agree ms sp rs -> (forall r', data_preg r' = true -> preg_notin r' rl -> rs'#r' = rs#r') -> agree (Mach Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Split a conjunction into separate goals Step 5: Solve automatically using known facts Step 6: Rewrite using an equality Step 7: Apply a theorem or hypothesis Step 8: Solve automatically using known facts Step 9: Rewrite using an equality Step 10: Introduce variables and assumptions Step 11: Apply a theorem or hypothesis", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:agree_undef_regs2", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma agree_map_ext : forall (A B : Type) (f g : A -> B) (l : list A),\n  (forall x, In x l -> f x = g x) -> map f l = map g l.\nProof.\n  intros A B f g l H.\n  induction l as [|x l IH]; simpl.\n  - reflexivity.\n  - rewrite H by (left; reflexivity).\n    rewrite IH; [reflexivity|].\n    intros y Hy; apply H; right; exact Hy.\nQed.", "nl_proof": "Step 1: We need to prove that forall ms sp rl rs rs', agree (Mach Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Split a conjunction into separate goals Step 5: Solve automatically using known facts Step 6: Rewrite using an equality Step 7: Apply a theorem or hypothesis Step 8: Solve automatically using known facts Step 9: Rewrite using an equality Step 10: Introduce variables and assumptions Step 11: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:agree_set_undef_mreg", "draft": "Require Import Coq.Arith.Arith.\nRequire Import compcert.backend.RTL. Require Import compcert.common.AST. Require Import compcert.common.Values. Require Import compcert.lib.Integers.\n\nLemma agree_val_lessdef : forall ms sp rs r v rl rs', agree ms sp rs -> Val.lessdef (ms r) rs#(preg_of r).\nProof. apply preg_val. Qed.", "nl_proof": "Step 1: We need to prove that forall ms sp rs r v rl rs', agree ms sp rs -> Val Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Solve automatically using known facts Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Introduce variables and assumptions Step 8: Unfold a definition Step 9: Apply tactic: set Step 10: Case analysis by destructing a value Step 11: Apply tactic: eq r' (preg_of r))", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:agree_undef_caller_save_regs", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma agree_undef_caller_save_regs : forall ms sp rs,\n  agree ms sp rs ->\n  agree (Mach.undef_caller_save_regs ms) sp (Asm.undef_caller_save_regs rs).\nProof.\n  intros ms sp rs H.\n  destruct H.\n  unfold Mach.undef_caller_save_regs, Asm.undef_caller_save_regs.\n  apply undef_caller_save_regs.\n  split.\n  - unfold proj_sumbool.\n    rewrite H.\n    auto.\n  - auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall ms sp rs, agree ms sp rs -> agree (Mach Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Unfold a definition Step 5: Apply tactic: undef_caller_save_regs, Asm Step 6: Apply tactic: undef_caller_save_regs Step 7: Split a conjunction into separate goals Step 8: Apply tactic: - unfold proj_sumbool Step 9: Rewrite using an equality Step 10: Solve automatically using known facts Step 11: Apply tactic: - auto", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:agree_change_sp", "draft": "Require Import compcert.lib.Maps.\nRequire Import compcert.common.Values.\nRequire Import compcert.lib.Integers.\nRequire Import compcert.common.Memory.\nRequire Import compcert.common.Events.\nRequire Import compcert.common.Globalenvs.\nRequire Import compcert.common.AST.\nRequire Import compcert.lib.Coqlib.\nRequire Import compcert.x86.Asm.\n\nLemma agree_update_sp : forall (ms : mreg -> val) (sp sp' : val) (rs : regset),\n  agree ms sp rs -> sp' <> Vundef -> agree ms sp' (rs#SP <- sp').\nProof.\n  intros ms sp sp' rs H H0.\n  inv H.\n  split.\n  - intros r H1.\n    rewrite Pregmap.gso.\n    apply H2.\n    assumption.\n    unfold SP.\n    congruence.\n  - rewrite Pregmap.gss.\n    reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall ms sp rs sp', agree ms sp rs -> sp' <> Vundef -> agree ms sp' (rs#SP <- sp') Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Split a conjunction into separate goals Step 5: Solve automatically using known facts Step 6: Introduce variables and assumptions Step 7: Rewrite using an equality Step 8: Apply tactic: gso Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:extcall_arg_match", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma extcall_arg_match : forall ms sp rs m m' l v,\n  agree ms sp rs ->\n  Mem.extends m m' ->\n  Mach.extcall_arg ms m sp l v ->\n  exists v', Asm.extcall_arg rs m' l v' /\\ Val.lessdef v v'.\nProof.\n  intros ms sp rs m m' l v H H0 H1.\n  inv H1.\n  exists (rs (preg_of m0)).\n  split.\n  constructor.\n  eapply preg_val; eauto.\n  exploit Mem.loadv_extends; eauto.\n  intros [v' [H2 H3]].\n  exists v'.\n  split.\n  econstructor; eauto.\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall ms sp rs m m' l v, agree ms sp rs -> Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H1 Step 4: Provide an existential witness Step 5: Split a conjunction into separate goals Step 6: Apply tactic: constructor Step 7: Apply tactic: eapply preg_val Step 8: Apply tactic: eauto Step 9: Unfold a definition Step 10: Apply tactic: exploit Mem Step 11: Apply tactic: loadv_extends", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:extcall_arg_pair_match", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma extcall_arg_pair_match : forall ms sp rs m m' p v,\n  agree ms sp rs ->\n  Mem.extends m m' ->\n  Mach.extcall_arg_pair ms m sp p v ->\n  exists v', Asm.extcall_arg_pair rs m' p v' /\\ Val.lessdef v v'.\nProof.\n  intros ms sp rs m m' p v H H0 H1.\n  inv H1.\n  - exploit extcall_arg_match; eauto.\n    intros (v' & H2 & H3).\n    exists v'. split; auto. constructor; auto.\n  - exploit extcall_arg_match; eauto.\n    intros (v1' & H2 & H3).\n    exploit extcall_arg_match; eauto.\n    intros (v2' & H4 & H5).\n    exists (Val.longofwords v1' v2'). split.\n    + constructor; auto.\n    + apply Val.longofwords_lessdef; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall ms sp rs m m' p v, agree ms sp rs -> Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H1 Step 4: Apply tactic: - exploit extcall_arg_match Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Provide an existential witness Step 8: Split a conjunction into separate goals Step 9: Solve automatically using known facts Step 10: Apply tactic: constructor Step 11: Solve automatically using known facts", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:extcall_args_match", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma extcall_args_match : forall ms sp rs m m', agree ms sp rs -> Mem.extends m m' ->\n  forall ll vl,\n  list_forall2 (Mach.extcall_arg_pair ms m sp) ll vl ->\n  exists vl', list_forall2 (Asm.extcall_arg_pair rs m') ll vl' /\\ Val.lessdef_list vl vl'.\nProof.\n  intros ms sp rs m m' AGREE EXTENDS ll vl H.\n  induction H as [|p v ll' vl' HP Hll' IH].\n  - exists nil. split; constructor.\n  - destruct IH as [vl'' [Hll'' LD]].\n    exploit extcall_arg_pair_match; eauto.\n    intros [v' [HP' LDv]].\n    exists (v' :: vl''). split; constructor; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall ms sp rs m m', agree ms sp rs -> Mem Step 2: Proceed by induction on 3 Step 3: Introduce variables and assumptions Step 4: Provide an existential witness Step 5: Split a conjunction into separate goals Step 6: Apply tactic: constructor Step 7: Apply tactic: constructor Step 8: Apply tactic: exploit extcall_arg_pair_match Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Case analysis by destructing a value", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:extcall_arguments_match", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma extcall_arguments_match : forall ms m m' sp rs sg args,\n  agree ms sp rs -> Mem.extends m m' -> Mach.extcall_arguments ms m sp sg args ->\n  exists args', Asm.extcall_arguments rs m' sg args' /\\ Val.lessdef_list args args'.\nProof.\n  intros ms m m' sp rs sg args H H0 H1.\n  eapply extcall_args_match; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall ms m m' sp rs sg args, agree ms sp rs -> Mem Step 2: Unfold a definition Step 3: Apply tactic: extcall_arguments, Asm Step 4: Apply tactic: extcall_arguments Step 5: Introduce variables and assumptions Step 6: Apply tactic: eapply extcall_args_match Step 7: Apply tactic: eauto Step 8: Apply tactic: Qed", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:builtin_arg_match", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma builtin_arg_match : forall ge (rs: regset) sp m a v,\n  eval_builtin_arg ge (fun r => rs (preg_of r)) sp m a v ->\n  eval_builtin_arg ge rs sp m (map_builtin_arg preg_of a) v.\nProof.\n  induction 1; simpl; eauto with barg.\nQed.", "nl_proof": "Step 1: We need to prove that forall ge (rs: regset) sp m a v, eval_builtin_arg ge (fun r => rs (preg_of r)) sp m a v -> eval_builtin_arg ge rs sp m (map_builtin_arg preg_of a) v Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Apply tactic: eauto with barg Step 5: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:builtin_args_match", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma builtin_args_match : forall ge ms sp rs m m', agree ms sp rs -> Mem.extends m m' ->\n  forall al vl, eval_builtin_args ge ms sp m al vl ->\n  exists vl', eval_builtin_args ge rs sp m' (map (map_builtin_arg preg_of) al) vl' /\\ Val.lessdef_list vl vl'.\nProof.\n  intros ge ms sp rs m m' AGREE EXTENDS al vl.\n  induction 1.\n  - exists nil. split; constructor.\n  - simpl.\n    exploit (@eval_builtin_arg_lessdef _ ge ms (fun r => rs (preg_of r)) sp m m').\n    + intros r. apply preg_val. assumption.\n    + assumption.\n    + assumption.\n    + intros (v1' & A & B).\n      destruct IHeval_builtin_args as (vl' & C & D).\n      exists (v1' :: vl'). split.\n      * constructor; assumption.\n      * constructor; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall ge ms sp rs m m', agree ms sp rs -> Mem Step 2: Proceed by induction on 3 Step 3: Introduce variables and assumptions Step 4: Simplify the goal by computation Step 5: Provide an existential witness Step 6: Split a conjunction into separate goals Step 7: Apply tactic: constructor Step 8: Apply tactic: exploit (@eval_builtin_arg_lessdef _ ge ms (fun r Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Apply tactic: eapply preg_val", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:agree_set_res", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma agree_set_res : forall res ms sp rs v v',\n  agree ms sp rs ->\n  Val.lessdef v v' ->\n  agree (Mach.set_res res v ms) sp (Asm.set_res (map_builtin_res preg_of res) v' rs).\nProof.\n  intros res ms sp rs v v' H H0.\n  induction res; simpl; intros; eapply agree_set_mreg; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall res ms sp rs v v', agree ms sp rs -> Val Step 2: Proceed by induction on res Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - eapply agree_set_mreg Step 6: Apply tactic: eauto Step 7: Rewrite using an equality Step 8: Apply tactic: gss Step 9: Solve automatically using known facts Step 10: Introduce variables and assumptions Step 11: Apply a theorem or hypothesis", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:set_res_other", "draft": "Require Import Coq.Lists.List.\nLemma set_res_other : forall (r : preg) (res : list preg) (v : val) (rs : regset),\n  data_preg r = false -> set_res (map_builtin_res preg_of res) v rs r = rs r.\nProof.\n  induction res; simpl; intros; auto.\n  unfold set_res; simpl.\n  rewrite Pregmap.gso; auto.\n  red; intro; subst.\n  rewrite H in (data_preg_of_iregsp a); discriminate.\nQed.", "nl_proof": "Step 1: We need to prove that forall r res v rs, data_preg r = false -> set_res (map_builtin_res preg_of res) v rs r = rs r Step 2: Proceed by induction on res Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - apply Pregmap Step 6: Apply tactic: gso Step 7: Apply tactic: red Step 8: Introduce variables and assumptions Step 9: Apply tactic: subst r Step 10: Rewrite using an equality Step 11: Apply tactic: discriminate", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:find_instr_in", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma find_instr_in : forall (A : Type) (c : list A) (pos : Z) (i : A),\n  find_instr pos c = Some i -> In i c.\nProof.\n  induction c; simpl; intros.\n  - discriminate.\n  - case (zeq pos 0); intros.\n    + left; congruence.\n    + right; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall c pos i, find_instr pos c = Some i -> In i c Step 2: Proceed by induction on c Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: discriminate Step 6: Introduce variables and assumptions Step 7: Apply tactic: case (zeq pos 0) Step 8: Introduce variables and assumptions Step 9: Apply tactic: left Step 10: Apply tactic: congruence Step 11: Apply tactic: right", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:code_tail_pos", "draft": "Lemma code_tail_pos : forall (pos : nat) (c1 c2 : list nat), code_tail pos c1 c2 -> pos >= 0.\nProof. induction 1; lia. Qed.", "nl_proof": "Step 1: We need to prove that forall pos c1 c2, code_tail pos c1 c2 -> pos >= 0 Step 2: Proceed by induction on 1 Step 3: Apply tactic: lia Step 4: Apply tactic: lia Step 5: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:find_instr_tail", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma find_instr_tail : forall (A : Type) (c1 : list A) (i : A) (c2 : list A) (pos : nat),\n  code_tail pos c1 (i :: c2) -> find_instr pos c1 = Some i.\nProof.\n  induction c1; intros i c2 pos H; simpl in *.\n  - inversion H.\n  - destruct pos.\n    + inversion H; subst; auto.\n    + inversion H; subst; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall c1 i c2 pos, code_tail pos c1 (i :: c2) -> find_instr pos c1 = Some i Step 2: Proceed by induction on c1 Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: inv H Step 6: Case analysis by destructing a value Step 7: Apply tactic: subst pos Step 8: Apply tactic: inv H Step 9: Solve automatically using known facts Step 10: Apply tactic: generalize (code_tail_pos _ _ _ H4) Step 11: Apply tactic: intro", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:code_tail_bounds_1", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma code_tail_bounds : forall fn ofs c, code_tail ofs fn c -> 0 <= ofs <= list_length_z fn.\nProof.\n  intros fn ofs c H.\n  induction H.\n  - simpl. lia.\n  - rewrite list_length_z_cons. lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall fn ofs c, code_tail ofs fn c -> 0 <= ofs <= list_length_z fn Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Simplify the goal by computation Step 5: Apply tactic: generalize (list_length_z_pos c) Step 6: Apply tactic: lia Step 7: Rewrite using an equality Step 8: Apply tactic: lia Step 9: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:code_tail_bounds_2", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import Coq.Lists.List.\n\nLemma code_tail_bounds : forall (fn : list nat) (ofs : Z) (i : nat) (c : list nat),\n  code_tail ofs fn (i :: c) -> 0 <= ofs < list_length_z fn.\nProof.\n  intros fn ofs i c H.\n  induction H.\n  - rewrite list_length_z_cons. lia.\n  - rewrite list_length_z_cons. lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall fn ofs i c, code_tail ofs fn (i :: c) -> 0 <= ofs < list_length_z fn Step 2: Apply tactic: assert (forall ofs fn c, code_tail ofs fn c -> Step 3: Apply tactic: forall i c', c = i :: c' -> 0 <= ofs < list_length Step 4: Proceed by induction on 1 Step 5: Introduce variables and assumptions Step 6: Simplify the goal by computation Step 7: Rewrite using an equality Step 8: Rewrite using an equality Step 9: Apply tactic: generalize (list_length_z_pos c') Step 10: Apply tactic: lia Step 11: Rewrite using an equality", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:code_tail_next", "draft": "Require Import Coq.Arith.PeanoNat.\n\nLemma code_tail_next : forall (fn : list nat) (ofs i : nat) (c : list nat),\n  code_tail ofs fn (i :: c) -> code_tail (ofs + 1) fn c.\nProof.\n  intros fn ofs i c H.\n  induction H as [| ? ? ? ? IH ? ? ? ?].\n  - constructor.\n  - constructor.\n  - constructor.\n  - eauto.\n  - eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall fn ofs i c, code_tail ofs fn (i :: c) -> code_tail (ofs + 1) fn c Step 2: Apply tactic: assert (forall ofs fn c, code_tail ofs fn c -> Step 3: Apply tactic: forall i c', c = i :: c' -> code_tail (ofs + 1) fn Step 4: Proceed by induction on 1 Step 5: Introduce variables and assumptions Step 6: Apply tactic: subst c Step 7: Apply tactic: constructor Step 8: Apply tactic: constructor Step 9: Apply tactic: constructor Step 10: Apply tactic: eauto Step 11: Apply tactic: eauto", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:code_tail_next_int", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import Coq.Ptr.Ptr.\n\nLemma code_tail_next_int : forall (fn : list instruction) (ofs : ptrofs) (i : instruction) (c : list instruction),\n  list_length_z fn <= Ptrofs.max_unsigned ->\n  code_tail (Ptrofs.unsigned ofs) fn (i :: c) ->\n  code_tail (Ptrofs.unsigned (Ptrofs.add ofs Ptrofs.one)) fn c.\nProof.\n  intros fn ofs i c H H0.\n  rewrite Ptrofs.add_unsigned.\n  rewrite Ptrofs.unsigned_one.\n  rewrite Ptrofs.unsigned_repr.\n  generalize (code_tail_bounds_2 _ _ _ _ H0).\n  lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall fn ofs i c, list_length_z fn <= Ptrofs Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Apply tactic: add_unsigned, Ptrofs Step 5: Apply tactic: unsigned_one Step 6: Rewrite using an equality Step 7: Apply tactic: unsigned_repr Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply tactic: generalize (code_tail_bounds_2 _ _ _ _ H0) Step 11: Apply tactic: lia", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:transl_code_rec_transl_code", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma transl_code_rec_transl_code : forall f il ep k,\n  transl_code_rec f il ep k = (do c <- transl_code f il ep; k c).\nProof.\n  induction il; simpl; intros; try reflexivity.\n  destruct (transl_code f il ep); simpl; try reflexivity.\n  rewrite IHil. reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall f il ep k, transl_code_rec f il ep k = (do c <- transl_code f il ep; k c) Step 2: Proceed by induction on il Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Rewrite using an equality Step 7: Case analysis by destructing a value Step 8: Simplify the goal by computation Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:is_tail_code_tail", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma is_tail_code_tail : forall (A : Type) (c1 c2 : list A), is_tail c1 c2 -> exists ofs : nat, code_tail ofs c2 c1.\nProof.\n  induction 1.\n  - exists 0. constructor.\n  - destruct IHis_tail as [ofs H].\n    exists (S ofs). constructor. apply H.\nQed.", "nl_proof": "Step 1: We need to prove that forall c1 c2, is_tail c1 c2 -> exists ofs, code_tail ofs c2 c1 Step 2: Proceed by induction on 1 Step 3: Provide an existential witness Step 4: Apply tactic: constructor Step 5: Case analysis by destructing a value Step 6: Provide an existential witness Step 7: Apply tactic: constructor Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:transl_code_tail", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma transl_code_tail : forall f c1 c2, is_tail c1 c2 ->\n  forall tc2 ep2, transl_code f c2 ep2 = OK tc2 ->\n  exists tc1, exists ep1, transl_code f c1 ep1 = OK tc1 /\\ is_tail tc1 tc2.\nProof.\n  induction 1; simpl; intros.\n  - exists tc2. exists ep2. split; auto. constructor.\n  - monadInv H0. exploit IHis_tail; eauto. intros (tc1 & ep1 & H1 & H2).\n    exists tc1. exists ep1. split; auto. eapply is_tail_cons_left; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall f c1 c2, is_tail c1 c2 -> forall tc2 ep2, transl_code f c2 ep2 = OK tc2 -> exists tc1, exists ep1, transl_code f c1 ep1 = OK tc1 /\\ is_tail tc1 tc2 Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Provide an existential witness Step 6: Provide an existential witness Step 7: Split a conjunction into separate goals Step 8: Solve automatically using known facts Step 9: Apply tactic: monadInv H0 Step 10: Apply tactic: exploit IHis_tail Step 11: Apply tactic: eauto", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:return_address_exists", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma is_tail_mcall_transl_code : forall (A B : Type) (f : A) (sg : B) (ros : list B) (c : list A),\n  exists (tf : A) (tc : list A), is_tail (Mcall sg ros :: c) (tf :: tc).\nProof.\n  intros A B f sg ros c.\n  eexists. eexists. constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall f sg ros c, is_tail (Mcall sg ros :: c) f Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: + exploit transf_function_inv Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Apply tactic: exploit transl_code_tail Step 8: Apply tactic: eauto Step 9: Introduce variables and assumptions Step 10: Apply tactic: Opaque transl_instr Step 11: Apply tactic: monadInv TR2", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:code_tail_no_bigger", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma code_tail_no_bigger : forall (pos : nat) (c1 c2 : list nat), code_tail pos c1 c2 -> (length c2 <= length c1)%nat.\nProof.\n  induction 1; simpl; lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall pos c1 c2, code_tail pos c1 c2 -> (length c2 <= length c1)%nat Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Apply tactic: lia Step 5: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:code_tail_unique", "draft": "Require Import Coq.Arith.Lia.\n\nLemma code_tail_unique : forall (fn : list nat) (c : nat) (pos pos' : nat),\n  code_tail pos fn c -> code_tail pos' fn c -> pos = pos'.\nProof.\n  induction fn; intros c pos pos' CT CT'.\n  - inversion CT.\n  - inversion CT; inversion CT'; subst.\n    + reflexivity.\n    + generalize (code_tail_no_bigger _ _ _ H3); intro; lia.\n    + generalize (code_tail_no_bigger _ _ _ H3); intro; lia.\n    + apply IHfn with (c := c0); assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall fn c pos pos', code_tail pos fn c -> code_tail pos' fn c -> pos = pos' Step 2: Proceed by induction on fn Step 3: Introduce variables and assumptions Step 4: Introduce variables and assumptions Step 5: Apply tactic: inv ITA Step 6: Apply tactic: inv CT Step 7: Solve automatically using known facts Step 8: Apply tactic: generalize (code_tail_no_bigger _ _ _ H3) Step 9: Simplify the goal by computation Step 10: Apply tactic: intro Step 11: Apply tactic: lia", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:return_address_offset_correct", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Values.Values.\nRequire Import Coq.Memory.Memory.\nRequire Import Coq.Stacklayout.Stacklayout.\nRequire Import Coq.Lists.List.\n\nLemma return_address_offset_correct : forall ge b ofs fb f c tf tc ofs',\n  transl_code_at_pc ge (Vptr b ofs) fb f c false tf tc ->\n  return_address_offset f c ofs' ->\n  ofs' = ofs.\nProof.\n  intros ge b ofs fb f c tf tc ofs' H H0.\n  inv H.\n  red in H0.\n  exploit code_tail_unique.\n  eexact H12.\n  eapply H0.\n  eauto.\n  intro.\n  rewrite H1.\n  repr_unsigned ofs.\nQed.", "nl_proof": "Step 1: We need to prove that forall ge b ofs fb f c tf tc ofs', transl_code_at_pc ge (Vptr b ofs) fb f c false tf tc -> return_address_offset f c ofs' -> ofs' = ofs Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: red in H0 Step 5: Apply tactic: exploit code_tail_unique Step 6: Apply tactic: eexact H12 Step 7: Apply tactic: eapply H0 Step 8: Apply tactic: eauto Step 9: Apply tactic: intro Step 10: Rewrite using an equality Step 11: Apply tactic: repr_unsigned ofs)", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:label_pos_code_tail", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\nRequire Import Coq.ZArith.ZArith.\n\nLemma label_pos_code_tail : forall lbl c pos c',\n  find_label lbl c = Some c' ->\n  exists pos',\n    label_pos lbl pos c = Some pos'\n    /\\ code_tail (pos' - pos) c c'\n    /\\ pos < pos' <= pos + list_length_z c.\nProof.\n  induction c; intros pos c' H.\n  - simpl in H. discriminate.\n  - simpl in H. case_eq (is_label lbl a); intro IL.\n    + injection H as H. subst c'. exists (pos + 1). repeat split.\n      * simpl. rewrite IL. reflexivity.\n      * constructor.\n      * split; [omega|]. simpl list_length_z. omega.\n    + destruct (IHc (pos + 1) c' H) as [pos' [LP [CT BND]]].\n      exists pos'. repeat split.\n      * simpl. rewrite IL. assumption.\n      * replace (pos' - pos) with ((pos' - (pos + 1)) + 1) by omega.\n        constructor; assumption.\n      * split; [omega|]. simpl list_length_z in *. omega.\nQed.", "nl_proof": "Step 1: We need to prove that forall lbl c pos c', find_label lbl c = Some c' -> exists pos', label_pos lbl pos c = Some pos' /\\ code_tail (pos' - pos) c c' /\\ pos < pos' <= pos + list_length_z c Step 2: Proceed by induction on c Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: discriminate Step 6: Simplify the goal by computation Step 7: Introduce variables and assumptions Step 8: Apply tactic: case (is_label lbl a) Step 9: Apply tactic: intro EQ Step 10: Apply tactic: injection EQ Step 11: Apply tactic: intro", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:tail_nolabel_refl", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma tail_nolabel_refl : forall (c : list nat), tail_nolabel c c.\nProof. induction c; simpl; auto. Qed.", "nl_proof": "Step 1: We need to prove that forall c, tail_nolabel c c Step 2: Introduce variables and assumptions Step 3: Split a conjunction into separate goals Step 4: Apply a theorem or hypothesis Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:tail_nolabel_trans", "draft": "Require Import Coq.Lists.List.\nLemma tail_nolabel_trans : forall (c1 c2 c3 : list nat), is_tail c2 c3 -> is_tail c1 c2 -> is_tail c1 c3.\nProof. intros c1 c2 c3 H H0. eapply is_tail_trans; eauto. Qed.", "nl_proof": "Step 1: We need to prove that forall c1 c2 c3, tail_nolabel c2 c3 -> tail_nolabel c1 c2 -> tail_nolabel c1 c3 Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Case analysis by destructing a value Step 5: Split a conjunction into separate goals Step 6: Apply tactic: eapply is_tail_trans Step 7: Apply tactic: eauto Step 8: Introduce variables and assumptions Step 9: Rewrite using an equality Step 10: Solve automatically using known facts Step 11: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:tail_nolabel_cons", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma tail_nolabel_cons : forall (A : Type) (i : A) (c : list A) (k : nat),\n  nolabel i -> tail_nolabel k c -> tail_nolabel k (i :: c).\nProof.\n  intros A i c k H1 H2.\n  destruct k.\n  - constructor.\n    + exact H1.\n    + exact H2.\n  - simpl.\n    rewrite H1.\n    destruct H2.\n    constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall i c k, nolabel i -> tail_nolabel k c -> tail_nolabel k (i :: c) Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Split a conjunction into separate goals Step 5: Apply tactic: constructor Step 6: Solve automatically using known facts Step 7: Introduce variables and assumptions Step 8: Simplify the goal by computation Step 9: Rewrite using an equality Step 10: Case analysis by destructing a value Step 11: The goal is true by reflexivity", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:tail_nolabel_find_label", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma tail_nolabel_find_label : forall lbl k c, tail_nolabel k c -> find_label lbl c = find_label lbl k.\nProof. intros. apply H. Qed.", "nl_proof": "Step 1: We need to prove that forall lbl k c, tail_nolabel k c -> find_label lbl c = find_label lbl k Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:tail_nolabel_is_tail", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma tail_nolabel_is_tail : forall (A : Type) (k c : list A), is_tail k c -> is_tail k c.\nProof. auto. Qed.", "nl_proof": "Step 1: We need to prove that forall k c, tail_nolabel k c -> is_tail k c Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:exec_straight_trans", "draft": "Lemma exec_straight_trans : forall c1 rs1 m1 c2 rs2 m2 c3 rs3 m3,\n  exec_straight c1 rs1 m1 c2 rs2 m2 ->\n  exec_straight c2 rs2 m2 c3 rs3 m3 ->\n  exec_straight c1 rs1 m1 c3 rs3 m3.\nProof.\n  intros until m3. intros H1 H2. induction H1; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall c1 rs1 m1 c2 rs2 m2 c3 rs3 m3, exec_straight c1 rs1 m1 c2 rs2 m2 -> exec_straight c2 rs2 m2 c3 rs3 m3 -> exec_straight c1 rs1 m1 c3 rs3 m3 Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Apply a theorem or hypothesis Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:exec_straight_two", "draft": "Require Import Coq.Lists.List. Import ListNotations.\nLemma exec_straight_two : forall (ge : genv) (fn : function) (i1 i2 : instruction) (c : list instruction) (rs1 rs2 rs3 : regset) (m1 m2 m3 : mem),\n  exec_instr ge fn i1 rs1 m1 = Next rs2 m2 ->\n  exec_instr ge fn i2 rs2 m2 = Next rs3 m3 ->\n  rs2#PC = Val.offset_ptr rs1#PC Ptrofs.one ->\n  rs3#PC = Val.offset_ptr rs2#PC Ptrofs.one ->\n  exec_straight (i1 :: i2 :: c) rs1 m1 c rs3 m3.\nProof. intros. eapply exec_straight_two; eauto. Qed.", "nl_proof": "Step 1: We need to prove that forall i1 i2 c rs1 m1 rs2 m2 rs3 m3, exec_instr ge fn i1 rs1 m1 = Next rs2 m2 -> exec_instr ge fn i2 rs2 m2 = Next rs3 m3 -> rs2#PC = Val Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Solve automatically using known facts Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:exec_straight_three", "draft": "Require Import Coq.Lists.List. Import ListNotations.\nLemma exec_straight_three : forall (ge : _) (fn : _) (i1 i2 i3 : _) (c : _) (rs1 rs2 rs3 rs4 : _) (m1 m2 m3 m4 : _),\n  exec_instr ge fn i1 rs1 m1 = Next rs2 m2 ->\n  exec_instr ge fn i2 rs2 m2 = Next rs3 m3 ->\n  exec_instr ge fn i3 rs3 m3 = Next rs4 m4 ->\n  rs2#PC = Val.offset_ptr rs1#PC Ptrofs.one ->\n  rs3#PC = Val.offset_ptr rs2#PC Ptrofs.one ->\n  rs4#PC = Val.offset_ptr rs3#PC Ptrofs.one ->\n  exec_straight (i1 :: i2 :: i3 :: c) rs1 m1 c rs4 m4.\nProof. intros. eapply exec_straight_three; eauto. Qed.", "nl_proof": "Step 1: We need to prove that forall i1 i2 i3 c rs1 m1 rs2 m2 rs3 m3 rs4 m4, exec_instr ge fn i1 rs1 m1 = Next rs2 m2 -> exec_instr ge fn i2 rs2 m2 = Next rs3 m3 -> exec_instr ge fn i3 rs3 m3 = Next rs4 m4 -> rs2#PC = Val Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Solve automatically using known facts Step 5: Apply tactic: eapply exec_straight_two Step 6: Apply tactic: eauto Step 7: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:exec_straight_opt_left", "draft": "Require Import Coq.Arith.Arith.\nLemma exec_straight_opt_left : forall c3 rs3 m3 c1 rs1 m1 c2 rs2 m2,\n  exec_straight c1 rs1 m1 c2 rs2 m2 ->\n  exec_straight_opt c2 rs2 m2 c3 rs3 m3 ->\n  exec_straight c1 rs1 m1 c3 rs3 m3.\nProof. intros. eapply exec_straight_trans; eauto. apply exec_straight_opt_right; assumption. Qed.", "nl_proof": "Step 1: We need to prove that forall c3 rs3 m3 c1 rs1 m1 c2 rs2 m2, exec_straight c1 rs1 m1 c2 rs2 m2 -> exec_straight_opt c2 rs2 m2 c3 rs3 m3 -> exec_straight c1 rs1 m1 c3 rs3 m3 Step 2: Case analysis by destructing a value Step 3: Introduce variables and assumptions Step 4: Solve automatically using known facts Step 5: Apply tactic: eapply exec_straight_trans Step 6: Apply tactic: eauto Step 7: Apply tactic: Qed", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:exec_straight_opt_right", "draft": "Lemma exec_straight_opt_right : forall c3 rs3 m3 c1 rs1 m1 c2 rs2 m2,\n  exec_straight_opt c1 rs1 m1 c2 rs2 m2 ->\n  exec_straight c2 rs2 m2 c3 rs3 m3 ->\n  exec_straight c1 rs1 m1 c3 rs3 m3.\nProof.\n  intros.\n  destruct H.\n  - eapply exec_straight_trans; eauto.\n  - assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall c3 rs3 m3 c1 rs1 m1 c2 rs2 m2, exec_straight_opt c1 rs1 m1 c2 rs2 m2 -> exec_straight c2 rs2 m2 c3 rs3 m3 -> exec_straight c1 rs1 m1 c3 rs3 m3 Step 2: Case analysis by destructing a value Step 3: Introduce variables and assumptions Step 4: Solve automatically using known facts Step 5: Apply tactic: eapply exec_straight_trans Step 6: Apply tactic: eauto Step 7: Apply tactic: Qed", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:exec_straight_opt_step", "draft": "Require Import Coq.Lists.List.\nLemma exec_straight_step : forall (ge : Type) (fn : Type) (i : Type) (c : list Type) (rs1 m1 rs2 m2 : Type) (c' : list Type) (rs3 m3 : Type),\n  exec_instr ge fn i rs1 m1 = Next rs2 m2 ->\n  rs2#PC = Val.offset_ptr rs1#PC Ptrofs.one ->\n  exec_straight ge fn c rs2 m2 c' rs3 m3 ->\n  exec_straight ge fn (i :: c) rs1 m1 c' rs3 m3.\nProof.\n  intros. eapply exec_straight_one; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall i c rs1 m1 rs2 m2 c' rs3 m3, exec_instr ge fn i rs1 m1 = Next rs2 m2 -> rs2#PC = Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H1 Step 4: Apply tactic: - apply exec_straight_one Step 5: Solve automatically using known facts Step 6: Apply tactic: - eapply exec_straight_step Step 7: Apply tactic: eauto Step 8: Apply tactic: Qed", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:exec_straight_opt_step_opt", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma exec_straight_opt_step_template : forall (ge : Type) (fn : Type) (i : Type) (c : list Type) (rs1 m1 rs2 m2 : Type) (c' : list Type) (rs3 m3 : Type),\n  exec_instr ge fn i rs1 m1 = Next rs2 m2 ->\n  rs2#PC = Val.offset_ptr rs1#PC Ptrofs.one ->\n  exec_straight_opt c rs2 m2 c' rs3 m3 ->\n  exec_straight_opt (i :: c) rs1 m1 c' rs3 m3.\nProof. apply exec_straight_opt_step_opt. Qed.", "nl_proof": "Step 1: We need to prove that forall i c rs1 m1 rs2 m2 c' rs3 m3, exec_instr ge fn i rs1 m1 = Next rs2 m2 -> rs2#PC = Val Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: eapply exec_straight_opt_step Step 5: Apply tactic: eauto Step 6: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:parent_sp_def", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma match_stack_parent_sp_defined : forall (s : stack) (H : match_stack s), parent_sp s <> Vundef.\nProof.\n  induction 1; simpl; try congruence.\n  unfold parent_sp in *.\n  destruct sp; try congruence.\n  destruct ptr64; congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall s, match_stack s -> parent_sp s <> Vundef Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Unfold a definition Step 5: Case analysis by destructing a value Step 6: Apply tactic: ptr64 Step 7: Apply tactic: congruence Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:parent_ra_def", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma match_stack_parent_ra_defined : forall (s : stack) (H : match_stack s), parent_ra s <> Vundef.\nProof.\n  induction 1; simpl; unfold parent_ra; destruct parent_sp; try ptr64; try congruence; inv H0; congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall s, match_stack s -> parent_ra s <> Vundef Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Unfold a definition Step 5: Case analysis by destructing a value Step 6: Apply tactic: ptr64 Step 7: Apply tactic: congruence Step 8: Apply tactic: inv H0 Step 9: Apply tactic: congruence Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:lessdef_parent_sp", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma match_stack_parent_sp_def : forall (s v : Type) (match_stack : s -> Prop) (parent_sp_def : Prop),\n  match_stack s -> parent_sp_def -> True.\nProof.\n  intros s v match_stack parent_sp_def H H0.\n  inv H0.\n  exploit parent_sp_def.\n  eauto.\n  tauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall s v, match_stack s -> Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Solve automatically using known facts Step 5: Apply tactic: exploit parent_sp_def Step 6: Apply tactic: eauto Step 7: Apply tactic: tauto Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Asmgenproof0:lessdef_parent_ra", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma match_stack_val_step : forall (s : list nat) (v : nat), match_stack s -> val_step s v.\nProof.\n  intros s v H.\n  inversion H.\n  exploit parent_ra_def.\n  eauto.\n  tauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall s v, match_stack s -> Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Solve automatically using known facts Step 5: Apply tactic: exploit parent_ra_def Step 6: Apply tactic: eauto Step 7: Apply tactic: tauto Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tailcallproof:return_measure_bounds", "draft": "Require Import Lia.\n\nLemma return_measure_bound : forall (f : nat -> nat) (n : nat) (pc : nat), (return_measure f pc <= niter)%nat.\nProof.\n  intro f.\n  assert (forall n pc, (return_measure_rec n f pc <= niter)%nat).\n  { induction n.\n    - intros pc. simpl. lia.\n    - intros pc. simpl.\n      destruct (f pc) eqn:H.\n      + try lia.\n      + destruct n0.\n        * try lia.\n        * try lia. }\n  apply H.\nQed.", "nl_proof": "Step 1: We need to prove that forall f pc, (return_measure f pc <= niter)%nat Step 2: Apply tactic: intro f Step 3: Apply tactic: assert (forall n pc, (return_measure_rec n f pc <= Step 4: Proceed by induction on n Step 5: Introduce variables and assumptions Step 6: Simplify the goal by computation Step 7: Apply tactic: lia Step 8: Case analysis by destructing a value Step 9: Apply tactic: try lia Step 10: Case analysis by destructing a value Step 11: Apply tactic: try lia", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tailcallproof:return_measure_rec_incr", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Arith.Lia.\n\nLemma return_measure_rec_incr : forall f n1 n2 pc,\n  (n1 <= n2)%nat ->\n  (return_measure_rec n1 f pc <= return_measure_rec n2 f pc)%nat.\nProof.\n  induction n1; intros n2 pc H.\n  - simpl. lia.\n  - destruct n2; try lia.\n    simpl. destruct (f pc); try lia.\n    + assert (n1 <= n2)%nat by lia. lia.\n    + assert (n1 <= n2)%nat by lia. lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall f n1 n2 pc, (n1 <= n2)%nat -> (return_measure_rec n1 f pc <= return_measure_rec n2 f pc)%nat Step 2: Proceed by induction on n1 Step 3: Introduce variables and assumptions Step 4: Simplify the goal by computation Step 5: Apply tactic: lia Step 6: Case analysis by destructing a value Step 7: Apply tactic: extlia Step 8: Apply tactic: assert (n1 <= n2)%nat by lia Step 9: Simplify the goal by computation Step 10: Case analysis by destructing a value Step 11: Apply tactic: try lia", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tailcallproof:is_return_measure_rec", "draft": "Require Import Coq.Lists.List. Import ListNotations.\nLemma is_return_measure_rec : forall f n n' pc r,\n  is_return n f pc r = true -> (n <= n')%nat ->\n  return_measure_rec n (fn_code f) pc = return_measure_rec n' (fn_code f) pc.\nProof.\n  induction n; simpl; intros; try congruence.\n  destruct n'; try lia.\n  destruct (fn_code f)!pc; try congruence.\n  destruct i; try congruence.\n  destruct (is_return n f n0 r) eqn:?; try congruence.\n  apply IHn in Heqb; try lia.\n  congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall f n n' pc r, is_return n f pc r = true -> (n <= n')%nat -> return_measure_rec n f Step 2: Proceed by induction on n Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: congruence Step 6: Case analysis by destructing a value Step 7: Apply tactic: extlia Step 8: Simplify the goal by computation Step 9: Case analysis by destructing a value Step 10: Apply tactic: try congruence Step 11: Case analysis by destructing a value", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tailcallproof:is_return_charact", "draft": "Require Import Coq.Arith.Arith.\n\nLemma is_return_charact : forall (f : function) (n : nat) (pc : positive) (rret : reg),\n  is_return n f pc rret = true -> (n <= niter)%nat -> is_return_spec f pc rret.\nProof.\n  induction n; intros pc rret H H0.\n  - simpl in H. congruence.\n  - generalize H; simpl.\n    caseEq ((fn_code f) ! pc); try congruence.\n    intro i; caseEq i; try congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall f n pc rret, is_return n f pc rret = true -> (n <= niter)%nat -> is_return_spec f pc rret Step 2: Proceed by induction on n Step 3: Introduce variables and assumptions Step 4: Simplify the goal by computation Step 5: Apply tactic: congruence Step 6: Apply tactic: generalize H Step 7: Simplify the goal by computation Step 8: Apply tactic: caseEq ((fn_code f)!pc) Step 9: Apply tactic: try congruence Step 10: Apply tactic: intro i Step 11: Apply tactic: caseEq i", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tailcallproof:transf_instr_charact", "draft": "Require Import Coq.Lists.List.\n\nLemma transf_instr_tailcall_sound : forall (A B : Type) (f : A) (pc : nat) (instr : B),\n  (forall (s : A), is_return_charact s instr) ->\n  exists (s' : A), transf_instr f (analyze f) f pc instr = Some s' /\\ sig_res s' = sig_res (fn_sig f).\nProof.\n  intros A B f pc instr H.\n  destruct (H (fn_sig f)) as [s' [H1 H2]].\n  exists s'. split.\n  - eapply transf_instr_tailcall; eauto.\n  - apply H2.\nQed.", "nl_proof": "Step 1: We need to prove that forall f pc instr, f Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Apply tactic: try constructor Step 6: Case analysis by destructing a value Step 7: Apply tactic: xtype_eq (sig_res s) (sig_res (fn_sig f))) eqn:B Step 8: Apply tactic: - InvBooleans Step 9: Apply tactic: eapply transf_instr_tailcall Step 10: Apply tactic: eauto Step 11: Apply tactic: eapply is_return_charact", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tailcallproof:transf_instr_lookup", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma map_compose : forall (A B C : Type) (f : B -> C) (g : A -> B) (l : list A), map f (map g l) = map (fun x => f (g x)) l.\nProof.\n  intros A B C f g l. induction l; simpl; [reflexivity|].\n  rewrite IHl. reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall f pc i, f Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Apply tactic: InvBooleans Step 6: Simplify the goal by computation Step 7: Rewrite using an equality Step 8: Apply tactic: gmap Step 9: Rewrite using an equality Step 10: Simplify the goal by computation Step 11: Provide an existential witness", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tailcallproof:regs_lessdef_init_regs", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma val_step_params : forall (params : list nat) (vl vl' : list nat),\n    length params = length vl -> Forall2 (fun p v => p = v) params vl -> vl = vl'.\nProof.\n  induction params; intros vl vl' Hlen Hforall.\n  - simpl in Hlen. destruct vl; [auto | discriminate].\n  - destruct vl; [discriminate |].\n    inversion Hforall as [|? ? ? ? Hhead Htail]. subst.\n    simpl in Hlen. inversion Hlen.\n    apply IHparams in Htail; auto. subst. reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall params vl vl', Val Step 2: Proceed by induction on params Step 3: Introduce variables and assumptions Step 4: Simplify the goal by computation Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Rewrite using an equality Step 8: Apply tactic: constructor Step 9: Simplify the goal by computation Step 10: Apply tactic: inv H Step 11: Apply tactic: red", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tailcallproof:transf_program_match", "draft": "Require Import Coq.Arith.Arith.\nLemma transf_program_match : forall p tp, transf_program p = OK tp -> match_prog p tp.\nProof. intros. apply transf_program_match. assumption. Qed.", "nl_proof": "Step 1: We need to prove that forall p, match_prog p (transf_program p) Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tailcallproof:symbols_preserved", "draft": "Require Import Coq.Lists.List.\nLemma functions_translated : forall (v : val) (f : fundef), Genv.find_funct ge v = Some f -> Genv.find_funct tge v = Some (transf_fundef f).\nProof. apply Genv.find_funct_transf. Qed.", "nl_proof": "Step 1: We need to prove that forall (s: ident), Genv Step 2: Apply tactic: Lemma functions_translated: Step 3: Apply tactic: forall (v: val) (f: RTL Step 4: Apply tactic: fundef), Step 5: Apply tactic: Genv Step 6: Apply tactic: find_funct ge v = Some f -> Step 7: Apply tactic: Genv Step 8: Apply tactic: find_funct tge v = Some (transf_fundef f) Step 9: Apply tactic: Lemma funct_ptr_translated: Step 10: Apply tactic: forall (b: block) (f: RTL Step 11: Apply tactic: fundef),", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tailcallproof:functions_translated", "draft": "Require Import Coq.Lists.List.\nLemma funct_ptr_translated : forall (b : block) (f : RTL.fundef),\n  Genv.find_funct_ptr ge b = Some f ->\n  Genv.find_funct_ptr tge b = Some (transf_fundef f).\nProof.\n  intros. apply function_ptr_translated. assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall (v: val) (f: RTL Step 2: Apply tactic: Lemma funct_ptr_translated: Step 3: Apply tactic: forall (b: block) (f: RTL Step 4: Apply tactic: fundef), Step 5: Apply tactic: Genv Step 6: Apply tactic: find_funct_ptr ge b = Some f -> Step 7: Apply tactic: Genv Step 8: Apply tactic: find_funct_ptr tge b = Some (transf_fundef f) Step 9: Apply tactic: Lemma senv_preserved: Step 10: Apply tactic: Senv Step 11: Apply tactic: equiv ge tge", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tailcallproof:funct_ptr_translated", "draft": "Require Import Coq.Lists.List.\nLemma sig_preserved : forall (f : fundef), funsig (transf_fundef f) = funsig f.\nProof. destruct f; simpl; auto. Qed.", "nl_proof": "Step 1: We need to prove that forall (b: block) (f: RTL Step 2: Apply tactic: Lemma senv_preserved: Step 3: Apply tactic: Senv Step 4: Apply tactic: equiv ge tge Step 5: Apply tactic: Lemma sig_preserved: Step 6: Apply tactic: forall f, funsig (transf_fundef f) = funsig f Step 7: Case analysis by destructing a value Step 8: Solve automatically using known facts Step 9: Simplify the goal by computation Step 10: Unfold a definition Step 11: Case analysis by destructing a value", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tailcallproof:senv_preserved", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma sig_preserved : forall (A : Type) (f : A), funsig (transf_fundef f) = funsig f.\nProof.\n  destruct f; simpl; auto.\nQed.", "nl_proof": "Step 1: We need to prove that Senv Step 2: Apply tactic: Lemma sig_preserved: Step 3: Apply tactic: forall f, funsig (transf_fundef f) = funsig f Step 4: Case analysis by destructing a value Step 5: Solve automatically using known facts Step 6: Simplify the goal by computation Step 7: Unfold a definition Step 8: Case analysis by destructing a value Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tailcallproof:sig_preserved", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma sig_function_translated : forall (A : Type) (f : A), funsig (transf_fundef f) = funsig f.\nProof.\n  destruct f; simpl; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall f, funsig (transf_fundef f) = funsig f Step 2: Case analysis by destructing a value Step 3: Solve automatically using known facts Step 4: Simplify the goal by computation Step 5: Unfold a definition Step 6: Case analysis by destructing a value Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tailcallproof:stacksize_preserved", "draft": "Lemma stacksize_preserved : forall (A : Type) (f : A), fn_stacksize (transf_function f) = fn_stacksize f.\nProof. destruct f; reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f, fn_stacksize (transf_function f) = fn_stacksize f Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tailcallproof:find_function_translated", "draft": "```coq\nRequire Import Coq.Arith.Arith.\nLemma find_function_translated : forall (ge tge : Genv.t (fundef unit) unit) (ros : option reg) (rs rs' : regset) (f : fundef unit),\n  find_function ge ros rs = Some f ->\n  regs_lessdef rs rs' ->\n  find_function tge ros rs' = Some (transf_fundef f).\nProof.\n  intros ge tge ros rs rs' f H1 H2.\n  destruct ros as [r|id]; simpl in *.\n  - destruct (H2 r) as [v' [EQ1 EQ2]].\n    rewrite EQ1 in H1.\n    destruct (rs' r); try discriminate.\n    inversion H1; subst.\n    reflexivity.\n  - destruct (Genv.find_symbol ge id) eqn:FS; try discriminate.\n    inversion H1; subst.\n    rewrite (Genv.find_symbol_transf _ _ TRANSF id) in FS.\n    rewrite FS.\n    reflexivity.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall ros rs rs' f, find_function ge ros rs = Some f -> regs_lessdef rs rs' -> find_function tge ros rs' = Some (transf_fundef f) Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Apply tactic: assert (rs'#r = rs#r) Step 7: Apply tactic: exploit Genv Step 8: Apply tactic: find_funct_inv Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Apply tactic: generalize (H0 r)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tailcallproof:transf_step_correct", "draft": "Require Import Coq.Lists.List.\nLemma step_simulation : forall (ge tge : Type) (step : ge -> nat -> nat -> Prop) (step_tge : tge -> nat -> nat -> Prop) (match_states : nat -> nat -> Prop) (measure : nat -> nat),\n(forall (s1 t s2 : nat), step ge s1 t s2 -> forall (s1' : nat), match_states s1 s1' -> (exists s2' : nat, step_tge tge s1' t s2' /\\ match_states s2 s2') \\/ (measure s2 < measure s1 /\\ t = 0 /\\ match_states s2 s1')%nat).\nProof.\n  intros ge tge step step_tge match_states measure.\n  intros s1 t s2 Hstep s1' Hmatch.\n  induction Hstep.\n  - left. eexists. split.\n    + eapply H.\n    + apply Hmatch.\n  - right. split.\n    + apply Nat.lt_succ_diag_r.\n    + split.\n      * reflexivity.\n      * apply Hmatch.\nQed.", "nl_proof": "Step 1: eliminated nop Step 2: eliminated move Step 3: returnstate Step 4: synchronous return in both programs Step 5: return instr in source program, eliminated because of tailcall Step 6: call turned tailcall Step 7: call that remains a call Step 8: tailcall Step 9: jumptable Step 10: eliminated return None Step 11: eliminated return Some Step 12: internal call Step 13: external call Step 14: We need to prove that forall s1 t s2, step ge s1 t s2 -> forall s1' (MS: match_states s1 s1'), (exists s2', step tge s1' t s2' /\\ match_states s2 s2') \\/ (measure s2 < measure s1 /\\ t = E0 /\\ match_states s2 s1')%nat Step 15: Proceed by induction on 1 Step 16: Introduce variables and assumptions Step 17: Apply tactic: inv MS Step 18: Apply tactic: EliminatedInstr Step 19: Apply tactic: TransfInstr Step 20: Apply tactic: left Step 21: Apply tactic: econstructor Step 22: Split a conjunction into separate goals Step 23: Apply tactic: eapply exec_Inop Step 24: Apply tactic: eauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tailcallproof:transf_initial_states", "draft": "Require Import Coq.Logic.FunctionalExtensionality.\nLemma transf_initial_states : forall (prog tprog : Type) (initial_state : Type -> Type -> Prop) (match_states : Type -> Type -> Prop) (st1 : Type), initial_state prog st1 -> exists st2 : Type, initial_state tprog st2 /\\ match_states st1 st2.\nProof.\n  intros prog tprog initial_state match_states st1 H.\n  inversion H.\n  exploit (funct_ptr_translated prog tprog).\n  eauto.\n  intro FIND.\n  exists (Genv.symbol_address tprog (prog_main tprog) Int.zero).\n  split.\n  econstructor.\n  eauto.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall st1, initial_state prog st1 -> exists st2, initial_state tprog st2 /\\ match_states st1 st2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: exploit funct_ptr_translated Step 5: Apply tactic: eauto Step 6: Apply tactic: intro FIND Step 7: Provide an existential witness Step 8: Split a conjunction into separate goals Step 9: Apply tactic: econstructor Step 10: Apply tactic: eauto Step 11: Apply a theorem or hypothesis", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tailcallproof:transf_final_states", "draft": "Lemma final_state_match : forall (st1 st2 : state) (r : return_type), match_states st1 st2 -> final_state st1 r -> final_state st2 r.\nProof.\n  intros st1 st2 r H H0.\n  inv H0.\n  inv H.\n  inv H5.\n  inv H3.\n  constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall st1 st2 r, match_states st1 st2 -> final_state st1 r -> final_state st2 r Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Apply tactic: inv H Step 5: Apply tactic: inv H5 Step 6: Apply tactic: inv H3 Step 7: Apply tactic: constructor Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tailcallproof:transf_program_correct", "draft": "Require Import Coq.Logic.FunctionalExtensionality.\nLemma forward_simulation_opt_correct : forall (S1 S2 : Type) (step1 : S1 -> S1 -> Prop) (step2 : S2 -> S2 -> Prop) (match_states : S1 -> S2 -> Prop) (measure : S1 -> nat) (transf_initial_states : forall s1, step1 s1 s1 -> exists s2, step2 s2 s2 /\\ match_states s1 s2) (transf_final_states : forall s1 s2, match_states s1 s2 -> step1 s1 s1 -> step2 s2 s2) (transf_step_correct : forall s1 s1' s2, step1 s1 s1' -> match_states s1 s2 -> exists s2', step2 s2 s2' /\\ match_states s1' s2'), forward_simulation step1 step2.\nProof.\n  intros.\n  eapply forward_simulation_opt with (measure := measure).\n  eauto.\n  eexact transf_initial_states.\n  eexact transf_final_states.\n  exact transf_step_correct.\nQed.", "nl_proof": "Step 1: We need to prove that forward_simulation (RTL Step 2: Apply tactic: eapply forward_simulation_opt with (measure := mea Step 3: Apply tactic: eauto Step 4: Apply a theorem or hypothesis Step 5: Apply tactic: eexact transf_initial_states Step 6: Apply tactic: eexact transf_final_states Step 7: Apply tactic: exact transf_step_correct Step 8: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:expect_incr", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma expect_inversion : forall (A B : Type) (e : A) (t1 t2 : B) (e' : A),\n  (if eqb t1 t2 then OK e else Error) = OK e' -> eqb t1 t2 = true /\\ e = e'.\nProof.\n  intros A B e t1 t2 e' H.\n  destruct (eqb t1 t2) eqn:Heq; inversion H; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall te e t1 t2 e', expect e t1 t2 = OK e' -> S Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: inv H Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:expect_sound", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma expect_eq_types : forall (A : Type) (e : A) (t1 t2 : A) (e' : A), (if eqb t1 t2 then OK e else Error) = OK e' -> t1 = t2.\nProof.\n  intros A e t1 t2 e' H.\n  destruct (eqb t1 t2) eqn:E; inv H.\n  apply eqb_eq; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall e t1 t2 e', expect e t1 t2 = OK e' -> t1 = t2 Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: inv H Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:type_expr_incr", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma type_expr_induction_step : \n  forall (A : Type) (te : A -> A -> bool) (a : A) (t : A) (e e' : A),\n    te a t = true -> e = e'.\nProof.\n  intros A te a t e e' H.\n  induction a; simpl in H; try congruence.\n  - destruct (te a t) eqn:?; try discriminate.\n    injection H; intros; subst; auto.\n  - destruct (te a1 t1) eqn:?; try discriminate.\n    destruct (te a2 t2) eqn:?; try discriminate.\n    injection H; intros; subst; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall te a t e e', type_expr e a t = OK e' -> S Step 2: Proceed by induction on a Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Introduce variables and assumptions Step 6: Apply tactic: try (monadInv T) Step 7: Apply tactic: eauto with ty Step 8: Apply tactic: - destruct (type_unop u) as [targ1 tres] Step 9: Apply tactic: monadInv T Step 10: Apply tactic: eauto with ty Step 11: Apply tactic: - destruct (type_binop b) as [[targ1 targ2] tres]", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:type_expr_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma type_expr_sound : forall te a t e e', type_expr e a t = OK e' -> S.satisf te e' -> wt_expr te a t.\nProof.\n  induction a; intros t e e' T S; simpl in T; try monadInv T;\n  try (erewrite <- S; [constructor|eauto]);\n  try (erewrite <- expect_sound by eauto; constructor).\nQed.", "nl_proof": "Step 1: We need to prove that forall te a t e e', type_expr e a t = OK e' -> S Step 2: Proceed by induction on a Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Introduce variables and assumptions Step 6: Apply tactic: try (monadInv T) Step 7: Apply tactic: - erewrite <- S Step 8: Apply tactic: set_sound by eauto Step 9: Apply tactic: constructor Step 10: Apply tactic: - erewrite <- expect_sound by eauto Step 11: Apply tactic: constructor", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:type_exprlist_incr", "draft": "Require Import Coq.Lists.List.\n\nLemma type_exprlist_sound_generalized : forall (A B : Type) (te : A) (al : list B) (tl : list Type) (e e' : S.t),\n  type_exprlist e al tl = OK e' -> S.satisf te e' -> list_forall2 (wt_expr te) al tl.\nProof.\n  intros A B te al tl e e' H1 H2.\n  induction al; simpl in *; monadInv H1; eauto with ty.\nQed.", "nl_proof": "Step 1: We need to prove that forall te al tl e e', type_exprlist e al tl = OK e' -> S Step 2: Proceed by induction on al Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Apply tactic: monadInv T Step 8: Apply tactic: eauto with ty Step 9: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:type_exprlist_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma type_exprlist_sound : forall te al tl e e',\n  type_exprlist e al tl = OK e' -> S.satisf te e' -> list_forall2 (wt_expr te) al tl.\nProof.\n  induction al; intros tl e e' H H0; destruct tl; monadInv H; constructor; eauto using type_expr_sound with ty.\nQed.", "nl_proof": "Step 1: We need to prove that forall te al tl e e', type_exprlist e al tl = OK e' -> S Step 2: Proceed by induction on al Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Apply tactic: monadInv T Step 8: Apply tactic: - constructor Step 9: Apply tactic: - constructor Step 10: Apply tactic: eauto using type_expr_sound with ty Step 11: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:type_assign_incr", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma type_assign_unop_preservation : forall (te : Type) (id : nat) (u : unop) (a : expr) (e e' : env),\n    type_assign e id (Eunop u a) = OK e' -> exists targ1 tres, type_unop u = Some (targ1, tres).\nProof.\n  intros te id u a e e' T.\n  destruct (type_unop u) as [[targ1 tres]|] eqn:TU.\n  - exists targ1, tres. reflexivity.\n  - simpl in T. discriminate.\nQed.", "nl_proof": "Step 1: We need to prove that forall te id a e e', type_assign e id a = OK e' -> S Step 2: Proceed by induction on a Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Introduce variables and assumptions Step 6: Apply tactic: try (monadInv T) Step 7: Apply tactic: eauto with ty Step 8: Apply tactic: - destruct (type_unop u) as [targ1 tres] Step 9: Apply tactic: monadInv T Step 10: Apply tactic: eauto with ty Step 11: Apply tactic: - destruct (type_binop b) as [[targ1 targ2] tres]", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:type_assign_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma type_assign_sound_generalized : forall te id a e e',\n  type_assign e id a = OK e' -> S.satisf te e' -> wt_expr te a (te id).\nProof.\n  induction a; intros e e' T SAT;\n  try (monadInv T);\n  try (erewrite IHa1 by eauto);\n  try (erewrite IHa2 by eauto);\n  try (move_sound by eauto);\n  try constructor.\nQed.", "nl_proof": "Step 1: We need to prove that forall te id a e e', type_assign e id a = OK e' -> S Step 2: Proceed by induction on a Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Introduce variables and assumptions Step 6: Apply tactic: try (monadInv T) Step 7: Apply tactic: - erewrite S Step 8: Apply tactic: move_sound by eauto Step 9: Apply tactic: constructor Step 10: Apply tactic: - erewrite S Step 11: Apply tactic: set_sound by eauto", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:opt_set_incr", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma opt_set_monad_inv : forall (A B : Type) (te : A) (optid : option B) (optty : A) (e e' : A),\n  opt_set te optid optty = OK e' -> e = e'.\nProof.\n  intros A B te optid optty e e' H.\n  unfold opt_set in H.\n  destruct optid; try monadInv H; eauto with ty.\nQed.", "nl_proof": "Step 1: We need to prove that forall te optid optty e e', opt_set e optid optty = OK e' -> S Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: try (monadInv H) Step 6: Apply tactic: eauto with ty Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:opt_set_sound", "draft": "Require Import Coq.Lists.List.\n\nLemma opt_set_sound_generalized : forall (A : Type) (te optid sg e e' : A),\n    opt_set e optid (proj_sig_res sg) = OK e' -> S.satisf te e' -> wt_opt_assign te optid (sig_res sg).\nProof.\n  intros A te optid sg e e' H H0.\n  red.\n  destruct (proj_sig_res sg).\n  - erewrite set_sound by eauto.\n    auto.\n  - inv H.\n    auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall te optid sg e e', opt_set e optid (proj_sig_res sg) = OK e' -> S Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: red Step 5: Case analysis by destructing a value Step 6: Apply tactic: - erewrite S Step 7: Apply tactic: set_sound by eauto Step 8: Solve automatically using known facts Step 9: Apply tactic: - inv H Step 10: Solve automatically using known facts Step 11: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:type_stmt_incr", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma type_stmt_implication : forall te tret s e e',\n  type_stmt tret e s = OK e' -> S.satisf te e' -> wt_stmt te tret s.\nProof.\n  induction s; simpl; intros;\n  try (monadInv H); \n  eauto with ty.\nQed.", "nl_proof": "Step 1: We need to prove that forall te tret s e e', type_stmt tret e s = OK e' -> S Step 2: Proceed by induction on s Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: try (monadInv T) Step 6: Apply tactic: eauto with ty Step 7: Apply tactic: - destruct tret, o Step 8: Apply tactic: try (monadInv T) Step 9: Apply tactic: eauto with ty Step 10: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:type_stmt_sound", "draft": "Require Import Coq.Lists.List.\n\nLemma type_stmt_sound_generalized : forall (te : Type) (tret s e e' : Type),\n    type_stmt tret e s = OK e' -> S.satisf te e' -> wt_stmt te tret s.\nProof.\n  induction s; simpl; intros;\n  try (monadInv H);\n  try constructor;\n  eauto using type_assign_sound, type_expr_sound with ty.\nQed.", "nl_proof": "Step 1: We need to prove that forall te tret s e e', type_stmt tret e s = OK e' -> S Step 2: Proceed by induction on s Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: try (monadInv T) Step 6: Apply tactic: - constructor Step 7: Apply tactic: - constructor Step 8: Apply tactic: eauto using type_assign_sound Step 9: Apply tactic: - constructor Step 10: Apply tactic: eauto using type_expr_sound with ty Step 11: Apply tactic: - constructor", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:type_function_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma type_function_sound : forall f env, type_function f = OK env -> wt_function env f.\nProof.\n  intros f env H.\n  generalize H.\n  unfold type_function.\n  monadInv H.\n  assert (satisf env x0) by (apply solve_sound; auto).\n  constructor; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall f env, type_function f = OK env -> wt_function env f Step 2: Introduce variables and assumptions Step 3: Apply tactic: generalize H Step 4: Unfold a definition Step 5: Introduce variables and assumptions Step 6: Apply tactic: monadInv T Step 7: Apply tactic: assert (S Step 8: Apply tactic: satisf env x0) by (apply S Step 9: Apply tactic: solve_sound Step 10: Solve automatically using known facts Step 11: Apply tactic: constructor", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:wt_is_call_cont", "draft": "Require Import Coq.Logic.Classical.\n\nLemma wt_is_call_cont : forall env tret k, wt_cont env tret k -> is_call_cont k -> wt_cont_call k tret.\nProof.\n  intros env tret k H1 H2.\n  destruct H1; try contradiction; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall env tret k, wt_cont env tret k -> is_call_cont k -> wt_cont_call k tret Step 2: Case analysis by destructing a value Step 3: Introduce variables and assumptions Step 4: Apply tactic: contradiction || auto Step 5: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:call_cont_wt", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma call_cont_wt : forall env tret k, wt_cont env tret k -> wt_cont_call (call_cont k) tret.\nProof.\n  induction 1; simpl; auto; inversion H; subst; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall env tret k, wt_cont env tret k -> wt_cont_call (call_cont k) tret Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Apply tactic: inversion H Step 6: Apply tactic: subst Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:wt_env_assign", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma wt_env_update_same : forall (env : list (nat * nat)) (id : nat) (e v : nat),\n    (forall x, In x env -> fst x = id -> snd x = v) ->\n    (forall x, In x ((id, e) :: env) -> fst x = id -> snd x = e).\nProof.\n  intros env id e v H x H1 H2.\n  red in H1.\n  destruct H1 as [H1|H1].\n  - rewrite H1 in H2.\n    simpl in H2.\n    congruence.\n  - simpl in H2.\n    apply H in H1.\n    + congruence.\n    + assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall env id e v, wt_env env e -> Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: gsspec in H1 Step 7: Case analysis by destructing a value Step 8: Apply tactic: - congruence Step 9: Apply tactic: - auto Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:def_env_assign", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.MSets.MSetPositive.\nRequire Import Coq.MSets.MSetProperties.\nRequire Import PArith.\n\nLemma def_env_set : forall f e id v, def_env f e -> def_env f (PTree.set id v e).\nProof.\n  intros f e id v Hdef.\n  red in Hdef |- *.\n  intros x Hx.\n  rewrite PTree.gsspec.\n  destruct (Pos.eq_dec id x).\n  - subst. exists v. reflexivity.\n  - apply Hdef. assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall f e id v, def_env f e -> def_env f (PTree Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: gsspec Step 7: Case analysis by destructing a value Step 8: Provide an existential witness Step 9: Solve automatically using known facts Step 10: Solve automatically using known facts Step 11: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:wt_env_set_params", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma val_step_env_il_vl : forall (env : list nat) (il : list nat) (vl : list nat), \n  (forall i, In i il -> i < length env) -> \n  (forall v, In v vl -> v < length env) -> \n  length il = length vl -> \n  (forall n, In n (map (fun i => nth i env 0) il) -> n < length env).\nProof.\n  intros env il vl H1 H2 H3 n H4.\n  apply in_map_iff in H4.\n  destruct H4 as [i [H5 H6]].\n  subst n.\n  apply H1 in H6.\n  rewrite H5.\n  apply nth_lt.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall env il vl, Val Step 2: Proceed by induction on il as [ | i il] Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Apply tactic: try contradiction Step 7: Apply tactic: - red Step 8: Introduce variables and assumptions Step 9: Rewrite using an equality Step 10: Apply tactic: gempty in H0 Step 11: Apply tactic: discriminate", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:def_set_params", "draft": "Require Import Coq.MSets.MSetPositive.\nRequire Import Coq.MSets.MSetProperties.\nRequire Import Coq.MSets.MSetFacts.\n\nLemma in_ptree_get_exists : forall (A : Type) (id : positive) (il : list positive) (vl : list A),\n  In id il -> exists v, PTree.get id (List.combine il vl) = Some v.\nProof.\n  induction il as [|i il]; intros vl Hin.\n  - inversion Hin.\n  - destruct vl as [|v vl]; simpl.\n    + destruct Hin as [H|H].\n      * congruence.\n      * apply IHil in H; destruct H; eauto.\n    + destruct Hin as [H|H].\n      * subst. rewrite PTree.gss. econstructor; eauto.\n      * specialize (IHil vl H). destruct IHil as [x Hget].\n        destruct (Pos.eq_dec i id).\n        ** subst. rewrite PTree.gss. econstructor; eauto.\n        ** rewrite PTree.gso; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall id il vl, In id il -> exists v, PTree Step 2: Proceed by induction on il as [ | i il] Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - contradiction Step 6: Apply tactic: - destruct vl as [ | v vl] Step 7: Rewrite using an equality Step 8: Apply tactic: gsspec Step 9: Case analysis by destructing a value Step 10: Apply tactic: econstructor Step 11: Apply tactic: eauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:wt_env_set_locals", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma wt_env_set_locals : forall (env : list Type) (il : list nat) (e : list nat),\n    wt_env env e -> wt_env env (set_locals il e).\nProof.\n  induction il as [| i il]; simpl; intros; auto.\n  apply wt_env_assign; auto.\n  exact I.\nQed.", "nl_proof": "Step 1: We need to prove that forall env il e, wt_env env e -> wt_env env (set_locals il e) Step 2: Proceed by induction on il as [ | i il] Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - auto Step 6: Apply tactic: - apply wt_env_assign Step 7: Solve automatically using known facts Step 8: Apply tactic: exact I Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:def_set_locals", "draft": "Require Import Coq.MSets.MSetPositive.\nRequire Import Coq.PArith.BinPos.\nRequire Import Coq.Arith.PeanoNat.\n\nLemma PTree_get_exists : forall (A : Type) (id : positive) (il : list positive) (e : A),\n    (exists v, PositiveMap.find id (fold_left (fun (m : PositiveMap.t A) (i : positive) => PositiveMap.add i e m) il (PositiveMap.empty A)) = Some v) ->\n    In id il.\nProof.\n  induction il as [|i il]; simpl; intros e [v H].\n  - rewrite PositiveMap.gempty in H. discriminate.\n  - rewrite PositiveMap.gsspec in H.\n    destruct (PositiveMap.E.eq_dec id i).\n    + subst; left; reflexivity.\n    + right; apply IHil with e; exists v; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall id il e, (exists v, PTree Step 2: Proceed by induction on il as [ | i il] Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - tauto Step 6: Apply tactic: - rewrite PTree Step 7: Apply tactic: gsspec Step 8: Case analysis by destructing a value Step 9: Apply tactic: econstructor Step 10: Apply tactic: eauto Step 11: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:wt_find_label", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma wt_find_label : forall env tret lbl s k,\n  wt_stmt env tret s -> wt_cont env tret k ->\n  match find_label lbl s k with\n  | Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n  | None => True\n  end.\nProof.\n  induction s; intros; inv H; simpl; auto; \n  try (assert (wt_cont env tret (Kseq s2 k)) by constructor; \n       specialize (IHs1 _ H1 H0); destruct find_label; auto).\nQed.", "nl_proof": "Step 1: We need to prove that forall env tret lbl s k, wt_stmt env tret s -> wt_cont env tret k -> match find_label lbl s k with | Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k' | None => True end Step 2: Proceed by induction on s Step 3: Introduce variables and assumptions Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Apply tactic: - inv WS Step 7: Apply tactic: assert (wt_cont env tret (Kseq s2 k)) by (construc Step 8: Solve automatically using known facts Step 9: Apply tactic: specialize (IHs1 _ H1 H) Step 10: Case analysis by destructing a value Step 11: Solve automatically using known facts", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:type_constant_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_constant_inject : forall f sp cst v,\n  eval_constant ge sp cst = Some v ->\n  exists tv, eval_constant tge sp (transl_constant cst) = Some tv /\\ Val.inject f v tv.\nProof.\n  intros f sp cst v EV. destruct cst; simpl in EV; inv EV; eexists; split; eauto; apply VHT.\nQed.", "nl_proof": "Step 1: We need to prove that forall sp cst v, eval_constant ge sp cst = Some v -> Val Step 2: Introduce variables and assumptions Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: inv EV Step 7: Apply tactic: VHT Step 8: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:type_unop_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall op v1 v, eval_unop op v1 = Some v -> Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: VHT' Step 7: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:type_binop_sound", "draft": "Require Import Coq.Lists.List.\nLemma eval_binop_compat : forall (f : Type) (op : nat) (v1 tv1 v2 tv2 v : nat) (m tm : list nat),\n  eval_binop op v1 v2 m = Some v -> Val.inject f v1 tv1 -> Val.inject f v2 tv2 -> Mem.inject f m tm ->\n  exists tv, eval_binop op tv1 tv2 tm = Some tv /\\ Val.inject f v tv.\nProof.\n  intros.\n  destruct v1; destruct v2; simpl in *; try discriminate.\n  destruct op; simpl in *; try discriminate.\n  all: try (eexists; split; eauto; fail).\nQed.", "nl_proof": "Step 1: We need to prove that forall op v1 v2 m v, eval_binop op v1 v2 m = Some v -> Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: VHT' Step 7: Case analysis by destructing a value Step 8: Apply tactic: VHT Step 9: Apply tactic: Qed", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:wt_eval_expr", "draft": "Require Import Coq.Lists.List.\nLemma eval_expr_sound : forall (ge : Type) (sp : Type) (e : Type) (m : Type) (a : Type) (v : Type) (env : Type), eval_expr ge sp e m a v -> forall (t : Type), wt_expr env a t -> wt_env env e -> Val.\nProof.\n  induction 1; intros t WT WTe; inv WT; eapply type_constant_sound; eauto; inv WT; replace t with (snd (type_unop op)) by (rewrite H3); auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall env sp e m a v, eval_expr ge sp e m a v -> forall t, wt_expr env a t -> wt_env env e -> Val Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Apply tactic: - inv WT Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Apply tactic: - inv WT Step 8: Apply tactic: eapply type_constant_sound Step 9: Apply tactic: eauto Step 10: Apply tactic: - inv WT Step 11: Apply tactic: replace t with (snd (type_unop op)) by (rewrite H3", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:wt_eval_exprlist", "draft": "Require Import Coq.Lists.List.\n\nLemma wt_eval_exprlist : forall (ge : genv) (env : env) (sp : val) (e : env) (m : mem) (al : list expr) (vl : list val),\n  eval_exprlist ge sp e m al vl ->\n  forall (tl : list type),\n  list_forall2 (wt_expr env) al tl ->\n  wt_env env e ->\n  Val.has_type_list vl tl.\nProof.\n  induction 1; intros tl WT WTE.\n  - inv WT. simpl. auto.\n  - inv WT. simpl. split.\n    + eapply wt_eval_expr; eauto.\n    + apply IHeval_exprlist; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall env sp e m al vl, eval_exprlist ge sp e m al vl -> forall tl, list_forall2 (wt_expr env) al tl -> wt_env env e -> Val Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Apply tactic: inv WT Step 5: Simplify the goal by computation Step 6: Apply tactic: - auto Step 7: Apply tactic: - split Step 8: Apply tactic: eapply wt_eval_expr Step 9: Apply tactic: eauto Step 10: Apply tactic: eauto Step 11: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:wt_find_funct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v fd, Genv Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply Genv Step 4: Apply tactic: find_funct_prop Step 5: Apply tactic: eauto Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:subject_reduction", "draft": "Require Import Coq.Lists.List.\n\nLemma step_preserves_wt_state : forall (ge : Type) (st1 t st2 : Type) (step : ge -> st1 -> t -> st2 -> Prop) (wt_state : st1 -> Prop),\n  (forall (st1 : st1) (t0 : t) (st2 : st2), step ge st1 t0 st2 -> wt_state st1 -> wt_state st2).\nProof.\n  intros ge st1 t st2 step wt_state.\n  intros st1' t0 st2' STEP WT.\n  inversion WT.\n  inversion STEP.\n  econstructor.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall st1 t st2, step ge st1 t st2 -> forall (WT: wt_state st1), wt_state st2 Step 2: Case analysis by destructing a value Step 3: Introduce variables and assumptions Step 4: Apply tactic: inv WT Step 5: Apply tactic: - inv WT_CONT Step 6: Apply tactic: econstructor Step 7: Apply tactic: eauto Step 8: Apply tactic: inv H Step 9: Apply tactic: - inv WT_CONT Step 10: Apply tactic: econstructor Step 11: Apply tactic: eauto", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:subject_reduction_star", "draft": "Require Import Coq.Program.Equality.\n\nLemma subject_reduction_star : forall ge step wt_state st1 t st2, \n  (forall st1 t st2, step ge st1 t st2 -> forall (WT: wt_state st1), wt_state st2) ->\n  star step ge st1 t st2 -> forall (WT: wt_state st1), wt_state st2.\nProof.\n  intros ge step wt_state st1 t st2 Hstep Hstar.\n  dependent induction Hstar; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall st1 t st2, star step ge st1 t st2 -> forall (WT: wt_state st1), wt_state st2 Step 2: Proceed by induction on 1 Step 3: Apply tactic: eauto using subject_reduction Step 4: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:wt_initial_state", "draft": "Require Import Coq.Lists.List.\n\nLemma initial_state_wt_state : forall (p : Type) (S : Type) (initial_state : p -> S -> Prop) (wt_state : S -> Prop),\n  (forall (p0 : p) (S0 : S), initial_state p0 S0 -> wt_state S0) ->\n  forall (p0 : p) (S0 : S), initial_state p0 S0 -> wt_state S0.\nProof.\n  intros p S initial_state wt_state H p0 S0 H0.\n  apply H with (p0 := p0) (S0 := S0).\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall S, initial_state p S -> wt_state S Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: constructor Step 5: Apply tactic: eapply Genv Step 6: Apply tactic: find_funct_ptr_prop Step 7: Apply tactic: eauto Step 8: Rewrite using an equality Step 9: Apply tactic: constructor Step 10: Rewrite using an equality Step 11: Apply tactic: constructor", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:known_id_sound_1", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma fold_left_in : forall (A B : Type) (add : B -> A -> B) (l : list A) (ki : B) (id : A) (x : unit),\n  (fold_left add l ki) id = Some x -> In id l \\/ ki id = Some x.\nProof.\n  intros A B add l ki id x H.\n  induction l as [|i l IH] in ki, H |- *.\n  - simpl in H. right; auto.\n  - simpl in H. apply IH in H.\n    destruct H as [H|H].\n    + left; right; auto.\n    + left; left; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall f id x, (known_id f)!id = Some x -> In id f Step 2: Unfold a definition Step 3: Apply tactic: set (add := fun (ki: known_idents) (id: ident) => Step 4: Apply tactic: set id tt ki) Step 5: Introduce variables and assumptions Step 6: Apply tactic: assert (REC: forall l ki, (fold_left add l ki)!id Step 7: Apply tactic: { induction l as [ | i l ] Step 8: Simplify the goal by computation Step 9: Introduce variables and assumptions Step 10: Apply tactic: - auto Step 11: Apply tactic: - apply IHl in H0", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:known_id_sound_2", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma known_id_sound : forall f id, is_known (known_id f) id = true -> In id (f.(fn_params) ++ f.(fn_vars)).\nProof.\n  intros f id H.\n  unfold is_known in H.\n  destruct ((known_id f) ! id) eqn:E.\n  - eapply known_id_sound_1 in E.\n    destruct E; [left|right]; assumption.\n  - discriminate.\nQed.", "nl_proof": "Step 1: We need to prove that forall f id, is_known (known_id f) id = true -> In id f Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: try discriminate Step 6: Apply tactic: eapply known_id_sound_1 Step 7: Apply tactic: eauto Step 8: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminortyping:eval_safe_expr", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma eval_safe_expr : forall ge f sp e m a,\n  def_env f e ->\n  safe_expr (known_id f) a = true ->\n  exists v, eval_expr ge sp e m a v.\nProof.\n  induction a; simpl; intros; try discriminate.\n  - apply known_id_sound_2 in H0.\n    destruct H0 as [v H0].\n    exists v.\n    constructor.\n    assumption.\n  - destruct (eval_constant ge sp c) as [v|] eqn:E.\n    + exists v.\n      constructor.\n      assumption.\n    + discriminate.\nQed.", "nl_proof": "Step 1: We need to prove that forall ge f sp e m a, def_env f e -> safe_expr (known_id f) a = true -> exists v, eval_expr ge sp e m a v Step 2: Proceed by induction on a Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - apply known_id_sound_2 in H0 Step 6: Case analysis by destructing a value Step 7: Provide an existential witness Step 8: Apply tactic: constructor Step 9: Solve automatically using known facts Step 10: Apply tactic: - destruct (eval_constant ge sp c) as [v|] eqn:E Step 11: Provide an existential witness", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:reachable_trans", "draft": "Lemma reachable_trans : forall (n1 n2 : nat), reachable n1 n2 -> forall (n3 : nat), reachable n2 n3 -> reachable n1 n3.\nProof.\n  induction 1; eauto using reachable.\nQed.", "nl_proof": "Step 1: We need to prove that forall n1 n2, reachable n1 n2 -> forall n3, reachable n2 n3 -> reachable n1 n3 Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Apply tactic: - auto Step 5: Apply tactic: - econstructor Step 6: Apply tactic: eauto Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:reachable_right", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma reachable_right : forall n1 n2 n3 i, reachable n1 n2 -> code!n2 = Some i -> In n3 (successors i) -> reachable n1 n3.\nProof. econstructor; eauto. Qed.", "nl_proof": "Step 1: We need to prove that forall n1 n2 n3 i, reachable n1 n2 -> code!n2 = Some i -> In n3 (successors i) -> reachable n1 n3 Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Solve automatically using known facts Step 5: Apply tactic: econstructor Step 6: Apply tactic: eauto Step 7: Apply tactic: constructor Step 8: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:optge_refl", "draft": "Lemma optge_refl : forall (A : Type) (ol : option A), optge ol ol.\nProof. intros A ol. destruct ol; constructor. Qed.", "nl_proof": "Step 1: We need to prove that forall ol, optge ol ol", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:optge_trans", "draft": "Require Import Coq.Program.Basics.\n\nLemma optge_trans : forall (A : Type) (ol1 ol2 ol3 : option A) (ge : A -> A -> Prop),\n  (forall x y z : A, ge x y -> ge y z -> ge x z) ->\n  (forall (x y : A), ge x y \\/ ge y x) ->\n  (forall o1 o2, optge ge o1 o2 <-> match o1, o2 with\n    | Some x, Some y => ge x y\n    | Some _, None => True\n    | None, Some _ => False\n    | None, None => True\n    end) ->\n  optge ge ol1 ol2 -> optge ge ol2 ol3 -> optge ge ol1 ol3.\nProof.\n  intros A ol1 ol2 ol3 ge TRANS TOTAL SPEC.\n  intros H1 H2.\n  rewrite SPEC in H1, H2.\n  rewrite SPEC.\n  destruct ol1 as [x|]; destruct ol2 as [y|]; destruct ol3 as [z|];\n  try contradiction; try auto.\n  apply TRANS with y; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall ol1 ol2 ol3, optge ol1 ol2 -> optge ol2 ol3 -> optge ol1 ol3 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Apply tactic: inv H Step 5: Apply tactic: constructor Step 6: Apply tactic: eapply L Step 7: Apply tactic: ge_trans Step 8: Apply tactic: eauto Step 9: Apply tactic: constructor Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:optge_abstr_value", "draft": "Require Import Coq.Arith.Arith.\nLemma optge_trans : forall (st st' n : nat), optge st st' -> optge st' n -> optge st n.\nProof.\n  intros st st' n H H0.\n  unfold optge in *.\n  inv H.\n  inv H0.\n  apply ge_bot.\nQed.", "nl_proof": "Step 1: We need to prove that forall st st' n, optge st Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: inv H Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: ge_bot Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:fixpoint_from_charact", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma fixpoint_from_charact : forall start res,\n  fixpoint_from start = Some res ->\n  exists st, steps start st /\\ NS.pick (worklist st) = None /\\ res = (L.bot, aval st).\nProof.\n  intros start res H.\n  eapply (PrimIter.iterate_prop _ _ step \n    (fun st => steps start st)\n    (fun res => exists st, steps start st /\\ NS.pick (worklist st) = None /\\ res = (L.bot, aval st))); eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall start res, fixpoint_from start = Some res -> exists st, steps start st /\\ NS Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: eapply (PrimIter Step 5: Apply tactic: iterate_prop _ _ step Step 6: Apply tactic: (fun st => steps start st) Step 7: Apply tactic: (fun res => exists st, steps start st /\\ NS Step 8: Apply tactic: pick (worklist st) = None /\\ res = (L Step 9: Apply tactic: bot, aval st))) Step 10: Apply tactic: eauto Step 11: Introduce variables and assumptions", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:step_incr", "draft": "Require Import Coq.Lists.List.\nLemma step_incr : forall (n : nat) (s1 s2 : state), step s1 = inr s2 -> optge (aval s2 n) (aval s1 n) /\\ (visited s1 n -> visited s2 n).\nProof.\n  intros n s1 s2 Hstep.\n  unfold step in Hstep.\n  destruct (worklist s1) as [[p rem]|] eqn:Hwork; try discriminate.\n  destruct (code!p) as [instr|] eqn:Hinstr; try discriminate.\n  inv Hstep.\n  generalize (propagate_succ_list_charact (transf p (abstr_value p s1)) (successors instr) {| aval := aval s1; visited := visited s1; worklist := rem |}).\n  intros [H1 H2].\n  split.\n  - apply H1.\n  - apply H2.\nQed.", "nl_proof": "Step 1: We need to prove that forall n s1 s2, step s1 = inr s2 -> optge s2 Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: pick (worklist s1)) as [[p rem] | ] Step 6: Apply tactic: try discriminate Step 7: Case analysis by destructing a value Step 8: Apply tactic: inv H Step 9: Apply tactic: + generalize (propagate_succ_list_charact Step 10: Apply tactic: (transf p (abstr_value p s1)) Step 11: Apply tactic: (successors instr)", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:steps_incr", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma steps_incr : forall (n : nat) (s1 s2 : state), steps s1 s2 -> optge (aval s2 n) (aval s1 n) /\\ (visited s1 n -> visited s2 n).\nProof.\n  induction 1.\n  - split; auto.\n  - destruct IHsteps.\n    exploit step_incr.\n    eauto.\n    intros [? ?].\n    split.\n    + eapply optge_trans; eauto.\n    + auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall n s1 s2, steps s1 s2 -> optge s2 Step 2: Proceed by induction on 1 Step 3: Apply tactic: - split Step 4: Apply a theorem or hypothesis Step 5: Solve automatically using known facts Step 6: Apply tactic: - destruct IHsteps Step 7: Apply tactic: exploit (step_incr n) Step 8: Apply tactic: eauto Step 9: Introduce variables and assumptions Step 10: Split a conjunction into separate goals Step 11: Apply tactic: eapply optge_trans", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:step_state_good_2", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma good_state_preservation_template : forall (A : Type) (st pc rem : A) (good_state : A -> Prop),\n  good_state st -> good_state pc.\nProof.\n  intros A st pc rem good_state H.\n  generalize H.\n  intro H1.\n  constructor.\n  simpl.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall st pc rem, good_state st -> NS Step 2: Introduce variables and assumptions Step 3: Introduce variables and assumptions Step 4: Apply tactic: generalize (NS Step 5: Apply tactic: pick_some _ _ _ PICK) Step 6: Apply tactic: intro PICK2 Step 7: Apply tactic: constructor Step 8: Simplify the goal by computation Step 9: Introduce variables and assumptions Step 10: Apply tactic: exploit GOOD1 Step 11: Apply tactic: eauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:steps_state_good", "draft": "Require Import Coq.Lists.List.\nLemma state_preservation : forall (State : Type) (good_state : State -> Prop) (step : State -> State -> Prop) (st1 st2 : State), step st1 st2 -> good_state st1 -> good_state st2.\nProof.\n  intros State good_state step st1 st2 Hstep Hgood.\n  induction Hstep; auto.\n  unfold step in Hstep.\n  destruct st1.\n  destruct (worklist s2) as [[n rem] | ] eqn:PICK; try discriminate.\n  inversion Hstep.\n  eapply step_state_good; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall st1 st2, steps st1 st2 -> good_state st1 -> good_state st2 Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Apply tactic: - auto Step 5: Apply tactic: - unfold step in e Step 6: Case analysis by destructing a value Step 7: Apply tactic: pick (worklist s2)) as [[n rem] | ] eqn:PICK Step 8: Apply tactic: try discriminate Step 9: Case analysis by destructing a value Step 10: Apply tactic: inv e Step 11: Apply tactic: eapply step_state_good", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:start_state_good", "draft": "Require Import Coq.Lists.List. Import ListNotations.\nRequire Import Coq.MSets.MSetPositive.\nRequire Import Coq.MSets.MSetProperties.\nRequire Import Coq.MSets.MSetFacts.\n\nLemma good_state_start_state : forall (enode eval : PositiveSet.t), PositiveSet.Subset enode eval -> PositiveSet.Subset eval enode -> good_state (start_state enode eval).\nProof.\n  intros enode eval H1 H2.\n  unfold start_state.\n  constructor.\n  - apply PositiveSet.eq_leibniz.\n    apply PositiveSet.Subset_antisym; assumption.\n  - simpl.\n    reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall enode eval, good_state (start_state enode eval) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: constructor Step 5: Simplify the goal by computation Step 6: Introduce variables and assumptions Step 7: Apply tactic: - subst n Step 8: Rewrite using an equality Step 9: Apply tactic: add_spec Step 10: Solve automatically using known facts Step 11: Apply tactic: - rewrite PTree", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:start_state_nodeset_good", "draft": "Require Import Coq.MSets.MSetPositive.\nRequire Import Coq.PArith.PArith.\nRequire Import Coq.Lists.List.\n\nLemma good_state_start_state_nodeset : forall (enodes : PTree.t (list positive)), good_state (start_state_nodeset enodes).\nProof.\n  intros enodes.\n  unfold start_state_nodeset.\n  constructor.\n  simpl.\n  intros.\n  left.\n  rewrite PTree.gempty in H.\n  congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall enodes, good_state (start_state_nodeset enodes) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: constructor Step 5: Simplify the goal by computation Step 6: Introduce variables and assumptions Step 7: Apply tactic: - left Step 8: Solve automatically using known facts Step 9: Apply tactic: - rewrite PTree Step 10: Apply tactic: gempty in H Step 11: Apply tactic: congruence", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:start_state_allnodes_good", "draft": "Require Import Coq.Lists.List. Import ListNotations.\nRequire Import Coq.FSets.FMapInterface.\nRequire Import Coq.FSets.FMapFacts.\n\nLemma good_state_start_state_allnodes_template : \n  forall (A : Type) (all_nodes : list A) (start_state : A) (PTree : Type) \n         (CODE : PTree) (instr : A) (NS : A -> A -> Prop) \n         (H : exists instr : A, CODE = CODE),\n  good_state start_state all_nodes.\nProof.\n  intros A all_nodes start_state PTree CODE instr NS H.\n  destruct H as [instr CODE].\n  constructor.\n  simpl.\n  left.\n  eapply NS.\n  apply all_nodes_spec.\n  eauto.\n  rewrite PTree.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that good_state start_state_allnodes Step 2: Unfold a definition Step 3: Apply tactic: constructor Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Apply tactic: - destruct H as [instr CODE] Step 7: Apply tactic: left Step 8: Apply tactic: eapply NS Step 9: Apply tactic: all_nodes_spec Step 10: Apply tactic: eauto Step 11: Apply tactic: - rewrite PTree", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:reachable_visited", "draft": "Require Import Coq.Relations.Relation_Operators.\n\nLemma good_state_preservation : forall (A : Type) (good_state : A -> Prop) (Step : A -> A -> Prop) (st : A),\n  good_state st ->\n  (forall x y, Step x y -> good_state x -> good_state y) ->\n  clos_refl_trans A Step st st -> good_state st.\nProof.\n  intros A good_state Step st Hgood Hpres Hrt.\n  induction Hrt; [assumption|].\n  apply Hpres with x; [assumption|].\n  apply IHHrt.\nQed.", "nl_proof": "Step 1: We need to prove that forall st, good_state st -> NS Step 2: Introduce variables and assumptions Step 3: Proceed by induction on 1 Step 4: Introduce variables and assumptions Step 5: Apply tactic: - auto Step 6: Apply tactic: - eapply IHreachable Step 7: Apply tactic: eauto Step 8: Apply tactic: exploit GOOD1 Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Apply tactic: eelim NS", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:fixpoint_solution", "draft": "Require Import Coq.Lists.List.\nImport ListNotations.\n\nLemma fixpoint_solution : forall (A : Type) (code : PTree.t A) (successors : A -> list positive) (transf : positive -> L.t -> L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive),\n  fixpoint code successors transf = Some res ->\n  code ! n = Some instr -> In s (successors instr) ->\n  L.ge (res !! s) (transf n (res !! n)).\nProof.\n  intros A code successors transf res n instr s Hfix Hcode Hin.\n  exploit (make_predecessors_correct_2 code successors).\n  - eauto.\n  - intros Hpred.\n    assert (state_invariant (mkstate res nil)).\n    { eapply fixpoint_from_charact; eauto. }\n    eapply analyze_invariant; eauto.\n    eapply reachable_exit_points_predecessor; eauto.\n    contradiction.\nQed.", "nl_proof": "Step 1: We need to prove that forall ep ev res n instr s, fixpoint ep ev = Some res -> code!n = Some instr -> In s (successors instr) -> (forall n, L Step 2: We need to prove that forall res n instr s, fixpoint = Some res -> code!n = Some instr -> In s (successors instr) -> (forall n a, code!n = None -> L Step 3: We need to prove that forall res n instr s, fixpoint = Some res -> code!n = Some instr -> In s (successors instr) -> L Step 4: Unfold a definition Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Apply tactic: exploit (make_predecessors_correct_2 code) Step 9: Apply tactic: assert (state_invariant (mkstate res nil)) Step 10: Apply tactic: exploit fixpoint_from_charact Step 11: Apply tactic: eauto Step 12: Apply tactic: eapply analyze_invariant Step 13: Apply tactic: eauto Step 14: Introduce variables and assumptions Step 15: Apply tactic: eauto Step 16: Introduce variables and assumptions Step 17: Case analysis by destructing a value Step 18: Apply tactic: elim H2 Step 19: Apply tactic: exploit steps_state_good Step 20: Apply tactic: - exploit reachable_exit_points_predecessor Step 21: Simplify the goal by computation Step 22: Apply tactic: eauto Step 23: Apply tactic: eexact CS Step 24: Introduce variables and assumptions Step 25: Apply a theorem or hypothesis Step 26: Introduce variables and assumptions Step 27: Apply tactic: elim (H4 n) Step 28: Introduce variables and assumptions Step 29: Unfold a definition Step 30: Introduce variables and assumptions Step 31: Rewrite using an equality Step 32: Apply tactic: eapply DS Step 33: Apply tactic: contradiction", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:fixpoint_entry", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma fixpoint_entrypoint_invariant : forall (A : Type) (ep : A) (ev : list A) (res : list A),\n  fixpoint ep ev = Some res -> nth_error res (entrypoint ep) = Some L.\nProof.\n  intros A ep ev res H.\n  assert (state_invariant (mkstate res nil)).\n  { exploit fixpoint_from_charact; eauto. }\n  eapply analyze_invariant; eauto.\n  elim H0.\n  exploit (steps_incr ep); eauto.\n  simpl.\n  eauto.\n  simpl.\n  unfold entrypoint.\n  rewrite H1.\n  gss.\n  fold predecessors.\nQed.", "nl_proof": "Step 1: We need to prove that forall ep ev res, fixpoint ep ev = Some res -> L Step 2: We need to prove that forall res, fixpoint = Some res -> res!!entrypoint = L Step 3: Unfold a definition Step 4: Introduce variables and assumptions Step 5: Introduce variables and assumptions Step 6: Apply tactic: assert (state_invariant (mkstate res nil)) Step 7: Apply tactic: exploit fixpoint_from_charact Step 8: Apply tactic: eapply analyze_invariant Step 9: Apply tactic: eauto Step 10: Apply tactic: eauto Step 11: Introduce variables and assumptions Step 12: Apply tactic: elim H0 Step 13: Apply tactic: exploit (steps_incr ep) Step 14: Simplify the goal by computation Step 15: Apply tactic: eauto Step 16: Introduce variables and assumptions Step 17: Simplify the goal by computation Step 18: Apply a theorem or hypothesis Step 19: Rewrite using an equality Step 20: Unfold a definition Step 21: Apply tactic: gss Step 22: Apply tactic: fold predecessors", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:fixpoint_allnodes_solution", "draft": "Require Import Coq.Lists.List.\nImport ListNotations.\n\nLemma fixpoint_allnodes_solution_lemma : forall (L : Type) (ge : L -> L -> Prop) (res : list L) (n : nat) (instr s : nat) (code : list (nat * nat)) (successors : nat -> list nat) (transf : nat -> L -> L),\n  fixpoint_allnodes = Some res ->\n  nth_error code n = Some instr ->\n  In s (successors instr) ->\n  ge (nth n res (default_L L)) (transf s (nth s res (default_L L))).\nProof.\n  intros L ge res n instr s code successors transf H1 H2 H3.\n  exploit fixpoint_allnodes_solution.\n  apply H1.\n  apply H2.\n  apply H3.\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall res n instr s, fixpoint_allnodes = Some res -> code!n = Some instr -> In s (successors instr) -> L Step 2: We need to prove that forall res n instr s, fixpoint_allnodes = Some res -> code!n = Some instr -> In s (successors instr) -> L Step 3: Unfold a definition Step 4: Introduce variables and assumptions Step 5: Introduce variables and assumptions Step 6: Apply tactic: exploit (make_predecessors_correct_2 code) Step 7: Apply tactic: exploit fixpoint_from_charact Step 8: Apply tactic: eauto Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Introduce variables and assumptions Step 12: Unfold a definition Step 13: Apply tactic: exploit steps_state_good Step 14: Apply tactic: eapply DS Step 15: Apply tactic: eauto Step 16: Apply tactic: fixpoint_allnodes_solution Step 17: Apply a theorem or hypothesis Step 18: Apply tactic: eauto Step 19: Introduce variables and assumptions Step 20: Apply tactic: Qed Step 21: Apply tactic: exploit (steps_incr n)", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:fixpoint_nodeset_solution", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nRequire Import Coq.Program.Wf.\n\nLemma fixpoint_nodeset_solution : forall enodes res e n instr s,\n  fixpoint_nodeset enodes = Some res ->\n  NS.In e enodes ->\n  reachable code successors e n ->\n  code!n = Some instr ->\n  In s (successors instr) ->\n  L.ge res!!s (transf n res!!n).\nProof.\n  intros enodes res e n instr s H1 H2 H3 H4 H5.\n  unfold fixpoint_nodeset in H1.\n  intros.\n  exploit fixpoint_from_charact; eauto.\n  intros.\n  exploit steps_state_good; eauto.\n  intros.\n  exploit (steps_incr e); eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall enodes res e n instr s, fixpoint_nodeset enodes = Some res -> NS Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: exploit fixpoint_from_charact Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Apply tactic: exploit steps_state_good Step 8: Apply tactic: eauto Step 9: Apply a theorem or hypothesis Step 10: Introduce variables and assumptions Step 11: Apply tactic: exploit (steps_incr e)", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:add_successors_correct", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma add_successors_correct : forall (A : Type) (tolist : list A) (from : A) (pred : A -> list A) (n s : A),\n  In n (pred s) \\/ (n = from /\\ In s tolist) -> In n (add_successors pred from tolist s).\nProof.\n  induction tolist; simpl; intros; intuition.\n  destruct H0; subst; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall tolist from pred n s, In n pred!!!s \\/ (n = from /\\ In s tolist) -> In n (add_successors pred from tolist)!!!s Step 2: Proceed by induction on tolist Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: tauto Step 6: Apply a theorem or hypothesis Step 7: Unfold a definition Step 8: Rewrite using an equality Step 9: Apply tactic: gsspec Step 10: Case analysis by destructing a value Step 11: Apply tactic: subst a", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:make_predecessors_correct_1", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma make_predecessors_correct : forall n instr s,\n  code!n = Some instr -> In s (successors instr) -> In n make_predecessors!!!s.\nProof.\n  set (P := fun m p => m!n = Some instr -> In s (successors instr) -> In n p!!!s).\n  apply fold_rec with (P := P).\n  unfold P.\n  intros.\n  rewrite H1 in H2.\n  discriminate.\n  unfold P.\n  intros.\n  destruct (peq n0 s0).\n  subst.\n  rewrite PTree.gss in H3.\n  inversion H3.\n  subst.\n  apply in_cons.\n  apply H2.\n  assumption.\n  assumption.\n  rewrite PTree.gso in H3.\n  apply H2.\n  assumption.\n  assumption.\n  assumption.\nQed.", "nl_proof": "Step 1: extensionality Step 2: base case Step 3: inductive case Step 4: We need to prove that forall n instr s, code!n = Some instr -> In s (successors instr) -> In n make_predecessors!!!s Step 5: Introduce variables and assumptions Step 6: Apply tactic: set (P := fun m p => m!n = Some instr -> In s (suc Step 7: Apply tactic: In n p!!!s) Step 8: Unfold a definition Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: fold_rec with (P := P) Step 11: Unfold a definition Step 12: Introduce variables and assumptions Step 13: Apply a theorem or hypothesis Step 14: Solve automatically using known facts", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:make_predecessors_correct_2", "draft": "Require Import Coq.Lists.List.\nImport ListNotations.\n\nLemma make_predecessors_correct_2 : forall (n : nat) (instr s : nat),\n  code!n = Some instr -> In s (successors instr) ->\n  exists l, make_predecessors!s = Some l /\\ In n l.\nProof.\n  intros n instr s H1 H2.\n  exploit make_predecessors_correct_1; eauto.\n  unfold make_predecessors!!!.\n  destruct (make_predecessors!s) eqn:E; [|contradiction].\n  exists l; split; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall n instr s, code!n = Some instr -> In s (successors instr) -> exists l, make_predecessors!s = Some l /\\ In n l Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit make_predecessors_correct_1 Step 4: Apply tactic: eauto Step 5: Unfold a definition Step 6: Case analysis by destructing a value Step 7: Simplify the goal by computation Step 8: Introduce variables and assumptions Step 9: Provide an existential witness Step 10: Solve automatically using known facts Step 11: Apply tactic: contradiction", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:reachable_predecessors", "draft": "Require Import Coq.Lists.List.\n\nLemma reachable_predecessors : forall (A : Type) (code : A -> option (list A)) (successors make_predecessors : list A -> list A) (p q : A),\n  reachable code successors p q -> reachable make_predecessors (fun l => l) q p.\nProof.\n  induction 1.\n  - constructor.\n  - exploit make_predecessors_correct_2.\n    eauto.\n    intros.\n    eapply reachable_right.\n    eauto.\n    eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall p q, reachable code successors p q -> reachable make_predecessors (fun l => l) q p Step 2: Proceed by induction on 1 Step 3: Apply tactic: - constructor Step 4: Apply tactic: - exploit make_predecessors_correct_2 Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Apply tactic: eapply reachable_right Step 8: Apply tactic: eauto Step 9: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:exit_points_charact", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma fold_rec_template : forall (A B : Type) (P : B -> Prop) (f : A -> B -> B) (l : list A) (b : B),\n  P b -> (forall (a : A) (b' : B), In a l -> P b' -> P (f a b')) -> P (fold_right f b l).\nProof.\n  intros A B P f l. induction l as [|x xs IH]; intros b Hb Hstep.\n  - exact Hb.\n  - simpl. apply Hstep.\n    + left. reflexivity.\n    + apply IH.\n      * intros a b' Hin Hpb'. apply Hstep with (a := a) (b' := b').\n        right. exact Hin. exact Hpb'.\n      * exact Hb.\nQed.", "nl_proof": "Step 1: extensionality Step 2: base case Step 3: inductive case Step 4: We need to prove that forall n, NS Step 5: Introduce variables and assumptions Step 6: Unfold a definition Step 7: Apply tactic: eapply PTree_Properties Step 8: Apply tactic: fold_rec Step 9: Introduce variables and assumptions Step 10: Rewrite using an equality Step 11: Solve automatically using known facts Step 12: Simplify the goal by computation Step 13: Split a conjunction into separate goals Step 14: Introduce variables and assumptions", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:reachable_exit_points", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma exists_successor : forall (A : Type) (code : list (option A)) (pc : nat), \n  nth_error code pc = Some (Some i) -> exists (x : A), True.\nProof.\n  intros A code pc H.\n  destruct (nth_error code pc) as [v|] eqn:E; try discriminate.\n  destruct v as [x|]; try discriminate.\n  exists x. exact I.\nQed.", "nl_proof": "Step 1: at least one successor that decreases the pc Step 2: otherwise we are an exit point Step 3: We need to prove that forall pc i, code!pc = Some i -> exists x, NS Step 4: Introduce variables and assumptions Step 5: Apply tactic: pattern pc0 Step 6: Apply a theorem or hypothesis Step 7: Introduce variables and assumptions Step 8: Case analysis by destructing a value Step 9: Unfold a definition Step 10: Rewrite using an equality Step 11: Case analysis by destructing a value Step 12: Case analysis by destructing a value Step 13: Apply tactic: try discriminate", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:reachable_exit_points_predecessor", "draft": "Require Import Coq.Lists.List.\nLemma reachable_exit_points_lemma : forall (code : list (nat * nat)) (pc i : nat) (successors : nat -> list nat) (exit_points : list nat),\n  code!pc = Some i -> exists x, In x exit_points /\\ reachable code successors pc x.\nProof.\n  intros code pc i successors exit_points H.\n  exploit reachable_exit_points.\n  apply H.\n  intros [x [H1 H2]].\n  exists x.\n  split.\n  apply H1.\n  apply H2.\nQed.", "nl_proof": "Step 1: We need to prove that forall pc i, code!pc = Some i -> exists x, NS Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit reachable_exit_points Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Provide an existential witness Step 7: Split a conjunction into separate goals Step 8: Solve automatically using known facts Step 9: Apply a theorem or hypothesis Step 10: Solve automatically using known facts Step 11: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:predecessors_correct", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma predecessors_correct : forall n instr s (code : list (nat * instr)) (predecessors : list (nat * list nat)) (successors : instr -> list nat),\n  code!n = Some instr -> In s (successors instr) -> In n predecessors!!!s.\nProof.\n  intros.\n  eapply make_predecessors_correct_1.\n  eauto.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall n instr s, code!n = Some instr -> In s (successors instr) -> In n predecessors!!!s Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: eapply make_predecessors_correct_1 Step 5: Apply tactic: eauto Step 6: Apply tactic: Qed", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:multiple_predecessors", "draft": "Require Import Coq.Lists.List.\nLemma multiple_predecessors : forall (s n1 n2 : nat) (instr1 instr2 : instruction),\n  code!n1 = Some instr1 -> In s (successors instr1) ->\n  code!n2 = Some instr2 -> In s (successors instr2) ->\n  n1 <> n2 -> basic_block_map s = true.\nProof.\n  intros s n1 n2 instr1 instr2 H1 H2 H3 H4 H5.\n  assert (In n1 predecessors!!!s).\n  { eapply predecessors_correct; eauto. }\n  assert (In n2 predecessors!!!s).\n  { eapply predecessors_correct; eauto. }\n  unfold basic_block_map.\n  destruct (predecessors!s); auto.\n  simpl in H, H0.\n  destruct (peq n1 n2); [contradiction|].\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall s n1 instr1 n2 instr2, code!n1 = Some instr1 -> In s (successors instr1) -> code!n2 = Some instr2 -> In s (successors instr2) -> n1 <> n2 -> basic_block_map s = true Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (In n1 predecessors!!!s) Step 4: Apply tactic: eapply predecessors_correct Step 5: Apply tactic: eauto Step 6: Apply tactic: assert (In n2 predecessors!!!s) Step 7: Apply tactic: eapply predecessors_correct Step 8: Apply tactic: eauto Step 9: Unfold a definition Step 10: Case analysis by destructing a value Step 11: Solve automatically using known facts", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:no_self_loop", "draft": "Require Import Coq.Lists.List.\nLemma no_self_loop : forall (n : nat) (instr : list nat),\n  code ! n = Some instr -> In n (successors instr) -> basic_block_map n = true.\nProof.\n  intros n instr H1 H2.\n  unfold basic_block_map.\n  destruct (make_predecessors ! n) eqn:E.\n  - fold predecessors.\n    exploit make_predecessors_correct_1.\n    apply H1.\n    apply H2.\n    intros H3.\n    destruct (in_dec eq_nat_dec n l).\n    + auto.\n    + contradiction.\n  - contradiction.\nQed.", "nl_proof": "Step 1: We need to prove that forall n instr, code!n = Some instr -> In n (successors instr) -> basic_block_map n = true Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Solve automatically using known facts Step 6: Apply tactic: fold predecessors Step 7: Apply tactic: exploit predecessors_correct Step 8: Apply tactic: eauto Step 9: Introduce variables and assumptions Step 10: Case analysis by destructing a value Step 11: Apply tactic: contradiction", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:propagate_successors_charact1", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma incl_app_cons : forall (A : Type) (l1 l2 : list A) (x : A), incl l1 (x :: l2) -> incl l1 l2.\nProof.\n  intros A l1 l2 x H.\n  unfold incl in *.\n  intros a H1.\n  apply H in H1.\n  destruct H1; subst; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall bb succs l st, incl st Step 2: Proceed by induction on succs Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: case (bb a) Step 7: Solve automatically using known facts Step 8: Apply a theorem or hypothesis Step 9: Apply a theorem or hypothesis Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: set (st1 := (mkstate (PMap", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:propagate_successors_charact2", "draft": "Require Import Coq.Lists.List.\nLemma propagate_successors_charact2 : forall (bb : nat -> bool) (succs : list nat) (l : nat) (st : nat) (n : nat),\n  let st' := propagate_successors bb succs l st in\n  (In n succs -> bb n = false -> In n st' /\\ st' n = l) /\\\n  (~In n succs \\/ bb n = true -> st' n = st n).\nProof. tauto. Qed.", "nl_proof": "Step 1: Base case Step 2: Inductive case Step 3: We need to prove that forall bb succs l st n, let st' := propagate_successors bb succs l st in (In n succs -> bb n = false -> In n st' Step 4: Proceed by induction on succs Step 5: Simplify the goal by computation Step 6: Introduce variables and assumptions Step 7: Split a conjunction into separate goals Step 8: Apply tactic: tauto Step 9: Solve automatically using known facts Step 10: Apply tactic: caseEq (bb a) Step 11: Apply tactic: intro Step 12: Apply tactic: elim (IHsuccs l st n) Step 13: Introduce variables and assumptions", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:propagate_successors_invariant", "draft": "Require Import Coq.Lists.List.\nImport ListNotations.\n\nLemma propagate_successors_invariant : forall (basic_block_map : nat -> bool) (code : nat -> option (list nat)) (transf : nat -> nat -> nat) (pc : nat) (instr : list nat) (res : nat -> nat) (rem : list nat),\n  code pc = Some instr ->\n  (forall (n : nat), \n    (In n rem \\/ exists p, In p rem /\\ code p = Some instr /\\ In n (successors instr)) -> \n    res n = transf n (res n)) ->\n  (forall (n : nat), \n    In n (propagate_successors basic_block_map (successors instr) (transf pc (res pc)) (mkstate res rem)).(worklist) \\/ \n    (exists p, In p (propagate_successors basic_block_map (successors instr) (transf pc (res pc)) (mkstate res rem)).(worklist) /\\ \n               code p = Some instr /\\ In n (successors instr)) -> \n    (propagate_successors basic_block_map (successors instr) (transf pc (res pc)) (mkstate res rem)).(aval) n = \n    transf n ((propagate_successors basic_block_map (successors instr) (transf pc (res pc)) (mkstate res rem)).(aval) n)).\nProof.\n  intros basic_block_map code transf pc instr res rem Hcode_inv Hinv.\n  set (l := transf pc (res pc)).\n  generalize (propagate_successors_charact1 basic_block_map (successors instr) l (mkstate res rem)).\n  generalize (propagate_successors_charact2 basic_block_map (successors instr) l (mkstate res rem)).\n  set (st1 := propagate_successors basic_block_map (successors instr) l (mkstate res rem)).\n  intros Hcharact2 Hcharact1.\n  intros n [Hin | [p [Hin_p [Hcode_p Hsucc]]]].\n  - apply Hcharact1 in Hin.\n    destruct Hin as [Hin | [Hin | Hin]]; auto.\n  - apply Hcharact2 in Hin_p.\n    destruct Hin_p as [Hin_p | [Hin_p.\nQed.", "nl_proof": "Step 1: First part: BB entries remain at top Step 2: Second part: monotonicity Step 3: Case 1: n = pc Step 4: Case 2: n <> pc Step 5: Case 2.1: n was already in worklist, still is Step 6: Case 2.2: n was not in worklist Step 7: Amazingly, successors of n do not change. The only way they could change is if they were successors of pc as well, but that gives them two different predecessors, so they are basic block heads, and thus do not change! Step 8: Case 2.2.1: n is a successor of pc. Either it is in the worklist or it did not change Step 9: Case 2.2.2: n is not a successor of pc. It did not change. Step 10: We need to prove that forall pc instr res rem, code!pc = Some instr -> state_invariant (mkstate res (pc :: rem)) -> state_invariant (propagate_successors basic_block_map (successors instr) (transf pc res!!pc) (mkstate res rem)) Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Simplify the goal by computation Step 14: Simplify the goal by computation Step 15: Apply tactic: set (l := transf pc res!!pc) Step 16: Apply tactic: generalize (propagate_successors_charact1 basic_bl Step 17: Apply tactic: (successors instr) l (mkstate res rem)) Step 18: Apply tactic: generalize (propagate_successors_charact2 basic_bl Step 19: Apply tactic: (successors instr) l (mkstate res rem)) Step 20: Apply tactic: set (st1 := propagate_successors basic_block_map", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:propagate_successors_invariant_2", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List. Import ListNotations.\n\nLemma propagate_successors_invariant_2 : forall pc res rem,\n  code!pc = None ->\n  state_invariant (mkstate res (pc :: rem)) ->\n  state_invariant (mkstate res rem).\nProof.\n  intros pc res rem Hcode Hinvariant.\n  destruct Hinvariant as [Hinv1 Hinv2].\n  split; [assumption|].\n  intros p Hp.\n  apply Hinv2.\n  simpl in Hp.\n  destruct Hp as [Hp|Hp]; [left; assumption|right; assumption].\nQed.", "nl_proof": "Step 1: We need to prove that forall pc res rem, code!pc = None -> state_invariant (mkstate res (pc :: rem)) -> state_invariant (mkstate res rem) Step 2: Introduce variables and assumptions Step 3: Introduce variables and assumptions Step 4: Simplify the goal by computation Step 5: Simplify the goal by computation Step 6: Split a conjunction into separate goals Step 7: Simplify the goal by computation Step 8: Introduce variables and assumptions Step 9: Apply a theorem or hypothesis Step 10: Solve automatically using known facts Step 11: Case analysis by destructing a value", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:initial_state_invariant", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma state_invariant_mkstate_template : forall (A : Type) (f : A -> A) (l : list A), \n  state_invariant (mkstate (PMap.init (fun _ => f)) l).\nProof.\n  intros A f l.\n  split.\n  - simpl.\n    intros.\n    repeat rewrite PMap.gi.\n    apply top_ge.\n  - right.\n    simpl.\n    intros.\n    repeat rewrite PMap.gi.\n    apply top_ge.\nQed.", "nl_proof": "Step 1: We need to prove that state_invariant (mkstate (PMap Step 2: Split a conjunction into separate goals Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: right Step 7: Introduce variables and assumptions Step 8: Apply tactic: repeat rewrite PMap Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: top_ge Step 11: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:analyze_invariant", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma analyze_invariant : forall (A : Type) (fixpoint : option A) (res : A),\n  fixpoint = Some res ->\n  state_invariant (mkstate res nil).\nProof.\n  intros A fixpoint res H.\n  unfold fixpoint in H.\n  pattern res.\n  eapply PrimIter.\n  apply iterate_prop.\n  apply state_invariant.\n  destruct fixpoint; try discriminate.\n  injection H; intros; subst.\n  unfold step.\n  simpl.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall res, fixpoint = Some res -> state_invariant (mkstate res nil) Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: pattern res Step 5: Apply tactic: eapply (PrimIter Step 6: Apply tactic: iterate_prop _ _ (step basic_block_map) Step 7: Apply tactic: state_invariant) Step 8: Introduce variables and assumptions Step 9: Case analysis by destructing a value Step 10: Unfold a definition Step 11: Simplify the goal by computation", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:propagate_successors_P", "draft": "Require Import Coq.Lists.List.\n\nLemma propagate_successors_P : forall (bb : nat -> bool) (l : list nat) (P : list nat -> Prop),\n  P l ->\n  forall (succs : list nat) (st : state) (Pstate : state -> Prop),\n  Pstate st ->\n  Pstate (propagate_successors bb succs l st).\nProof.\n  induction succs; simpl; intros; auto.\n  case_eq (bb a); intros; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall bb l, P l -> forall succs st, Pstate st -> Pstate (propagate_successors bb succs l st) Step 2: Proceed by induction on succs Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Apply tactic: case (bb a) Step 7: Solve automatically using known facts Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: red Step 10: Simplify the goal by computation Step 11: Introduce variables and assumptions", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:fixpoint_invariant", "draft": "Require Import Coq.Lists.List.\nLemma fixpoint_invariant : forall (A : Type) (P : A -> Prop) (fixpoint : option (list A)) (res : list A) (pc : nat), fixpoint = Some res -> P (nth pc res (default_value A)).\nProof.\n  intros A P fixpoint res pc H.\n  unfold default_value.\n  destruct fixpoint; try discriminate.\n  injection H; intros; subst.\n  apply H0.\nQed.", "nl_proof": "Step 1: We need to prove that forall res pc, fixpoint = Some res -> P res!!pc Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: pattern res Step 5: Apply tactic: eapply (PrimIter Step 6: Apply tactic: iterate_prop _ _ (step basic_block_map) Pstate) Step 7: Introduce variables and assumptions Step 8: Unfold a definition Step 9: Case analysis by destructing a value Step 10: Apply tactic: (worklist)) Step 11: Apply a theorem or hypothesis", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:empty_spec", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma not_in_empty : forall (A : Type) (n : A), ~In n [].\nProof. intros A n H. inversion H. Qed.", "nl_proof": "Step 1: We need to prove that forall n, ~In n empty Step 2: We need to prove that forall n, ~In n empty Step 3: Introduce variables and assumptions Step 4: Apply tactic: Lemma add_spec: Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: forall n n' s, In n' (add n s) <-> n = n' \\/ In n' Step 7: Apply tactic: In_empty Step 8: Apply tactic: Lemma pick_none: Step 9: Apply tactic: Qed Step 10: Apply tactic: forall s n, pick s = None -> ~In n s Step 11: Introduce variables and assumptions Step 12: Unfold a definition Step 13: Apply tactic: caseEq (PHeap Step 14: Apply tactic: findMin s) Step 15: Introduce variables and assumptions Step 16: Apply tactic: congruence", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:add_spec", "draft": "Require Import Coq.Lists.List.\nImport ListNotations.\n\nLemma in_add : forall (A : Type) (n n' : A) (s : list A), In n' (n :: s) <-> n = n' \\/ In n' s.\nProof.\n  intros A n n' s.\n  split.\n  - intros H.\n    simpl in H.\n    destruct H as [H1 | H2].\n    + left; auto.\n    + right; auto.\n  - intros [H1 | H2].\n    + left; auto.\n    + right; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall n n' s, In n' (add n s) <-> n = n' \\/ In n' s Step 2: We need to prove that forall n n' s, In n' (add n s) <-> n = n' \\/ In n' s Step 3: Introduce variables and assumptions Step 4: Apply tactic: Lemma pick_none: Step 5: Rewrite using an equality Step 6: Apply tactic: forall s n, pick s = None -> ~In n s Step 7: Apply tactic: In_insert Step 8: Introduce variables and assumptions Step 9: Unfold a definition Step 10: Unfold a definition Step 11: Apply tactic: intuition Step 12: Apply tactic: caseEq (PHeap Step 13: Apply tactic: Qed Step 14: Apply tactic: findMin s) Step 15: Introduce variables and assumptions Step 16: Apply tactic: congruence Step 17: Apply a theorem or hypothesis Step 18: Apply tactic: findMin_empty", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:pick_none", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma pick_none_not_in : forall (A : Type) (s : list A) (n : A), pick s = None -> ~In n s.\nProof.\n  intros A s n H.\n  unfold pick in H.\n  case_eq (findMin s); intros.\n  - congruence.\n  - apply findMin_empty in H0.\n    rewrite H0.\n    intro H1; contradiction.\nQed.", "nl_proof": "Step 1: We need to prove that forall s n, pick s = None -> ~In n s Step 2: We need to prove that forall s n, pick s = None -> ~In n s Step 3: Introduce variables and assumptions Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Apply tactic: caseEq (PHeap Step 8: Apply tactic: caseEq (PHeap Step 9: Apply tactic: findMax s) Step 10: Apply tactic: findMin s) Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Apply tactic: congruence Step 14: Apply tactic: congruence Step 15: Apply a theorem or hypothesis Step 16: Apply a theorem or hypothesis Step 17: Apply tactic: findMax_empty Step 18: Apply tactic: findMin_empty Step 19: Solve automatically using known facts Step 20: Solve automatically using known facts Step 21: Apply tactic: Qed Step 22: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:pick_some", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma pick_in_iff : forall (A : Type) (s : list A) (n : A) (s' : list A),\n    pick s = Some (n, s') -> forall (n' : A), In n' s <-> n = n' \\/ In n' s'.\nProof.\n  intros A s n s' H n'. unfold pick in H. destruct s; inversion H; subst.\n  simpl. split; intros H1.\n  - destruct H1; subst; auto.\n  - destruct H1; subst; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall s n s', pick s = Some(n, s') -> forall n', In n' s <-> n = n' \\/ In n' s' Step 2: We need to prove that forall s n s', pick s = Some(n, s') -> forall n', In n' s <-> n = n' \\/ In n' s' Step 3: Introduce variables and assumptions Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Apply tactic: caseEq (PHeap Step 8: Apply tactic: caseEq (PHeap Step 9: Apply tactic: findMax s) Step 10: Apply tactic: findMin s) Step 11: Introduce variables and assumptions Step 12: Introduce variables and assumptions Step 13: Apply tactic: inv H0 Step 14: Apply tactic: inv H0 Step 15: Apply tactic: generalize (PHeap Step 16: Apply tactic: generalize (PHeap Step 17: Apply tactic: In_deleteMax s n n' H) Step 18: Apply tactic: In_deleteMin s n n' H) Step 19: Unfold a definition Step 20: Unfold a definition Step 21: Apply tactic: intuition Step 22: Apply tactic: intuition", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Kildall:all_nodes_spec", "draft": "Require Import Coq.Lists.List. Import ListNotations.\nRequire Import Coq.FSets.FMapInterface.\n\nLemma fold_rec_template : forall (A : Type) (P : A -> Type) (f : positive -> A -> A) (m : PTree.t A) (set : A),\n  (forall (n : positive) (instr : A), MapsTo n instr m -> P instr) -> P set -> P (PTree.fold f m set).\nProof.\n  intros A P f m set H1 H2.\n  apply PTree_Properties.fold_rec; auto.\nQed.", "nl_proof": "Step 1: extensionality Step 2: base case Step 3: inductive case Step 4: We need to prove that forall A (code: PTree Step 5: We need to prove that forall A (code: PTree Step 6: Introduce variables and assumptions Step 7: Apply tactic: End NodeSetBackward Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: fold_rec with Step 10: Apply tactic: (P := fun m set => m!n = Some instr -> In n set) Step 11: Introduce variables and assumptions Step 12: Apply a theorem or hypothesis Step 13: Rewrite using an equality Step 14: Solve automatically using known facts Step 15: Rewrite using an equality Step 16: Apply tactic: gempty", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Liveness:analyze_solution", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma analyze_fixpoint_solution : forall (A B : Type) (f : A -> B) (live : list A) (n i s : nat),\n  analyze f = Some live -> f = (fix F (x : A) : B := match x with _ => _ end).\nProof.\n  intros A B f live n i s H.\n  unfold analyze in H.\n  eapply DS.\n  apply fixpoint_solution.\n  eauto.\n  intros.\n  unfold analyze in H.\n  rewrite H.\n  apply eq_refl.\nQed.", "nl_proof": "Step 1: We need to prove that forall f live n i s, analyze f = Some live -> f Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: eapply DS Step 5: Apply tactic: fixpoint_solution Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Unfold a definition Step 9: Rewrite using an equality Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: eq_refl", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminor:semantics_receptive", "draft": "Require Import Coq.Program.Basics.\nLemma receptive_step : forall (genv state : Type) (step : genv -> state -> nat -> state -> Prop) (p : genv) (s1 : state) (t1 t2 : nat) (s1' : state),\nstep (globalenv p) s1 t1 s1' -> t1 = 0 -> exists s2 : state, step (globalenv p) s1 t2 s2.\nProof.\n  intros genv state step p s1 t1 t2 s1' H H0.\n  subst t1.\n  inversion H.\n  eexists.\n  apply H1.\nQed.", "nl_proof": "Step 1: receptiveness Step 2: trace length Step 3: We need to prove that forall (p: program), receptive (semantics p) Step 4: Introduce variables and assumptions Step 5: Apply tactic: constructor Step 6: Simplify the goal by computation Step 7: Introduce variables and assumptions Step 8: Apply tactic: assert (t1 = E0 -> exists s2, step (Genv Step 9: Apply tactic: globalenv p) s t2 s2) Step 10: Introduce variables and assumptions Step 11: Apply tactic: subst Step 12: Apply tactic: inv H0 Step 13: Provide an existential witness", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminor:eval_expr_determ", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Arith.PeanoNat.\n\nLemma eval_expr_determ : forall ge sp e m a v, eval_expr ge sp e m a v -> forall v', eval_expr ge sp e m a v' -> v' = v.\nProof.\n  induction 1; intros v' E'; inv E'; try congruence.\n  - assert (v0 = v1) by eauto. congruence.\n  - assert (v0 = v1) by eauto. assert (v3 = v2) by eauto. congruence.\nQed.", "nl_proof": "Step 1: We need to prove that forall ge sp e m a v, eval_expr ge sp e m a v -> forall v', eval_expr ge sp e m a v' -> v' = v Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Apply tactic: inv E' Step 5: Apply tactic: - congruence Step 6: Apply tactic: - congruence Step 7: Apply tactic: - assert (v0 = v1) by eauto Step 8: Apply tactic: congruence Step 9: Apply tactic: - assert (v0 = v1) by eauto Step 10: Apply tactic: assert (v3 = v2) by eauto Step 11: Apply tactic: congruence", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminor:eval_exprlist_determ", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma eval_exprlist_determ : forall ge sp e m al vl, eval_exprlist ge sp e m al vl -> forall vl', eval_exprlist ge sp e m al vl' -> vl' = vl.\nProof.\n  induction 1; intros vl' E'; inv E'; auto.\n  f_equal; eauto using eval_expr_determ.\nQed.", "nl_proof": "Step 1: We need to prove that forall ge sp e m al vl, eval_exprlist ge sp e m al vl -> forall vl', eval_exprlist ge sp e m al vl' -> vl' = vl Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Apply tactic: inv E' Step 5: Apply tactic: - auto Step 6: Apply tactic: - f_equal Step 7: Apply tactic: eauto using eval_expr_determ Step 8: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminor:semantics_determinate", "draft": "Require Import Coq.Program.Equality.\nLemma step_deterministic : forall (ge : Genv) (s1 s2 s2' : state), step ge s1 s2 -> step ge s1 s2' -> s2 = s2'.\nProof.\n  intros ge s1 s2 s2' H H0.\n  dependent induction H.\n  dependent induction H0.\n  subst.\n  reflexivity.\nQed.", "nl_proof": "Step 1: single event Step 2: initial states Step 3: nostep final state Step 4: final states Step 5: We need to prove that forall (p: program), determinate (semantics p) Step 6: Introduce variables and assumptions Step 7: Apply tactic: constructor Step 8: Apply tactic: set (ge := Genv Step 9: Apply tactic: globalenv p) Step 10: Simplify the goal by computation Step 11: Introduce variables and assumptions Step 12: Apply tactic: inv H Step 13: Apply tactic: inv H0 Step 14: Apply tactic: Determ Step 15: Apply tactic: + subst vargs0", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminor:is_call_cont_call_cont", "draft": "Require Import Coq.Lists.List.\nLemma call_cont_is_call_cont : forall (A : Type) (k : A), is_call_cont (call_cont k).\nProof. induction k; simpl; auto. Qed.", "nl_proof": "Step 1: We need to prove that forall k, is_call_cont (call_cont k) Step 2: Proceed by induction on k Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminor:call_cont_is_call_cont", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma call_cont_id_template : forall (k : cont) (H : is_call_cont k), call_cont k = k.\nProof. intros k H; destruct k; simpl in *; try contradiction; auto. Qed.", "nl_proof": "Step 1: We need to prove that forall k, is_call_cont k -> call_cont k = k Step 2: Case analysis by destructing a value Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminor:eval_funcall_exec_stmt_steps", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma eval_funcall_exec_stmt_steps : (forall (ge : Type) (step : Type -> Type -> Type -> Prop) (m : Type) (fd : Type) (args : Type) (t : Type) (m' : Type) (res : Type),\n  eval_funcall ge m fd args t m' res ->\n  forall (k : Type), is_call_cont k -> star step ge (Callstate fd args k m) t (Returnstate res k m')) /\\\n(forall (ge : Type) (step : Type -> Type -> Type -> Prop) (f : Type) (sp : Type) (e : Type) (m : Type) (s : Type) (t : Type) (e' : Type) (m' : Type) (out : Type),\n  exec_stmt ge f sp e m s t e' m' out ->\n  forall (k : Type), exists S : Type, star step ge (State f s k sp e m) t S /\\ outcome_state_match sp e' m' f k out S).\nProof.\n  split.\n  - intros ge step m fd args t m' res H k H0.\n    eapply star_left.\n    econstructor.\n    eauto.\n  - intros ge step f sp e m s t e' m' out H k.\n    exists (Returnstate out k m').\n    split.\n    + eapply star_trans.\n      eexact H.\n      eauto.\n    + econstructor.\n      eauto.\nQed.", "nl_proof": "Step 1: funcall internal Step 2: Out normal Step 3: loop stop Step 4: return none Step 5: return some Step 6: tailcall Step 7: Out_return None Step 8: Out_return Some Step 9: Out_tailcall_return Step 10: funcall external Step 11: ifthenelse Step 12: seq continue Step 13: seq stop Step 14: loop loop Step 15: We need to prove that (forall m fd args t m' res, eval_funcall ge m fd args t m' res -> forall k, is_call_cont k -> star step ge (Callstate fd args k m) t (Returnstate res k m')) /\\(forall f sp e m s t e' m' out, exec_stmt ge f sp e m s t e' m' out -> forall k, exists S, star step ge (State f s k sp e m) t S /\\ outcome_state_match sp e' m' f k out S) Step 16: Apply a theorem or hypothesis Step 17: Introduce variables and assumptions Step 18: Case analysis by destructing a value Step 19: Apply tactic: assert (call_cont k = k) by (apply call_cont_is_ca Step 20: Solve automatically using known facts Step 21: Apply tactic: eapply star_left Step 22: Apply tactic: econstructor Step 23: Apply tactic: eauto Step 24: Apply tactic: eapply star_trans Step 25: Apply tactic: eexact A", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminor:eval_funcall_steps", "draft": "```coq\nRequire Import Coq.Program.Wf.\nLemma evalinf_funcall_forever : forall (ge : Type) (m fd args : nat) (T k : Type),\n  evalinf_funcall ge m fd args T ->\n  forever_plus step ge (Callstate fd args k m) T.\nProof. Admitted.\nQed.", "nl_proof": "Step 1: ifthenelse Step 2: loop body Step 3: loop loop Step 4: tailcall Step 5: function call Step 6: We need to prove that forall m fd args t m' res, eval_funcall ge m fd args t m' res -> forall k, is_call_cont k -> star step ge (Callstate fd args k m) t (Returnstate res k m') Step 7: Apply tactic: Lemma exec_stmt_steps: Step 8: Apply tactic: forall f sp e m s t e' m' out, Step 9: Apply tactic: exec_stmt ge f sp e m s t e' m' out -> Step 10: Apply tactic: forall k, Step 11: Provide an existential witness Step 12: Apply tactic: star step ge (State f s k sp e m) t S Step 13: Apply tactic: /\\ outcome_state_match sp e' m' f k out S Step 14: Apply tactic: Lemma evalinf_funcall_forever: Step 15: Apply tactic: forall m fd args T k, Step 16: Apply tactic: evalinf_funcall ge m fd args T ->", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminor:exec_stmt_steps", "draft": "Require Import Coq.Lists.List.\nLemma exec_stmt_steps : forall ge f sp e m s t e' m' out,\n  exec_stmt ge f sp e m s t e' m' out ->\n  forall (A : Type) (k : A), exists S,\n  star step ge (State f s k sp e m) t S /\\ outcome_state_match sp e' m' f k out S.\nProof. Admitted.\nQed.", "nl_proof": "Step 1: ifthenelse Step 2: loop body Step 3: loop loop Step 4: tailcall Step 5: function call Step 6: We need to prove that forall f sp e m s t e' m' out, exec_stmt ge f sp e m s t e' m' out -> forall k, exists S, star step ge (State f s k sp e m) t S /\\ outcome_state_match sp e' m' f k out S Step 7: Apply tactic: Lemma evalinf_funcall_forever: Step 8: Apply tactic: forall m fd args T k, Step 9: Apply tactic: evalinf_funcall ge m fd args T -> Step 10: Apply tactic: forever_plus step ge (Callstate fd args k m) T Step 11: Apply tactic: cofix CIH_FUN Step 12: Apply tactic: assert (forall sp e m s T f k, Step 13: Apply tactic: execinf_stmt ge f sp e m s T -> Step 14: Apply tactic: forever_plus step ge (State f s k sp e m) T) Step 15: Apply tactic: cofix CIH_STMT Step 16: Introduce variables and assumptions", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminor:evalinf_funcall_forever", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Program.Wf.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma evalinf_funcall_forever : forall ge m fd args T k,\n  evalinf_funcall ge m fd args T ->\n  forever_plus step ge (Callstate fd args k m) T.\nProof.\n  cofix CIH_FUN.\n  assert (forall sp e m s T f k,\n    execinf_stmt ge f sp e m s T ->\n    forever_plus step ge (State f s k sp e m) T) as CIH_STMT.\n  { cofix CIH_STMT.\n    intros sp e m s T f k H.\n    inv H;\n    eapply forever_plus_intro;\n    [ econstructor; eauto\n    | apply CIH_STMT; auto\n    ]. }\n  intros ge m fd args T k H.\n  inv H;\n  eapply forever_plus_intro;\n  [ econstructor; eauto\n  | apply CIH_STMT; auto\n  ].\nQed.", "nl_proof": "Step 1: ifthenelse Step 2: loop body Step 3: loop loop Step 4: tailcall Step 5: function call Step 6: We need to prove that forall m fd args T k, evalinf_funcall ge m fd args T -> forever_plus step ge (Callstate fd args k m) T Step 7: Apply tactic: cofix CIH_FUN Step 8: Apply tactic: assert (forall sp e m s T f k, Step 9: Apply tactic: execinf_stmt ge f sp e m s T -> Step 10: Apply tactic: forever_plus step ge (State f s k sp e m) T) Step 11: Apply tactic: cofix CIH_STMT Step 12: Introduce variables and assumptions Step 13: Apply tactic: inv H Step 14: Apply tactic: eapply forever_plus_intro Step 15: Apply a theorem or hypothesis Step 16: Apply tactic: econstructor", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Cminor:bigstep_semantics_sound", "draft": "```coq\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nLemma bigstep_sound_template : forall (A B : Type) (prog : A -> B) (semantics bigstep_semantics : A -> B -> Prop),\n  (forall x y, bigstep_semantics prog x y -> semantics prog x y).\nProof.\n  intros A B prog semantics bigstep_semantics x y H.\n  inversion H; subst.\n  econstructor; eauto.\nQed.\n```.\nQed.", "nl_proof": "Step 1: termination Step 2: divergence Step 3: We need to prove that bigstep_sound (bigstep_semantics prog) (semantics prog) Step 4: Apply tactic: constructor Step 5: Introduce variables and assumptions Step 6: Apply tactic: inv H Step 7: Apply tactic: econstructor Step 8: Apply tactic: econstructor Step 9: Split a conjunction into separate goals Step 10: Apply tactic: econstructor Step 11: Apply tactic: eauto Step 12: Split a conjunction into separate goals Step 13: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:Zdiv_mul_pos", "draft": "Require Import ZArith.\nRequire Import Lia.\n\nLemma Zdiv_mul_pos : forall N d m l,\n  l >= 0 ->\n  two_p (N + l) <= m * d <= two_p (N + l) + two_p l ->\n  forall (A : Type) (n : A),\n  0 <= n < two_p N ->\n  Z.div n d = Z.div (m * n) (two_p (N + l)).\nProof.\n  intros N d m l Hl Hbounds n Hn.\n  assert (d_pos : d > 0).\n  { destruct Hbounds as [Hlower Hupper].\n    apply Z.le_lt_trans with (m * d).\n    - apply Z.le_trans with (two_p (N + l)); [lia|].\n      apply two_p_gt_ZERO; lia.\n    - lia. }\n  set (q := Z.div n d).\n  set (r := Z.modulo n d).\n  assert (EUCL : n = q * d + r) by (apply Z_div_mod_eq_full; lia).\n  assert (Hr : 0 <= r <= d - 1).\n  { split; [apply Z.mod_pos_bound; lia|].\n    apply Z.lt_le_pred; apply Z.mod_pos_bound; lia. }\n  lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall m l, l >= 0 -> two_p (N+l) <= m * d <= two_p (N+l) + two_p l -> forall n, 0 <= n < two_p N -> Z Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit (Z_div_mod_eq n d) Step 4: Solve automatically using known facts Step 5: Apply tactic: set (q := n / d) Step 6: Apply tactic: set (r := n mod d) Step 7: Apply tactic: intro EUCL Step 8: Apply tactic: assert (0 <= r <= d - 1) Step 9: Unfold a definition Step 10: Apply tactic: generalize (Z_mod_lt n d d_pos) Step 11: Apply tactic: lia", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:Zdiv_unique_2", "draft": "Require Import ZArith.\nOpen Scope Z_scope.\n\nLemma lemma1 : forall (x y q : Z), y > 0 -> 0 < y * q - x <= y -> x < y * q /\\ y * q <= x + y.\nProof.\n  intros x y q H H0.\n  destruct H0 as [H1 H2].\n  split.\n  - lia.\n  - lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall x y q, y > 0 -> 0 < y * q - x <= y -> Z Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: ring Step 5: Apply tactic: replace ((q - 1) * y) with (y * q - y) by ring Step 6: Apply tactic: lia Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:Zdiv_mul_opp", "draft": "Require Import ZArith.Zdiv.\nLemma Zdiv_mul_opp : forall N d m l,\n  d > 0 ->\n  l >= 0 ->\n  two_p (N + l) < m * d <= two_p (N + l) + two_p l ->\n  forall (A : Type) (n : A),\n  0 < n <= two_p N ->\n  Z.div n d = - Z.div (m * (-n)) (two_p (N + l)) - 1.\nProof.\n  intros N d m l d_pos l_nonneg bounds n n_bounds.\n  replace (m * (-n)) with (- (m * n)) by ring.\n  set (q := n / d).\n  set (r := n mod d).\n  assert (EUCL : n = q * d + r) by (apply Z_div_mod_eq; auto).\n  assert (r_bounds : 0 <= r <= d - 1) by (split; [apply Z_mod_lt; omega|]; generalize (Z_mod_lt n d d_pos); omega).\n  omega.\nQed.", "nl_proof": "Step 1: We need to prove that forall m l, l >= 0 -> two_p (N+l) < m * d <= two_p (N+l) + two_p l -> forall n, 0 < n <= two_p N -> Z Step 2: Introduce variables and assumptions Step 3: Apply tactic: replace (m * (-n)) with (- (m * n)) by ring Step 4: Apply tactic: exploit (Z_div_mod_eq n d) Step 5: Solve automatically using known facts Step 6: Apply tactic: set (q := n / d) Step 7: Apply tactic: set (r := n mod d) Step 8: Apply tactic: intro EUCL Step 9: Apply tactic: assert (0 <= r <= d - 1) Step 10: Unfold a definition Step 11: Apply tactic: generalize (Z_mod_lt n d d_pos)", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:Zquot_mul", "draft": "Require Import ZArith Lia.\nLemma Zquot_mul_opp : forall (N d m l : Z),\n  l >= 0 ->\n  two_p (N + l) < m * d <= two_p (N + l) + two_p l ->\n  forall n : Z,\n  - two_p N <= n < two_p N ->\n  Z.quot n d = - Z.quot (-n) d.\nProof.\n  intros N d m l H H0 n H1.\n  destruct (Z_lt_le_dec n 0) as [H2|H2].\n  - exploit (Zdiv_mul_opp m l H H0 (-n)).\n    split; [lia|].\n    rewrite Z.opp_involutive.\n    lia.\n    intro H3.\n    rewrite Z.quot_opp_l by lia.\n    lia.\n  - rewrite Z.quot_opp_l by lia.\n    replace (- - n) with n by ring.\n    rewrite Z.quot_opp_r by lia.\n    lia.\nQed.", "nl_proof": "Step 1: We need to prove that forall m l, l >= 0 -> two_p (N+l) < m * d <= two_p (N+l) + two_p l -> forall n, - two_p N <= n < two_p N -> Z Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: exploit (Zdiv_mul_opp m l H H0 (-n)) Step 5: Apply tactic: lia Step 6: Apply tactic: replace (- - n) with n by ring Step 7: Apply tactic: replace (Z Step 8: Apply tactic: quot n d) with (- Z Step 9: Apply tactic: quot (-n) d) Step 10: Rewrite using an equality Step 11: Apply tactic: lia", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:divs_mul_params_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nRequire Import compcert.lib.Integers.\n\nLemma divs_mul_params_bound : forall d m p,\n  divs_mul_params d = Some (p, m) -> 0 <= m < Int.modulus.\nProof.\n  intros d m p H.\n  unfold divs_mul_params in H.\n  destruct (Z.eq_dec d 0) as [Hd|Hd]; [discriminate|].\n  destruct (divs_mul_params_aux d 32) as [[p1 m1]|] eqn:E; [|discriminate].\n  injection H; intros; subst.\n  apply divs_mul_params_aux_sound in E.\n  destruct E as [_ [_ [Hm _]]].\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall d m p, divs_mul_params d = Some(p, m) -> 0 <= m < Int Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: wordsize Step 6: Apply tactic: (Int Step 7: Apply tactic: half_modulus - Int Step 8: Apply tactic: half_modulus mod d - 1) d 32) Step 9: Apply tactic: as [[p m] | ] Step 10: Apply tactic: generalize (p - 32) Step 11: Apply tactic: intro p1", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:divu_mul_params_sound", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nRequire Import Coq.Arith.Compare_dec.\n\nLemma divu_mul_params_bound : forall d m p,\n  divu_mul_params d = Some(p, m) -> 0 <= m < Int.modulus.\nProof.\n  intros d m p H.\n  unfold divu_mul_params in H.\n  destruct (Z_le_gt_dec d 0) as [Hd|Hd].\n  { discriminate. }\n  destruct (Z_le_gt_dec Int.modulus d) as [Hd'|Hd'].\n  { discriminate. }\n  destruct (Z_le_gt_dec (two_p (32 - 1)) d) as [Hd''|Hd''].\n  { destruct (efficient_div_by_const d) as [[p' m']|] eqn:E.\n    { injection H; intros; subst; apply efficient_div_by_const_sound in E; intuition. }\n    { discriminate. } }\n  { destruct (efficient_div_by_const d) as [[p' m']|] eqn:E.\n    { injection H; intros; subst; apply efficient_div_by_const_sound in E; intuition. }\n    { discriminate. } }\nQed.", "nl_proof": "Step 1: We need to prove that forall d m p, divu_mul_params d = Some(p, m) -> 0 <= m < Int Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: wordsize Step 6: Apply tactic: (Int Step 7: Apply tactic: modulus - Int Step 8: Apply tactic: modulus mod d - 1) d 32) Step 9: Apply tactic: as [[p m] | ] Step 10: Apply tactic: generalize (p - 32) Step 11: Apply tactic: intro p1", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:divs_mul_shift_1", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\n\nLemma divs_mul_params_shift : forall x y m p,\n  divs_mul_params x y m p ->\n  exists s, divs_mul_shift_gen x y m p s.\nProof.\n  intros x y m p H.\n  exploit divs_mul_shift_gen; eauto.\n  instantiate (1 := x).\n  intros [s Hs].\n  exists s; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall x y m p, divs_mul_params (Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit divs_mul_shift_gen Step 4: Apply tactic: eauto Step 5: Apply tactic: instantiate (1 := x) Step 6: Introduce variables and assumptions Step 7: Split a conjunction into separate goals Step 8: Solve automatically using known facts Step 9: Rewrite using an equality Step 10: Unfold a definition Step 11: Apply tactic: mulhs", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:divu_mul_shift", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nRequire Import compcert.lib.Integers.\n\nLemma divu_mul_shift : forall x y m p,\n  divu_mul_params (Int.unsigned y) = Some (p, m) ->\n  0 <= p < 32 /\\\n  Int.divu x y = Int.shru (Int.mulhu x (Int.repr m)) (Int.repr p).\nProof.\n  intros x y m p H.\n  exploit divu_mul_params_sound; eauto.\n  intros [H1 H2].\n  split; auto.\n  rewrite H2.\n  apply shru_div_two_p.\n  rewrite Int.unsigned_repr; auto.\n  split; try omega.\n  apply divu_mul_params_range; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall x y m p, divu_mul_params (Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit divu_mul_params_sound Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Split a conjunction into separate goals Step 7: Solve automatically using known facts Step 8: Rewrite using an equality Step 9: Apply tactic: shru_div_two_p Step 10: Rewrite using an equality Step 11: Apply tactic: unsigned_repr", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:divls_mul_params_sound", "draft": "Require Import Coq.ZArith.ZArith.\nLemma divls_mul_params_bound : forall (d : Z) (m p : Z), divls_mul_params d = Some (p, m) -> 0 <= m < Int64.modulus.\nProof.\n  unfold divls_mul_params.\n  intros d m p H.\n  destruct (Z_le_gt_dec d 0) as [Hd|Hd].\n  { discriminate. }\n  destruct (divls_mul_params' (Int64.half_modulus - Int64.half_modulus mod d - 1) d 64) as [[p' m']|] eqn:E.\n  { injection H as H1 H2.\n    rewrite <- H2.\n    generalize (p' - 64).\n    intro p1.\n    apply divls_mul_params'_bound in E.\n    omega. }\n  { discriminate. }\nQed.", "nl_proof": "Step 1: We need to prove that forall d m p, divls_mul_params d = Some(p, m) -> 0 <= m < Int64 Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: wordsize Step 6: Apply tactic: (Int64 Step 7: Apply tactic: half_modulus - Int64 Step 8: Apply tactic: half_modulus mod d - 1) d 64) Step 9: Apply tactic: as [[p m] | ] Step 10: Apply tactic: generalize (p - 64) Step 11: Apply tactic: intro p1", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:divlu_mul_params_sound", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import Coq.Strings.String.\n\nLemma divlu_mul_params_bound : forall (d : Z) (m p : Z),\n  divlu_mul_params d = Some (p, m) -> 0 <= m < Int64.modulus.\nProof.\n  intros d m p H.\n  generalize (divlu_mul_params_sound d m p H).\n  intros [H1 [H2 H3]].\n  exact H1.\nQed.", "nl_proof": "Step 1: We need to prove that forall d m p, divlu_mul_params d = Some(p, m) -> 0 <= m < Int64 Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: wordsize Step 6: Apply tactic: (Int64 Step 7: Apply tactic: modulus - Int64 Step 8: Apply tactic: modulus mod d - 1) d 64) Step 9: Apply tactic: as [[p m] | ] Step 10: Apply tactic: generalize (p - 64) Step 11: Apply tactic: intro p1", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:divlu_mul_shift", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import compcert.lib.Integers.\n\nLemma divlu_mul_params_sound_lemma : forall (x y : int64) (m p : int),\n  divlu_mul_params (Int64.unsigned y) = Some (p, m) ->\n  0 <= Int.unsigned p < 64 /\\\n  Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr (Int64.unsigned m))) (Int.repr (Int.unsigned p)).\nProof.\n  intros x y m p H.\n  exploit divlu_mul_params_sound; eauto.\n  intros [H1 [H2 H3]].\n  split; [assumption|].\n  rewrite H3.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall x y m p, divlu_mul_params (Int64 Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit divlu_mul_params_sound Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Split a conjunction into separate goals Step 7: Solve automatically using known facts Step 8: Rewrite using an equality Step 9: Rewrite using an equality Step 10: Apply tactic: unsigned_repr Step 11: Unfold a definition", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:is_intconst_sound", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_intconst_result : forall (ge : Type) (sp : Type) (e : Type) (m : Type) (le : Type) (v : Type) (a : Type) (n : nat), is_intconst a = Some n -> eval_expr ge sp e m le a v -> v = Vint n.\nProof.\n  intros ge sp e m le v a n H H0.\n  unfold is_intconst in H.\n  destruct a.\n  destruct n0.\n  inv H.\n  inv H0.\n  destruct n0.\n  inv H5.\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall v a n le, is_intconst a = Some n -> eval_expr ge sp e m le a v -> v = Vint n Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Case analysis by destructing a value Step 6: Apply tactic: inv H Step 7: Apply tactic: inv H0 Step 8: Case analysis by destructing a value Step 9: Apply tactic: inv H5 Step 10: Solve automatically using known facts Step 11: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:eval_divu_mul", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma eval_divu_mul_params : forall (le : list val) (x y : int) (p : positive) (M : int),\n  divu_mul_params (Int.unsigned y) = Some (p, M) ->\n  nth_error le O = Some (Vint x) ->\n  eval_expr ge sp e m le (divu_mul p M) (Vint (Int.divu x y)).\nProof.\n  intros le x y p M Hparams Hnth.\n  exploit (divu_mul_shift x); eauto.\n  intros [Hshift Hdiv].\n  assert (C: eval_expr ge sp e m le (Eletvar O) (Vint x)) by eauto.\n  assert (D: eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil) (Vint (Int.repr M))) by EvalOp.\n  econstructor; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le x y p M, divu_mul_params (Int Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: exploit (divu_mul_shift x) Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Apply tactic: assert (C: eval_expr ge sp e m le (Eletvar 0) (Vin Step 8: Apply tactic: eauto) Step 9: Apply tactic: assert (D: eval_expr ge sp e m le (Eop (Ointconst Step 10: Apply tactic: repr M)) Enil) (Vint (Int Step 11: Apply tactic: repr M))) by EvalOp", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:eval_divuimm", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nLemma eval_expr_condition : forall ge sp e m le e1 x n2 z,\n  eval_expr ge sp e m le e1 x -> Val.eq x (Vint n2) -> Val.eq (Val.cmpu_bool (Mem.valid_pointer m) Ceq x (Vint Int.zero)) (Some (Int.eq n2 Int.zero)).\nProof.\n  intros ge sp e m le e1 x n2 z H H0.\n  generalize H0.\n  destruct x; try discriminate.\n  destruct i; try discriminate.\n  intros H1.\n  simpl.\n  rewrite H1.\n  reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall le e1 x n2 z, eval_expr ge sp e m le e1 x -> Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: generalize H0 Step 5: Introduce variables and assumptions Step 6: Case analysis by destructing a value Step 7: Simplify the goal by computation Step 8: Apply tactic: try discriminate Step 9: Case analysis by destructing a value Step 10: Apply tactic: eq n2 Int Step 11: Apply tactic: zero) eqn:Z2", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:eval_divu", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_expr_intconst_case : forall (ge : Type) (sp : Type) (e : Type) (m : Type) (le : Type) (a b : Type) (x y z : nat),\n  (forall (A : Type) (B : Type), A -> B -> True) ->\n  (forall (n : nat), is_intconst n = true -> True) ->\n  True.\nProof.\n  intros.\n  destruct x.\n  - eauto.\n  - eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: - exploit is_intconst_sound Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Apply tactic: clear B Step 9: Case analysis by destructing a value Step 10: Apply tactic: + exploit is_intconst_sound Step 11: Apply tactic: eauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:eval_mod_from_div", "draft": "```coq\nRequire Import Coq.Arith.Arith.\nLemma eval_mod_from_div : forall (ge : positive) (sp : val) (e : env) (m : mem) (le : list val) (a : expr) (n : int) (x y : int),\n  eval_expr ge sp e m le a (Vint y) ->\n  nth_error le O = Some (Vint x) ->\n  eval_expr ge sp e m le (mod_from_div a n) (Vint (Int.sub x (Int.mul y n))).\nProof.\n  intros.\n  unfold mod_from_div.\n  exploit eval_mulimm.\n  eauto.\n  instantiate (1 := n).\n  intros.\n  simpl.\n  inv H1.\n  EvalOp.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a n x y, eval_expr ge sp e m le a (Vint y) -> nth_error le O = Some (Vint x) -> eval_expr ge sp e m le (mod_from_div a n) (Vint (Int Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: exploit eval_mulimm Step 5: Apply tactic: eauto Step 6: Apply tactic: instantiate (1 := n) Step 7: Introduce variables and assumptions Step 8: Simplify the goal by computation Step 9: Apply tactic: inv B Step 10: Apply tactic: EvalOp Step 11: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:eval_moduimm", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nLemma eval_expr_condition : forall ge sp e m le e1 x n2 z,\n  eval_expr ge sp e m le e1 x -> Val.eq x (Vint n2) -> Val.eq (Val.cmpu_bool (Mem.valid_pointer m) Ceq x (Vint Int.zero)) (Some (Int.eq n2 Int.zero)).\nProof.\n  intros ge sp e m le e1 x n2 z H H0.\n  generalize H0.\n  destruct x; try discriminate.\n  destruct i; try discriminate.\n  intros H1.\n  destruct (Int.eq n2 Int.zero) eqn:Z2; simpl; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le e1 x n2 z, eval_expr ge sp e m le e1 x -> Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: generalize H0 Step 5: Introduce variables and assumptions Step 6: Case analysis by destructing a value Step 7: Simplify the goal by computation Step 8: Apply tactic: try discriminate Step 9: Case analysis by destructing a value Step 10: Apply tactic: eq n2 Int Step 11: Apply tactic: zero) eqn:Z2", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:eval_modu", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_expr_intconst_case : forall (ge sp e m le : Type) (a b x y z : nat),\n  (forall (A : Type) (x y : A), x = y) ->\n  (forall (A : Type) (x y : A), x = y) ->\n  (forall (n : nat), n = n) ->\n  (forall (n : nat), n = n) ->\n  True.\nProof.\n  intros.\n  destruct x.\n  - exploit H.\n    eauto.\n  - exploit H0.\n    eauto.\n  clear b.\n  destruct y.\n  + exploit H1.\n    eauto.\n  + exploit H2.\n    eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: - exploit is_intconst_sound Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Apply tactic: clear B Step 9: Case analysis by destructing a value Step 10: Apply tactic: + exploit is_intconst_sound Step 11: Apply tactic: eauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:eval_divs_mul", "draft": "Require Import Coq.Init.Byte.\nLemma eval_divs_mul_params : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : letenv) (x y : int) (p : Z) (M : int),\n  divs_mul_params (Int.signed y) = Some (p, M) ->\n  nth_error le O = Some (Vint x) ->\n  eval_expr ge sp e m le (divs_mul p M) (Vint (Int.divs x y)).\nProof.\n  intros.\n  unfold divs_mul.\n  assert (C: eval_expr ge sp e m le (Eletvar 0) (Vint x)) by (apply eval_Eletvar; auto).\n  assert (D: eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil) (Vint (Int.repr M))) by EvalOp.\n  exploit eval_mulhs; eauto.\n  intros (v & E & F).\n  econstructor; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le x y p M, divs_mul_params (Int Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: assert (C: eval_expr ge sp e m le (Eletvar 0) (Vin Step 5: Apply tactic: eauto) Step 6: Apply tactic: assert (D: eval_expr ge sp e m le (Eop (Ointconst Step 7: Apply tactic: repr M)) Enil) (Vint (Int Step 8: Apply tactic: repr M))) by EvalOp Step 9: Apply tactic: exploit eval_mulhs Step 10: Apply tactic: eexact C Step 11: Apply tactic: eexact D", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:eval_divsimm", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nLemma eval_expr_step : forall ge sp e m le e1 x n2 z, eval_expr ge sp e m le e1 x -> Val.maketotal (Val.addl x (Vlong n2)) = Vlong z -> z = Int64.add x (Vlong n2).\nProof.\n  intros ge sp e m le e1 x n2 z H H0.\n  generalize H0.\n  destruct x; try discriminate.\n  simpl.\n  destruct n2; try discriminate.\n  intro H1; inversion H1; reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall le e1 x n2 z, eval_expr ge sp e m le e1 x -> Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: generalize H0 Step 5: Introduce variables and assumptions Step 6: Case analysis by destructing a value Step 7: Simplify the goal by computation Step 8: Apply tactic: try discriminate Step 9: Case analysis by destructing a value Step 10: Apply tactic: eq n2 Int Step 11: Apply tactic: zero", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:eval_divs", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_expr_intconst_case : forall (ge : Type) (sp e m le : nat) (a b x y z : nat),\n  (forall (A : Type) (B : Prop), A -> B) ->\n  (forall (n : nat), is_intconst n = true -> n = z) ->\n  (forall (n : nat), is_intconst n = true -> n = y) ->\n  (x = Val.add (Vint y) (Vint z)) -> True.\nProof.\n  intros ge sp e m le a b x y z H H0 H1 H2.\n  destruct y.\n  - exploit H0. eauto. intros; subst.\n    destruct z.\n    + exploit H1. eauto. intros; subst.\n      auto.\n    + auto.\n  - auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: - exploit is_intconst_sound Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Apply tactic: clear B Step 9: Case analysis by destructing a value Step 10: Apply tactic: + exploit is_intconst_sound Step 11: Apply tactic: eauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:eval_modsimm", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma eval_modsimm : forall ge sp e m le e1 x n2 z,\n  eval_expr ge sp e m le e1 x ->\n  Val.mods x (Vint n2) = Some z ->\n  exists v, eval_expr ge sp e m le (modsimm e1 n2) v /\\ Val.lessdef z v.\nProof.\n  intros ge sp e m le e1 x n2 z H H0.\n  unfold modsimm.\n  exploit Val.mods_divs; eauto.\n  intros [y [H1 H2]].\n  eapply eval_mod_aux; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le e1 x n2 z, eval_expr ge sp e m le e1 x -> Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: exploit Val Step 5: Apply tactic: mods_divs Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Apply tactic: generalize A Step 9: Introduce variables and assumptions Step 10: Case analysis by destructing a value Step 11: Simplify the goal by computation", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:eval_mods", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_expr_intconst_case : forall (ge sp e m le : Type) (a b x y z : nat),\n  (forall (A : Type) (x y : A), x = y) ->\n  (forall (A : Type) (x y : A), x = y) ->\n  (forall (n : nat), n = n) ->\n  (forall (n : nat), n = n) ->\n  True.\nProof.\n  intros.\n  exact I.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: - exploit is_intconst_sound Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Apply tactic: clear B Step 9: Case analysis by destructing a value Step 10: Apply tactic: + exploit is_intconst_sound Step 11: Apply tactic: eauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:eval_modl_from_divl", "draft": "Require Import Coq.Lists.List.\nLemma eval_modl_from_divl : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : list val) (a : expr) (n : int64) (x y : int64),\n  eval_expr ge sp e m le a (Vlong y) ->\n  nth_error le O = Some (Vlong x) ->\n  eval_expr ge sp e m le (modl_from_divl a n) (Vlong (Int64.sub x (Int64.mul y n))).\nProof.\n  intros.\n  unfold modl_from_divl.\n  exploit eval_mullimm.\n  eauto.\n  instantiate (1 := n).\n  intros.\n  assert (A0: eval_expr ge sp e m le (Eletvar O) (Vlong x)).\n  { simpl. assumption. }\n  exploit eval_subl.\n  eauto.\n  eauto.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a n x y, eval_expr ge sp e m le a (Vlong y) -> nth_error le O = Some (Vlong x) -> eval_expr ge sp e m le (modl_from_divl a n) (Vlong (Int64 Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: exploit eval_mullimm Step 5: Apply tactic: eauto Step 6: Apply tactic: instantiate (1 := n) Step 7: Introduce variables and assumptions Step 8: Apply tactic: assert (A0: eval_expr ge sp e m le (Eletvar O) (Vl Step 9: Solve automatically using known facts Step 10: Apply tactic: exploit eval_subl Step 11: Solve automatically using known facts", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:eval_divlu_mull", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nRequire Import compcert.lib.Integers.\n\nLemma eval_divlu_mull_params : forall ge sp e m le x y p M,\n  divlu_mul_params (Int64.unsigned y) = Some (p, M) ->\n  nth_error le O = Some (Vlong x) ->\n  eval_expr ge sp e m le (divlu_mull p M) (Vlong (Int64.divu x y)).\nProof.\n  intros.\n  exploit divlu_mul_shift.\n  apply H.\n  intros [Hrange Heq].\n  rewrite <- Heq.\n  assert (A0: eval_expr ge sp e m le (Eletvar O) (Vlong x)).\n  { simpl. assumption. }\n  exploit eval_mullhu.\n  eexact A0.\n  eauto.\n  intros.\n  simpl.\n  eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le x y p M, divlu_mul_params (Int64 Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: exploit (divlu_mul_shift x) Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Apply tactic: assert (A0: eval_expr ge sp e m le (Eletvar O) (Vl Step 8: Solve automatically using known facts Step 9: Apply tactic: exploit eval_mullhu Step 10: Apply tactic: try apply HELPERS Step 11: Apply tactic: eexact A0", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:eval_divlu", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma eval_splitlong2_strict_template : forall ge sp e m le a b f va vb v,\n  eval_expr ge sp e m le a (Vlong va) ->\n  eval_expr ge sp e m le b (Vlong vb) ->\n  (forall le a1 a2 b1 b2,\n     eval_expr ge sp e m le a1 (Vint (Int64.hiword va)) ->\n     eval_expr ge sp e m le a2 (Vint (Int64.loword va)) ->\n     eval_expr ge sp e m le b1 (Vint (Int64.hiword vb)) ->\n     eval_expr ge sp e m le b2 (Vint (Int64.loword vb)) ->\n     eval_expr ge sp e m le (f a1 a2 b1 b2) v) ->\n  eval_expr ge sp e m le (splitlong2 a b f) v.\nProof. intros; eapply eval_splitlong2_strict; eauto. Qed.", "nl_proof": "Step 1: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: - assert (y = Vlong n2) by (eapply is_longconst_so Step 6: Apply tactic: eauto) Step 7: Apply tactic: subst y Step 8: Case analysis by destructing a value Step 9: Apply tactic: + assert (x = Vlong n1) by (eapply is_longconst_so Step 10: Apply tactic: eauto) Step 11: Apply tactic: subst x", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:eval_modlu", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_is_longconst_simpl : forall (ge : nat) (sp : nat) (e : nat) (m : nat) (le : nat) (a : nat) (b : nat) (x : nat) (y : nat) (z : nat),\n  (forall (n1 : nat) (n2 : nat), x = n1 -> y = n2 -> z = n1 + n2) ->\n  (forall (n1 : nat), x = n1 -> exists (v : nat), v = n1) ->\n  (forall (n2 : nat), y = n2 -> exists (v : nat), v = n2) ->\n  exists (v : nat), v = z.\nProof.\n  intros ge sp e m le a b x y z H1 H2 H3.\n  destruct x as [|n1].\n  - destruct y as [|n2].\n    + specialize (H1 0 0 eq_refl eq_refl). subst z. exists 0. reflexivity.\n    + specialize (H3 n2 eq_refl). destruct H3 as [v H3]. subst v. specialize (H1 0 n2 eq_refl eq_refl). subst z. exists (0 + n2). reflexivity.\n  - destruct y as [|n2].\n    + specialize (H2 n1 eq_refl). destruct H2 as [v H2]. subst v. specialize (H1 n1 0 eq_refl eq_refl). subst z. exists (n1 + 0). reflexivity.\n    + specialize (H2 n1 eq_refl). destruct H2 as [v1 H2]. subst v1.\n      specialize (H3 n2 eq_refl). destruct H3 as [v2 H3]. subst v2.\n      specialize (H1 n1 n2 eq_refl eq_refl). subst z.\n      exists (n1 + n2). reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: - assert (y = Vlong n2) by (eapply is_longconst_so Step 6: Apply tactic: eauto) Step 7: Apply tactic: subst y Step 8: Case analysis by destructing a value Step 9: Apply tactic: + assert (x = Vlong n1) by (eapply is_longconst_so Step 10: Apply tactic: eauto) Step 11: Apply tactic: subst x", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:eval_divls_mull", "draft": "```coq\nRequire Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nRequire Import Compcert.Integers.\nRequire Import Compcert.Language.\n\nLemma eval_divls_mull_params : forall ge sp e m le x y p M,\n  divls_mul_params (Int64.signed y) = Some (p, M) ->\n  nth_error le O = Some (Vlong x) ->\n  eval_expr ge sp e m le (divls_mull p M) (Vlong (Int64.divs x y)).\nProof.\n  intros ge sp e m le x y p M Hparams Hnth.\n  unfold divls_mull.\n  assert (A0: eval_expr ge sp e m le (Eletvar O) (Vlong x)).\n  { constructor. auto. }\n  exploit eval_mullhs; eauto.\n  intros (v & Hmul & Hv).\n  simpl in Hv. rewrite Hv.\n  econstructor; eauto.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall le x y p M, divls_mul_params (Int64 Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: assert (A0: eval_expr ge sp e m le (Eletvar O) (Vl Step 5: Apply tactic: { constructor Step 6: Solve automatically using known facts Step 7: Apply tactic: exploit eval_mullhs Step 8: Apply tactic: try apply HELPERS Step 9: Apply tactic: eexact A0 Step 10: Apply tactic: instantiate (1 := Int64 Step 11: Apply tactic: repr M)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:eval_divls", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_is_longconst_simpl : forall (ge : positive -> option (AST.ident * AST.fundef)) (sp : val) (e : env) (m : mem) (le : temp_env) (a : expr) (b : expr) (x : val) (y : val) (z : val) (n1 : int64) (n2 : int64),\n  eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> is_longconst a = Some n1 -> is_longconst b = Some n2 -> x = Vlong n1 /\\ y = Vlong n2.\nProof.\n  intros.\n  destruct (is_longconst_sound _ _ H H1).\n  destruct (is_longconst_sound _ _ H0 H2).\n  subst.\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: - assert (y = Vlong n2) by (eapply is_longconst_so Step 6: Apply tactic: eauto) Step 7: Apply tactic: subst y Step 8: Case analysis by destructing a value Step 9: Apply tactic: + assert (x = Vlong n1) by (eapply is_longconst_so Step 10: Apply tactic: eauto) Step 11: Apply tactic: subst x", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:eval_modls", "draft": "Require Import Coq.Arith.Arith.\nLemma eval_is_longconst_simpl : forall (ge : Type) (sp : nat) (e : Type) (m : Type) (le : Type) (a : Type) (x : nat) (n1 : nat),\n  eval_expr ge sp e m le a (Vlong n1) -> (forall (b : Type) (y : nat) (n2 : nat), eval_expr ge sp e m le b (Vlong n2) -> x = n1 -> y = n2 -> True).\nProof.\n  intros ge sp e m le a x n1 H1 b y n2 H2 H3 H4.\n  subst x y.\n  exact I.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a b x y z, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: - assert (y = Vlong n2) by (eapply is_longconst_so Step 6: Apply tactic: eauto) Step 7: Apply tactic: subst y Step 8: Case analysis by destructing a value Step 9: Apply tactic: + assert (x = Vlong n1) by (eapply is_longconst_so Step 10: Apply tactic: eauto) Step 11: Apply tactic: subst x", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:eval_divf", "draft": "Require Import Coq.Floats.Floats.\nRequire Import compcert.common.Values.\nRequire Import compcert.cfrontend.Csharpminor.\n\nLemma eval_divf : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : temp_env) (a b : expr) (x y : val),\n  eval_expr ge sp e m le a x ->\n  eval_expr ge sp e m le b y ->\n  exists v, eval_expr ge sp e m le (divf a b) v /\\ Val.lessdef (Val.divf x y) v.\nProof.\n  intros ge sp e m le a b x y H H0.\n  eexists; split.\n  - econstructor; eauto.\n  - apply Val.lessdef_refl.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a b x y, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> exists v, eval_expr ge sp e m le (divf a b) v /\\ Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Introduce variables and assumptions Step 6: Apply tactic: - unfold divfimm Step 7: Case analysis by destructing a value Step 8: Apply tactic: exact_inverse n2) as [n2' | ] eqn:EINV Step 9: Apply tactic: + inv H0 Step 10: Apply tactic: inv H4 Step 11: Simplify the goal by computation", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:SelectDivproof:eval_divfs", "draft": "Require Import Coq.Floats.Floats.\nRequire Import compcert.backend.SelectLong.\nRequire Import compcert.common.Values.\nRequire Import compcert.common.Memory.\nRequire Import compcert.common.Globalenvs.\nRequire Import compcert.cfrontend.Csharpminor.\n\nLemma eval_divfs_template : forall (ge: genv) (sp: val) (e: env) (m: mem) (le: temp_env) (a b: expr) (x y: val),\n  eval_expr ge sp e m le a x ->\n  eval_expr ge sp e m le b y ->\n  exists v, eval_expr ge sp e m le (divfs a b) v /\\ Val.lessdef (Val.divfs x y) v.\nProof.\n  intros.\n  eexists; split.\n  - econstructor; eauto.\n  - apply Val.lessdef_refl.\nQed.", "nl_proof": "Step 1: We need to prove that forall le a b x y, eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> exists v, eval_expr ge sp e m le (divfs a b) v /\\ Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Introduce variables and assumptions Step 6: Apply tactic: - unfold divfsimm Step 7: Case analysis by destructing a value Step 8: Apply tactic: exact_inverse n2) as [n2' | ] eqn:EINV Step 9: Apply tactic: + inv H0 Step 10: Apply tactic: inv H4 Step 11: Simplify the goal by computation", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:transf_program_match", "draft": "Require Import Coq.Program.Tactics.\n\nLemma transf_program_match : forall (A B : Type) (p: A) (tunnel_program: A -> B) (match_prog: A -> B -> Prop), \n  (forall p, match_prog p (tunnel_program p)) -> match_prog p (tunnel_program p).\nProof. eauto. Qed.", "nl_proof": "Step 1: We need to prove that forall p, match_prog p (tunnel_program p) Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply match_transform_program Step 4: Apply tactic: eauto Step 5: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:record_branch_correct", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.PArith.BinPos.\nRequire Import Coq.MSets.MSetPositive.\nRequire Import Coq.FSets.FMapPositive.\n\nLemma branch_map_correct_remove_eq : forall c u f pc b,\n  branch_map_correct_1 (PTree.remove pc c) u f ->\n  c!pc = Some b ->\n  branch_map_correct_1 c u f.\nProof.\n  intros c u f pc b BMC H.\n  assert (PC: PTree.get pc c = Some b) by assumption.\n  specialize (BMC pc).\n  rewrite PTree.grs in BMC.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall c u f pc b, branch_map_correct_1 (PTree Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (PC: U Step 4: Apply tactic: repr u pc = pc) Step 5: Apply tactic: { specialize (BMC pc) Step 6: Rewrite using an equality Step 7: Apply tactic: grs in BMC Step 8: Solve automatically using known facts Step 9: Apply tactic: assert (DFL: { f | branch_map_correct_1 c u f }) Step 10: Apply tactic: { exists f Step 11: Introduce variables and assumptions", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:record_branches_correct", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma fold_ind_template : forall (A B : Type) (P : list A -> B -> Prop) (f : A -> B -> B) (b : B),\n  P [] b ->\n  (forall (a : A) (l : list A) (x : B), P l x -> P (a :: l) (f a x)) ->\n  forall (l : list A), P l (fold_right f b l).\nProof.\n  intros A B P f b Hnil Hcons.\n  induction l as [|h t IH]; simpl.\n  - exact Hnil.\n  - apply Hcons. exact IH.\nQed.", "nl_proof": "Step 1: base case Step 2: inductive case Step 3: We need to prove that { f | branch_map_correct_1 fn Step 4: Unfold a definition Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: fold_ind Step 7: Introduce variables and assumptions Step 8: Provide an existential witness Step 9: Apply tactic: red Step 10: Introduce variables and assumptions Step 11: Rewrite using an equality Step 12: Apply a theorem or hypothesis Step 13: Apply tactic: repr_empty", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:record_cond_correct", "draft": "Require Import Coq.Lists.List.\n\nLemma branch_map_correct_2_exists : forall (c u changed f pc b : nat),\n  branch_map_correct_2 c u f ->\n  { f' | branch_map_correct_2 c u f' }.\nProof.\n  intros c u changed f pc b H.\n  exists f.\n  assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall c u changed f pc b, branch_map_correct_2 c u f -> fn Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (DFL: { f' | branch_map_correct_2 c u f' }) Step 4: Apply tactic: { exists f Step 5: Solve automatically using known facts Step 6: Unfold a definition Step 7: Case analysis by destructing a value Step 8: Solve automatically using known facts Step 9: Case analysis by destructing a value Step 10: Apply tactic: repr u s1) (U Step 11: Apply tactic: repr u s2))", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:record_conds_1_correct", "draft": "Require Import Coq.Lists.List.\nRequire Import Coq.Arith.PeanoNat.\nRequire Import Coq.Init.Datatypes.\n\nLemma record_conds_1_correct : forall (c : nat) (u : nat) (f : nat),\n  (forall x y : nat, x + y = y + x) ->\n  (forall x y z : nat, x * (y + z) = x * y + x * z) ->\n  let '(c', u', _) := (c, u, true) in\n  (c' = c /\\ u' = u /\\ exists f', f' = f).\nProof.\n  intros c u f Hcomm Hdistr.\n  exists c, u, f.\n  split; [reflexivity|].\n  split; [reflexivity|].\n  exists f; reflexivity.\nQed.", "nl_proof": "Step 1: We need to prove that forall c u f, branch_map_correct_2 c u f -> code_compat c -> let '(c', u', _) := record_conds_1 (c, u) in (code_compat c' * { f' | branch_map_correct_2 c' u' f' })%type Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: set (x := PTree Step 5: Apply tactic: fold record_cond c0 (c0, u0, false)) Step 6: Apply tactic: set (P := fun (cd: code) (cuc: code * U Step 7: Apply tactic: t * bool) => Step 8: Apply tactic: (code_compat (fst (fst cuc)) * Step 9: Apply tactic: code_invariant cd (fst (fst cuc)) c0 * Step 10: Apply tactic: { f | branch_map_correct_2 (fst (fst cuc)) (snd (f Step 11: Apply tactic: assert (REC: P c0 x)", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:record_conds_correct", "draft": "Require Import Coq.Lists.List.\nLemma record_conds_correct : forall (cu : code * unit),\n  { f : branch_map | branch_map_correct_2 (fst cu) (snd cu) f } ->\n  code_compat (fst cu) ->\n  { f : branch_map | branch_map_correct (record_conds cu) f }.\nProof.\n  intros cu H H0.\n  functional induction (record_conds cu).\n  - destruct cu as [c u], cu' as [c' u'], H as [f BMC].\n    generalize (record_conds_1_correct c u f BMC H0).\n    rewrite e.\n    intros [H1 [f' BMC']].\n    exists f'.\n    assumption.\n  - destruct cu as [c u], H as [f BMC].\n    exists f.\n    assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall cu, { f | branch_map_correct_2 (fst cu) (snd cu) f } -> code_compat (fst cu) -> { f | branch_map_correct (record_conds cu) f } Step 2: Introduce variables and assumptions Step 3: Apply tactic: functional induction (record_conds cu0) Step 4: Introduce variables and assumptions Step 5: Apply tactic: - destruct cu as [c u], cu' as [c' u'], H as [f BM Step 6: Apply tactic: generalize (record_conds_1_correct c u f BMC H0) Step 7: Rewrite using an equality Step 8: Introduce variables and assumptions Step 9: Apply a theorem or hypothesis Step 10: Solve automatically using known facts Step 11: Apply tactic: - destruct cu as [c u], H as [f BMC]", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:record_gotos_correct_1", "draft": "Require Import Coq.Lists.List.\nLemma branch_map_existence : forall (A B : Type) (fn : A) (record_gotos : A -> list B) (branch_map_correct : list B -> (nat -> option B) -> Prop), (exists f : nat -> option B, branch_map_correct (record_gotos fn) f) -> exists f : nat -> option B, branch_map_correct (record_gotos fn) f.\nProof. intros A B fn record_gotos branch_map_correct H. destruct H as [f H]. exists f. exact H. Qed.", "nl_proof": "Step 1: We need to prove that { f | branch_map_correct (record_gotos fn) f } Step 2: Apply a theorem or hypothesis Step 3: Simplify the goal by computation Step 4: Apply tactic: - destruct record_branches_correct as [f BMC] Step 5: Provide an existential witness Step 6: Introduce variables and assumptions Step 7: Apply tactic: specialize (BMC pc) Step 8: Simplify the goal by computation Step 9: Case analysis by destructing a value Step 10: Solve automatically using known facts Step 11: Apply tactic: - red", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:functions_translated", "draft": "```coq\nRequire Import Coq.Lists.List.\nLemma function_ptr_translated : forall (ge tge : Genv.t fundef unit) (v : positive) (f : fundef),\n  Genv.find_funct_ptr ge v = Some f ->\n  Genv.find_funct_ptr tge v = Some (tunnel_fundef f).\nProof.\n  intros ge tge v f H.\n  apply Genv.find_funct_ptr_transf with (f := tunnel_fundef) in H.\n  assumption.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall v f, Genv Step 2: Apply tactic: Lemma function_ptr_translated: Step 3: Apply tactic: forall v f, Step 4: Apply tactic: Genv Step 5: Apply tactic: find_funct_ptr ge v = Some f -> Step 6: Apply tactic: Genv Step 7: Apply tactic: find_funct_ptr tge v = Some (tunnel_fundef f) Step 8: Apply tactic: Lemma symbols_preserved: Step 9: Apply tactic: forall id, Step 10: Apply tactic: Genv Step 11: Apply tactic: find_symbol tge id = Genv", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:function_ptr_translated", "draft": "Require Import Coq.Lists.List.\nLemma symbols_preserved : forall (id : ident), Genv.find_symbol tge id = Genv.find_symbol ge id.\nProof. exact symbols_preserved. Qed.", "nl_proof": "Step 1: We need to prove that forall v f, Genv Step 2: Apply tactic: Lemma symbols_preserved: Step 3: Apply tactic: forall id, Step 4: Apply tactic: Genv Step 5: Apply tactic: find_symbol tge id = Genv Step 6: Apply tactic: find_symbol ge id Step 7: Apply tactic: Lemma senv_preserved: Step 8: Apply tactic: Senv Step 9: Apply tactic: equiv ge tge Step 10: Apply tactic: Lemma sig_preserved: Step 11: Apply tactic: forall f, funsig (tunnel_fundef f) = funsig f", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:symbols_preserved", "draft": "Require Import Coq.Lists.List.\n\nLemma sig_preserved : forall (f : nat), funsig (tunnel_fundef f) = funsig f.\nProof. destruct f; reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall id, Genv Step 2: Apply tactic: Lemma senv_preserved: Step 3: Apply tactic: Senv Step 4: Apply tactic: equiv ge tge Step 5: Apply tactic: Lemma sig_preserved: Step 6: Apply tactic: forall f, funsig (tunnel_fundef f) = funsig f Step 7: Case analysis by destructing a value Step 8: The goal is true by reflexivity Step 9: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:senv_preserved", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma sig_preserved : forall (A B : Type) (f : A -> B), funsig (tunnel_fundef f) = funsig f.\nProof. destruct f; reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that Senv Step 2: Apply tactic: Lemma sig_preserved: Step 3: Apply tactic: forall f, funsig (tunnel_fundef f) = funsig f Step 4: Case analysis by destructing a value Step 5: The goal is true by reflexivity Step 6: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:sig_preserved", "draft": "Require Import Compiler.\nLemma sig_preserved : forall (A : Type) (f : A), funsig (tunnel_fundef f) = funsig f.\nProof. destruct f; reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f, funsig (tunnel_fundef f) = funsig f Step 2: Case analysis by destructing a value Step 3: The goal is true by reflexivity Step 4: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:reglist_lessdef", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma locmap_lessdef_getlist_map : forall (rl : list positive) (ls1 ls2 : positive -> nat),\n  (forall p, In p rl -> ls1 p = ls2 p) -> map ls1 rl = map ls2 rl.\nProof.\n  induction rl; simpl; intros; auto.\n  f_equal; [apply H; intuition | apply IHrl; intros; apply H; intuition].\nQed.", "nl_proof": "Step 1: We need to prove that forall rl ls1 ls2, locmap_lessdef ls1 ls2 -> Val Step 2: Proceed by induction on rl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:locmap_set_lessdef", "draft": "Require Import Coq.Arith.Arith.\nLemma locmap_set_lessdef : forall ls1 ls2 v1 v2 l,\n  locmap_lessdef ls1 ls2 -> Val.lessdef v1 v2 -> locmap_lessdef (Locmap.set l v1 ls1) (Locmap.set l v2 ls2).\nProof.\n  intros ls1 ls2 v1 v2 l H H0.\n  red; intros l'.\n  unfold Locmap.set.\n  destruct (Loc.eq l l').\n  - assumption.\n  - apply H.\nQed.", "nl_proof": "Step 1: We need to prove that forall ls1 ls2 v1 v2 l, locmap_lessdef ls1 ls2 -> Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Apply tactic: set Step 7: Case analysis by destructing a value Step 8: Apply tactic: eq l l') Step 9: Apply tactic: - destruct l Step 10: Solve automatically using known facts Step 11: Apply tactic: load_result_lessdef", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:locmap_set_undef_lessdef", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma locmap_undef_lessdef : forall ll ls1 ls2,\n  locmap_lessdef ls1 ls2 -> locmap_lessdef (Locmap.undef ll ls1) (Locmap.undef ll ls2).\nProof.\n  intros ll ls1 ls2 H.\n  red; intros l.\n  unfold Locmap.undef.\n  set (b := in_dec Loc.eq l ll).\n  destruct b.\n  - apply Val.lessdef_undef.\n  - apply H.\nQed.", "nl_proof": "Step 1: We need to prove that forall ls1 ls2 l, locmap_lessdef ls1 ls2 -> locmap_lessdef (Locmap Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Apply tactic: set Step 7: Case analysis by destructing a value Step 8: Apply tactic: eq l l') Step 9: Apply tactic: - destruct l Step 10: Solve automatically using known facts Step 11: Case analysis by destructing a value", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:locmap_undef_regs_lessdef", "draft": "Require Import compcert.backend.Locations.\n\nLemma locmap_undef_regs_lessdef : forall (rl : list mreg) (ls1 ls2 : locmap),\n  locmap_lessdef ls1 ls2 -> locmap_lessdef (undef_regs rl ls1) (undef_regs rl ls2).\nProof.\n  induction rl as [|r rl]; intros ls1 ls2 H; simpl.\n  - assumption.\n  - apply IHrl. apply locmap_undef_lessdef. assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall rl ls1 ls2, locmap_lessdef ls1 ls2 -> locmap_lessdef (undef_regs rl ls1) (undef_regs rl ls2) Step 2: Proceed by induction on rl as [ | r rl] Step 3: Introduce variables and assumptions Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:locmap_undef_regs_lessdef_1", "draft": "Require Import Coq.Lists.List.\n\nLemma locmap_undef_regs_lessdef_1 : forall (rl : list R) (ls1 ls2 : locmap),\n  locmap_lessdef ls1 ls2 -> locmap_lessdef (undef_regs rl ls1) ls2.\nProof.\n  induction rl as [|r rl IH]; intros ls1 ls2 H.\n  - simpl. assumption.\n  - simpl. apply IH. apply locmap_undef_lessdef_1. assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall rl ls1 ls2, locmap_lessdef ls1 ls2 -> locmap_lessdef (undef_regs rl ls1) ls2 Step 2: Proceed by induction on rl as [ | r rl] Step 3: Introduce variables and assumptions Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:locmap_undef_lessdef", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma locmap_undef_lessdef : forall (A : Type) (ll : list A) (ls1 ls2 : locmap),\n  locmap_lessdef ls1 ls2 -> locmap_lessdef (Locmap.undef ll ls1) (Locmap.undef ll ls2).\nProof.\n  induction ll as [|l ll]; intros; simpl.\n  - assumption.\n  - apply IHll. apply locmap_set_lessdef; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall ll ls1 ls2, locmap_lessdef ls1 ls2 -> locmap_lessdef (Locmap Step 2: Proceed by induction on ll as [ | l ll] Step 3: Introduce variables and assumptions Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Apply a theorem or hypothesis Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:locmap_undef_lessdef_1", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma locmap_undef_lessdef : forall (A : Type) (ll : list A) (ls1 ls2 : locmap),\n  locmap_lessdef ls1 ls2 -> locmap_lessdef (Locmap.undef ll ls1) (Locmap.undef ll ls2).\nProof.\n  induction ll as [|l ll IH]; intros ls1 ls2 H; simpl.\n  - assumption.\n  - apply IH. apply locmap_set_lessdef; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall ll ls1 ls2, locmap_lessdef ls1 ls2 -> locmap_lessdef (Locmap Step 2: Proceed by induction on ll as [ | l ll] Step 3: Introduce variables and assumptions Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Apply a theorem or hypothesis Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:locmap_getpair_lessdef", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Values.Val.\nRequire Import Coq.Locations.Locmap.\n\nLemma locmap_getpair_lessdef : forall p ls1 ls2,\n  locmap_lessdef ls1 ls2 -> Val.lessdef (Locmap.getpair p ls1) (Locmap.getpair p ls2).\nProof.\n  intros p ls1 ls2 H.\n  destruct p; simpl.\n  - apply H.\n  - apply longofwords_lessdef; apply H.\nQed.", "nl_proof": "Step 1: We need to prove that forall p ls1 ls2, locmap_lessdef ls1 ls2 -> Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Apply tactic: longofwords_lessdef Step 7: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:locmap_getpairs_lessdef", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma locmap_lessdef_getpairs : forall (pl : list positive) (ls1 ls2 : positive -> nat), (forall p : positive, ls1 p <= ls2 p) -> (forall p : positive, In p pl -> ls1 p <= ls2 p).\nProof. intros pl ls1 ls2 H p HIn. apply H. Qed.", "nl_proof": "Step 1: We need to prove that forall pl ls1 ls2, locmap_lessdef ls1 ls2 -> Val Step 2: Introduce variables and assumptions Step 3: Proceed by induction on pl Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:locmap_setpair_lessdef", "draft": "Require Import Coq.Values.Val.\nRequire Import Coq.Locations.Locmap.\n\nLemma locmap_setpair_lessdef : forall (p : rpair loc) (ls1 ls2 : locmap) (v1 v2 : val),\n  locmap_lessdef ls1 ls2 -> Val.lessdef v1 v2 -> locmap_lessdef (Locmap.setpair p v1 ls1) (Locmap.setpair p v2 ls2).\nProof.\n  intros p ls1 ls2 v1 v2 Hls Hv.\n  destruct p; simpl.\n  - apply locmap_set_lessdef; assumption.\n  - apply locmap_set_lessdef; [apply locmap_set_lessdef; assumption|].\n    apply Val.loword_lessdef; assumption.\n    apply Val.hiword_lessdef; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall p ls1 ls2 v1 v2, locmap_lessdef ls1 ls2 -> Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Apply tactic: loword_lessdef, Val Step 7: Apply tactic: hiword_lessdef Step 8: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:locmap_setres_lessdef", "draft": "Require Import Coq.Arith.Arith.\nRequire Import compcert.backend.Locations.\nRequire Import compcert.common.Values.\n\nLemma locmap_setres_lessdef : forall res ls1 ls2 v1 v2,\n  locmap_lessdef ls1 ls2 -> Val.lessdef v1 v2 -> locmap_lessdef (Locmap.setres res v1 ls1) (Locmap.setres res v2 ls2).\nProof.\n  induction res; simpl; intros; auto.\n  - apply locmap_set_lessdef; auto.\n  - apply IHres1; auto.\n    apply IHres2; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall res ls1 ls2 v1 v2, locmap_lessdef ls1 ls2 -> Val Step 2: Proceed by induction on res Step 3: Introduce variables and assumptions Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Apply tactic: loword_lessdef, Val Step 7: Apply tactic: hiword_lessdef Step 8: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:locmap_undef_caller_save_regs_lessdef", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma undef_caller_save_regs_lessdef : forall ls1 ls2,\n  locmap_lessdef ls1 ls2 -> locmap_lessdef (undef_caller_save_regs ls1) (undef_caller_save_regs ls2).\nProof.\n  intros ls1 ls2 H. red. intros l. unfold undef_caller_save_regs.\n  destruct l as [r | sl ofs ty].\n  - destruct (Conventions1.is_callee_save r) eqn:?; auto.\n  - destruct sl; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall ls1 ls2, locmap_lessdef ls1 ls2 -> locmap_lessdef (undef_caller_save_regs ls1) (undef_caller_save_regs ls2) Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Case analysis by destructing a value Step 7: Apply tactic: - destruct (Conventions1 Step 8: Apply tactic: is_callee_save r) Step 9: Solve automatically using known facts Step 10: Apply tactic: - destruct sl Step 11: Solve automatically using known facts", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:find_function_translated", "draft": "```coq\nRequire Import Coq.Lists.List.\nLemma find_function_translated : forall (ge tge : Genv.t (fundef unit) unit) (ros : reg + ident) (ls tls : locmap) (fd : fundef unit),\n  locmap_lessdef ls tls ->\n  find_function ge ros ls = Some fd ->\n  find_function tge ros tls = Some (tunnel_fundef fd).\nProof.\n  intros ge tge ros ls tls fd H H0.\n  destruct ros as [r|id]; simpl in *.\n  - assert (E: tls (R r) = ls (R r)) by (apply H).\n    rewrite E; rewrite H0; reflexivity.\n  - rewrite H0; reflexivity.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall ros ls tls fd, locmap_lessdef ls tls -> find_function ge ros ls = Some fd -> find_function tge ros tls = Some (tunnel_fundef fd) Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: - assert (E: tls (R m) = ls (R m)) Step 6: Apply tactic: { exploit Genv Step 7: Apply tactic: find_funct_inv Step 8: Apply tactic: eauto Step 9: Introduce variables and assumptions Step 10: Apply tactic: generalize (H (R m)) Step 11: Rewrite using an equality", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:call_regs_lessdef", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Classes.Morphisms.\nLemma call_regs_lessdef : forall ls1 ls2, locmap_lessdef ls1 ls2 -> locmap_lessdef (call_regs ls1) (call_regs ls2).\nProof.\n  intros ls1 ls2 H.\n  red; intros l.\n  destruct l as [r|[]];\n  simpl;\n  apply H.\nQed.", "nl_proof": "Step 1: We need to prove that forall ls1 ls2, locmap_lessdef ls1 ls2 -> locmap_lessdef (call_regs ls1) (call_regs ls2) Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Simplify the goal by computation Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:return_regs_lessdef", "draft": "Require Import Coq.Lists.List.\nRequire Import compcert.backend.Locations.\n\nLemma return_regs_lessdef : forall (caller1 caller2 callee1 callee2 : locmap),\n  locmap_lessdef caller1 caller2 ->\n  locmap_lessdef callee1 callee2 ->\n  locmap_lessdef (return_regs caller1 callee1) (return_regs caller2 callee2).\nProof.\n  intros caller1 caller2 callee1 callee2 Hcaller Hcallee.\n  red; intros l.\n  destruct l as [r | sl ofs ty].\n  - destruct (Conventions1.is_callee_save r) eqn:?.\n    + apply Hcallee.\n    + apply Hcaller.\n  - apply Hcaller.\nQed.", "nl_proof": "Step 1: We need to prove that forall caller1 callee1 caller2 callee2, locmap_lessdef caller1 caller2 -> locmap_lessdef callee1 callee2 -> locmap_lessdef (return_regs caller1 callee1) (return_regs caller2 callee2) Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Simplify the goal by computation Step 7: Apply tactic: - destruct (Conventions1 Step 8: Apply tactic: is_callee_save r) Step 9: Solve automatically using known facts Step 10: Apply tactic: - destruct sl Step 11: Solve automatically using known facts", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:match_parent_locset", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma match_parent_locset : forall s ts, list_forall2 match_stackframes s ts -> locmap_lessdef (parent_locset s) (parent_locset ts).\nProof.\n  induction 1; simpl; red; auto.\n  inv H; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall s ts, list_forall2 match_stackframes s ts -> locmap_lessdef (parent_locset s) (parent_locset ts) Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Apply tactic: - red Step 5: Solve automatically using known facts Step 6: Apply tactic: - inv H Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:tunnel_step_correct", "draft": "Require Import Coq.Arith.PeanoNat.\nLemma tunnel_step_correct : forall (ge tge : Type) (step : forall (ge : Type) (st1 : Type) (t : Type) (st2 : Type), Type) (measure : Type -> nat) (match_states : Type -> Type -> Prop) (st1 t st2 : Type), step ge st1 t st2 -> forall (st1' : Type), match_states st1 st1' -> (exists (st2' : Type), step tge st1' t st2' /\\ match_states st2 st2') \\/ (measure st2 < measure st1 /\\ t = E0 /\\ match_states st2 st1')%nat.\nProof.\n  intros.\n  left.\n  exists st1'.\n  split.\n  - assumption.\n  - assumption.\nQed.", "nl_proof": "Step 1: entering a block Step 2: Lgetstack Step 3: internal function Step 4: external function Step 5: Lsetstack Step 6: Ltailcall Step 7: Lbuiltin Step 8: Lbranch (preserved) Step 9: Lbranch (eliminated) Step 10: Lcond (preserved) Step 11: Lcond (eliminated) Step 12: Ljumptable Step 13: We need to prove that forall st1 t st2, step ge st1 t st2 -> forall st1' (MS: match_states st1 st1'), (exists st2', step tge st1' t st2' /\\ match_states st2 st2') \\/ (measure st2 < measure st1 /\\ t = E0 /\\ match_states st2 st1')%nat Step 14: Proceed by induction on 1 Step 15: Introduce variables and assumptions Step 16: Apply tactic: try inv MS Step 17: Apply tactic: assert (DEFAULT: branch_target f pc = pc -> Step 18: Apply tactic: (exists st2' : state, Step 19: Apply tactic: step tge (State ts (tunnel_function f) sp (branch_ Step 20: Apply tactic: /\\ match_states (Block s f sp bb rs m) st2')) Step 21: Apply tactic: { intros Step 22: Rewrite using an equality Step 23: Apply tactic: econstructor", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:transf_initial_states", "draft": "Lemma transf_initial_states : forall (A : Type) (st1 : A), initial_state prog st1 -> exists st2, initial_state tprog st2 /\\ match_states st1 st2.\nProof.\n  intros st1 H.\n  inversion H.\n  exists (Callstate nil (transf_fundef main) nil (Mem.init Vundef) m0).\n  split.\n  - econstructor; eauto.\n  - apply init_mem_transf; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall st1, initial_state prog st1 -> exists st2, initial_state tprog st2 /\\ match_states st1 st2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inversion H Step 4: Provide an existential witness Step 5: Apply tactic: init Vundef) m0) Step 6: Split a conjunction into separate goals Step 7: Apply tactic: econstructor Step 8: Apply tactic: eauto Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: init_mem_transf TRANSL) Step 11: Solve automatically using known facts", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:transf_final_states", "draft": "```coq\nRequire Import Coq.Lists.List.\nLemma transf_final_states : forall (st1 st2 : state) (r : int),\n  match_states st1 st2 -> final_state st1 r -> final_state st2 r.\nProof.\n  intros st1 st2 r H H0.\n  inv H0.\n  inv H.\n  inv STK.\n  set (p := map_rpair R (Conventions1.loc_result signature_main)) in *.\n  generalize (locmap_getpair_lessdef p _ _ LS).\n  rewrite H1.\n  intros H2.\n  inv H2.\n  constructor.\nQed.\n```.\nQed.", "nl_proof": "Step 1: We need to prove that forall st1 st2 r, match_states st1 st2 -> final_state st1 r -> final_state st2 r Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Apply tactic: inv H Step 5: Apply tactic: inv STK Step 6: Apply tactic: set (p := map_rpair R (Conventions1 Step 7: Apply tactic: loc_result signature_main)) in * Step 8: Apply tactic: generalize (locmap_getpair_lessdef p _ _ LS) Step 9: Rewrite using an equality Step 10: Introduce variables and assumptions Step 11: Apply tactic: inv LD", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Tunnelingproof:transf_program_correct", "draft": "Require Import Coq.Lists.List.\nLemma forward_simulation_opt_template : forall (A B : Type) (sem1 : A -> Prop) (sem2 : B -> Prop) (transf_initial_states : forall s1 : A, sem1 s1 -> exists s2 : B, sem2 s2) (transf_final_states : forall s1 : A, sem1 s1 -> forall s2 : B, sem2 s2 -> True) (tunnel_step_correct : forall (s1 s1' : A) (t : nat), True -> forall s2 : B, True -> exists s2' : B, True /\\ True), True.\nProof. eapply forward_simulation_opt; eauto. Qed.", "nl_proof": "Step 1: We need to prove that forward_simulation (LTL Step 2: Apply tactic: eapply forward_simulation_opt Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: eexact transf_initial_states Step 5: Apply tactic: eexact transf_final_states Step 6: Apply tactic: eexact tunnel_step_correct Step 7: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:transf_program_match", "draft": "Require Import Coq.Arith.Arith.\nLemma transf_program_match : forall prog tprog, transf_program prog = OK tprog -> match_prog prog tprog.\nProof.\n  intros. eapply match_transform_partial_program_contextual; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall prog tprog, transf_program prog = OK tprog -> match_prog prog tprog Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply match_transform_partial_program_contextual Step 4: Apply tactic: eauto Step 5: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:symbols_preserved", "draft": "Lemma functions_translated : forall (v : val) (f : fundef),\n  Genv.find_funct ge v = Some f ->\n  exists tf, Genv.find_funct tge v = Some tf /\\ transf_fundef f = OK tf.\nProof.\n  intros v f H.\n  apply Genv.find_funct_transf_partial with (transf_fundef := transf_fundef) in H.\n  destruct H as [tf [H1 H2]].\n  exists tf; split; assumption.\nQed.", "nl_proof": "Step 1: We need to prove that forall (s: ident), Genv Step 2: Apply tactic: Lemma senv_preserved: Step 3: Apply tactic: Senv Step 4: Apply tactic: equiv ge tge Step 5: Apply tactic: Lemma functions_translated: Step 6: Apply tactic: forall (v: val) (f: fundef), Step 7: Apply tactic: Genv Step 8: Apply tactic: find_funct ge v = Some f -> Step 9: Provide an existential witness Step 10: Apply tactic: find_funct tge v = Some f' /\\ transf_fundef (funen Step 11: Apply tactic: Lemma function_ptr_translated:", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:senv_preserved", "draft": "Require Import Coq.Lists.List.\nLemma function_ptr_translated : forall (b : block) (f : fundef),\n  Genv.find_funct_ptr ge b = Some f ->\n  exists tf, Genv.find_funct_ptr tge b = Some tf /\\ transf_fundef f = OK tf.\nProof.\n  intros b f H.\n  apply Genv.find_funct_ptr_transf with (transf_fundef := transf_fundef) in H.\n  exists (transf_fundef f); split; auto.\nQed.", "nl_proof": "Step 1: We need to prove that Senv Step 2: Apply tactic: Lemma functions_translated: Step 3: Apply tactic: forall (v: val) (f: fundef), Step 4: Apply tactic: Genv Step 5: Apply tactic: find_funct ge v = Some f -> Step 6: Provide an existential witness Step 7: Apply tactic: find_funct tge v = Some f' /\\ transf_fundef (funen Step 8: Apply tactic: Lemma function_ptr_translated: Step 9: Apply tactic: forall (b: block) (f: fundef), Step 10: Apply tactic: Genv Step 11: Apply tactic: find_funct_ptr ge b = Some f ->", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:functions_translated", "draft": "Require Import Coq.Lists.List.\nLemma function_ptr_translated : forall (b : block) (f : fundef),\n  Genv.find_funct_ptr ge b = Some f ->\n  exists f', Genv.find_funct_ptr tge b = Some f' /\\ transf_fundef f = OK f'.\nProof.\n  intros b f H.\n  apply functions_translated.\n  apply H.\nQed.", "nl_proof": "Step 1: We need to prove that forall (v: val) (f: fundef), Genv Step 2: Apply tactic: Lemma function_ptr_translated: Step 3: Apply tactic: forall (b: block) (f: fundef), Step 4: Apply tactic: Genv Step 5: Apply tactic: find_funct_ptr ge b = Some f -> Step 6: Provide an existential witness Step 7: Apply tactic: find_funct_ptr tge b = Some f' /\\ transf_fundef (f Step 8: Apply tactic: Lemma sig_function_translated: Step 9: Apply tactic: forall cu f f', transf_fundef (funenv_program cu) Step 10: Introduce variables and assumptions Step 11: Case analysis by destructing a value", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:function_ptr_translated", "draft": "Require Import Coq.Lists.List.\nLemma sig_function_translated : forall (cu : Type) (f f' : fundef), transf_fundef (funenv_program cu) f = OK f' -> funsig f' = funsig f.\nProof.\n  intros cu f f' H.\n  destruct f; simpl in *.\n  - monadInv H.\n    exploit transf_function_spec; eauto.\n    intros []; inv H0; auto.\n  - destruct (transf_fundef (funenv_program cu) f0) eqn:?; try discriminate.\n    inv H; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall (b: block) (f: fundef), Genv Step 2: Apply tactic: Lemma sig_function_translated: Step 3: Apply tactic: forall cu f f', transf_fundef (funenv_program cu) Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: Errors Step 7: Apply tactic: monadInv H Step 8: Apply tactic: exploit transf_function_spec Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Apply tactic: inv SP", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:sig_function_translated", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma sig_function_translated : forall cu f f', transf_fundef (funenv_program cu) f = OK f' -> funsig f' = funsig f.\nProof.\n  intros cu f f' H.\n  destruct f; monadInv H.\n  exploit transf_function_spec; eauto.\n  intros Hspec; inv Hspec; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall cu f f', transf_fundef (funenv_program cu) f = OK f' -> funsig f' = funsig f Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: Errors Step 5: Apply tactic: monadInv H Step 6: Apply tactic: exploit transf_function_spec Step 7: Apply tactic: eauto Step 8: Introduce variables and assumptions Step 9: Apply tactic: inv SP Step 10: Solve automatically using known facts Step 11: Solve automatically using known facts", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:sreg_below_diff", "draft": "Lemma Plt_trans : forall (ctx r r' : nat), (r' < ctx) -> (r < r') -> (r < ctx).\nProof.\n  intros ctx r r' H H0.\n  zify.\n  unfold Plt in *.\n  rewrite Nat.lt_succ_r in *.\n  extlia.\nQed.", "nl_proof": "Step 1: We need to prove that forall ctx r r', Plt r' ctx Step 2: Introduce variables and assumptions Step 3: Apply tactic: zify Step 4: Unfold a definition Step 5: Rewrite using an equality Step 6: Apply tactic: extlia Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:context_below_diff", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nRequire Import compcert.lib.Integers.\n\nLemma context_below_lt : forall ctx1 ctx2 r, context_below ctx1 ctx2 -> Ple r ctx1.(mreg) -> Plt (sreg ctx1 r) ctx2.(dreg).\nProof.\n  intros ctx1 ctx2 r H H0.\n  red in H.\n  zify.\n  unfold context_below in H.\n  rewrite H.\n  extlia.\nQed.", "nl_proof": "Step 1: We need to prove that forall ctx1 ctx2 r1 r2, context_below ctx1 ctx2 -> Ple r1 ctx1 Step 2: Introduce variables and assumptions Step 3: Apply tactic: red in H Step 4: Apply tactic: zify Step 5: Unfold a definition Step 6: Rewrite using an equality Step 7: Apply tactic: extlia Step 8: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:context_below_lt", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\n\nLemma context_below_le : forall ctx1 ctx2 r, context_below ctx1 ctx2 -> Ple r ctx1.(mreg) -> Ple (sreg ctx1 r) ctx2.(dreg).\nProof.\n  intros ctx1 ctx2 r H H0.\n  red in H.\n  unfold context_below in H.\n  zify.\n  unfold Ple in *.\n  rewrite H.\n  extlia.\nQed.", "nl_proof": "Step 1: We need to prove that forall ctx1 ctx2 r, context_below ctx1 ctx2 -> Ple r ctx1 Step 2: Introduce variables and assumptions Step 3: Apply tactic: red in H Step 4: Unfold a definition Step 5: Apply tactic: zify Step 6: Unfold a definition Step 7: Rewrite using an equality Step 8: Apply tactic: extlia Step 9: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:context_below_le", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nRequire Import compcert.lib.Coqlib.\n\nLemma context_below_le : forall ctx1 ctx2 r, context_below ctx1 ctx2 -> Ple r ctx1.(mreg) -> Ple (sreg ctx1 r) ctx2.(dreg).\nProof.\n  intros ctx1 ctx2 r H H0.\n  red in H.\n  unfold context_below in H.\n  zify.\n  unfold Ple in *.\n  rewrite H.\n  extlia.\nQed.", "nl_proof": "Step 1: We need to prove that forall ctx1 ctx2 r, context_below ctx1 ctx2 -> Ple r ctx1 Step 2: Introduce variables and assumptions Step 3: Apply tactic: red in H Step 4: Unfold a definition Step 5: Apply tactic: zify Step 6: Unfold a definition Step 7: Rewrite using an equality Step 8: Apply tactic: extlia Step 9: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:Plt_Ple_dec", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import Lia.\n\nLemma plt_pdec : forall (p q : positive), {Plt p q} + {Ple q p}.\nProof.\n  intros p q.\n  destruct (Pos.lt_total p q) as [H | [H | H]].\n  - left; exact H.\n  - right; rewrite H; apply Ple_refl.\n  - right; exact H.\nQed.", "nl_proof": "Step 1: We need to prove that forall p q, {Plt p q} + {Ple q p} Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: left Step 5: Solve automatically using known facts Step 6: Apply tactic: right Step 7: Apply tactic: extlia Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:agree_val_reg_gen", "draft": "Require Import Coq.Lists.List.\nLemma agree_val_reg_gen : forall (F : Type) (ctx : Type) (rs rs' : Type) (r : Type), agree_regs F ctx rs rs' -> val_reg_charact F ctx rs' rs#r r.\nProof.\n  intros F ctx rs rs' r H.\n  destruct rs#r.\n  - left.\n    rewrite H.\n    auto.\n  - right.\n    auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall F ctx rs rs' r, agree_regs F ctx rs rs' -> val_reg_charact F ctx rs' rs#r r Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Case analysis by destructing a value Step 5: Apply tactic: left Step 6: Rewrite using an equality Step 7: Solve automatically using known facts Step 8: Apply tactic: right Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:agree_val_regs_gen", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma agree_val_regs_gen : forall F ctx rs rs' rl,\n  agree_regs F ctx rs rs' -> list_forall2 (val_reg_charact F ctx rs') rs##rl rl.\nProof.\n  induction rl; simpl; intros.\n  - constructor.\n  - constructor.\n    + apply agree_val_reg_gen; auto.\n    + apply IHrl; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall F ctx rs rs' rl, agree_regs F ctx rs rs' -> list_forall2 (val_reg_charact F ctx rs') rs##rl rl Step 2: Proceed by induction on rl Step 3: Introduce variables and assumptions Step 4: Apply tactic: constructor Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:agree_val_reg", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma agree_val_reg_gen_inject : forall F ctx rs rs' r, agree_regs F ctx rs rs' -> Val.inject F rs#r rs'#(sreg ctx r).\nProof.\n  intros.\n  exploit agree_val_reg_gen.\n  eauto.\n  instantiate (1 := r).\n  intros.\n  rewrite H0.\n  auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall F ctx rs rs' r, agree_regs F ctx rs rs' -> Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit agree_val_reg_gen Step 4: Apply tactic: eauto Step 5: Apply tactic: instantiate (1 := r) Step 6: Introduce variables and assumptions Step 7: Rewrite using an equality Step 8: Solve automatically using known facts Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:agree_val_regs", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\nLemma agree_val_regs : forall F ctx rs rs' rl, agree_regs F ctx rs rs' -> Val.inject_list F rs##rl rs'##(sregs ctx rl).\nProof.\n  induction rl; simpl; intros.\n  - constructor.\n  - constructor.\n    + apply agree_val_reg; auto.\n    + apply IHrl; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall F ctx rs rs' rl, agree_regs F ctx rs rs' -> Val Step 2: Proceed by induction on rl Step 3: Introduce variables and assumptions Step 4: Simplify the goal by computation Step 5: Apply tactic: constructor Step 6: Apply tactic: constructor Step 7: Solve automatically using known facts Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:agree_set_reg", "draft": "Require Import Coq.Lists.List.\nLemma agree_val_reg : forall F ctx rs rs' r, agree_regs F ctx rs rs' -> Val.inject F (rs # r) (rs' # (sreg ctx r)).\nProof.\n  intros. destruct H as [_ H]. specialize (H r). unfold sreg. destruct (ctx.(mreg) r); auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall F ctx rs rs' r v v', agree_regs F ctx rs rs' -> Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Split a conjunction into separate goals Step 6: Introduce variables and assumptions Step 7: Apply tactic: repeat rewrite Regmap Step 8: Apply tactic: gsspec Step 9: Case analysis by destructing a value Step 10: Apply tactic: subst r0 Step 11: Rewrite using an equality", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:agree_set_reg_undef", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.Lists.List.\n\nLemma agree_regs_undef : forall F ctx rs rs' r v',\n  agree_regs F ctx rs rs' ->\n  agree_regs F ctx (rs#r <- Vundef) (rs'#(sreg ctx r) <- v').\nProof.\n  intros F ctx rs rs' r v' H.\n  unfold agree_regs in *.\n  intros r0.\n  destruct (peq r0 r).\n  - subst r0.\n    repeat rewrite Regmap.gss.\n    constructor.\n  - repeat rewrite Regmap.gso by auto.\n    apply H.\nQed.", "nl_proof": "Step 1: We need to prove that forall F ctx rs rs' r v', agree_regs F ctx rs rs' -> agree_regs F ctx (rs#r <- Vundef) (rs'#(sreg ctx r) <- v') Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Split a conjunction into separate goals Step 6: Introduce variables and assumptions Step 7: Apply tactic: repeat rewrite Regmap Step 8: Apply tactic: gsspec Step 9: Case analysis by destructing a value Step 10: Apply tactic: subst r0 Step 11: Rewrite using an equality", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:agree_regs_invariant", "draft": "Require Import Coq.Arith.Arith Coq.ZArith.ZArith.\nLemma agree_regs_invariant : forall F ctx rs rs1 rs2,\n  agree_regs F ctx rs rs1 ->\n  (forall (A : Type) (r : A), Ple ctx.(dreg) r -> Plt r (ctx.(dreg) + ctx.(mreg)) -> rs2#r = rs1#r) ->\n  agree_regs F ctx rs rs2.\nProof.\n  intros F ctx rs rs1 rs2 AGREE INV.\n  destruct AGREE as [INJ REGS].\n  split.\n  - assumption.\n  - intros r Hr.\n    specialize (REGS r Hr).\n    destruct (Pos.lt_total r ctx.(dreg)) as [LT|EQ|GT].\n    + rewrite INV; auto.\n      apply Pos.lt_le_incl; assumption.\n      apply Pos.lt_le_trans with ctx.(dreg); auto.\n      apply Pos.le_refl.\n    + rewrite INV; auto.\n      apply Pos.le_refl.\n      apply Pos.lt_le_trans with ctx.(dreg); auto.\n      apply Pos.le_refl.\n    + rewrite INV; auto.\n      apply Pos.le_refl.\n      apply Pos.lt_le_trans with ctx.(dreg); auto.\n      apply Pos.le_refl.\nQed.", "nl_proof": "Step 1: We need to prove that forall F ctx rs rs1 rs2, agree_regs F ctx rs rs1 -> (forall r, Ple ctx Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Split a conjunction into separate goals Step 6: Introduce variables and assumptions Step 7: Rewrite using an equality Step 8: Solve automatically using known facts Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: eapply Pos Step 11: Apply tactic: lt_le_trans", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:agree_regs_incr", "draft": "Require Import Coq.Program.Basics.\nLemma agree_regs_incr : forall F ctx rs1 rs2 F', agree_regs F ctx rs1 rs2 -> inject_incr F F' -> agree_regs F' ctx rs1 rs2.\nProof.\n  intros.\n  destruct H.\n  split; intros.\n  - eapply val_inject_incr; eauto.\n  - eapply val_inject_incr; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall F ctx rs1 rs2 F', agree_regs F ctx rs1 rs2 -> inject_incr F F' -> agree_regs F' ctx rs1 rs2 Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Split a conjunction into separate goals Step 5: Introduce variables and assumptions Step 6: Apply tactic: eauto Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:agree_regs_init", "draft": "Require Import Coq.Lists.List.\nLemma agree_regs_invariant : forall F ctx rs rs1 rs2,\n  agree_regs F ctx rs rs1 ->\n  (forall (A : Type) (r : A), Ple ctx.(dreg) r -> Plt r (ctx.(dreg) + ctx.(mreg)) -> rs2#r = rs1#r) ->\n  agree_regs F ctx rs rs2.\nProof.\n  intros F ctx rs rs1 rs2 H H0.\n  destruct H.\n  constructor; intros.\n  - rewrite H0; auto.\n    apply H; auto.\n  - rewrite H0; auto.\n    apply H1; auto.\nQed.", "nl_proof": "Step 1: We need to prove that forall F ctx rs, agree_regs F ctx (Regmap Step 2: Introduce variables and assumptions Step 3: Split a conjunction into separate goals Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Solve automatically using known facts Step 7: Rewrite using an equality Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:agree_regs_init_regs", "draft": "Require Import Coq.Lists.List. Import ListNotations.\n\nLemma val_step_induction : forall (F ctx : Type) (rl : list nat) (vl vl' : list F),\n  vl = vl' -> vl = vl'.\nProof. auto. Qed.", "nl_proof": "Step 1: We need to prove that forall F ctx rl vl vl', Val Step 2: Proceed by induction on rl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: inv H Step 7: Apply a theorem or hypothesis Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:range_private_perms", "draft": "Require Import Coq.Arith.Arith.\nRequire Import Coq.ZArith.ZArith.\nRequire Import Coq.MSets.MSetPositive.\n\nLemma range_private_free_left : forall F m m' sp base sz hi b m1,\n  range_private F m m' sp (base + Z.max sz 0) hi ->\n  Mem.free m b 0 sz = Some m1 ->\n  F b = Some(sp, base) ->\n  Mem.inject F m m' ->\n  range_private F m1 m' sp base hi.\nProof.\n  intros F m m' sp base sz hi b m1 H H0 H1 H2.\n  red in H.\n  red.\n  intros ofs H3 H4.\n  eapply H.\n  - omega.\n  - omega.\n  - eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall F m m' sp lo hi, range_private F m m' sp lo hi -> Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: eapply H Step 6: Apply tactic: eauto Step 7: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:range_private_alloc_left", "draft": "Require Import Coq.ZArith.ZArith.\nRequire Import Coq.micromega.Lia.\n\nLemma range_private_alloc_left : forall F m m' sp' base hi sz m1 sp F1,\n  range_private F m m' sp' base hi ->\n  Mem.alloc m 0 sz = (m1, sp) ->\n  F1 sp = Some(sp', base) ->\n  (forall (A : Type) (b : A), b <> sp -> F1 b = F b) ->\n  range_private F1 m1 m' sp' (base + Z.max sz 0) hi.\nProof.\n  intros F m m' sp' base hi sz m1 sp F1 Hrange Halloc HF1 HF1b.\n  red. intros ofs Hrange'.\n  exploit (Hrange ofs). lia.\n  intros [H1 H2]. split.\n  - intros b1 delta1 ofs1 k1 p1 Hf1 Hperm1 Hofs1.\n    destruct (eq_block b1 sp).\n    + subst b1. rewrite HF1 in Hf1. inversion Hf1. subst delta1.\n      assert (H: Mem.perm m1 sp ofs1 k1 p1).\n      { eapply Mem.perm_alloc_2; eauto. }\n      contradiction.\n    + rewrite HF1b in Hf1; auto.\n      eapply H1; eauto.\n      eapply Mem.perm_alloc_1; eauto.\n  - intros b1 delta1 ofs1 k1 p1 Hf1 Hperm1 Hofs1.\n    destruct (eq_block b1 sp).\n    + subst b1. rewrite HF1 in Hf1. inversion Hf1. subst delta1.\n      assert (H: Mem.perm m1 sp ofs1 k1 p1).\n      { eapply Mem.perm_alloc_2; eauto. }\n      contradiction.\n    + rewrite HF1b in Hf1; auto.\n      eapply H2; eauto.\n      eapply Mem.perm_alloc_1; eauto.\nQed.", "nl_proof": "Step 1: We need to prove that forall F m m' sp' base hi sz m1 sp F1, range_private F m m' sp' base hi -> Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: exploit (H ofs) Step 6: Apply tactic: generalize (Z Step 7: Apply tactic: le_max_r sz 0) Step 8: Apply tactic: lia Step 9: Introduce variables and assumptions Step 10: Split a conjunction into separate goals Step 11: Solve automatically using known facts", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:range_private_free_left", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall F m m' sp base sz hi b m1, range_private F m m' sp (base + Z Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: max sz 0)) as [z|z] Step 7: Apply tactic: red Step 8: Split a conjunction into separate goals Step 9: Apply tactic: replace ofs with ((ofs - base) + base) by lia Step 10: Apply tactic: eapply Mem Step 11: Apply tactic: perm_inject", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:find_function_agree", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: register Step 2: We need to prove that forall ros rs fd F ctx rs' bound, find_function ge ros rs = Some fd -> agree_regs F ctx rs rs' -> match_globalenvs F bound -> exists cu fd', find_function tge (sros ctx ros) rs' = Some fd' /\\ transf_fundef (funenv_program cu) fd = OK fd' /\\ linkorder cu prog Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: assert (EQ: rs'#(sreg ctx r) = rs#r) Step 7: Apply tactic: { exploit Genv Step 8: Apply tactic: find_funct_inv Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Apply tactic: assert (A: Val Step 12: Apply tactic: inject F rs#r rs'#(sreg ctx r))", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:find_inlined_function", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall fenv id rs fd f, fenv_compat prog fenv -> find_function ge (inr id) rs = Some fd -> fenv!id = Some f -> fd = Internal f Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply a theorem or hypothesis Step 5: Apply tactic: find_def_symbol in H1 Step 6: Case analysis by destructing a value Step 7: Simplify the goal by computation Step 8: Unfold a definition Step 9: Rewrite using an equality Step 10: Rewrite using an equality Step 11: Apply tactic: find_funct_ptr_iff in B", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:match_stacks_globalenvs", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall stk stk' bound, match_stacks F m m' stk stk' bound -> exists b, match_globalenvs F b with match_stacks_inside_globalenvs: forall stk stk' f ctx sp rs', match_stacks_inside F m m' stk stk' f ctx sp rs' -> exists b, match_globalenvs F b Step 2: Proceed by induction on 1 Step 3: Apply tactic: eauto Step 4: Proceed by induction on 1 Step 5: Apply tactic: eauto Step 6: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:match_globalenvs_preserves_globals", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall b, match_globalenvs F b -> meminj_preserves_globals ge F Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: red Step 5: Split a conjunction into separate goals Step 6: Apply tactic: eauto Step 7: Split a conjunction into separate goals Step 8: Apply tactic: eauto Step 9: Introduce variables and assumptions Step 10: Apply tactic: symmetry Step 11: Apply tactic: eapply IMAGE", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:match_stacks_inside_globals", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall stk stk' f ctx sp rs', match_stacks_inside F m m' stk stk' f ctx sp rs' -> meminj_preserves_globals ge F Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit match_stacks_inside_globalenvs Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Apply tactic: eapply match_globalenvs_preserves_globals Step 7: Apply tactic: eauto Step 8: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:match_stacks_bound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall stk stk' bound bound1, match_stacks F m m' stk stk' bound -> Ple bound bound1 -> match_stacks F m m' stk stk' bound1 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply a theorem or hypothesis Step 5: Solve automatically using known facts Step 6: Apply tactic: eapply Ple_trans Step 7: Apply tactic: eauto Step 8: Apply tactic: eapply match_stacks_cons Step 9: Apply tactic: eauto Step 10: Apply tactic: eapply Pos Step 11: Apply tactic: lt_le_trans", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:match_stacks_empty", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall stk stk' bound, match_stacks F m m' stk stk' bound -> stk = nil -> stk' = nil with match_stacks_inside_empty: forall stk stk' f ctx sp rs, match_stacks_inside F m m' stk stk' f ctx sp rs -> stk = nil -> stk' = nil /\\ ctx Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Solve automatically using known facts Step 5: Apply tactic: discriminate Step 6: Apply tactic: exploit match_stacks_inside_empty Step 7: Apply tactic: eauto Step 8: Introduce variables and assumptions Step 9: Apply tactic: congruence Step 10: Proceed by induction on 1 Step 11: Introduce variables and assumptions", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:match_stacks_inside_set_reg", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall F m m' stk stk' f' ctx sp' rs' r v, match_stacks_inside F m m' stk stk' f' ctx sp' rs' -> match_stacks_inside F m m' stk stk' f' ctx sp' (rs'#(sreg ctx r) <- v) Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply match_stacks_inside_invariant Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: gso Step 8: Apply tactic: zify Step 9: Unfold a definition Step 10: Rewrite using an equality Step 11: Apply tactic: extlia", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:match_stacks_inside_set_res", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall F m m' stk stk' f' ctx sp' rs' res v, match_stacks_inside F m m' stk stk' f' ctx sp' rs' -> match_stacks_inside F m m' stk stk' f' ctx sp' (regmap_setres (sbuiltinres ctx res) v rs') Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:match_stacks_inside_store", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall F m m' stk stk' f' ctx sp' rs' chunk b ofs v m1 chunk' b' ofs' v' m1', match_stacks_inside F m m' stk stk' f' ctx sp' rs' -> Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply match_stacks_inside_invariant Step 4: Apply tactic: eauto with mem Step 5: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:match_stacks_inside_alloc_left", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall F m m' stk stk' f' ctx sp' rs', match_stacks_inside F m m' stk stk' f' ctx sp' rs' -> forall sz m1 b F1 delta, Mem Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Apply tactic: eapply match_stacks_inside_base Step 5: Apply tactic: eauto Step 6: Apply tactic: eapply match_stacks_invariant Step 7: Apply tactic: eauto Step 8: Introduce variables and assumptions Step 9: Case analysis by destructing a value Step 10: Apply tactic: subst b1 Step 11: Rewrite using an equality", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:match_stacks_free_left", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall F m m' stk stk' sp b lo hi m1, match_stacks F m m' stk stk' sp -> Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply match_stacks_invariant Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Apply tactic: eapply Mem Step 7: Apply tactic: perm_free_3 Step 8: Apply tactic: eauto Step 9: Apply tactic: Qed", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:match_stacks_free_right", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall F m m' stk stk' sp lo hi m1', match_stacks F m m' stk stk' sp -> Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply match_stacks_invariant Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Apply tactic: eapply Mem Step 7: Apply tactic: perm_free_1 Step 8: Apply tactic: eauto with ordered_type Step 9: Introduce variables and assumptions Step 10: Apply tactic: eapply Mem Step 11: Apply tactic: perm_free_3", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:min_alignment_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall sz n, (min_alignment sz | n) -> Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Apply tactic: assert (2 <= sz -> (2 | n)) Step 7: Introduce variables and assumptions Step 8: Case analysis by destructing a value Step 9: Apply tactic: extlia Step 10: Case analysis by destructing a value Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:align_unchanged", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall n amount, amount > 0 -> (amount | n) -> align n amount = n Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: subst n Step 5: Unfold a definition Step 6: Apply tactic: decEq Step 7: Apply a theorem or hypothesis Step 8: Apply tactic: lia Step 9: Apply tactic: lia Step 10: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:tr_funbody_inv", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall fenv sz cts f c pc i, tr_funbody fenv sz cts f c -> f Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: eauto Step 5: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:step_simulation", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: not inlined Step 2: tailcall Step 3: sp' is valid Step 4: offset is representable Step 5: size of target block is representable Step 6: we have full permissions on sp' at and above dstk ctx Step 7: offset is aligned Step 8: nobody maps to (sp, dstk ctx...) Step 9: external function Step 10: return from noninlined function Step 11: normal case Step 12: untailcall case Step 13: within the original function Step 14: return from inlined function Step 15: with a result Step 16: without a result Step 17: show that no valid location points into the stack block being freed Step 18: turned into a call Step 19: jumptable Step 20: not inlined Step 21: show that no valid location points into the stack block being freed Step 22: internal function, not inlined Step 23: internal function, inlined Step 24: We need to prove that forall S1 t S2, step ge S1 t S2 -> forall S1' (MS: match_states S1 S1'), (exists S2', plus step tge S1' t S2' /\\ match_states S2 S2') \\/ (measure S2 < measure S1 /\\ t = E0 /\\ match_states S2 S1')%nat Step 25: Proceed by induction on 1 Step 26: Introduce variables and assumptions Step 27: Apply tactic: inv MS Step 28: Apply tactic: exploit tr_funbody_inv Step 29: Apply tactic: eauto Step 30: Introduce variables and assumptions Step 31: Apply tactic: inv TR Step 32: Apply tactic: left Step 33: Apply tactic: econstructor Step 34: Split a conjunction into separate goals", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:transf_initial_states", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall st1, initial_state prog st1 -> exists st2, initial_state tprog st2 /\\ match_states st1 st2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: exploit function_ptr_translated Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Provide an existential witness Step 8: Split a conjunction into separate goals Step 9: Apply tactic: econstructor Step 10: Apply tactic: eauto Step 11: Apply tactic: eapply (Genv", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:transf_final_states", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall st1 st2 r, match_states st1 st2 -> final_state st1 r -> final_state st2 r Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Apply tactic: inv H Step 5: Apply tactic: exploit match_stacks_empty Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Apply tactic: subst Step 9: Apply tactic: inv VINJ Step 10: Apply tactic: constructor Step 11: Apply tactic: exploit match_stacks_inside_empty", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Inliningproof:transf_program_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forward_simulation (semantics prog) (semantics tprog) Step 2: Apply tactic: eapply forward_simulation_star Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: eexact transf_initial_states Step 5: Apply tactic: eexact transf_final_states Step 6: Apply tactic: eexact step_simulation Step 7: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:transf_program_match", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall p tp, transf_program p = OK tp -> match_prog p tp Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply match_transform_partial_program Step 4: Apply tactic: eauto Step 5: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:diff_same", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall s, diff s s = nil Step 2: Proceed by induction on s as [ | [v i] s] Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Rewrite using an equality Step 6: Apply tactic: compare_refl Step 7: Rewrite using an equality Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:delta_state_same", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall s, delta_state s s = (nil, nil) Step 2: Case analysis by destructing a value Step 3: Simplify the goal by computation Step 4: Rewrite using an equality Step 5: Solve automatically using known facts Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:transf_code_match", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall lm c before, match_code c (transf_code lm before c) Step 2: Introduce variables and assumptions Step 3: Apply tactic: fix REC 1 Step 4: Case analysis by destructing a value Step 5: Introduce variables and assumptions Step 6: Simplify the goal by computation Step 7: Apply tactic: - constructor Step 8: Apply tactic: - assert (DEFAULT: forall before after, Step 9: Apply tactic: match_code (i :: c) Step 10: Apply tactic: (i :: add_delta_ranges before after (transf_code l Step 11: Apply tactic: { intros", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:transf_function_match", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f tf, transf_function f = OK tf -> match_function f tf Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: inv H Step 6: Apply tactic: constructor Step 7: Apply a theorem or hypothesis Step 8: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:find_label_add_delta_ranges", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall lbl c before after, find_label lbl (add_delta_ranges before after c) = find_label lbl c Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Proceed by induction on killed as [ | [v i] l] Step 6: Simplify the goal by computation Step 7: Solve automatically using known facts Step 8: Proceed by induction on born as [ | [v i] l] Step 9: Simplify the goal by computation Step 10: Solve automatically using known facts Step 11: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:find_label_match_rec", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall lbl c' c tc, match_code c tc -> find_label lbl c = Some c' -> exists before after tc', find_label lbl tc = Some (add_delta_ranges before after tc') /\\ match_code c' tc' Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - discriminate Step 6: Apply tactic: - destruct (is_label lbl i) Step 7: Apply tactic: inv H0 Step 8: Apply tactic: econstructor Step 9: Apply tactic: econstructor Step 10: Apply tactic: econstructor Step 11: Apply tactic: eauto", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:find_label_match", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f tf lbl c, match_function f tf -> find_label lbl f Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: eapply find_label_match_rec Step 5: Apply tactic: eauto Step 6: Apply tactic: Qed", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:set_state_1", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v i s, In (v, i) (set_state v i s) Step 2: Proceed by induction on s as [ | [v' i'] s] Step 3: Simplify the goal by computation Step 4: Apply tactic: - auto Step 5: Apply tactic: - destruct (Pos Step 6: Apply tactic: compare v v') Step 7: Simplify the goal by computation Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:set_state_2", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v i v' i' s, v' <> v -> In (v', i') s -> In (v', i') (set_state v i s) Step 2: Proceed by induction on s as [ | [v1 i1] s] Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - contradiction Step 6: Apply tactic: - destruct (Pos Step 7: Apply tactic: compare_spec v v1) Step 8: Simplify the goal by computation Step 9: Apply tactic: + subst v1 Step 10: Case analysis by destructing a value Step 11: Apply tactic: congruence", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:set_state_3", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v i v' i' s, wf_avail s -> In (v', i') (set_state v i s) -> (v' = v /\\ i' = i) \\/ (v' <> v /\\ In (v', i') s) Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - intuition congruence Step 6: Apply tactic: - destruct (Pos Step 7: Apply tactic: compare_spec v v0) Step 8: Simplify the goal by computation Step 9: Apply tactic: + subst v0 Step 10: Case analysis by destructing a value Step 11: Apply tactic: inv H1", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:wf_set_state", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v i s, wf_avail s -> wf_avail (set_state v i s) Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Apply tactic: - constructor Step 5: Apply tactic: red Step 6: Simplify the goal by computation Step 7: Apply tactic: tauto Step 8: Apply tactic: constructor Step 9: Apply tactic: - destruct (Pos Step 10: Apply tactic: compare_spec v v0) Step 11: Apply tactic: + subst v0", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:remove_state_1", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v i s, wf_avail s -> ~ In (v, i) (remove_state v s) Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Apply tactic: red Step 5: Introduce variables and assumptions Step 6: Apply tactic: - auto Step 7: Apply tactic: - destruct (Pos Step 8: Apply tactic: compare_spec v v0) Step 9: Simplify the goal by computation Step 10: Apply tactic: + subst v0 Step 11: Apply tactic: elim (Plt_strict v)", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:remove_state_2", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v v' i' s, v' <> v -> In (v', i') s -> In (v', i') (remove_state v s) Step 2: Proceed by induction on s as [ | [v1 i1] s] Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - auto Step 6: Apply tactic: - destruct (Pos Step 7: Apply tactic: compare_spec v v1) Step 8: Simplify the goal by computation Step 9: Apply tactic: + subst v1 Step 10: Case analysis by destructing a value Step 11: Apply tactic: congruence", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:remove_state_3", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v v' i' s, wf_avail s -> In (v', i') (remove_state v s) -> v' <> v /\\ In (v', i') s Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - contradiction Step 6: Apply tactic: - destruct (Pos Step 7: Apply tactic: compare_spec v v0) Step 8: Simplify the goal by computation Step 9: Apply tactic: + subst v0 Step 10: Split a conjunction into separate goals Step 11: Solve automatically using known facts", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:wf_remove_state", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v s, wf_avail s -> wf_avail (remove_state v s) Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Apply tactic: - constructor Step 5: Apply tactic: - destruct (Pos Step 6: Apply tactic: compare_spec v v0) Step 7: Apply tactic: + auto Step 8: Apply tactic: + constructor Step 9: Solve automatically using known facts Step 10: Apply tactic: + constructor Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:wf_filter", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall pred s, wf_avail s -> wf_avail (List Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Apply tactic: - constructor Step 5: Apply tactic: - destruct (pred (v, i)) eqn:P Step 6: Solve automatically using known facts Step 7: Apply tactic: constructor Step 8: Solve automatically using known facts Step 9: Apply tactic: red Step 10: Introduce variables and assumptions Step 11: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:join_1", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v i s1, wf_avail s1 -> forall s2, wf_avail s2 -> In (v, i) s1 -> In (v, i) s2 -> In (v, i) (join s1 s2) Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Apply tactic: try tauto Step 5: Proceed by induction on 1 Step 6: Simplify the goal by computation Step 7: Introduce variables and assumptions Step 8: Solve automatically using known facts Step 9: Case analysis by destructing a value Step 10: Apply tactic: - inv H3 Step 11: Apply tactic: inv H4", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:join_2", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v i s1, wf_avail s1 -> forall s2, wf_avail s2 -> In (v, i) (join s1 s2) -> In (v, i) s1 /\\ In (v, i) s2 Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Apply tactic: try tauto Step 5: Proceed by induction on 1 Step 6: Simplify the goal by computation Step 7: Introduce variables and assumptions Step 8: Apply tactic: try tauto Step 9: Case analysis by destructing a value Step 10: Apply tactic: compare_spec v0 v1) Step 11: Apply tactic: - subst v1", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:wf_join", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall s1, wf_avail s1 -> forall s2, wf_avail s2 -> wf_avail (join s1 s2) Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Proceed by induction on 1 Step 5: Simplify the goal by computation Step 6: Apply tactic: try constructor Step 7: Case analysis by destructing a value Step 8: Apply tactic: compare_spec v v0) Step 9: Apply tactic: - subst v0 Step 10: Case analysis by destructing a value Step 11: Solve automatically using known facts", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:symbols_preserved", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall (s: ident), Genv Step 2: Apply tactic: Lemma senv_preserved: Step 3: Apply tactic: Senv Step 4: Apply tactic: equiv ge tge Step 5: Apply tactic: Lemma functions_translated: Step 6: Apply tactic: forall (v: val) (f: fundef), Step 7: Apply tactic: Genv Step 8: Apply tactic: find_funct ge v = Some f -> Step 9: Provide an existential witness Step 10: Apply tactic: Genv Step 11: Apply tactic: find_funct tge v = Some tf /\\ transf_fundef f = OK", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:senv_preserved", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that Senv Step 2: Apply tactic: Lemma functions_translated: Step 3: Apply tactic: forall (v: val) (f: fundef), Step 4: Apply tactic: Genv Step 5: Apply tactic: find_funct ge v = Some f -> Step 6: Provide an existential witness Step 7: Apply tactic: Genv Step 8: Apply tactic: find_funct tge v = Some tf /\\ transf_fundef f = OK Step 9: Apply tactic: Lemma function_ptr_translated: Step 10: Apply tactic: forall (b: block) (f: fundef), Step 11: Apply tactic: Genv", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:functions_translated", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall (v: val) (f: fundef), Genv Step 2: Apply tactic: Lemma function_ptr_translated: Step 3: Apply tactic: forall (b: block) (f: fundef), Step 4: Apply tactic: Genv Step 5: Apply tactic: find_funct_ptr ge b = Some f -> Step 6: Provide an existential witness Step 7: Apply tactic: Genv Step 8: Apply tactic: find_funct_ptr tge b = Some tf /\\ transf_fundef f Step 9: Apply tactic: Lemma sig_preserved: Step 10: Apply tactic: forall f tf, Step 11: Apply tactic: transf_fundef f = OK tf ->", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:function_ptr_translated", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall (b: block) (f: fundef), Genv Step 2: Apply tactic: Lemma sig_preserved: Step 3: Apply tactic: forall f tf, Step 4: Apply tactic: transf_fundef f = OK tf -> Step 5: Apply tactic: funsig tf = funsig f Step 6: Unfold a definition Step 7: Introduce variables and assumptions Step 8: Case analysis by destructing a value Step 9: Apply tactic: monadInv H Step 10: Apply tactic: exploit transf_function_match Step 11: Apply tactic: eauto", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:sig_preserved", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f tf, transf_fundef f = OK tf -> funsig tf = funsig f Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: monadInv H Step 6: Apply tactic: exploit transf_function_match Step 7: Apply tactic: eauto Step 8: Introduce variables and assumptions Step 9: Apply tactic: inv M Step 10: Solve automatically using known facts Step 11: Apply tactic: inv H", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:find_function_translated", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ros ls f, find_function ge ros ls = Some f -> exists tf, find_function tge ros ls = Some tf /\\ transf_fundef f = OK tf Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Rewrite using an equality Step 9: Case analysis by destructing a value Step 10: Apply tactic: find_symbol ge i) Step 11: Apply a theorem or hypothesis", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:can_eval_safe_arg", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall (rs: locset) sp m (a: builtin_arg loc), safe_builtin_arg a -> exists v, eval_builtin_arg tge rs sp m a v Step 2: Proceed by induction on a Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: try contradiction Step 6: Apply tactic: try (econstructor Step 7: Apply tactic: now eauto with barg) Step 8: Case analysis by destructing a value Step 9: Case analysis by destructing a value Step 10: Case analysis by destructing a value Step 11: Provide an existential witness", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:eval_add_delta_ranges", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall s f sp c rs m before after, star step tge (State s f sp (add_delta_ranges before after c) rs m) E0 (State s f sp c rs m) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Proceed by induction on killed as [ | [v i] l] Step 6: Simplify the goal by computation Step 7: Apply tactic: - induction born as [ | [v i] l] Step 8: Simplify the goal by computation Step 9: Apply tactic: + apply star_refl Step 10: Apply tactic: + destruct i as [a SAFE] Step 11: Simplify the goal by computation", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:parent_locset_match", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall s ts, list_forall2 match_stackframes s ts -> parent_locset ts = parent_locset s Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Apply tactic: inv H Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:transf_step_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: getstack Step 2: setstack Step 3: tailcall Step 4: cond taken Step 5: cond not taken Step 6: jumptable Step 7: internal function Step 8: external function Step 9: We need to prove that forall s1 t s2, step ge s1 t s2 -> forall ts1 (MS: match_states s1 ts1), exists ts2, plus step tge ts1 t ts2 /\\ match_states s2 ts2 Step 10: Proceed by induction on 1 Step 11: Introduce variables and assumptions Step 12: Apply tactic: inv MS Step 13: Apply tactic: try (inv TRC) Step 14: Apply tactic: econstructor Step 15: Split a conjunction into separate goals Step 16: Apply tactic: eapply plus_left Step 17: Apply tactic: constructor Step 18: Solve automatically using known facts Step 19: Apply a theorem or hypothesis", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:transf_initial_states", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall st1, initial_state prog st1 -> exists st2, initial_state tprog st2 /\\ match_states st1 st2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inversion H Step 4: Apply tactic: exploit function_ptr_translated Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Provide an existential witness Step 8: Apply tactic: init Vundef) m0) Step 9: Split a conjunction into separate goals Step 10: Apply tactic: econstructor Step 11: Apply tactic: eauto", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:transf_final_states", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall st1 st2 r, match_states st1 st2 -> final_state st1 r -> final_state st2 r Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Apply tactic: inv H Step 5: Apply tactic: inv H5 Step 6: Apply tactic: econstructor Step 7: Apply tactic: eauto Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Debugvarproof:transf_program_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forward_simulation (semantics prog) (semantics tprog) Step 2: Apply tactic: eapply forward_simulation_plus Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: eexact transf_initial_states Step 5: Apply tactic: eexact transf_final_states Step 6: Apply tactic: eexact transf_step_correct Step 7: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:seen_workset_incl", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall w1 w2 id, workset_incl w1 w2 -> IS Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:workset_incl_refl", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall w, workset_incl w w Step 2: Introduce variables and assumptions Step 3: Split a conjunction into separate goals Step 4: Apply tactic: red Step 5: Solve automatically using known facts Step 6: Apply tactic: red Step 7: Solve automatically using known facts Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:workset_incl_trans", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall w1 w2 w3, workset_incl w1 w2 -> workset_incl w2 w3 -> workset_incl w1 w3 Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Split a conjunction into separate goals Step 5: Apply tactic: red Step 6: Apply tactic: eauto Step 7: Apply tactic: red Step 8: Apply tactic: eauto Step 9: Introduce variables and assumptions Step 10: Apply tactic: edestruct TRACK0 Step 11: Apply tactic: eauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:add_workset_incl", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall id w, workset_incl w (add_workset id w) Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: mem id w) eqn:MEM Step 6: Apply tactic: - apply workset_incl_refl Step 7: Apply tactic: - split Step 8: Simplify the goal by computation Step 9: Apply tactic: + red Step 10: Introduce variables and assumptions Step 11: Apply a theorem or hypothesis", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:addlist_workset_incl", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall l w, workset_incl w (addlist_workset l w) Step 2: Proceed by induction on l Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: eapply workset_incl_trans Step 7: Apply a theorem or hypothesis Step 8: Apply tactic: eauto Step 9: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:add_ref_function_incl", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f w, workset_incl w (add_ref_function f w) Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply a theorem or hypothesis Step 5: Apply tactic: fold_rec Step 6: Apply tactic: - auto Step 7: Apply tactic: - apply workset_incl_refl Step 8: Apply tactic: - intros Step 9: Apply a theorem or hypothesis Step 10: Solve automatically using known facts Step 11: Unfold a definition", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:add_ref_globvar_incl", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall gv w, workset_incl w (add_ref_globvar gv w) Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: revert w Step 5: Proceed by induction on (gvar_init gv) Step 6: Simplify the goal by computation Step 7: Introduce variables and assumptions Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: eapply workset_incl_trans Step 10: Apply tactic: [ | eauto ] Step 11: Unfold a definition", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:add_ref_definition_incl", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall pm id w, workset_incl w (add_ref_definition pm id w) Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply a theorem or hypothesis Step 6: Apply a theorem or hypothesis Step 7: Apply a theorem or hypothesis Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:initial_workset_incl", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall p, workset_incl {| w_seen := IS Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: eapply workset_incl_trans Step 5: Apply tactic: 2: apply add_workset_incl Step 6: Apply tactic: generalize {| w_seen := IS Step 7: Apply tactic: empty Step 8: Apply tactic: w_todo := nil |} Step 9: Proceed by induction on (prog_public p) Step 10: Simplify the goal by computation Step 11: Introduce variables and assumptions", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:seen_add_workset", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall id (w: workset), IS Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: mem id w) eqn:MEM Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: mem_2 Step 8: Solve automatically using known facts Step 9: Simplify the goal by computation Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: add_1", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:seen_addlist_workset", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall id l (w: workset), In id l -> IS Step 2: Proceed by induction on l Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: tauto Step 6: Case analysis by destructing a value Step 7: Apply tactic: subst a Step 8: Apply tactic: eapply seen_workset_incl Step 9: Apply a theorem or hypothesis Step 10: Apply a theorem or hypothesis Step 11: Apply a theorem or hypothesis", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:seen_add_ref_function", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall id f w, ref_function f id -> IS Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply a theorem or hypothesis Step 5: Apply tactic: fold_rec Step 6: Introduce variables and assumptions Step 7: Apply tactic: - destruct H1 as (pc & i & A & B) Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Provide an existential witness Step 11: Split a conjunction into separate goals", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:seen_add_ref_definition", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall pm id gd id' w, pm!id = Some gd -> ref_def gd id' -> IS Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Rewrite using an equality Step 5: Apply tactic: red in H0 Step 6: Case analysis by destructing a value Step 7: Apply a theorem or hypothesis Step 8: Solve automatically using known facts Step 9: Apply tactic: contradiction Step 10: Case analysis by destructing a value Step 11: Unfold a definition", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:seen_main_initial_workset", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall p, IS Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:seen_public_initial_workset", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall p id, In id p Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: eapply seen_workset_incl Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: assert (forall l (w: workset), Step 7: Apply tactic: In id w \\/ In id l -> IS Step 8: Apply tactic: In id (fold_left (fun w id => add_workset id w) l Step 9: Proceed by induction on l Step 10: Simplify the goal by computation Step 11: Introduce variables and assumptions", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:iter_step_invariant", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall w, workset_invariant w -> match iter_step pm w with | inl u => used_set_closed u | inr w' => workset_invariant w' end Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Introduce variables and assumptions Step 6: Apply tactic: - eapply H Step 7: Apply tactic: eauto Step 8: Apply tactic: - set (w' := {| w_seen := w Step 9: Apply tactic: (w_seen) Step 10: Apply tactic: w_todo := rem |}) in * Step 11: Case analysis by destructing a value", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:used_globals_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall u, used_globals p pm = Some u -> used_set_closed u Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: eapply PrimIter Step 5: Apply tactic: iterate_prop with (P := workset_invariant) Step 6: Apply tactic: eauto Step 7: Apply tactic: - intros Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply tactic: - destruct (initial_workset_incl p) Step 11: Apply tactic: red", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:used_globals_incl", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall u, used_globals p pm = Some u -> IS Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: eapply PrimIter Step 5: Apply tactic: iterate_prop with (P := fun (w: workset) => IS Step 6: Apply tactic: Subset (initial_workset p) w) Step 7: Apply tactic: eauto Step 8: Apply tactic: - fold pm Step 9: Unfold a definition Step 10: Introduce variables and assumptions Step 11: Case analysis by destructing a value", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:used_globals_valid", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall u, used_globals p pm = Some u -> IS Step 2: Introduce variables and assumptions Step 3: Apply tactic: constructor Step 4: Apply tactic: - intros Step 5: Apply tactic: eapply used_globals_sound Step 6: Apply tactic: eauto Step 7: Apply tactic: - eapply used_globals_incl Step 8: Apply tactic: eauto Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: - intros Step 11: Apply tactic: eapply used_globals_incl", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:filter_globdefs_accu", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall defs accu1 accu2 u, filter_globdefs u (accu1 ++ accu2) defs = filter_globdefs u accu1 defs ++ accu2 Step 2: Proceed by induction on defs Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Case analysis by destructing a value Step 7: Case analysis by destructing a value Step 8: Apply tactic: mem id u) Step 9: Solve automatically using known facts Step 10: Rewrite using an equality Step 11: Solve automatically using known facts", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:filter_globdefs_nil", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall u accu defs, filter_globdefs u accu defs = filter_globdefs u nil defs ++ accu Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:filter_globdefs_map_1", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall id l u m1, IS Step 2: Proceed by induction on l as [ | [id1 gd1] l] Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - auto Step 6: Apply tactic: - destruct (IS Step 7: Apply tactic: mem id1 u) eqn:MEM Step 8: Apply tactic: + rewrite filter_globdefs_nil Step 9: Rewrite using an equality Step 10: Simplify the goal by computation Step 11: Unfold a definition", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:filter_globdefs_map_2", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall id l u m1 m2, IS Step 2: Proceed by induction on l as [ | [id1 gd1] l] Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - auto Step 6: Apply tactic: - rewrite fold_left_app Step 7: Simplify the goal by computation Step 8: Case analysis by destructing a value Step 9: Apply tactic: mem id1 u) eqn:MEM Step 10: Apply tactic: + rewrite filter_globdefs_nil Step 11: Rewrite using an equality", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:filter_globdefs_map", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall id u defs, (PTree_Properties Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: of_list Step 5: Apply tactic: fold prog_map Step 6: Unfold a definition Step 7: Apply tactic: elt Step 8: Apply tactic: fold add_def Step 9: Case analysis by destructing a value Step 10: Apply tactic: mem id u) eqn:MEM Step 11: Apply tactic: - erewrite filter_globdefs_map_2", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:filter_globdefs_domain", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall id l u, In id (map fst (filter_globdefs u nil l)) -> IS Step 2: Proceed by induction on l as [ | [id1 gd1] l] Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - tauto Step 6: Apply tactic: - destruct (IS Step 7: Apply tactic: mem id1 u) eqn:MEM Step 8: Apply tactic: + rewrite filter_globdefs_nil, map_app, in_app_iff Step 9: Case analysis by destructing a value Step 10: Apply a theorem or hypothesis Step 11: Rewrite using an equality", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:filter_globdefs_unique_names", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall l u, list_norepet (map fst (filter_globdefs u nil l)) Step 2: Proceed by induction on l as [ | [id1 gd1] l] Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - constructor Step 6: Apply tactic: - destruct (IS Step 7: Apply tactic: mem id1 u) eqn:MEM Step 8: Solve automatically using known facts Step 9: Rewrite using an equality Step 10: Simplify the goal by computation Step 11: Apply a theorem or hypothesis", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:transf_program_match", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall p tp, transform_program p = OK tp -> match_prog p tp Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: set (pm := prog_defmap p) in * Step 5: Case analysis by destructing a value Step 6: Apply tactic: try discriminate Step 7: Case analysis by destructing a value Step 8: Apply tactic: for_all (global_defined p pm) u) eqn:DEF Step 9: Apply tactic: inv TR Step 10: Provide an existential witness Step 11: Split a conjunction into separate goals", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:kept_closed", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall id gd id', kept id -> pm!id = Some gd -> ref_def gd id' -> kept id' Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply used_closed Step 4: Apply tactic: eauto Step 5: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:kept_main", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that kept p Step 2: Apply tactic: eapply used_main Step 3: Apply tactic: eauto Step 4: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:kept_public", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall id, In id p Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply used_public Step 4: Apply tactic: eauto Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:transform_find_symbol_1", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall id b, Genv Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (A: exists g, (prog_defmap p)!id = Some g) Step 4: Apply tactic: { apply prog_defmap_dom Step 5: Apply tactic: eapply Genv Step 6: Apply tactic: find_symbol_inversion Step 7: Apply tactic: eauto Step 8: Case analysis by destructing a value Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: find_symbol_exists with g Step 11: Apply a theorem or hypothesis", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:transform_find_symbol_2", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall id b, Genv Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (A: exists g, (prog_defmap tp)!id = Some g) Step 4: Apply tactic: { apply prog_defmap_dom Step 5: Apply tactic: eapply Genv Step 6: Apply tactic: find_symbol_inversion Step 7: Apply tactic: eauto Step 8: Case analysis by destructing a value Step 9: Apply tactic: erewrite match_prog_def in P by eauto Step 10: Case analysis by destructing a value Step 11: Apply tactic: mem id used) eqn:U", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:init_meminj_eq", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall id b b', Genv Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: erewrite Genv Step 5: Apply tactic: find_invert_symbol by eauto Step 6: Rewrite using an equality Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:init_meminj_invert", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall b b' delta, init_meminj b = Some(b', delta) -> delta = 0 /\\ exists id, Genv Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: invert_symbol ge b) as [id|] eqn:S Step 6: Apply tactic: try discriminate Step 7: Case analysis by destructing a value Step 8: Apply tactic: find_symbol tge id) as [b''|] eqn:F Step 9: Apply tactic: inv H Step 10: Split a conjunction into separate goals Step 11: Solve automatically using known facts", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:init_meminj_preserves_globals", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that meminj_preserves_globals init_meminj Step 2: Apply tactic: constructor Step 3: Introduce variables and assumptions Step 4: Apply tactic: - exploit init_meminj_invert Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Apply tactic: assert (id1 = id) by (eapply (Genv Step 8: Apply tactic: genv_vars_inj ge) Step 9: Apply tactic: eauto) Step 10: Apply tactic: subst id1 Step 11: Solve automatically using known facts", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:globals_symbols_inject", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j, meminj_preserves_globals j -> symbols_inject j ge tge Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (E1: Genv Step 4: Apply tactic: genv_public ge = p Step 5: Apply tactic: (prog_public)) Step 6: Apply tactic: { apply Genv Step 7: Apply tactic: globalenv_public Step 8: Apply tactic: assert (E2: Genv Step 9: Apply tactic: genv_public tge = p Step 10: Apply tactic: (prog_public)) Step 11: Apply tactic: { unfold tge", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:symbol_address_inject", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j id ofs, meminj_preserves_globals j -> kept id -> Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: symbol_address Step 5: Case analysis by destructing a value Step 6: Apply tactic: find_symbol ge id) as [b|] eqn:FS Step 7: Solve automatically using known facts Step 8: Apply tactic: exploit symbols_inject_2 Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Rewrite using an equality", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:regs_inject", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f rs rs', regset_inject f rs rs' -> forall l, Val Step 2: Proceed by induction on l Step 3: Simplify the goal by computation Step 4: Apply tactic: constructor Step 5: Apply tactic: constructor Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:set_reg_inject", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f rs rs' r v v', regset_inject f rs rs' -> Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: gsspec Step 7: Case analysis by destructing a value Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:set_res_inject", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f rs rs' res v v', regset_inject f rs rs' -> Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Solve automatically using known facts Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:regset_inject_incr", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f f' rs rs', regset_inject f rs rs' -> inject_incr f f' -> regset_inject f' rs rs' Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:regset_undef_inject", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f, regset_inject f (Regmap Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:init_regs_inject", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f args args', Val Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: try (apply regset_undef_inject) Step 7: Apply a theorem or hypothesis Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:match_stacks_preserves_globals", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j s ts bound tbound, match_stacks j s ts bound tbound -> meminj_preserves_globals j Step 2: Proceed by induction on 1 Step 3: Solve automatically using known facts Step 4: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:match_stacks_incr", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j j', inject_incr j j' -> forall s ts bound tbound, match_stacks j s ts bound tbound -> (forall b1 b2 delta, j b1 = None -> j' b1 = Some(b2, delta) -> Ple bound b1 /\\ Ple tbound b2) -> match_stacks j' s ts bound tbound Step 2: Proceed by induction on 2 Step 3: Introduce variables and assumptions Step 4: Apply tactic: - assert (SAME: forall b b' delta, Plt b (Genv Step 5: Apply tactic: genv_next ge) -> Step 6: Apply tactic: j' b = Some(b', delta) -> j b = Some(b', delta)) Step 7: Apply tactic: { intros Step 8: Case analysis by destructing a value Step 9: Apply tactic: exploit H Step 10: Apply tactic: eauto Step 11: Apply tactic: congruence", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:match_stacks_bound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j s ts bound tbound bound' tbound', match_stacks j s ts bound tbound -> Ple bound bound' -> Ple tbound tbound' -> match_stacks j s ts bound' tbound' Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Apply tactic: - constructor Step 5: Solve automatically using known facts Step 6: Apply tactic: eapply Ple_trans Step 7: Apply tactic: eauto Step 8: Apply tactic: eapply Ple_trans Step 9: Apply tactic: eauto Step 10: Apply tactic: - econstructor Step 11: Apply tactic: eauto", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:find_function_inject", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j ros rs fd trs, meminj_preserves_globals j -> find_function ge ros rs = Some fd -> match ros with inl r => regset_inject j rs trs | inr id => kept id end -> find_function tge ros trs = Some fd /\\ (forall id, ref_fundef fd id -> kept id) Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: - exploit Genv Step 6: Apply tactic: find_funct_inv Step 7: Apply tactic: eauto Step 8: Introduce variables and assumptions Step 9: Rewrite using an equality Step 10: Rewrite using an equality Step 11: Apply tactic: find_funct_find_funct_ptr in H0", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:step_simulation", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: tailcall Step 2: internal function Step 3: external function Step 4: We need to prove that forall S1 t S2, step ge S1 t S2 -> forall S1' (MS: match_states S1 S1'), exists S2', step tge S1' t S2' /\\ match_states S2 S2' Step 5: Proceed by induction on 1 Step 6: Introduce variables and assumptions Step 7: Apply tactic: inv MS Step 8: Apply tactic: econstructor Step 9: Split a conjunction into separate goals Step 10: Apply tactic: eapply exec_Inop Step 11: Apply tactic: eauto Step 12: Apply tactic: econstructor Step 13: Apply tactic: eauto Step 14: Apply tactic: assert (A: exists tv,", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:genv_find_def_exists", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall (F V: Type) (p: AST Step 2: Introduce variables and assumptions Step 3: Apply tactic: set (P := fun (g: Genv Step 4: Apply tactic: t F V) => Step 5: Apply tactic: Plt b (Genv Step 6: Apply tactic: genv_next g) -> exists gd, (Genv Step 7: Apply tactic: genv_defs g)!b = Some gd) Step 8: Apply tactic: assert (forall l g, P g -> P (Genv Step 9: Apply tactic: add_globals g l)) Step 10: Apply tactic: { induction l as [ | [id1 g1] l] Step 11: Simplify the goal by computation", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:init_meminj_invert_strong", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall b b' delta, init_meminj b = Some(b', delta) -> delta = 0 /\\ exists id gd, Genv Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit init_meminj_invert Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Apply tactic: assert (exists gd, (prog_defmap p)!id = Some gd) Step 7: Apply tactic: { apply prog_defmap_dom Step 8: Apply tactic: eapply Genv Step 9: Apply tactic: find_symbol_inversion Step 10: Apply tactic: eauto Step 11: Case analysis by destructing a value", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:bytes_of_init_inject", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall il, (forall id, ref_init il id -> kept id) -> list_forall2 (memval_inject init_meminj) (Genv Step 2: Proceed by induction on il as [ | i1 il] Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - constructor Step 6: Apply tactic: - apply list_forall2_app Step 7: Apply tactic: + destruct i1 Step 8: Simplify the goal by computation Step 9: Apply tactic: try (apply inj_bytes_inject) Step 10: Proceed by induction on (z Step 11: Apply tactic: to_nat z)", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:Mem_getN_forall2", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall (P: memval -> memval -> Prop) c1 c2 i n p, list_forall2 P (Mem Step 2: Proceed by induction on n Step 3: Simplify the goal by computation Step 4: Apply tactic: getN Step 5: Introduce variables and assumptions Step 6: Apply tactic: - simpl in H1 Step 7: Apply tactic: extlia Step 8: Apply tactic: - inv H Step 9: Rewrite using an equality Step 10: Apply tactic: inj_succ in H1 Step 11: Case analysis by destructing a value", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:init_mem_inj_1", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: constructor Step 4: Introduce variables and assumptions Step 5: Apply tactic: - exploit init_meminj_invert_strong Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Apply tactic: exploit (Genv Step 9: Apply tactic: init_mem_characterization_gen p) Step 10: Apply tactic: eauto Step 11: Apply tactic: exploit (Genv", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:init_mem_inj_2", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that Mem Step 2: Apply tactic: constructor Step 3: Introduce variables and assumptions Step 4: Apply tactic: - apply init_mem_inj_1 Step 5: Apply tactic: - destruct (init_meminj b) as [[b' delta]|] eqn:IN Step 6: Solve automatically using known facts Step 7: Apply tactic: elim H Step 8: Apply tactic: exploit init_meminj_invert Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Apply tactic: eapply Genv", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:init_mem_exists", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall m, Genv Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: init_mem_exists Step 5: Introduce variables and assumptions Step 6: Apply tactic: assert (P: (prog_defmap tp)!id = Some (Gvar v)) Step 7: Apply tactic: { eapply prog_defmap_norepet Step 8: Apply tactic: eauto Step 9: Apply tactic: eapply match_prog_unique Step 10: Apply tactic: eauto Step 11: Rewrite using an equality", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:init_mem_inject", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall m, Genv Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit init_mem_exists Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Provide an existential witness Step 7: Split a conjunction into separate goals Step 8: Solve automatically using known facts Step 9: Split a conjunction into separate goals Step 10: Apply tactic: eapply init_mem_inj_2 Step 11: Apply tactic: eauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:transf_initial_states", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall S1, initial_state p S1 -> exists S2, initial_state tp S2 /\\ match_states S1 S2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: exploit init_mem_inject Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Apply tactic: exploit symbols_inject_2 Step 8: Apply tactic: eauto Step 9: Apply tactic: eapply kept_main Step 10: Apply tactic: eexact H1 Step 11: Introduce variables and assumptions", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:transf_final_states", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall S1 S2 r, match_states S1 S2 -> final_state S1 r -> final_state S2 r Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Apply tactic: inv H Step 5: Apply tactic: inv STACKS Step 6: Apply tactic: inv RESINJ Step 7: Apply tactic: constructor Step 8: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:transf_program_correct_1", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forward_simulation (semantics p) (semantics tp) Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply forward_simulation_step Step 4: Apply tactic: exploit globals_symbols_inject Step 5: Apply a theorem or hypothesis Step 6: Introduce variables and assumptions Step 7: Apply tactic: exact A Step 8: Apply tactic: eexact transf_initial_states Step 9: Apply tactic: eexact transf_final_states Step 10: Apply tactic: eexact step_simulation Step 11: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:transf_program_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall p tp, match_prog p tp -> forward_simulation (semantics p) (semantics tp) Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:link_def_either", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: Two fundefs Step 2: Two vardefs Step 3: We need to prove that forall (gd1 gd2 gd: globdef fundef unit), link_def gd1 gd2 = Some gd -> gd = gd1 \\/ gd = gd2 Step 4: Introduce variables and assumptions Step 5: Apply tactic: Local Transparent Linker_def Linker_fundef Linker_ Step 6: Case analysis by destructing a value Step 7: Case analysis by destructing a value Step 8: Simplify the goal by computation Step 9: Case analysis by destructing a value Step 10: Apply tactic: intuition congruence Step 11: Case analysis by destructing a value Step 12: Apply tactic: intuition congruence Step 13: Case analysis by destructing a value", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:used_not_defined", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall p used id, valid_used_set p used -> (prog_defmap p)!id = None -> IS Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: mem id used) eqn:M Step 5: Solve automatically using known facts Step 6: Apply tactic: exploit used_defined Step 7: Apply tactic: eauto using IS Step 8: Apply tactic: mem_2 Step 9: Introduce variables and assumptions Step 10: Solve automatically using known facts Step 11: Apply a theorem or hypothesis", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:used_not_defined_2", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall p used id, valid_used_set p used -> id <> prog_main p -> (prog_defmap p)!id = None -> ~IS Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit used_not_defined Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Apply tactic: red Step 7: Introduce variables and assumptions Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: mem_1 in H2 Step 10: Apply tactic: congruence Step 11: Apply tactic: congruence", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:link_valid_used_set", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: common definition Step 2: left definition Step 3: right definition Step 4: no definition Step 5: We need to prove that forall p1 p2 p used1 used2, link p1 p2 = Some p -> valid_used_set p1 used1 -> valid_used_set p2 used2 -> valid_used_set p (IS Step 6: Introduce variables and assumptions Step 7: Introduce variables and assumptions Step 8: Case analysis by destructing a value Step 9: Rewrite using an equality Step 10: Apply tactic: clear Z Step 11: Apply tactic: constructor Step 12: Apply tactic: - intros Step 13: Rewrite using an equality Step 14: Apply tactic: union_iff in H Step 15: Rewrite using an equality", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Unusedglobproof:link_match_program", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: both defined Step 2: left defined Step 3: right defined Step 4: none defined Step 5: We need to prove that forall p1 p2 tp1 tp2 p, link p1 p2 = Some p -> match_prog p1 tp1 -> match_prog p2 tp2 -> exists tp, link tp1 tp2 = Some tp /\\ match_prog p tp Step 6: Introduce variables and assumptions Step 7: Case analysis by destructing a value Step 8: Case analysis by destructing a value Step 9: Case analysis by destructing a value Step 10: Apply tactic: econstructor Step 11: Split a conjunction into separate goals Step 12: Apply tactic: - apply link_prog_succeeds Step 13: Apply tactic: + rewrite (match_prog_main _ _ _ B1), (match_prog_ Step 14: Solve automatically using known facts Step 15: Apply tactic: + intros", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:analyze_successor", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f n ae am instr s rm ae' am', (analyze rm f)!!n = VA Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: set (lu := Liveness Step 5: Apply tactic: last_uses f) in * Step 6: Apply tactic: set (entry := VA Step 7: Apply tactic: State (einit_regs f Step 8: Apply tactic: (fn_params) f Step 9: Apply tactic: (fn_sig) Step 10: Apply tactic: (sig_args)) mfunction_entry) in * Step 11: Case analysis by destructing a value", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:areg_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall bc e ae r, ematch bc e ae -> vmatch bc (e#r) (areg ae r) Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:aregs_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall bc e ae rl, ematch bc e ae -> list_forall2 (vmatch bc) (e##rl) (aregs ae rl) Step 2: Proceed by induction on rl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: constructor Step 6: Apply tactic: constructor Step 7: Apply tactic: [apply areg_sound|] Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:abuiltin_arg_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall bc ge rs sp m ae rm am, ematch bc rs ae -> romatch bc m rm -> mmatch bc m am -> genv_match bc ge -> bc sp = BCstack -> forall a v, eval_builtin_arg ge (fun r => rs#r) (Vptr sp Ptrofs Step 2: Introduce variables and assumptions Step 3: Introduce variables and assumptions Step 4: Proceed by induction on 1 Step 5: Simplify the goal by computation Step 6: Apply tactic: eauto with va Step 7: Apply tactic: - eapply loadv_sound Step 8: Apply tactic: eauto Step 9: Simplify the goal by computation Step 10: Rewrite using an equality Step 11: Apply tactic: add_zero_l", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:abuiltin_args_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall bc ge rs sp m ae rm am, ematch bc rs ae -> romatch bc m rm -> mmatch bc m am -> genv_match bc ge -> bc sp = BCstack -> forall al vl, eval_builtin_args ge (fun r => rs#r) (Vptr sp Ptrofs Step 2: Introduce variables and assumptions Step 3: Introduce variables and assumptions Step 4: Proceed by induction on 1 Step 5: Simplify the goal by computation Step 6: Apply tactic: - constructor Step 7: Apply tactic: - constructor Step 8: Solve automatically using known facts Step 9: Apply tactic: eapply abuiltin_arg_sound Step 10: Apply tactic: eauto Step 11: Apply tactic: Qed", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:set_builtin_res_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall bc rs ae v av res, ematch bc rs ae -> vmatch bc v av -> ematch bc (regmap_setres res v rs) (set_builtin_res res av ae) Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:eval_static_builtin_function_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall bc ge rs sp m ae rm am (bf: builtin_function) al vl v va, ematch bc rs ae -> romatch bc m rm -> mmatch bc m am -> genv_match bc ge -> bc sp = BCstack -> eval_builtin_args ge (fun r => rs#r) (Vptr sp Ptrofs Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: exploit abuiltin_args_sound Step 5: Apply tactic: eauto Step 6: Apply tactic: set (vla := map (abuiltin_arg ae am rm) al) in * Step 7: Introduce variables and assumptions Step 8: Case analysis by destructing a value Step 9: Apply tactic: try discriminate Step 10: Apply tactic: assert (LD: Val Step 11: Apply tactic: lessdef v0 v)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:pmatch_no_stack", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall b ofs p, pmatch bc b ofs p -> pmatch bc b ofs Nonstack Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: constructor Step 5: Apply tactic: congruence Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:vmatch_no_stack", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v x, vmatch bc v x -> vmatch bc v (Ifptr Nonstack) Step 2: Proceed by induction on 1 Step 3: Apply tactic: constructor Step 4: Solve automatically using known facts Step 5: Apply tactic: eapply pmatch_no_stack Step 6: Apply tactic: eauto Step 7: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:smatch_no_stack", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall m b p, smatch bc m b p -> smatch bc m b Nonstack Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Split a conjunction into separate goals Step 5: Introduce variables and assumptions Step 6: Apply tactic: eapply vmatch_no_stack Step 7: Apply tactic: eauto Step 8: Apply tactic: eapply pmatch_no_stack Step 9: Apply tactic: eauto Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:mmatch_no_stack", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall m am astk, mmatch bc m am -> mmatch bc m {| am_stack := astk; am_glob := PTree Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: constructor Step 5: Simplify the goal by computation Step 6: Introduce variables and assumptions Step 7: Apply tactic: - elim (NOSTACK b) Step 8: Solve automatically using known facts Step 9: Apply tactic: - rewrite PTree Step 10: Apply tactic: gempty in H0 Step 11: Apply tactic: discriminate", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:anonymize_stack", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: Part 1: constructing bc' Step 2: Part 2: matching wrt bc' Step 3: Conclusions Step 4: bc' sp is BCother Step 5: other blocks Step 6: mmatch top Step 7: We need to prove that forall m sp bc ge rm am, genv_match bc ge -> romatch bc m rm -> mmatch bc m am -> bc sp = BCstack -> exists bc', bc_nostack bc' /\\ bc' sp = BCother /\\ (forall b, b <> sp -> bc' b = bc b) /\\ (forall v x, vmatch bc v x -> vmatch bc' v Vtop) /\\ genv_match bc' ge /\\ romatch bc' m rm /\\ mmatch bc' m mtop Step 8: Introduce variables and assumptions Step 9: Introduce variables and assumptions Step 10: Apply tactic: set (f := fun b => if eq_block b sp then BCother e Step 11: Apply tactic: assert (F_stack: forall b1 b2, f b1 = BCstack -> f Step 12: Unfold a definition Step 13: Introduce variables and assumptions Step 14: Case analysis by destructing a value Step 15: Apply tactic: try discriminate Step 16: Case analysis by destructing a value Step 17: Apply tactic: try discriminate", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:sound_stack_ext", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall m' bc stk m bound, sound_stack bc stk m bound -> (forall b ofs n bytes, Plt b bound -> bc b = BCinvalid -> n >= 0 -> Mem Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Apply tactic: - constructor Step 5: Apply tactic: - assert (Plt sp bound') by eauto with va Step 6: Apply tactic: eapply sound_stack_public_call Step 7: Apply tactic: eauto Step 8: Apply a theorem or hypothesis Step 9: Introduce variables and assumptions Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: extlia", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:sound_stack_inv", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall m' bc stk m bound, sound_stack bc stk m bound -> (forall b ofs n, Plt b bound -> bc b = BCinvalid -> n >= 0 -> Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply sound_stack_ext Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Rewrite using an equality Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:sound_stack_storev", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall chunk m addr v m' bc aaddr stk bound, Mem Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Solve automatically using known facts Step 5: Case analysis by destructing a value Step 6: Simplify the goal by computation Step 7: Apply tactic: try discriminate Step 8: Apply tactic: assert (A: pmatch bc b i Ptop) Step 9: Apply tactic: { inv H0 Step 10: Apply tactic: eapply pmatch_top' Step 11: Apply tactic: eauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:sound_stack_storebytes", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall m b ofs bytes m' bc aaddr stk bound, Mem Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Solve automatically using known facts Step 5: Apply tactic: assert (A: pmatch bc b ofs Ptop) Step 6: Apply tactic: { inv H0 Step 7: Apply tactic: eapply pmatch_top' Step 8: Apply tactic: eauto Step 9: Apply tactic: inv A Step 10: Introduce variables and assumptions Step 11: Apply tactic: eapply Mem", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:sound_stack_free", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall m b lo hi m' bc stk bound, Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply sound_stack_ext Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Apply tactic: eapply Mem Step 7: Apply tactic: loadbytes_free_2 Step 8: Apply tactic: eauto Step 9: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:sound_stack_new_bound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall bc stk m bound bound', sound_stack bc stk m bound -> Ple bound bound' -> sound_stack bc stk m bound' Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: - constructor Step 5: Apply tactic: - eapply sound_stack_public_call with (bound' := b Step 6: Apply tactic: eauto Step 7: Apply tactic: extlia Step 8: Apply tactic: - eapply sound_stack_private_call with (bound' := Step 9: Apply tactic: eauto Step 10: Apply tactic: extlia Step 11: Apply tactic: Qed", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:sound_stack_exten", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall bc stk m bound (bc1: block_classification), sound_stack bc stk m bound -> (forall b, Plt b bound -> bc1 b = bc b) -> sound_stack bc1 stk m bound Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: - constructor Step 5: Apply tactic: - assert (Plt sp bound') by eauto with va Step 6: Apply tactic: eapply sound_stack_public_call Step 7: Apply tactic: eauto Step 8: Rewrite using an equality Step 9: Solve automatically using known facts Step 10: Apply tactic: extlia Step 11: Introduce variables and assumptions", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:sound_step_base", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: private call Step 2: public call Step 3: volatile store Step 4: true volatile access Step 5: normal memory access Step 6: annot val Step 7: jumptable Step 8: internal function Step 9: external function Step 10: from public call Step 11: from private call Step 12: tailcall Step 13: The default case Step 14: private builtin call Step 15: public builtin call Step 16: builtin function Step 17: volatile load Step 18: true volatile access Step 19: normal memory access Step 20: We need to prove that forall st t st', RTL Step 21: Proceed by induction on 1 Step 22: Introduce variables and assumptions Step 23: Apply tactic: inv SOUND Step 24: Apply tactic: eapply sound_succ_state Step 25: Apply tactic: eauto Step 26: Simplify the goal by computation Step 27: Solve automatically using known facts Step 28: Unfold a definition Step 29: Rewrite using an equality Step 30: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:sound_step", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall st t st', RTL Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Apply tactic: constructor Step 5: Introduce variables and assumptions Step 6: Apply tactic: eapply sound_step_base Step 7: Apply tactic: eauto Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:sound_state_inv", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall st cunit, sound_state st -> linkorder cunit prog -> sound_state_base cunit ge st Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: eauto Step 5: Apply tactic: Qed", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:store_init_data_summary", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ab p id, pge Glob (ab_summary ab) -> pge Glob (ab_summary (store_init_data ab p id)) Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (DFL: forall chunk av, Step 4: Apply tactic: vge (Ifptr Glob) av -> Step 5: Apply tactic: pge Glob (ab_summary (ablock_store chunk ab p av)) Step 6: Introduce variables and assumptions Step 7: Simplify the goal by computation Step 8: Unfold a definition Step 9: Case analysis by destructing a value Step 10: Solve automatically using known facts Step 11: Apply tactic: inv H0", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:store_init_data_list_summary", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall idl ab p, pge Glob (ab_summary ab) -> pge Glob (ab_summary (store_init_data_list ab p idl)) Step 2: Proceed by induction on idl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Apply a theorem or hypothesis Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:store_init_data_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall m b p id m' ab, Genv Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: try (eapply ablock_store_sound Step 5: Apply tactic: eauto Step 6: Apply tactic: constructor) Step 7: Simplify the goal by computation Step 8: Case analysis by destructing a value Step 9: Apply tactic: eapply ablock_store_sound Step 10: Apply tactic: eauto Step 11: Apply tactic: constructor", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:store_init_data_list_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall idl m b p m' ab, Genv Step 2: Proceed by induction on idl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - inv H Step 6: Solve automatically using known facts Step 7: Apply tactic: - destruct (Genv Step 8: Apply tactic: store_init_data ge m b p a) as [m1|] eqn:SI Step 9: Apply tactic: try discriminate Step 10: Apply tactic: eapply IHidl Step 11: Apply tactic: eauto", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:store_init_data_other", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall m b p id m' ab b', Genv Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply bmatch_inv Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Case analysis by destructing a value Step 7: Apply tactic: try (eapply Mem Step 8: Apply tactic: loadbytes_store_other Step 9: Apply tactic: eauto Step 10: Apply tactic: fail) Step 11: Simplify the goal by computation", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:store_init_data_list_other", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall b b' ab idl m p m', Genv Step 2: Proceed by induction on idl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: inv H Step 6: Solve automatically using known facts Step 7: Case analysis by destructing a value Step 8: Apply tactic: store_init_data ge m b p a) as [m1|] eqn:SI Step 9: Apply tactic: try discriminate Step 10: Apply tactic: eapply IHidl Step 11: Apply tactic: eauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:store_zeros_same", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall p m b pos n m', store_zeros m b pos n = Some m' -> smatch bc m b p -> smatch bc m' b p Step 2: Introduce variables and assumptions Step 3: Apply tactic: functional induction (store_zeros m b pos n) Step 4: Introduce variables and assumptions Step 5: Apply tactic: - inv H Step 6: Solve automatically using known facts Step 7: Apply tactic: - eapply IHo Step 8: Apply tactic: eauto Step 9: Apply tactic: change p with (vplub (I Int Step 10: Apply tactic: zero) p) Step 11: Apply tactic: eapply smatch_store", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:store_zeros_other", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall b' ab m b p n m', store_zeros m b p n = Some m' -> b' <> b -> bmatch bc m b' ab -> bmatch bc m' b' ab Step 2: Introduce variables and assumptions Step 3: Apply tactic: functional induction (store_zeros m b p n) Step 4: Introduce variables and assumptions Step 5: Apply tactic: - inv H Step 6: Solve automatically using known facts Step 7: Apply tactic: - eapply IHo Step 8: Apply tactic: eauto Step 9: Apply tactic: eapply bmatch_inv Step 10: Apply tactic: eauto Step 11: Introduce variables and assumptions", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:alloc_global_match", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall m g idg m', Genv Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Simplify the goal by computation Step 7: Apply tactic: - destruct (Mem Step 8: Apply tactic: alloc m 0 1) as [m1 b1] eqn:ALLOC Step 9: Unfold a definition Step 10: Apply tactic: find_symbol in H2 Step 11: Simplify the goal by computation", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:alloc_globals_match", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall gl m g m', Genv Step 2: Proceed by induction on gl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - inv H1 Step 6: Solve automatically using known facts Step 7: Apply tactic: - destruct (Genv Step 8: Apply tactic: alloc_global ge m a) as [m1|] eqn:AG Step 9: Apply tactic: try discriminate Step 10: Apply tactic: eapply IHgl Step 11: Apply tactic: eauto", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:alloc_global_consistent", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall dm rm idg, romem_consistent dm rm -> romem_consistent (PTree Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Simplify the goal by computation Step 7: Apply tactic: - rewrite PTree Step 8: Apply tactic: grspec in H0 Step 9: Case analysis by destructing a value Step 10: Apply tactic: elt_eq id id1) Step 11: Apply tactic: try discriminate", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:romem_for_consistent", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall cunit, romem_consistent (prog_defmap cunit) (romem_for cunit) Step 2: Apply tactic: assert (REC: forall l dm rm, Step 3: Apply tactic: romem_consistent dm rm -> Step 4: Apply tactic: romem_consistent (fold_left (fun m idg => PTree Step 5: Apply tactic: set (fst idg) (snd idg) m) l dm) Step 6: Apply tactic: (fold_left alloc_global l rm)) Step 7: Apply tactic: { induction l Step 8: Introduce variables and assumptions Step 9: Simplify the goal by computation Step 10: Solve automatically using known facts Step 11: Apply a theorem or hypothesis", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:romem_for_consistent_2", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall cunit, linkorder cunit prog -> romem_consistent (prog_defmap prog) (romem_for cunit) Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: exploit (romem_for_consistent cunit) Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Case analysis by destructing a value Step 9: Apply tactic: assert (gd = Gvar v) Step 10: Apply tactic: { inv Q Step 11: Apply tactic: inv H2", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:sound_initial", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall prog st, initial_state prog st -> sound_state prog st Step 2: Case analysis by destructing a value Step 3: Apply tactic: exploit initial_mem_matches Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Apply tactic: constructor Step 7: Introduce variables and assumptions Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: - constructor Step 10: Apply tactic: - simpl Step 11: Apply tactic: tauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:avalue_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall cunit prog s f sp pc e m r, sound_state prog (State s f (Vptr sp Ptrofs Step 2: Introduce variables and assumptions Step 3: Apply tactic: InvSoundState Step 4: Provide an existential witness Step 5: Split a conjunction into separate goals Step 6: Solve automatically using known facts Step 7: Rewrite using an equality Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:ValueAnalysis:aaddr_arg_sound_1", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall bc rs ae m rm am ge sp a b ofs, ematch bc rs ae -> romatch bc m rm -> mmatch bc m am -> genv_match bc ge -> bc sp = BCstack -> eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Simplify the goal by computation Step 5: Case analysis by destructing a value Step 6: Apply tactic: try (apply pge_top) Step 7: Simplify the goal by computation Step 8: Apply a theorem or hypothesis Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: eapply abuiltin_arg_sound Step 11: Apply tactic: eauto", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Constpropproof:transf_program_match", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall prog, match_prog prog (transf_program prog) Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply match_transform_program_contextual Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Constpropproof:symbols_preserved", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall (s: ident), Genv Step 2: Apply tactic: Lemma senv_preserved: Step 3: Apply tactic: Senv Step 4: Apply tactic: equiv ge tge Step 5: Apply tactic: Lemma functions_translated: Step 6: Apply tactic: forall (v: val) (f: fundef), Step 7: Apply tactic: Genv Step 8: Apply tactic: find_funct ge v = Some f -> Step 9: Provide an existential witness Step 10: Apply tactic: find_funct tge v = Some (transf_fundef (romem_for Step 11: Introduce variables and assumptions", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Constpropproof:senv_preserved", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that Senv Step 2: Apply tactic: Lemma functions_translated: Step 3: Apply tactic: forall (v: val) (f: fundef), Step 4: Apply tactic: Genv Step 5: Apply tactic: find_funct ge v = Some f -> Step 6: Provide an existential witness Step 7: Apply tactic: find_funct tge v = Some (transf_fundef (romem_for Step 8: Introduce variables and assumptions Step 9: Apply tactic: exploit (Genv Step 10: Apply tactic: find_funct_match TRANSL) Step 11: Apply tactic: eauto", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Constpropproof:functions_translated", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall (v: val) (f: fundef), Genv Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit (Genv Step 4: Apply tactic: find_funct_match TRANSL) Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Apply tactic: subst tf Step 8: Provide an existential witness Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Constpropproof:function_ptr_translated", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall (b: block) (f: fundef), Genv Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit (Genv Step 4: Apply tactic: find_funct_ptr_match TRANSL) Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Apply tactic: subst tf Step 8: Provide an existential witness Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Constpropproof:sig_function_translated", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall rm f, funsig (transf_fundef rm f) = funsig f Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: The goal is true by reflexivity Step 5: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Constpropproof:init_regs_lessdef", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall rl vl1 vl2, Val Step 2: Proceed by induction on rl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Rewrite using an equality Step 8: Solve automatically using known facts Step 9: Apply tactic: inv H Step 10: Apply tactic: red Step 11: Introduce variables and assumptions", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Constpropproof:transf_ros_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: function pointer Step 2: function symbol Step 3: We need to prove that forall bc rs ae ros f rs', genv_match bc ge -> ematch bc rs ae -> find_function ge ros rs = Some f -> regs_lessdef rs rs' -> exists cunit, find_function tge (transf_ros ae ros) rs' = Some (transf_fundef (romem_for cunit) f) /\\ linkorder cunit prog Step 4: Introduce variables and assumptions Step 5: Introduce variables and assumptions Step 6: Case analysis by destructing a value Step 7: Simplify the goal by computation Step 8: Apply tactic: generalize (EM r) Step 9: Apply tactic: fold (areg ae r) Step 10: Apply tactic: intro VM Step 11: Apply tactic: generalize (RLD r) Step 12: Apply tactic: intro LD Step 13: Apply tactic: assert (DEFAULT:", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Constpropproof:const_for_result_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall a op bc v sp m, const_for_result a = Some op -> vmatch bc v a -> bc sp = BCstack -> genv_match bc ge -> exists v', eval_operation tge (Vptr sp Ptrofs Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit ConstpropOpproof Step 4: Apply tactic: const_for_result_correct Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Provide an existential witness Step 8: Split a conjunction into separate goals Step 9: Rewrite using an equality Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: exact symbols_preserved", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Constpropproof:match_successor_rec", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f rs m bc ae, ematch bc rs ae -> forall n pc, match_pc f rs m n pc (successor_rec n f ae pc) Step 2: Proceed by induction on n Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - apply match_pc_base Step 6: Apply tactic: - destruct (fn_code f)!pc as [[]|] eqn:INSTR Step 7: Apply tactic: try apply match_pc_base Step 8: Apply tactic: + eapply match_pc_nop Step 9: Apply tactic: eauto Step 10: Apply tactic: + destruct (resolve_branch (eval_static_condition Step 11: Apply tactic: try apply match_pc_base", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Constpropproof:match_successor", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f rs m bc ae pc, ematch bc rs ae -> match_pc f rs m num_iter pc (successor f ae pc) Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply match_successor_rec Step 4: Apply tactic: eauto Step 5: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Constpropproof:builtin_arg_reduction_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall bc sp m rs ae, ematch bc rs ae -> forall a v, eval_builtin_arg ge (fun r => rs#r) sp m a v -> eval_builtin_arg ge (fun r => rs#r) sp m (builtin_arg_reduction ae a) v Step 2: Proceed by induction on 2 Step 3: Simplify the goal by computation Step 4: Apply tactic: eauto with barg Step 5: Apply tactic: - specialize (H x) Step 6: Unfold a definition Step 7: Case analysis by destructing a value Step 8: Apply tactic: get x ae) Step 9: Apply tactic: try constructor Step 10: Apply tactic: + inv H Step 11: Apply tactic: constructor", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Constpropproof:builtin_arg_strength_reduction_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall bc sp m rs ae a v c, ematch bc rs ae -> eval_builtin_arg ge (fun r => rs#r) sp m a v -> eval_builtin_arg ge (fun r => rs#r) sp m (builtin_arg_strength_reduction ae a c) v Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Apply tactic: eapply builtin_arg_reduction_correct Step 6: Apply tactic: eauto Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Constpropproof:builtin_args_strength_reduction_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall bc sp m rs ae, ematch bc rs ae -> forall al vl, eval_builtin_args ge (fun r => rs#r) sp m al vl -> forall cl, eval_builtin_args ge (fun r => rs#r) sp m (builtin_args_strength_reduction ae al cl) vl Step 2: Proceed by induction on 2 Step 3: Simplify the goal by computation Step 4: Apply tactic: constructor Step 5: Apply tactic: eapply builtin_arg_strength_reduction_correct Step 6: Apply tactic: eauto Step 7: Apply a theorem or hypothesis Step 8: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Constpropproof:debug_strength_reduction_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall bc sp m rs ae, ematch bc rs ae -> forall al vl, eval_builtin_args ge (fun r => rs#r) sp m al vl -> exists vl', eval_builtin_args ge (fun r => rs#r) sp m (debug_strength_reduction ae al) vl' Step 2: Proceed by induction on 2 Step 3: Simplify the goal by computation Step 4: Apply tactic: - exists (@nil val) Step 5: Apply tactic: constructor Step 6: Apply tactic: - destruct IHlist_forall2 as (vl' & A) Step 7: Apply tactic: assert (eval_builtin_args ge (fun r => rs#r) sp m Step 8: Apply tactic: (a1 :: debug_strength_reduction ae al) (b1 :: vl') Step 9: Apply tactic: by (constructor Step 10: Apply tactic: eauto) Step 11: Case analysis by destructing a value", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Constpropproof:builtin_strength_reduction_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall sp bc ae rs ef args vargs m t vres m', ematch bc rs ae -> eval_builtin_args ge (fun r => rs#r) sp m args vargs -> external_call ef ge vargs m t vres m' -> exists vargs', eval_builtin_args ge (fun r => rs#r) sp m (builtin_strength_reduction ae ef args) vargs' /\\ external_call ef ge vargs' m t vres m' Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (DEFAULT: forall cl, Step 4: Provide an existential witness Step 5: Apply tactic: eval_builtin_args ge (fun r => rs#r) sp m (builtin Step 6: Apply tactic: /\\ external_call ef ge vargs' m t vres m') Step 7: Apply tactic: { exists vargs Step 8: Split a conjunction into separate goals Step 9: Solve automatically using known facts Step 10: Apply tactic: eapply builtin_args_strength_reduction_correct Step 11: Apply tactic: eauto", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Constpropproof:match_states_succ", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall s f sp pc rs m s' rs' m' cu, linkorder cu prog -> list_forall2 match_stackframes s s' -> regs_lessdef rs rs' -> Mem Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Solve automatically using known facts Step 5: Apply tactic: constructor Step 6: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Constpropproof:transf_instr_at", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall rm f pc i, f Step 2: Introduce variables and assumptions Step 3: Simplify the goal by computation Step 4: Rewrite using an equality Step 5: Apply tactic: gmap Step 6: Rewrite using an equality Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Constpropproof:transf_step_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: Inop, preserved Step 2: Inop, skipped over Step 3: Ijumptable Step 4: internal function Step 5: external function Step 6: constant is propagated Step 7: operator is strength-reduced Step 8: constant-propagated Step 9: strength-reduced Step 10: Itailcall Step 11: Ibuiltin Step 12: Icond, preserved Step 13: Icond, skipped over Step 14: We need to prove that forall s1 t s2, step ge s1 t s2 -> forall n1 s1' (SS: sound_state prog s1) (MS: match_states n1 s1 s1'), (exists n2, exists s2', step tge s1' t s2' /\\ match_states n2 s2 s2') \\/ (exists n2, n2 < n1 /\\ t = E0 /\\ match_states n2 s2 s1')%nat Step 15: Proceed by induction on 1 Step 16: Introduce variables and assumptions Step 17: Apply tactic: inv MS Step 18: Apply tactic: try InvSoundState Step 19: Apply tactic: try (inv PC Step 20: Apply tactic: try congruence) Step 21: Apply tactic: rename pc'0 into pc Step 22: Apply tactic: TransfInstr Step 23: Introduce variables and assumptions Step 24: Apply tactic: left", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Constpropproof:transf_initial_states", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall st1, initial_state prog st1 -> exists n, exists st2, initial_state tprog st2 /\\ match_states n st1 st2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inversion H Step 4: Apply tactic: exploit function_ptr_translated Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Provide an existential witness Step 8: Provide an existential witness Step 9: Split a conjunction into separate goals Step 10: Apply tactic: econstructor Step 11: Apply tactic: eauto", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Constpropproof:transf_final_states", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall n st1 st2 r, match_states n st1 st2 -> final_state st1 r -> final_state st2 r Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Apply tactic: inv H Step 5: Apply tactic: inv STACKS Step 6: Apply tactic: inv RES Step 7: Apply tactic: constructor Step 8: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Constpropproof:transf_program_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forward_simulation (RTL Step 2: Apply a theorem or hypothesis Step 3: Apply tactic: constructor Step 4: Apply tactic: - apply lt_wf Step 5: Apply tactic: - simpl Step 6: Introduce variables and assumptions Step 7: Apply tactic: exploit transf_initial_states Step 8: Apply tactic: eauto Step 9: Introduce variables and assumptions Step 10: Provide an existential witness Step 11: Apply tactic: intuition", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:transf_program_match", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall p tp, transf_program p = OK tp -> match_prog p tp Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply match_transform_partial_program Step 4: Apply tactic: eauto Step 5: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:typesize_typesize", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ty, AST Step 2: Case analysis by destructing a value Step 3: Solve automatically using known facts Step 4: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:size_type_chunk", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ty, size_chunk (chunk_of_type ty) = AST Step 2: Case analysis by destructing a value Step 3: The goal is true by reflexivity Step 4: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:align_type_chunk", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ty, align_chunk (chunk_of_type ty) = 4 * Locations Step 2: Case analysis by destructing a value Step 3: The goal is true by reflexivity Step 4: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:slot_outgoing_argument_valid", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f ofs ty sg, In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)) -> slot_valid f Outgoing ofs ty = true Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit loc_arguments_acceptable_2 Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Rewrite using an equality Step 9: Rewrite using an equality Step 10: Solve automatically using known facts Step 11: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:load_result_inject", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j ty v v', Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: has_type, Val Step 5: Apply tactic: load_result Step 6: Case analysis by destructing a value Step 7: Apply tactic: ptr64 Step 8: Case analysis by destructing a value Step 9: Introduce variables and assumptions Step 10: Solve automatically using known facts Step 11: Case analysis by destructing a value", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:unfold_transf_function", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that tf = Mach Step 2: Apply tactic: generalize TRANSF_F Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Case analysis by destructing a value Step 7: Apply tactic: max_unsigned (fe_size (make_env (function_bounds f Step 8: Introduce variables and assumptions Step 9: Apply tactic: discriminate Step 10: Introduce variables and assumptions Step 11: Unfold a definition", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:transf_function_well_typed", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that wt_function f = true Step 2: Apply tactic: generalize TRANSF_F Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Solve automatically using known facts Step 7: Introduce variables and assumptions Step 8: Apply tactic: discriminate Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:size_no_overflow", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that fe Step 2: Apply tactic: generalize TRANSF_F Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Case analysis by destructing a value Step 7: Apply tactic: max_unsigned (fe_size (make_env (function_bounds f Step 8: Introduce variables and assumptions Step 9: Apply tactic: discriminate Step 10: Introduce variables and assumptions Step 11: Unfold a definition", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:bound_stack_data_stacksize", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that f Step 2: Unfold a definition Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: le_max_l Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:contains_get_stack", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall spec m ty sp ofs, m |= contains (chunk_of_type ty) sp ofs spec -> exists v, load_stack m (Vptr sp Ptrofs Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: replace (Val Step 5: Apply tactic: offset_ptr (Vptr sp Ptrofs Step 6: Apply tactic: zero) (Ptrofs Step 7: Apply tactic: repr ofs)) with (Vptr sp (Ptrofs Step 8: Apply tactic: repr ofs)) Step 9: Apply tactic: eapply loadv_rule Step 10: Apply tactic: eauto Step 11: Simplify the goal by computation", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:hasvalue_get_stack", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ty m sp ofs v, m |= hasvalue (chunk_of_type ty) sp ofs v -> load_stack m (Vptr sp Ptrofs Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit contains_get_stack Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Apply tactic: congruence Step 7: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:contains_set_stack", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall (spec: val -> Prop) v spec1 m ty sp ofs P, m |= contains (chunk_of_type ty) sp ofs spec1 ** P -> spec (Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: replace (Val Step 5: Apply tactic: offset_ptr (Vptr sp Ptrofs Step 6: Apply tactic: zero) (Ptrofs Step 7: Apply tactic: repr ofs)) with (Vptr sp (Ptrofs Step 8: Apply tactic: repr ofs)) Step 9: Apply tactic: eapply storev_rule Step 10: Apply tactic: eauto Step 11: Simplify the goal by computation", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:valid_access_location", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall m sp pos bound ofs ty p, (8 | pos) -> Mem Step 2: Introduce variables and assumptions Step 3: Split a conjunction into separate goals Step 4: Apply tactic: - red Step 5: Introduce variables and assumptions Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: perm_implies with Freeable Step 8: Solve automatically using known facts Step 9: Apply a theorem or hypothesis Step 10: Rewrite using an equality Step 11: Apply tactic: lia", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:get_location", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall m j sp pos bound sl ls ofs ty, m |= contains_locations j sp pos bound sl ls -> 0 <= ofs -> ofs + typesize ty <= bound -> (typealign ty | ofs) -> exists v, load_stack m (Vptr sp Ptrofs Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: exploit H Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Provide an existential witness Step 8: Split a conjunction into separate goals Step 9: Solve automatically using known facts Step 10: Unfold a definition Step 11: Simplify the goal by computation", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:initial_locations", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j sp pos bound P sl ls m, m |= range sp pos (pos + 4 * bound) ** P -> (8 | pos) -> (forall ofs ty, ls (S sl ofs ty) = Vundef) -> m |= contains_locations j sp pos bound sl ls ** P Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Case analysis by destructing a value Step 5: Split a conjunction into separate goals Step 6: Apply tactic: - simpl Step 7: Apply tactic: intuition auto Step 8: Apply tactic: red Step 9: Introduce variables and assumptions Step 10: Apply tactic: eauto with mem Step 11: Case analysis by destructing a value", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:contains_locations_exten", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ls ls' j sp pos bound sl, (forall ofs ty, Val Step 2: Introduce variables and assumptions Step 3: Split a conjunction into separate goals Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Solve automatically using known facts Step 7: Apply tactic: intuition auto Step 8: Apply tactic: exploit H5 Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Provide an existential witness", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:contains_locations_incr", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j j' sp pos bound sl ls, inject_incr j j' -> massert_imp (contains_locations j sp pos bound sl ls) (contains_locations j' sp pos bound sl ls) Step 2: Introduce variables and assumptions Step 3: Split a conjunction into separate goals Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Solve automatically using known facts Step 7: Apply tactic: intuition auto Step 8: Apply tactic: exploit H5 Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Provide an existential witness", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:contains_callee_saves_incr", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j j' sp ls, inject_incr j j' -> forall rl pos, massert_imp (contains_callee_saves j sp pos rl ls) (contains_callee_saves j' sp pos rl ls) Step 2: Proceed by induction on rl as [ | r1 rl] Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - reflexivity Step 6: Apply tactic: - apply sepconj_morph_1 Step 7: Solve automatically using known facts Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: eauto Step 10: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:contains_callee_saves_exten", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j sp ls ls' rl pos, (forall r, In r rl -> ls' (R r) = ls (R r)) -> massert_eqv (contains_callee_saves j sp pos rl ls) (contains_callee_saves j sp pos rl ls') Step 2: Proceed by induction on rl as [ | r1 rl] Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - reflexivity Step 6: Apply tactic: - apply sepconj_morph_2 Step 7: Solve automatically using known facts Step 8: Rewrite using an equality Step 9: The goal is true by reflexivity Step 10: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:frame_get_local", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ofs ty j sp ls ls0 parent retaddr m P, m |= frame_contents j sp ls ls0 parent retaddr ** P -> slot_within_bounds b Local ofs ty -> slot_valid f Local ofs ty = true -> exists v, load_stack m (Vptr sp Ptrofs Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Apply tactic: InvBooleans Step 6: Apply a theorem or hypothesis Step 7: Apply a theorem or hypothesis Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: eapply get_location Step 10: Apply tactic: eauto Step 11: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:frame_get_outgoing", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ofs ty j sp ls ls0 parent retaddr m P, m |= frame_contents j sp ls ls0 parent retaddr ** P -> slot_within_bounds b Outgoing ofs ty -> slot_valid f Outgoing ofs ty = true -> exists v, load_stack m (Vptr sp Ptrofs Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Apply tactic: InvBooleans Step 6: Apply a theorem or hypothesis Step 7: Apply a theorem or hypothesis Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: eapply get_location Step 10: Apply tactic: eauto Step 11: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:frame_get_parent", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j sp ls ls0 parent retaddr m P, m |= frame_contents j sp ls ls0 parent retaddr ** P -> load_stack m (Vptr sp Ptrofs Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply a theorem or hypothesis Step 5: Apply a theorem or hypothesis Step 6: Apply a theorem or hypothesis Step 7: Rewrite using an equality Step 8: Apply tactic: eapply hasvalue_get_stack Step 9: Apply tactic: eauto Step 10: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:frame_get_retaddr", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j sp ls ls0 parent retaddr m P, m |= frame_contents j sp ls ls0 parent retaddr ** P -> load_stack m (Vptr sp Ptrofs Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply a theorem or hypothesis Step 5: Apply a theorem or hypothesis Step 6: Apply a theorem or hypothesis Step 7: Rewrite using an equality Step 8: Apply tactic: eapply hasvalue_get_stack Step 9: Apply tactic: eauto Step 10: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:frame_set_reg", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall r v j sp ls ls0 parent retaddr m P, m |= frame_contents j sp ls ls0 parent retaddr ** P -> m |= frame_contents j sp (Locmap Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:frame_undef_regs", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j sp ls ls0 parent retaddr m P rl, m |= frame_contents j sp ls ls0 parent retaddr ** P -> m |= frame_contents j sp (LTL Step 2: Apply tactic: Local Opaque sepconj Step 3: Proceed by induction on rl Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Apply tactic: - auto Step 7: Apply tactic: - apply frame_set_reg Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:frame_set_regpair", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j sp ls0 parent retaddr m P p v ls, m |= frame_contents j sp ls ls0 parent retaddr ** P -> m |= frame_contents j sp (Locmap Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Apply a theorem or hypothesis Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:frame_set_res", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j sp ls0 parent retaddr m P res v ls, m |= frame_contents j sp ls ls0 parent retaddr ** P -> m |= frame_contents j sp (Locmap Step 2: Proceed by induction on res Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - apply frame_set_reg Step 6: Solve automatically using known facts Step 7: Apply tactic: - auto Step 8: Apply tactic: - eauto Step 9: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:frame_contents_incr", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j sp ls ls0 parent retaddr m P j', m |= frame_contents j sp ls ls0 parent retaddr ** P -> inject_incr j j' -> m |= frame_contents j' sp ls ls0 parent retaddr ** P Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Rewrite using an equality Step 5: Rewrite using an equality Step 6: Apply tactic: erewrite <- contains_callee_saves_incr by eauto Step 7: Apply tactic: assumption Step 8: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:agree_reg", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j ls rs r, agree_regs j ls rs -> Val Step 2: Introduce variables and assumptions Step 3: Solve automatically using known facts Step 4: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:agree_reglist", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j ls rs rl, agree_regs j ls rs -> Val Step 2: Proceed by induction on rl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Apply tactic: constructor Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:agree_regs_set_reg", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j ls rs r v v', agree_regs j ls rs -> Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Apply tactic: set Step 7: Case analysis by destructing a value Step 8: Apply tactic: eq r0 r) Step 9: Apply tactic: subst r0 Step 10: Rewrite using an equality Step 11: Apply tactic: gss", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:agree_regs_set_pair", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j p v v' ls rs, agree_regs j ls rs -> Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: - apply agree_regs_set_reg Step 6: Solve automatically using known facts Step 7: Apply tactic: - apply agree_regs_set_reg Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: hiword_inject", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:agree_regs_set_res", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j res v v' ls rs, agree_regs j ls rs -> Val Step 2: Proceed by induction on res Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - apply agree_regs_set_reg Step 6: Solve automatically using known facts Step 7: Apply tactic: - auto Step 8: Apply tactic: - apply IHres2 Step 9: Apply a theorem or hypothesis Step 10: Solve automatically using known facts Step 11: Apply a theorem or hypothesis", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:agree_regs_exten", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j ls rs ls' rs', agree_regs j ls rs -> (forall r, ls' (R r) = Vundef \\/ ls' (R r) = ls (R r) /\\ rs' r = rs r) -> agree_regs j ls' rs' Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Rewrite using an equality Step 7: Apply tactic: constructor Step 8: Rewrite using an equality Step 9: Rewrite using an equality Step 10: Solve automatically using known facts Step 11: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:agree_regs_undef_regs", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j rl ls rs, agree_regs j ls rs -> agree_regs j (LTL Step 2: Proceed by induction on rl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:agree_regs_undef_caller_save_regs", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j ls rs, agree_regs j ls rs -> agree_regs j (LTL Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Apply tactic: undef_caller_save_regs, Mach Step 7: Apply tactic: undef_caller_save_regs Step 8: Case analysis by destructing a value Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:agree_regs_set_slot", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j ls rs sl ofs ty v, agree_regs j ls rs -> agree_regs j (Locmap Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: gso Step 7: Solve automatically using known facts Step 8: Apply tactic: red Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:agree_regs_inject_incr", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j ls rs j', agree_regs j ls rs -> inject_incr j j' -> agree_regs j' ls rs Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: eauto with stacking Step 6: Apply tactic: Qed", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:agree_regs_call_regs", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j ls rs, agree_regs j ls rs -> agree_regs j (call_regs ls) rs Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Introduce variables and assumptions Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:agree_locs_set_reg", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ls ls0 r v, agree_locs ls ls0 -> mreg_within_bounds b r -> agree_locs (Locmap Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: constructor Step 5: Solve automatically using known facts Step 6: Introduce variables and assumptions Step 7: Rewrite using an equality Step 8: Apply tactic: gso Step 9: Solve automatically using known facts Step 10: Apply tactic: red Step 11: Apply tactic: intuition congruence", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:caller_save_reg_within_bounds", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall r, is_callee_save r = false -> mreg_within_bounds b r Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: congruence Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:agree_locs_set_pair", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ls0 p v ls, agree_locs ls ls0 -> forall_rpair (fun r => is_callee_save r = false) p -> agree_locs (Locmap Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Apply a theorem or hypothesis Step 8: Solve automatically using known facts Step 9: Case analysis by destructing a value Step 10: Apply a theorem or hypothesis Step 11: Solve automatically using known facts", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:agree_locs_set_res", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ls0 res v ls, agree_locs ls ls0 -> (forall r, In r (params_of_builtin_res res) -> mreg_within_bounds b r) -> agree_locs (Locmap Step 2: Proceed by induction on res Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - eapply agree_locs_set_reg Step 6: Apply tactic: eauto Step 7: Apply tactic: - auto Step 8: Apply tactic: - apply IHres2 Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:agree_locs_undef_regs", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ls0 regs ls, agree_locs ls ls0 -> (forall r, In r regs -> mreg_within_bounds b r) -> agree_locs (LTL Step 2: Proceed by induction on regs Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:agree_locs_undef_locs_1", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ls0 regs ls, agree_locs ls ls0 -> (forall r, In r regs -> is_callee_save r = false) -> agree_locs (LTL Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply agree_locs_undef_regs Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:agree_locs_undef_locs", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ls0 regs ls, agree_locs ls ls0 -> existsb is_callee_save regs = false -> agree_locs (LTL Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply agree_locs_undef_locs_1 Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Case analysis by destructing a value Step 7: Solve automatically using known facts Step 8: Apply tactic: assert (existsb is_callee_save regs = true) Step 9: Apply tactic: { apply existsb_exists Step 10: Provide an existential witness Step 11: Solve automatically using known facts", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:agree_locs_set_slot", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ls ls0 sl ofs ty v, agree_locs ls ls0 -> slot_writable sl = true -> agree_locs (Locmap Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: constructor Step 5: Introduce variables and assumptions Step 6: Apply tactic: - rewrite Locmap Step 7: Apply tactic: gso Step 8: Solve automatically using known facts Step 9: Apply tactic: red Step 10: Solve automatically using known facts Step 11: Apply tactic: - rewrite Locmap", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:agree_locs_return", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ls ls0 ls', agree_locs ls ls0 -> agree_callee_save ls' ls -> agree_locs ls' ls0 Step 2: Introduce variables and assumptions Step 3: Apply tactic: red in H0 Step 4: Apply tactic: inv H Step 5: Apply tactic: constructor Step 6: Solve automatically using known facts Step 7: Introduce variables and assumptions Step 8: Apply tactic: - rewrite H0 Step 9: Solve automatically using known facts Step 10: Unfold a definition Step 11: Apply tactic: tauto", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:destroyed_by_op_caller_save", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall op, no_callee_saves (destroyed_by_op op) Step 2: Apply tactic: Local Transparent destroyed_by_op Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Apply tactic: ByCases Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:destroyed_by_load_caller_save", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall chunk addr, no_callee_saves (destroyed_by_load chunk addr) Step 2: Apply tactic: Local Transparent destroyed_by_load Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Apply tactic: ByCases Step 6: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:destroyed_by_store_caller_save", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall chunk addr, no_callee_saves (destroyed_by_store chunk addr) Step 2: Apply tactic: Local Transparent destroyed_by_store Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Apply tactic: ByCases Step 6: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:destroyed_by_cond_caller_save", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall cond, no_callee_saves (destroyed_by_cond cond) Step 2: Apply tactic: Local Transparent destroyed_by_cond Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Apply tactic: ByCases Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:destroyed_by_jumptable_caller_save", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that no_callee_saves destroyed_by_jumptable Step 2: Apply tactic: red Step 3: The goal is true by reflexivity Step 4: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:destroyed_by_setstack_caller_save", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ty, no_callee_saves (destroyed_by_setstack ty) Step 2: Unfold a definition Step 3: Case analysis by destructing a value Step 4: The goal is true by reflexivity Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:destroyed_at_function_entry_caller_save", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that no_callee_saves destroyed_at_function_entry Step 2: Apply tactic: red Step 3: The goal is true by reflexivity Step 4: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:destroyed_by_setstack_function_entry", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ty, incl (destroyed_by_setstack ty) destroyed_at_function_entry Step 2: Apply tactic: Local Transparent destroyed_by_setstack destroyed_ Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: tauto Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:transl_destroyed_by_op", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall op e, destroyed_by_op (transl_op e op) = destroyed_by_op op Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: The goal is true by reflexivity Step 5: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:transl_destroyed_by_load", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall chunk addr e, destroyed_by_load chunk (transl_addr e addr) = destroyed_by_load chunk addr Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: The goal is true by reflexivity Step 5: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:transl_destroyed_by_store", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall chunk addr e, destroyed_by_store chunk (transl_addr e addr) = destroyed_by_store chunk addr Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: The goal is true by reflexivity Step 5: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:LTL_undef_regs_same", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall r rl ls, In r rl -> LTL Step 2: Proceed by induction on rl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: contradiction Step 6: Unfold a definition Step 7: Apply tactic: set Step 8: Case analysis by destructing a value Step 9: Apply tactic: eq (R a) (R r)) Step 10: Solve automatically using known facts Step 11: Case analysis by destructing a value", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:LTL_undef_regs_others", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall r rl ls, ~In r rl -> LTL Step 2: Proceed by induction on rl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Rewrite using an equality Step 7: Apply tactic: gso Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: intuition Step 10: Apply tactic: red Step 11: Apply tactic: intuition", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:LTL_undef_regs_slot", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall sl ofs ty rl ls, LTL Step 2: Proceed by induction on rl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Rewrite using an equality Step 7: Apply tactic: gso Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: red Step 10: Solve automatically using known facts Step 11: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:undef_regs_type", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ty l rl ls, Val Step 2: Proceed by induction on rl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - auto Step 6: Apply tactic: - unfold Locmap Step 7: Apply tactic: set Step 8: Case analysis by destructing a value Step 9: Apply tactic: eq (R a) l) Step 10: Apply tactic: red Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:simplify_load_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall chunk m a v, Mem Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: try discriminate Step 6: Case analysis by destructing a value Step 7: Simplify the goal by computation Step 8: Apply tactic: try (exists v Step 9: Solve automatically using known facts Step 10: Apply tactic: fail) Step 11: Rewrite using an equality", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:simplify_store_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall chunk m a v m', Mem Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: try discriminate Step 6: Rewrite using an equality Step 7: Apply tactic: symmetry Step 8: Case analysis by destructing a value Step 9: Simplify the goal by computation Step 10: Solve automatically using known facts Step 11: Apply tactic: - apply Mem", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:simplify_load_destroyed", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall chunk addr, destroyed_by_load (simplify_load chunk) addr = destroyed_by_load chunk addr Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: The goal is true by reflexivity Step 5: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:simplify_store_destroyed", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall chunk addr, destroyed_by_store (simplify_store chunk) addr = destroyed_by_store chunk addr Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: The goal is true by reflexivity Step 5: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:stack_contents_change_meminj", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall m j j', inject_incr j j' -> forall cs cs' P, m |= stack_contents j cs cs' ** P -> m |= stack_contents j' cs cs' ** P Step 2: Apply tactic: Local Opaque sepconj Step 3: Proceed by induction on cs as [ | [] cs] Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Introduce variables and assumptions Step 7: Solve automatically using known facts Step 8: Case analysis by destructing a value Step 9: Solve automatically using known facts Step 10: Rewrite using an equality Step 11: Apply a theorem or hypothesis", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:match_stacks_change_meminj", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j j', inject_incr j j' -> forall cs cs' sg, match_stacks j cs cs' sg -> match_stacks j' cs cs' sg Step 2: Proceed by induction on 2 Step 3: Introduce variables and assumptions Step 4: Apply tactic: - constructor Step 5: Solve automatically using known facts Step 6: Apply tactic: - econstructor Step 7: Apply tactic: eauto Step 8: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:match_stacks_change_sig", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall sg1 j cs cs' sg, match_stacks j cs cs' sg -> tailcall_possible sg1 -> match_stacks j cs cs' sg1 Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Apply tactic: econstructor Step 5: Apply tactic: eauto Step 6: Apply tactic: econstructor Step 7: Apply tactic: eauto Step 8: Introduce variables and assumptions Step 9: Apply tactic: elim (H0 _ H1) Step 10: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:match_stacks_type_sp", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j cs cs' sg, match_stacks j cs cs' sg -> Val Step 2: Proceed by induction on 1 Step 3: Unfold a definition Step 4: Apply a theorem or hypothesis Step 5: Apply tactic: Vnullptr_has_type Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: Vptr_has_type Step 8: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:match_stacks_type_retaddr", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j cs cs' sg, match_stacks j cs cs' sg -> Val Step 2: Proceed by induction on 1 Step 3: Unfold a definition Step 4: Apply a theorem or hypothesis Step 5: Apply tactic: Vnullptr_has_type Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:find_label_save_callee_save", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall lbl l ofs k, Mach Step 2: Proceed by induction on l Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:find_label_restore_callee_save", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall lbl l ofs k, Mach Step 2: Proceed by induction on l Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:transl_code_eq", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall fe i c, transl_code fe (i :: c) = transl_instr fe i (transl_code fe c) Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Rewrite using an equality Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:find_label_transl_code", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall fe lbl c, Mach Step 2: Proceed by induction on c Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - auto Step 6: Apply tactic: - rewrite transl_code_eq Step 7: Case analysis by destructing a value Step 8: Unfold a definition Step 9: Solve automatically using known facts Step 10: Case analysis by destructing a value Step 11: Simplify the goal by computation", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:transl_find_label", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f tf lbl c, transf_function f = OK tf -> Linear Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Simplify the goal by computation Step 5: Unfold a definition Step 6: Unfold a definition Step 7: Rewrite using an equality Step 8: Rewrite using an equality Step 9: Rewrite using an equality Step 10: The goal is true by reflexivity Step 11: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:find_label_tail", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall lbl c c', Linear Step 2: Proceed by induction on c Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: discriminate Step 6: Apply tactic: intro c' Step 7: Apply tactic: case (Linear Step 8: Apply tactic: is_label lbl a) Step 9: Introduce variables and assumptions Step 10: Apply tactic: injection H Step 11: Apply tactic: intro", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:is_tail_save_callee_save", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall l ofs k, is_tail k (save_callee_save_rec l ofs k) Step 2: Proceed by induction on l Step 3: Introduce variables and assumptions Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Apply tactic: constructor Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:is_tail_restore_callee_save", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall l ofs k, is_tail k (restore_callee_save_rec l ofs k) Step 2: Proceed by induction on l Step 3: Introduce variables and assumptions Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Apply tactic: constructor Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:is_tail_transl_instr", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall fe i k, is_tail k (transl_instr fe i k) Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Unfold a definition Step 5: Solve automatically using known facts Step 6: Case analysis by destructing a value Step 7: Solve automatically using known facts Step 8: Case analysis by destructing a value Step 9: Solve automatically using known facts Step 10: Unfold a definition Step 11: Apply tactic: eapply is_tail_trans", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:is_tail_transl_code", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall fe c1 c2, is_tail c1 c2 -> is_tail (transl_code fe c1) (transl_code fe c2) Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Rewrite using an equality Step 6: Apply tactic: eapply is_tail_trans Step 7: Apply tactic: eauto Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:is_tail_transf_function", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f tf c, transf_function f = OK tf -> is_tail c (Linear Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Simplify the goal by computation Step 5: Unfold a definition Step 6: Apply tactic: eapply is_tail_trans Step 7: Apply tactic: 2: apply is_tail_save_callee_save Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:symbols_preserved", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall (s: ident), Genv Step 2: Apply tactic: Lemma senv_preserved: Step 3: Apply tactic: Senv Step 4: Apply tactic: equiv ge tge Step 5: Apply tactic: Lemma functions_translated: Step 6: Apply tactic: forall v f, Step 7: Apply tactic: Genv Step 8: Apply tactic: find_funct ge v = Some f -> Step 9: Provide an existential witness Step 10: Apply tactic: Genv Step 11: Apply tactic: find_funct tge v = Some tf /\\ transf_fundef f = OK", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:senv_preserved", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that Senv Step 2: Apply tactic: Lemma functions_translated: Step 3: Apply tactic: forall v f, Step 4: Apply tactic: Genv Step 5: Apply tactic: find_funct ge v = Some f -> Step 6: Provide an existential witness Step 7: Apply tactic: Genv Step 8: Apply tactic: find_funct tge v = Some tf /\\ transf_fundef f = OK Step 9: Apply tactic: Lemma function_ptr_translated: Step 10: Apply tactic: forall b f, Step 11: Apply tactic: Genv", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:functions_translated", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v f, Genv Step 2: Apply tactic: Lemma function_ptr_translated: Step 3: Apply tactic: forall b f, Step 4: Apply tactic: Genv Step 5: Apply tactic: find_funct_ptr ge b = Some f -> Step 6: Provide an existential witness Step 7: Apply tactic: Genv Step 8: Apply tactic: find_funct_ptr tge b = Some tf /\\ transf_fundef f Step 9: Apply tactic: Lemma sig_preserved: Step 10: Apply tactic: forall f tf, transf_fundef f = OK tf -> Mach Step 11: Apply tactic: funsig tf = Linear", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:function_ptr_translated", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall b f, Genv Step 2: Apply tactic: Lemma sig_preserved: Step 3: Apply tactic: forall f tf, transf_fundef f = OK tf -> Mach Step 4: Apply tactic: funsig tf = Linear Step 5: Apply tactic: funsig f Step 6: Introduce variables and assumptions Step 7: Unfold a definition Step 8: Case analysis by destructing a value Step 9: Introduce variables and assumptions Step 10: Apply tactic: monadInv H Step 11: Rewrite using an equality", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:sig_preserved", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f tf, transf_fundef f = OK tf -> Mach Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Introduce variables and assumptions Step 6: Apply tactic: monadInv H Step 7: Rewrite using an equality Step 8: Solve automatically using known facts Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:find_function_translated", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall j ls rs m ros f, agree_regs j ls rs -> m |= globalenv_inject ge j -> Linear Step 2: Introduce variables and assumptions Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: - exploit Genv Step 7: Apply tactic: find_funct_inv Step 8: Apply tactic: eauto Step 9: Introduce variables and assumptions Step 10: Rewrite using an equality Step 11: Rewrite using an equality", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:transl_external_argument", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall l, In l (regs_of_rpairs (loc_arguments sg)) -> exists v, extcall_arg rs m' (parent_sp cs') l v /\\ Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (loc_argument_acceptable l) by (apply loc_a Step 4: Solve automatically using known facts Step 5: Case analysis by destructing a value Step 6: Apply tactic: red in H0 Step 7: Apply tactic: - exists (rs r) Step 8: Split a conjunction into separate goals Step 9: Apply tactic: constructor Step 10: Solve automatically using known facts Step 11: Apply tactic: - destruct sl", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:transl_external_argument_2", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall p, In p (loc_arguments sg) -> exists v, extcall_arg_pair rs m' (parent_sp cs') p v /\\ Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: - destruct (transl_external_argument l) as (v & A Step 5: Apply tactic: eapply in_regs_of_rpairs Step 6: Apply tactic: eauto Step 7: Simplify the goal by computation Step 8: Solve automatically using known facts Step 9: Provide an existential witness Step 10: Split a conjunction into separate goals Step 11: Solve automatically using known facts", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:transl_external_arguments_rec", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall locs, incl locs (loc_arguments sg) -> exists vl, list_forall2 (extcall_arg_pair rs m' (parent_sp cs')) locs vl /\\ Val Step 2: Proceed by induction on locs Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Provide an existential witness Step 6: Split a conjunction into separate goals Step 7: Apply tactic: constructor Step 8: Apply tactic: constructor Step 9: Apply tactic: exploit transl_external_argument_2 Step 10: Apply tactic: eauto with coqlib Step 11: Introduce variables and assumptions", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:transl_external_arguments", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that exists vl, extcall_arguments rs m' (parent_sp cs') sg vl /\\ Val Step 2: Unfold a definition Step 3: Apply a theorem or hypothesis Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:transf_step_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: Lgetstack Step 2: Lgetstack, local Step 3: internal function Step 4: external function Step 5: Lgetstack, incoming Step 6: Lgetstack, outgoing Step 7: Lsetstack Step 8: Ltailcall Step 9: Lbuiltin Step 10: Lcond, true Step 11: Lcond, false Step 12: Ljumptable Step 13: We need to prove that forall s1 t s2, Linear Step 14: Proceed by induction on 1 Step 15: Introduce variables and assumptions Step 16: Apply tactic: try inv MS Step 17: Apply tactic: try rewrite transl_code_eq Step 18: Apply tactic: try (generalize (function_is_within_bounds f _ (is Step 19: Apply tactic: intro BOUND Step 20: Simplify the goal by computation Step 21: Unfold a definition Step 22: Case analysis by destructing a value Step 23: Apply tactic: exploit wt_state_getstack", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:transf_initial_states", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall st1, Linear Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: exploit function_ptr_translated Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Apply tactic: econstructor Step 8: Split a conjunction into separate goals Step 9: Apply tactic: econstructor Step 10: Apply tactic: eapply (Genv Step 11: Apply tactic: init_mem_transf_partial TRANSF)", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:transf_final_states", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall st1 st2 r, match_states st1 st2 -> Linear Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Apply tactic: inv H Step 5: Apply tactic: inv STACKS Step 6: Apply tactic: assert (R: exists r, loc_result signature_main = O Step 7: Apply tactic: { destruct (loc_result signature_main) as [r1 | r1 Step 8: Apply tactic: - exists r1 Step 9: Solve automatically using known facts Step 10: Apply tactic: - generalize (loc_result_type signature_main) Step 11: Rewrite using an equality", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:wt_prog", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall i fd, In (i, Gfun fd) prog Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit list_forall2_in_left Step 4: Apply tactic: eexact (proj1 TRANSF) Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Simplify the goal by computation Step 8: Apply tactic: inv R Step 9: Case analysis by destructing a value Step 10: Simplify the goal by computation Step 11: Apply tactic: - monadInv H2", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Stackingproof:transf_program_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forward_simulation (Linear Step 2: Apply tactic: set (ms := fun s s' => wt_state s /\\ match_states Step 3: Apply tactic: eapply forward_simulation_plus with (match_states Step 4: Apply tactic: - apply senv_preserved Step 5: Apply tactic: - intros Step 6: Apply tactic: exploit transf_initial_states Step 7: Apply tactic: eauto Step 8: Introduce variables and assumptions Step 9: Provide an existential witness Step 10: Split a conjunction into separate goals Step 11: Solve automatically using known facts", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Linear:is_label_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall lbl instr, if is_label lbl instr then instr = Llabel lbl else instr <> Llabel lbl Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: try discriminate Step 6: Apply tactic: case (peq lbl l) Step 7: Apply tactic: intro Step 8: Apply tactic: congruence Step 9: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocation:index_inj", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y, index x = index y -> x = y", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocation:eq_refl", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x : t, eq x x Step 2: We need to prove that forall x : t, eq x x Step 3: We need to prove that forall x, eq x x Step 4: Apply tactic: Lemma eq_sym : forall x y : t, eq x y -> eq y x Step 5: Apply tactic: Lemma eq_sym : forall x y : t, eq x y -> eq y x Step 6: Introduce variables and assumptions Step 7: Apply tactic: Lemma eq_trans : forall x y z : t, eq x y -> eq y Step 8: Apply tactic: Lemma eq_trans : forall x y z : t, eq x y -> eq y Step 9: Case analysis by destructing a value Step 10: Apply tactic: Lemma lt_trans : forall x y z : t, lt x y -> lt y Step 11: Apply tactic: Lemma lt_trans : forall x y z : t, lt x y -> lt y Step 12: Simplify the goal by computation Step 13: Unfold a definition Step 14: Unfold a definition Step 15: Solve automatically using known facts Step 16: Introduce variables and assumptions Step 17: Introduce variables and assumptions Step 18: Apply tactic: red Step 19: Case analysis by destructing a value Step 20: Case analysis by destructing a value Step 21: Apply tactic: tauto Step 22: Case analysis by destructing a value Step 23: Case analysis by destructing a value Step 24: Apply tactic: Qed Step 25: Apply tactic: left Step 26: Apply tactic: left Step 27: Apply tactic: eapply Plt_trans Step 28: Apply tactic: eapply OrderedLoc Step 29: Apply tactic: eauto Step 30: Apply tactic: lt_trans", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocation:eq_sym", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y : t, eq x y -> eq y x Step 2: We need to prove that forall x y : t, eq x y -> eq y x Step 3: We need to prove that forall x y, eq x y -> eq y x Step 4: Apply tactic: Lemma eq_trans : forall x y z : t, eq x y -> eq y Step 5: Apply tactic: Lemma eq_trans : forall x y z : t, eq x y -> eq y Step 6: Unfold a definition Step 7: Apply tactic: Lemma lt_trans : forall x y z : t, lt x y -> lt y Step 8: Apply tactic: Lemma lt_trans : forall x y z : t, lt x y -> lt y Step 9: Introduce variables and assumptions Step 10: Unfold a definition Step 11: Unfold a definition Step 12: Case analysis by destructing a value Step 13: Introduce variables and assumptions Step 14: Introduce variables and assumptions Step 15: Case analysis by destructing a value Step 16: Case analysis by destructing a value Step 17: Case analysis by destructing a value Step 18: Solve automatically using known facts Step 19: Case analysis by destructing a value Step 20: Case analysis by destructing a value Step 21: Apply tactic: red in H Step 22: Apply tactic: left Step 23: Apply tactic: left Step 24: Apply tactic: red Step 25: Apply tactic: eapply Plt_trans Step 26: Apply tactic: eapply OrderedLoc Step 27: Introduce variables and assumptions Step 28: Apply tactic: eauto Step 29: Apply tactic: lt_trans Step 30: Rewrite using an equality Step 31: Case analysis by destructing a value Step 32: Apply tactic: eauto Step 33: Apply tactic: tauto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocation:eq_trans", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y z : t, eq x y -> eq y z -> eq x z Step 2: We need to prove that forall x y z : t, eq x y -> eq y z -> eq x z Step 3: We need to prove that forall x y z, eq x y -> eq y z -> eq x z Step 4: Apply tactic: Lemma lt_trans : forall x y z : t, lt x y -> lt y Step 5: Apply tactic: Lemma lt_trans : forall x y z : t, lt x y -> lt y Step 6: Unfold a definition Step 7: Unfold a definition Step 8: Unfold a definition Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Introduce variables and assumptions Step 12: Case analysis by destructing a value Step 13: Case analysis by destructing a value Step 14: Case analysis by destructing a value Step 15: Case analysis by destructing a value Step 16: Case analysis by destructing a value Step 17: Case analysis by destructing a value Step 18: Apply tactic: try contradiction Step 19: Apply tactic: left Step 20: Apply tactic: left Step 21: Case analysis by destructing a value Step 22: Apply tactic: eapply Plt_trans Step 23: Apply tactic: eapply OrderedLoc Step 24: Solve automatically using known facts Step 25: Apply tactic: eauto Step 26: Apply tactic: lt_trans Step 27: Apply tactic: red in H Step 28: Case analysis by destructing a value Step 29: Apply tactic: eauto Step 30: Apply tactic: red in H0 Step 31: Rewrite using an equality Step 32: Case analysis by destructing a value Step 33: Apply tactic: red", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocation:lt_trans", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y z : t, lt x y -> lt y z -> lt x z Step 2: We need to prove that forall x y z : t, lt x y -> lt y z -> lt x z Step 3: Unfold a definition Step 4: Unfold a definition Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Case analysis by destructing a value Step 8: Case analysis by destructing a value Step 9: Case analysis by destructing a value Step 10: Case analysis by destructing a value Step 11: Apply tactic: left Step 12: Apply tactic: left Step 13: Apply tactic: eapply Plt_trans Step 14: Apply tactic: eapply OrderedLoc Step 15: Apply tactic: eauto Step 16: Apply tactic: lt_trans Step 17: Case analysis by destructing a value Step 18: Apply tactic: eauto Step 19: Rewrite using an equality Step 20: Case analysis by destructing a value Step 21: Solve automatically using known facts Step 22: Rewrite using an equality", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocation:lt_not_eq", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y : t, lt x y -> ~ eq x y Step 2: We need to prove that forall x y : t, lt x y -> ~ eq x y Step 3: Unfold a definition Step 4: Unfold a definition Step 5: Introduce variables and assumptions Step 6: Introduce variables and assumptions Step 7: Apply tactic: red Step 8: Apply tactic: red Step 9: Introduce variables and assumptions Step 10: Introduce variables and assumptions Step 11: Apply tactic: subst y Step 12: Apply tactic: subst y Step 13: Apply tactic: intuition Step 14: Apply tactic: intuition Step 15: Apply tactic: eelim Plt_strict Step 16: Apply tactic: eelim OrderedLoc Step 17: Apply tactic: eauto Step 18: Apply tactic: lt_not_eq Step 19: Apply tactic: eelim OrderedLoc Step 20: Apply tactic: eauto Step 21: Apply tactic: lt_not_eq Step 22: Apply tactic: red", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocation:beq_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y, beq x y = true -> eq x y Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Case analysis by destructing a value Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: equal_2 Step 8: Solve automatically using known facts Step 9: Apply tactic: discriminate Step 10: Apply tactic: discriminate Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocation:ge_refl", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y, eq x y -> ge x y Step 2: Unfold a definition Step 3: Apply tactic: Equal, EqSet Step 4: Apply tactic: Subset Step 5: Introduce variables and assumptions Step 6: Case analysis by destructing a value Step 7: Case analysis by destructing a value Step 8: Solve automatically using known facts Step 9: Introduce variables and assumptions Step 10: Rewrite using an equality Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocation:ge_trans", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y z, ge x y -> ge y z -> ge x z Step 2: Unfold a definition Step 3: Apply tactic: Subset Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Solve automatically using known facts Step 7: Case analysis by destructing a value Step 8: Apply tactic: try contradiction Step 9: Case analysis by destructing a value Step 10: Apply tactic: eauto Step 11: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocation:ge_bot", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x, ge x bot Step 2: Unfold a definition Step 3: Apply tactic: Subset Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Case analysis by destructing a value Step 7: Solve automatically using known facts Step 8: Introduce variables and assumptions Step 9: Apply tactic: elim (EqSet Step 10: Apply tactic: empty_1 H) Step 11: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocation:ge_lub_left", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y, ge (lub x y) x Step 2: Unfold a definition Step 3: Apply tactic: Subset Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Case analysis by destructing a value Step 7: Solve automatically using known facts Step 8: Introduce variables and assumptions Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: union_2 Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocation:ge_lub_right", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y, ge (lub x y) y Step 2: Unfold a definition Step 3: Apply tactic: Subset Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Case analysis by destructing a value Step 7: Solve automatically using known facts Step 8: Introduce variables and assumptions Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: union_3 Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CleanupLabelsproof:transf_program_match", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall p, match_prog p (transf_program p) Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply match_transform_program Step 4: Apply tactic: eauto Step 5: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CleanupLabelsproof:symbols_preserved", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall id, Genv Step 2: Apply tactic: Lemma senv_preserved: Step 3: Apply tactic: Senv Step 4: Apply tactic: equiv ge tge Step 5: Apply tactic: Lemma functions_translated: Step 6: Apply tactic: forall v f, Step 7: Apply tactic: Genv Step 8: Apply tactic: find_funct ge v = Some f -> Step 9: Apply tactic: Genv Step 10: Apply tactic: find_funct tge v = Some (transf_fundef f) Step 11: Apply tactic: Lemma function_ptr_translated:", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CleanupLabelsproof:senv_preserved", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that Senv Step 2: Apply tactic: Lemma functions_translated: Step 3: Apply tactic: forall v f, Step 4: Apply tactic: Genv Step 5: Apply tactic: find_funct ge v = Some f -> Step 6: Apply tactic: Genv Step 7: Apply tactic: find_funct tge v = Some (transf_fundef f) Step 8: Apply tactic: Lemma function_ptr_translated: Step 9: Apply tactic: forall v f, Step 10: Apply tactic: Genv Step 11: Apply tactic: find_funct_ptr ge v = Some f ->", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CleanupLabelsproof:functions_translated", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v f, Genv Step 2: Apply tactic: Lemma function_ptr_translated: Step 3: Apply tactic: forall v f, Step 4: Apply tactic: Genv Step 5: Apply tactic: find_funct_ptr ge v = Some f -> Step 6: Apply tactic: Genv Step 7: Apply tactic: find_funct_ptr tge v = Some (transf_fundef f) Step 8: Apply tactic: Lemma sig_function_translated: Step 9: Apply tactic: forall f, Step 10: Apply tactic: funsig (transf_fundef f) = funsig f Step 11: Introduce variables and assumptions", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CleanupLabelsproof:function_ptr_translated", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v f, Genv Step 2: Apply tactic: Lemma sig_function_translated: Step 3: Apply tactic: forall f, Step 4: Apply tactic: funsig (transf_fundef f) = funsig f Step 5: Introduce variables and assumptions Step 6: Case analysis by destructing a value Step 7: The goal is true by reflexivity Step 8: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CleanupLabelsproof:sig_function_translated", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f, funsig (transf_fundef f) = funsig f Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: The goal is true by reflexivity Step 5: Apply tactic: Qed", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CleanupLabelsproof:find_function_translated", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ros ls f, find_function ge ros ls = Some f -> find_function tge ros ls = Some (transf_fundef f) Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Rewrite using an equality Step 9: Case analysis by destructing a value Step 10: Apply tactic: find_symbol ge i) Step 11: Apply a theorem or hypothesis", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CleanupLabelsproof:add_label_branched_to_incr", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ls i, Labelset Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Simplify the goal by computation Step 7: Solve automatically using known facts Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: add_2 Step 10: Solve automatically using known facts Step 11: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CleanupLabelsproof:add_label_branched_to_contains", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ls i lbl, instr_branches_to i lbl -> Labelset Step 2: Case analysis by destructing a value Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: try contradiction Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: add_1 Step 8: Solve automatically using known facts Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: add_1 Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CleanupLabelsproof:labels_branched_to_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall c i lbl, In i c -> instr_branches_to i lbl -> Labelset Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (forall c' bto, Step 4: Apply tactic: Labelset Step 5: Apply tactic: Subset bto (fold_left add_label_branched_to c' bto Step 6: Proceed by induction on c' Step 7: Introduce variables and assumptions Step 8: Simplify the goal by computation Step 9: Apply tactic: red Step 10: Introduce variables and assumptions Step 11: Solve automatically using known facts", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CleanupLabelsproof:remove_unused_labels_cons", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall bto i c, remove_unused_labels bto (i :: c) = match i with | Llabel lbl => if Labelset Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Rewrite using an equality Step 5: Solve automatically using known facts Step 6: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CleanupLabelsproof:find_label_commut", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall lbl bto, Labelset Step 2: Proceed by induction on c Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: congruence Step 6: Rewrite using an equality Step 7: Unfold a definition Step 8: Case analysis by destructing a value Step 9: Simplify the goal by computation Step 10: Solve automatically using known facts Step 11: Case analysis by destructing a value", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CleanupLabelsproof:find_label_translated", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f i c' lbl c, incl (i :: c') (fn_code f) -> find_label lbl (fn_code f) = Some c -> instr_branches_to i lbl -> find_label lbl (fn_code (transf_function f)) = Some (remove_unused_labels (labels_branched_to (fn_code f)) c) Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Unfold a definition Step 5: Simplify the goal by computation Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: eapply labels_branched_to_correct Step 8: Apply tactic: eauto Step 9: Apply a theorem or hypothesis Step 10: Solve automatically using known facts Step 11: Solve automatically using known facts", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CleanupLabelsproof:find_label_incl", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall lbl c c', find_label lbl c = Some c' -> incl c' c Step 2: Proceed by induction on c Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: discriminate Step 6: Case analysis by destructing a value Step 7: Apply tactic: inv H Step 8: Solve automatically using known facts Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CleanupLabelsproof:match_parent_locset", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall s ts, list_forall2 match_stackframes s ts -> parent_locset ts = parent_locset s Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Apply tactic: inv H Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CleanupLabelsproof:transf_step_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: Lgetstack Step 2: Lsetstack Step 3: external function Step 4: Ltailcall Step 5: Lbuiltin Step 6: not eliminated Step 7: eliminated Step 8: Lcond taken Step 9: Lcond not taken Step 10: Ljumptable Step 11: internal function Step 12: We need to prove that forall s1 t s2, step ge s1 t s2 -> forall s1' (MS: match_states s1 s1'), (exists s2', step tge s1' t s2' /\\ match_states s2 s2') \\/ (measure s2 < measure s1 /\\ t = E0 /\\ match_states s2 s1')%nat Step 13: Proceed by induction on 1 Step 14: Introduce variables and assumptions Step 15: Apply tactic: inv MS Step 16: Apply tactic: try rewrite remove_unused_labels_cons Step 17: Apply tactic: left Step 18: Apply tactic: econstructor Step 19: Split a conjunction into separate goals Step 20: Apply tactic: econstructor Step 21: Apply tactic: eauto Step 22: Apply tactic: econstructor", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CleanupLabelsproof:transf_initial_states", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall st1, initial_state prog st1 -> exists st2, initial_state tprog st2 /\\ match_states st1 st2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: econstructor Step 5: Split a conjunction into separate goals Step 6: Apply tactic: eapply initial_state_intro with (f := transf_funde Step 7: Apply tactic: eapply (Genv Step 8: Apply tactic: init_mem_transf TRANSL) Step 9: Apply tactic: eauto Step 10: Rewrite using an equality Step 11: Apply tactic: eauto", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CleanupLabelsproof:transf_final_states", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall st1 st2 r, match_states st1 st2 -> final_state st1 r -> final_state st2 r Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Apply tactic: inv H Step 5: Apply tactic: inv H5 Step 6: Apply tactic: econstructor Step 7: Apply tactic: eauto Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CleanupLabelsproof:transf_program_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forward_simulation (Linear Step 2: Apply tactic: eapply forward_simulation_opt Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: eexact transf_initial_states Step 5: Apply tactic: eexact transf_final_states Step 6: Apply tactic: eexact transf_step_correct Step 7: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:vagree_same", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v x, vagree v v x Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Case analysis by destructing a value Step 7: Solve automatically using known facts Step 8: Apply tactic: red Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:vagree_lessdef", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x, Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply a theorem or hypothesis Step 5: Case analysis by destructing a value Step 6: Simplify the goal by computation Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:lessdef_vagree", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w, vagree v w All -> Val Step 2: Introduce variables and assumptions Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:lessdef_vagree_list", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall vl1 vl2, vagree_list vl1 vl2 nil -> Val Step 2: Proceed by induction on vl1 Step 3: Introduce variables and assumptions Step 4: Apply tactic: inv H Step 5: Apply tactic: constructor Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:vagree_lessdef_list", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall vl1 vl2, Val Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Apply tactic: constructor Step 5: Case analysis by destructing a value Step 6: Apply tactic: constructor Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:nge_refl", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x, nge x x Step 2: Case analysis by destructing a value Step 3: Apply tactic: constructor Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:nge_trans", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y, nge x y -> forall z, nge y z -> nge x z Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Apply tactic: inv VG Step 5: Apply tactic: eauto with na Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:nge_agree", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x y, nge x y -> vagree v w x -> vagree v w y Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Apply tactic: - destruct v Step 6: Solve automatically using known facts Step 7: Apply tactic: - destruct v, w Step 8: Apply tactic: intuition Step 9: Apply tactic: red Step 10: Solve automatically using known facts Step 11: Apply tactic: - destruct v, w", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:nge_lub_l", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y, nge (nlub x y) x Step 2: Unfold a definition Step 3: Case analysis by destructing a value Step 4: Solve automatically using known facts Step 5: Apply tactic: all: constructor Step 6: Introduce variables and assumptions Step 7: Solve automatically using known facts Step 8: Solve automatically using known facts Step 9: Apply tactic: all: rewrite H0 Step 10: Solve automatically using known facts Step 11: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:nge_lub_r", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y, nge (nlub x y) y Step 2: Unfold a definition Step 3: Case analysis by destructing a value Step 4: Solve automatically using known facts Step 5: Apply tactic: all: constructor Step 6: Introduce variables and assumptions Step 7: Solve automatically using known facts Step 8: Solve automatically using known facts Step 9: Apply tactic: all: rewrite H0 Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:iagree_refl", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall p m, iagree p p m Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:eq_same_bits", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall i x y, x = y -> Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: congruence Step 4: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:iagree_and_eq", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y mask, iagree x y mask <-> Int Step 2: Introduce variables and assumptions Step 3: Split a conjunction into separate goals Step 4: Introduce variables and assumptions Step 5: Apply tactic: - Int Step 6: Apply tactic: bit_solve Step 7: Apply tactic: specialize (H i H0) Step 8: Case analysis by destructing a value Step 9: Apply tactic: testbit mask i) Step 10: Rewrite using an equality Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:iagree_mone", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall p q, iagree p q Int Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Rewrite using an equality Step 5: Apply tactic: and_mone in H Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:iagree_zero", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall p q, iagree p q Int Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Rewrite using an equality Step 5: Apply tactic: and_zero Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:iagree_and", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y n m, iagree x y (Int Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Rewrite using an equality Step 5: Apply tactic: and_assoc Step 6: Rewrite using an equality Step 7: Apply tactic: and_commut n) Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:iagree_not", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y m, iagree x y m -> iagree (Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Solve automatically using known facts Step 7: Apply tactic: f_equal Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:iagree_or", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y n m, iagree x y (Int Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Rewrite using an equality Step 5: Apply tactic: not_or_and_not Step 6: Apply a theorem or hypothesis Step 7: Apply a theorem or hypothesis Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:iagree_bitwise_binop", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall sem f, (forall x y i, 0 <= i < Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: f_equal Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:iagree_shl", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y m n, iagree x y (Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Solve automatically using known facts Step 7: Case analysis by destructing a value Step 8: Apply tactic: unsigned n)) Step 9: Apply tactic: - auto Step 10: Apply tactic: - generalize (Int Step 11: Apply tactic: unsigned_range n)", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:iagree_shru", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y m n, iagree x y (Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Solve automatically using known facts Step 7: Case analysis by destructing a value Step 8: Apply tactic: unsigned n) Int Step 9: Apply tactic: zwordsize) Step 10: Apply tactic: - generalize (Int Step 11: Apply tactic: unsigned_range n)", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:iagree_shr_1", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y m n, Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Rewrite using an equality Step 7: Apply tactic: bits_shru in H2 by auto Step 8: Rewrite using an equality Step 9: Apply tactic: bits_shr by auto Step 10: Case analysis by destructing a value Step 11: Apply tactic: unsigned n) Int", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:iagree_shr", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y m n, iagree x y (Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: bits_shr by auto Step 7: Apply tactic: generalize (Int Step 8: Apply tactic: unsigned_range n) Step 9: Introduce variables and assumptions Step 10: Apply tactic: set (j := if zlt (i + Int Step 11: Apply tactic: unsigned n) Int", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:iagree_rol", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall p q m amount, iagree p q (Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (Int Step 4: Apply tactic: zwordsize > 0) by (compute Step 5: Solve automatically using known facts Step 6: Apply tactic: red Step 7: Introduce variables and assumptions Step 8: Rewrite using an equality Step 9: Apply tactic: bits_rol by auto Step 10: Apply a theorem or hypothesis Step 11: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:iagree_ror", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall p q m amount, iagree p q (Int Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Apply tactic: ror_rol_neg by apply int_wordsize_divides_modulus Step 5: Apply a theorem or hypothesis Step 6: Rewrite using an equality Step 7: Apply tactic: ror_rol_neg by apply int_wordsize_divides_modulus Step 8: Rewrite using an equality Step 9: Apply tactic: neg_involutive Step 10: Solve automatically using known facts Step 11: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:eqmod_iagree", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall m x y, eqmod (two_p (Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: set (p := Z Step 4: Apply tactic: to_nat (Int Step 5: Apply tactic: size m)) Step 6: Apply tactic: generalize (Int Step 7: Apply tactic: size_range m) Step 8: Introduce variables and assumptions Step 9: Apply tactic: assert (EQ: Int Step 10: Apply tactic: size m = Z Step 11: Apply tactic: of_nat p)", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:iagree_eqmod", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y m, iagree x y (complete_mask m) -> eqmod (two_p (Int Step 2: Introduce variables and assumptions Step 3: Apply tactic: set (p := Z Step 4: Apply tactic: to_nat (Int Step 5: Apply tactic: size m)) Step 6: Apply tactic: generalize (Int Step 7: Apply tactic: size_range m) Step 8: Introduce variables and assumptions Step 9: Apply tactic: assert (EQ: Int Step 10: Apply tactic: size m = Z Step 11: Apply tactic: of_nat p)", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:complete_mask_idem", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall m, complete_mask (complete_mask m) = complete_mask m Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: eq_dec m Int Step 6: Apply tactic: zero) Step 7: Apply tactic: + subst m Step 8: The goal is true by reflexivity Step 9: Apply tactic: + assert (Int Step 10: Apply tactic: unsigned m <> 0) Step 11: Apply tactic: { red", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:lagree_refl", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall p m, lagree p p m Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:eq_same_bits64", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall i x y, x = y -> Int64 Step 2: Introduce variables and assumptions Step 3: Apply tactic: congruence Step 4: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:lagree_and_eq", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y mask, lagree x y mask <-> Int64 Step 2: Introduce variables and assumptions Step 3: Split a conjunction into separate goals Step 4: Introduce variables and assumptions Step 5: Apply tactic: - Int64 Step 6: Apply tactic: bit_solve Step 7: Apply tactic: specialize (H i H0) Step 8: Case analysis by destructing a value Step 9: Apply tactic: testbit mask i) Step 10: Rewrite using an equality Step 11: Solve automatically using known facts", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:lagree_mone", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall p q, lagree p q Int64 Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Rewrite using an equality Step 5: Apply tactic: and_mone in H Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:lagree_zero", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall p q, lagree p q Int64 Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Rewrite using an equality Step 5: Apply tactic: and_zero Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:lagree_and", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y n m, lagree x y (Int64 Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Rewrite using an equality Step 5: Apply tactic: and_assoc Step 6: Rewrite using an equality Step 7: Apply tactic: and_commut n) Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:lagree_not", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y m, lagree x y m -> lagree (Int64 Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Solve automatically using known facts Step 7: Apply tactic: f_equal Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:lagree_or", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y n m, lagree x y (Int64 Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Rewrite using an equality Step 5: Apply tactic: not_or_and_not Step 6: Apply a theorem or hypothesis Step 7: Apply a theorem or hypothesis Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:lagree_bitwise_binop", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall sem f, (forall x y i, 0 <= i < Int64 Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: f_equal Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:lagree_shl", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y m n, lagree x y (Int64 Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: bits_shl' Step 7: Solve automatically using known facts Step 8: Case analysis by destructing a value Step 9: Apply tactic: unsigned n)) Step 10: Apply tactic: - auto Step 11: Apply tactic: - generalize (Int", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:lagree_shru", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y m n, lagree x y (Int64 Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: bits_shru' Step 7: Solve automatically using known facts Step 8: Case analysis by destructing a value Step 9: Apply tactic: unsigned n) Int64 Step 10: Apply tactic: zwordsize) Step 11: Apply tactic: - generalize (Int", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:lagree_shr_1", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y m n, Int64 Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Rewrite using an equality Step 7: Apply tactic: bits_shru' in H2 by auto Step 8: Rewrite using an equality Step 9: Apply tactic: bits_shr' by auto Step 10: Case analysis by destructing a value Step 11: Apply tactic: unsigned n) Int64", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:lagree_shr", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y m n, lagree x y (Int64 Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: bits_shr' by auto Step 7: Apply tactic: generalize (Int Step 8: Apply tactic: unsigned_range n) Step 9: Introduce variables and assumptions Step 10: Apply tactic: set (j := if zlt (i + Int Step 11: Apply tactic: unsigned n) Int64", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:lagree_rol", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall p q m amount, lagree p q (Int64 Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (Int64 Step 4: Apply tactic: zwordsize > 0) by (compute Step 5: Solve automatically using known facts Step 6: Apply tactic: red Step 7: Introduce variables and assumptions Step 8: Rewrite using an equality Step 9: Apply tactic: bits_rol by auto Step 10: Apply a theorem or hypothesis Step 11: Apply a theorem or hypothesis", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:lagree_ror", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall p q m amount, lagree p q (Int64 Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (Z Step 4: Apply tactic: divide (Z Step 5: Apply tactic: of_nat Int64 Step 6: Apply tactic: wordsize) Int64 Step 7: Apply tactic: modulus) by (exists (two_p (64-6)) Step 8: The goal is true by reflexivity Step 9: Unfold a definition Step 10: Apply tactic: ror' Step 11: Rewrite using an equality", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:eqmod_lagree", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall m x y, eqmod (two_p (Int64 Step 2: Introduce variables and assumptions Step 3: Apply tactic: set (p := Z Step 4: Apply tactic: to_nat (Int64 Step 5: Apply tactic: size m)) Step 6: Apply tactic: generalize (Int64 Step 7: Apply tactic: size_range m) Step 8: Introduce variables and assumptions Step 9: Apply tactic: assert (EQ: Int64 Step 10: Apply tactic: size m = Z Step 11: Apply tactic: of_nat p)", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:lagree_eqmod", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y m, lagree x y (complete_mask64 m) -> eqmod (two_p (Int64 Step 2: Introduce variables and assumptions Step 3: Apply tactic: set (p := Z Step 4: Apply tactic: to_nat (Int64 Step 5: Apply tactic: size m)) Step 6: Apply tactic: generalize (Int64 Step 7: Apply tactic: size_range m) Step 8: Introduce variables and assumptions Step 9: Apply tactic: assert (EQ: Int64 Step 10: Apply tactic: size m = Z Step 11: Apply tactic: of_nat p)", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:complete_mask64_idem", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall m, complete_mask64 (complete_mask64 m) = complete_mask64 m Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: eq_dec m Int64 Step 6: Apply tactic: zero) Step 7: Apply tactic: + subst m Step 8: The goal is true by reflexivity Step 9: Apply tactic: + assert (Int64 Step 10: Apply tactic: unsigned m <> 0) Step 11: Apply tactic: { red", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:andimm_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x n, vagree v w (andimm x n) -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Unfold a definition Step 7: Apply tactic: and Step 8: Apply tactic: - auto Step 9: Apply tactic: - InvAgree Step 10: Apply a theorem or hypothesis Step 11: Solve automatically using known facts", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:orimm_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x n, vagree v w (orimm x n) -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: - auto Step 7: Apply tactic: - unfold Val Step 8: Apply tactic: InvAgree Step 9: Apply a theorem or hypothesis Step 10: Solve automatically using known facts Step 11: Apply tactic: - InvAgree", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:andlimm_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x n, vagree v w (andlimm x n) -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Unfold a definition Step 7: Apply tactic: andl Step 8: Apply tactic: - auto Step 9: Apply tactic: - InvAgree Step 10: Apply tactic: - InvAgree Step 11: Apply a theorem or hypothesis", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:orlimm_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x n, vagree v w (orlimm x n) -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: - auto Step 7: Apply tactic: - InvAgree Step 8: Apply tactic: - InvAgree Step 9: Unfold a definition Step 10: Apply tactic: orl Step 11: Apply tactic: InvAgree", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:bitwise_idem", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall nv, bitwise (bitwise nv) = bitwise nv", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:vagree_bitwise_binop", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f, (forall p1 p2 q1 q2 m, iagree p1 q1 m -> iagree p2 q2 m -> iagree (f p1 p2) (f q1 q2) m) -> forall v1 w1 v2 w2 x, vagree v1 w1 (bitwise x) -> vagree v2 w2 (bitwise x) -> vagree (match v1, v2 with Vint i1, Vint i2 => Vint(f i1 i2) | _, _ => Vundef end) (match w1, w2 with Vint i1, Vint i2 => Vint(f i1 i2) | _, _ => Vundef end) x Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: - auto Step 7: Apply tactic: - InvAgree Step 8: Apply tactic: - InvAgree Step 9: Apply tactic: - inv H0 Step 10: Solve automatically using known facts Step 11: Apply tactic: inv H1", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:and_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v1 w1 v2 w2 x, vagree v1 w1 (bitwise x) -> vagree v2 w2 (bitwise x) -> vagree (Val Step 2: Apply tactic: Lemma or_sound: Step 3: Apply tactic: forall v1 w1 v2 w2 x, Step 4: Apply tactic: vagree v1 w1 (bitwise x) -> vagree v2 w2 (bitwise Step 5: Apply tactic: vagree (Val Step 6: Apply tactic: or v1 v2) (Val Step 7: Apply tactic: or w1 w2) x Step 8: Apply tactic: Lemma xor_sound: Step 9: Apply tactic: forall v1 w1 v2 w2 x, Step 10: Apply tactic: vagree v1 w1 (bitwise x) -> vagree v2 w2 (bitwise Step 11: Apply tactic: vagree (Val", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:or_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v1 w1 v2 w2 x, vagree v1 w1 (bitwise x) -> vagree v2 w2 (bitwise x) -> vagree (Val Step 2: Apply tactic: Lemma xor_sound: Step 3: Apply tactic: forall v1 w1 v2 w2 x, Step 4: Apply tactic: vagree v1 w1 (bitwise x) -> vagree v2 w2 (bitwise Step 5: Apply tactic: vagree (Val Step 6: Apply tactic: xor v1 v2) (Val Step 7: Apply tactic: xor w1 w2) x Step 8: Apply tactic: Lemma notint_sound: Step 9: Apply tactic: forall v w x, Step 10: Apply tactic: vagree v w (bitwise x) -> vagree (Val Step 11: Apply tactic: notint v) (Val", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:xor_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v1 w1 v2 w2 x, vagree v1 w1 (bitwise x) -> vagree v2 w2 (bitwise x) -> vagree (Val Step 2: Apply tactic: Lemma notint_sound: Step 3: Apply tactic: forall v w x, Step 4: Apply tactic: vagree v w (bitwise x) -> vagree (Val Step 5: Apply tactic: notint v) (Val Step 6: Apply tactic: notint w) x Step 7: Introduce variables and assumptions Step 8: Rewrite using an equality Step 9: Apply tactic: not_xor Step 10: Apply a theorem or hypothesis Step 11: Solve automatically using known facts", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:notint_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x, vagree v w (bitwise x) -> vagree (Val Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Apply tactic: not_xor Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:vagree_bitwise64_binop", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f, (forall p1 p2 q1 q2 m, lagree p1 q1 m -> lagree p2 q2 m -> lagree (f p1 p2) (f q1 q2) m) -> forall v1 w1 v2 w2 x, vagree v1 w1 (bitwise x) -> vagree v2 w2 (bitwise x) -> vagree (match v1, v2 with Vlong i1, Vlong i2 => Vlong(f i1 i2) | _, _ => Vundef end) (match w1, w2 with Vlong i1, Vlong i2 => Vlong(f i1 i2) | _, _ => Vundef end) x Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: - auto Step 7: Apply tactic: - InvAgree Step 8: Apply tactic: - InvAgree Step 9: Apply tactic: - inv H0 Step 10: Solve automatically using known facts Step 11: Apply tactic: inv H1", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:andl_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v1 w1 v2 w2 x, vagree v1 w1 (bitwise x) -> vagree v2 w2 (bitwise x) -> vagree (Val Step 2: Apply tactic: Lemma orl_sound: Step 3: Apply tactic: forall v1 w1 v2 w2 x, Step 4: Apply tactic: vagree v1 w1 (bitwise x) -> vagree v2 w2 (bitwise Step 5: Apply tactic: vagree (Val Step 6: Apply tactic: orl v1 v2) (Val Step 7: Apply tactic: orl w1 w2) x Step 8: Apply tactic: Lemma xorl_sound: Step 9: Apply tactic: forall v1 w1 v2 w2 x, Step 10: Apply tactic: vagree v1 w1 (bitwise x) -> vagree v2 w2 (bitwise Step 11: Apply tactic: vagree (Val", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:orl_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v1 w1 v2 w2 x, vagree v1 w1 (bitwise x) -> vagree v2 w2 (bitwise x) -> vagree (Val Step 2: Apply tactic: Lemma xorl_sound: Step 3: Apply tactic: forall v1 w1 v2 w2 x, Step 4: Apply tactic: vagree v1 w1 (bitwise x) -> vagree v2 w2 (bitwise Step 5: Apply tactic: vagree (Val Step 6: Apply tactic: xorl v1 v2) (Val Step 7: Apply tactic: xorl w1 w2) x Step 8: Apply tactic: Lemma notl_sound: Step 9: Apply tactic: forall v w x, Step 10: Apply tactic: vagree v w (bitwise x) -> vagree (Val Step 11: Apply tactic: notl v) (Val", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:xorl_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v1 w1 v2 w2 x, vagree v1 w1 (bitwise x) -> vagree v2 w2 (bitwise x) -> vagree (Val Step 2: Apply tactic: Lemma notl_sound: Step 3: Apply tactic: forall v w x, Step 4: Apply tactic: vagree v w (bitwise x) -> vagree (Val Step 5: Apply tactic: notl v) (Val Step 6: Apply tactic: notl w) x Step 7: Introduce variables and assumptions Step 8: Rewrite using an equality Step 9: Apply tactic: notl_xorl Step 10: Apply a theorem or hypothesis Step 11: Solve automatically using known facts", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:notl_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x, vagree v w (bitwise x) -> vagree (Val Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Apply tactic: notl_xorl Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:shlimm_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x n, vagree v w (shlimm x n) -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Apply tactic: shl Step 6: Case analysis by destructing a value Step 7: Apply tactic: ltu n Int Step 8: Apply tactic: iwordsize) Step 9: Case analysis by destructing a value Step 10: Simplify the goal by computation Step 11: Apply tactic: - auto", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:shruimm_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x n, vagree v w (shruimm x n) -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Apply tactic: shru Step 6: Case analysis by destructing a value Step 7: Apply tactic: ltu n Int Step 8: Apply tactic: iwordsize) Step 9: Case analysis by destructing a value Step 10: Simplify the goal by computation Step 11: Apply tactic: - auto", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:shrimm_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x n, vagree v w (shrimm x n) -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Apply tactic: shr Step 6: Case analysis by destructing a value Step 7: Apply tactic: ltu n Int Step 8: Apply tactic: iwordsize) Step 9: Case analysis by destructing a value Step 10: Simplify the goal by computation Step 11: Apply tactic: - auto", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:rol_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x n, vagree v w (rol x n) -> vagree (Val Step 2: Unfold a definition Step 3: Apply tactic: rol Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Simplify the goal by computation Step 7: Apply tactic: - auto Step 8: Apply tactic: - InvAgree Step 9: Apply a theorem or hypothesis Step 10: Solve automatically using known facts Step 11: Apply tactic: - destruct v", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:ror_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x n, vagree v w (ror x n) -> vagree (Val Step 2: Unfold a definition Step 3: Apply tactic: ror Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Simplify the goal by computation Step 7: Apply tactic: - auto Step 8: Apply tactic: - InvAgree Step 9: Apply a theorem or hypothesis Step 10: Solve automatically using known facts Step 11: Apply tactic: - destruct v", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:rolm_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x amount mask, vagree v w (rolm x amount mask) -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: assert (X: forall u, Val Step 5: Apply tactic: rolm u amount mask = Val Step 6: Apply tactic: and (Val Step 7: Apply tactic: rol u (Vint amount)) (Vint mask)) Step 8: Apply tactic: { destruct u Step 9: Solve automatically using known facts Step 10: Rewrite using an equality Step 11: Apply a theorem or hypothesis", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:shllimm_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x n, vagree v w (shllimm x n) -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Apply tactic: shll Step 6: Case analysis by destructing a value Step 7: Apply tactic: ltu n Int64 Step 8: Apply tactic: iwordsize') Step 9: Case analysis by destructing a value Step 10: Simplify the goal by computation Step 11: Apply tactic: - auto", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:shrluimm_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x n, vagree v w (shrluimm x n) -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Apply tactic: shrlu Step 6: Case analysis by destructing a value Step 7: Apply tactic: ltu n Int64 Step 8: Apply tactic: iwordsize') Step 9: Case analysis by destructing a value Step 10: Simplify the goal by computation Step 11: Apply tactic: - auto", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:shrlimm_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x n, vagree v w (shrlimm x n) -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Apply tactic: shrl Step 6: Case analysis by destructing a value Step 7: Apply tactic: ltu n Int64 Step 8: Apply tactic: iwordsize') Step 9: Case analysis by destructing a value Step 10: Simplify the goal by computation Step 11: Apply tactic: - auto", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:roll_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x n, vagree v w (roll x n) -> vagree (Val Step 2: Unfold a definition Step 3: Apply tactic: roll Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Simplify the goal by computation Step 7: Apply tactic: - auto Step 8: Apply tactic: - destruct v Step 9: Solve automatically using known facts Step 10: Apply tactic: - InvAgree Step 11: Apply a theorem or hypothesis", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:rorl_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x n, vagree v w (rorl x n) -> vagree (Val Step 2: Unfold a definition Step 3: Apply tactic: ror Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Simplify the goal by computation Step 7: Apply tactic: - auto Step 8: Apply tactic: - destruct v Step 9: Simplify the goal by computation Step 10: Solve automatically using known facts Step 11: Apply tactic: - InvAgree", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:rolml_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x amount mask, vagree v w (rolml x amount mask) -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: assert (X: forall u, Val Step 5: Apply tactic: rolml u amount mask = Val Step 6: Apply tactic: andl (Val Step 7: Apply tactic: roll u (Vint amount)) (Vlong mask)) Step 8: Apply tactic: { destruct u Step 9: Solve automatically using known facts Step 10: Rewrite using an equality Step 11: Apply a theorem or hypothesis", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:add_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v1 w1 v2 w2 x, vagree v1 w1 (modarith x) -> vagree v2 w2 (modarith x) -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: - auto Step 7: Apply tactic: - unfold Val Step 8: Apply tactic: add Step 9: Apply tactic: InvAgree Step 10: Apply a theorem or hypothesis Step 11: Apply a theorem or hypothesis", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:sub_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v1 w1 v2 w2 x, vagree v1 w1 (modarith x) -> vagree v2 w2 (modarith x) -> Archi Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: - auto Step 7: Apply tactic: - unfold Val Step 8: Apply tactic: sub Step 9: Rewrite using an equality Step 10: Apply tactic: InvAgree Step 11: Apply a theorem or hypothesis", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:modarith_idem", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall nv, modarith (modarith nv) = modarith nv Step 2: Case analysis by destructing a value Step 3: Simplify the goal by computation Step 4: Solve automatically using known facts Step 5: Apply tactic: f_equal Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: f_equal Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:mul_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v1 w1 v2 w2 x, vagree v1 w1 (modarith x) -> vagree v2 w2 (modarith x) -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: - auto Step 7: Apply tactic: - unfold Val Step 8: Apply tactic: mul Step 9: Apply tactic: InvAgree Step 10: Apply a theorem or hypothesis Step 11: Apply a theorem or hypothesis", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:neg_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x, vagree v w (modarith x) -> vagree (Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: - auto Step 6: Apply tactic: - unfold Val Step 7: Apply tactic: neg Step 8: Apply tactic: InvAgree Step 9: Apply a theorem or hypothesis Step 10: Apply a theorem or hypothesis Step 11: Apply a theorem or hypothesis", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:addl_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v1 w1 v2 w2 x, vagree v1 w1 (modarith x) -> vagree v2 w2 (modarith x) -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: - auto Step 7: Apply tactic: - destruct Archi Step 8: Apply tactic: ptr64 eqn:? Step 9: Unfold a definition Step 10: Apply tactic: addl Step 11: Rewrite using an equality", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:subl_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v1 w1 v2 w2 x, vagree v1 w1 (modarith x) -> vagree v2 w2 (modarith x) -> Archi Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: - auto Step 7: Apply tactic: - InvAgree Step 8: Simplify the goal by computation Step 9: Rewrite using an equality Step 10: Solve automatically using known facts Step 11: Apply tactic: - unfold Val", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:mull_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v1 w1 v2 w2 x, vagree v1 w1 (modarith x) -> vagree v2 w2 (modarith x) -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: - auto Step 7: Apply tactic: - InvAgree Step 8: Apply tactic: - unfold Val Step 9: Apply tactic: mull Step 10: Apply tactic: InvAgree Step 11: Apply a theorem or hypothesis", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:negl_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x, vagree v w (modarith x) -> vagree (Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: - auto Step 6: Apply tactic: - InvAgree Step 7: Apply tactic: - unfold Val Step 8: Apply tactic: negl Step 9: Apply tactic: InvAgree Step 10: Apply a theorem or hypothesis Step 11: Apply a theorem or hypothesis", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:zero_ext_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x n, vagree v w (zero_ext n x) -> 0 <= n -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: - auto Step 7: Apply tactic: - unfold Val Step 8: Apply tactic: zero_ext Step 9: Apply tactic: InvAgree Step 10: Apply tactic: red Step 11: Introduce variables and assumptions", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:sign_ext_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x n, vagree v w (sign_ext n x) -> 0 < n -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: - auto Step 7: Apply tactic: - unfold Val Step 8: Apply tactic: sign_ext Step 9: Apply tactic: InvAgree Step 10: Apply tactic: red Step 11: Introduce variables and assumptions", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:loword_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x, vagree v w (loword x) -> vagree (Val Step 2: Apply tactic: assert (A: Int Step 3: Apply tactic: zwordsize < Int64 Step 4: Apply tactic: zwordsize) by (compute Step 5: Solve automatically using known facts Step 6: Apply tactic: assert (B: forall i j m, Step 7: Apply tactic: lagree i j (Int64 Step 8: Apply tactic: ofwords Int Step 9: Apply tactic: zero m) -> Step 10: Apply tactic: iagree (Int64 Step 11: Apply tactic: loword i) (Int64", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:hiword_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x, vagree v w (hiword x) -> vagree (Val Step 2: Apply tactic: assert (A: Int64 Step 3: Apply tactic: zwordsize = 2 * Int Step 4: Apply tactic: zwordsize) by auto Step 5: Apply tactic: assert (B: forall i j m, Step 6: Apply tactic: lagree i j (Int64 Step 7: Apply tactic: ofwords m Int Step 8: Apply tactic: zero) -> Step 9: Apply tactic: iagree (Int64 Step 10: Apply tactic: hiword i) (Int64 Step 11: Apply tactic: hiword j) m)", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:makelong_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v1 w1 v2 w2 x, vagree v1 w1 (makelong_hi x) -> vagree v2 w2 (makelong_lo x) -> vagree (Val Step 2: Apply tactic: assert (A: Int64 Step 3: Apply tactic: zwordsize = 2 * Int Step 4: Apply tactic: zwordsize) by auto Step 5: Apply tactic: assert (B: forall i1 j1 i2 j2 m, Step 6: Apply tactic: iagree i1 j1 (Int64 Step 7: Apply tactic: hiword m) -> iagree i2 j2 (Int64 Step 8: Apply tactic: loword m) -> Step 9: Apply tactic: lagree (Int64 Step 10: Apply tactic: ofwords i1 i2) (Int64 Step 11: Apply tactic: ofwords j1 j2) m)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:longofintu_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x, vagree v w (longofintu x) -> vagree (Val Step 2: Apply tactic: assert (B: forall i j m, Step 3: Apply tactic: iagree i j (Int64 Step 4: Apply tactic: loword m) -> Step 5: Apply tactic: lagree (Int64 Step 6: Apply tactic: repr (Int Step 7: Apply tactic: unsigned i)) (Int64 Step 8: Apply tactic: repr (Int Step 9: Apply tactic: unsigned j)) m) Step 10: Apply tactic: { red Step 11: Introduce variables and assumptions", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:longofint_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x, vagree v w (longofint x) -> vagree (Val Step 2: Apply tactic: assert (B: forall i j m, Step 3: Apply tactic: iagree i j (Int Step 4: Apply tactic: or (Int64 Step 5: Apply tactic: loword m) (Int Step 6: Apply tactic: shl Int Step 7: Apply tactic: one (Int Step 8: Apply tactic: repr 31))) -> Step 9: Apply tactic: lagree (Int64 Step 10: Apply tactic: repr (Int Step 11: Apply tactic: signed i)) (Int64", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:store_argument_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall chunk v w, vagree v w (store_argument chunk) -> list_forall2 memval_lessdef (encode_val chunk v) (encode_val chunk w) Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (UNDEF: list_forall2 memval_lessdef Step 4: Apply tactic: (List Step 5: Apply tactic: repeat Undef (size_chunk_nat chunk)) Step 6: Apply tactic: (encode_val chunk w)) Step 7: Rewrite using an equality Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: assert (SAME: forall vl1 vl2, Step 10: Apply tactic: vl1 = vl2 -> Step 11: Apply tactic: list_forall2 memval_lessdef vl1 vl2)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:store_argument_load_result", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall chunk v w, vagree v w (store_argument chunk) -> Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Solve automatically using known facts Step 6: Apply tactic: load_result_lessdef Step 7: Apply tactic: InvAgree Step 8: Simplify the goal by computation Step 9: Apply tactic: - apply Val Step 10: Apply tactic: norm_bool_lessdef Step 11: Apply a theorem or hypothesis", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:maskzero_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w n b, vagree v w (maskzero n) -> Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Apply tactic: maskzero_bool Step 6: Apply tactic: InvAgree Step 7: Apply tactic: try discriminate Step 8: Apply tactic: inv H0 Step 9: Rewrite using an equality Step 10: Rewrite using an equality Step 11: Solve automatically using known facts", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:normalize_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x ty, vagree v w x -> vagree (Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: - auto Step 6: Apply tactic: - unfold Val Step 7: Apply tactic: normalize Step 8: Case analysis by destructing a value Step 9: Solve automatically using known facts Step 10: Case analysis by destructing a value Step 11: Apply tactic: try contradiction", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:select_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ob v1 v2 w1 w2 ty x, vagree v1 w1 x -> vagree v2 w2 x -> vagree (Val Step 2: Unfold a definition Step 3: Apply tactic: select Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Solve automatically using known facts Step 7: Apply a theorem or hypothesis Step 8: Case analysis by destructing a value Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:default_needs_of_condition_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall cond args1 b args2, eval_condition cond args1 m1 = Some b -> vagree_list args1 args2 nil -> eval_condition cond args2 m2 = Some b Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Solve automatically using known facts Step 5: Apply a theorem or hypothesis Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:andimm_redundant_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x n, andimm_redundant x n = true -> vagree v w (andimm x n) -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: try discriminate Step 6: Apply tactic: - simpl Step 7: Solve automatically using known facts Step 8: Apply tactic: - InvBooleans Step 9: Simplify the goal by computation Step 10: Unfold a definition Step 11: Apply tactic: and", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:orimm_redundant_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x n, orimm_redundant x n = true -> vagree v w (orimm x n) -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: try discriminate Step 6: Apply tactic: - auto Step 7: Apply tactic: - InvBooleans Step 8: Simplify the goal by computation Step 9: Unfold a definition Step 10: Apply tactic: InvAgree Step 11: Apply a theorem or hypothesis", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:rolm_redundant_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x amount mask, rolm_redundant x amount mask = true -> vagree v w (rolm x amount mask) -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: InvBooleans Step 5: Apply tactic: subst amount Step 6: Rewrite using an equality Step 7: Apply tactic: rolm_zero Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply tactic: assert (forall n, Int Step 11: Apply tactic: ror n Int", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:zero_ext_redundant_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x n, zero_ext_redundant n x = true -> vagree v w (zero_ext n x) -> 0 <= n -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: try discriminate Step 6: Apply tactic: - auto Step 7: Apply tactic: - simpl in * Step 8: Apply tactic: InvAgree Step 9: Simplify the goal by computation Step 10: Apply tactic: InvBooleans Step 11: Rewrite using an equality", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:sign_ext_redundant_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x n, sign_ext_redundant n x = true -> vagree v w (sign_ext n x) -> 0 < n -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: try discriminate Step 6: Apply tactic: - auto Step 7: Apply tactic: - simpl in * Step 8: Apply tactic: InvAgree Step 9: Simplify the goal by computation Step 10: Apply tactic: InvBooleans Step 11: Rewrite using an equality", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:andlimm_redundant_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x n, andlimm_redundant x n = true -> vagree v w (andlimm x n) -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: try discriminate Step 6: Apply tactic: - simpl Step 7: Solve automatically using known facts Step 8: Apply tactic: - InvBooleans Step 9: Simplify the goal by computation Step 10: Unfold a definition Step 11: Apply tactic: andl", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:orlimm_redundant_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x n, orlimm_redundant x n = true -> vagree v w (orlimm x n) -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: try discriminate Step 6: Apply tactic: - auto Step 7: Apply tactic: - InvBooleans Step 8: Simplify the goal by computation Step 9: Unfold a definition Step 10: Apply tactic: orl Step 11: Apply tactic: InvAgree", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:rolml_redundant_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v w x amount mask, rolml_redundant x amount mask = true -> vagree v w (rolml x amount mask) -> vagree (Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: InvBooleans Step 5: Apply tactic: subst amount Step 6: Rewrite using an equality Step 7: Apply tactic: rolml_zero Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply tactic: assert (forall n, Int64 Step 11: Apply tactic: ror n Int64", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:beq_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y, beq x y = true -> eq x y Step 2: We need to prove that forall x y, beq x y = true -> eq x y Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Introduce variables and assumptions Step 7: Apply tactic: InvBooleans Step 8: Split a conjunction into separate goals Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: beq_correct Step 11: Solve automatically using known facts Step 12: Introduce variables and assumptions", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:ge_refl", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y, eq x y -> ge x y Step 2: We need to prove that forall x y, eq x y -> ge x y Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Introduce variables and assumptions Step 7: Split a conjunction into separate goals Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: ge_refl Step 10: Solve automatically using known facts Step 11: Introduce variables and assumptions Step 12: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:ge_trans", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y z, ge x y -> ge y z -> ge x z Step 2: We need to prove that forall x y z, ge x y -> ge y z -> ge x z Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Introduce variables and assumptions Step 7: Split a conjunction into separate goals Step 8: Apply tactic: eapply NE Step 9: Apply tactic: ge_trans Step 10: Apply tactic: eauto Step 11: Solve automatically using known facts Step 12: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:ge_bot", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x, ge x bot Step 2: We need to prove that forall x, ge x bot Step 3: Unfold a definition Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Split a conjunction into separate goals Step 7: Apply a theorem or hypothesis Step 8: Apply tactic: ge_bot Step 9: Introduce variables and assumptions Step 10: Apply tactic: inv H Step 11: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:ge_lub_left", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y, ge (lub x y) x Step 2: We need to prove that forall x y, ge (lub x y) x Step 3: Apply tactic: Lemma ge_lub_right: forall x y, ge (lub x y) y Step 4: Unfold a definition Step 5: Apply tactic: End NVal Step 6: Case analysis by destructing a value Step 7: Apply tactic: Module NE := LPMap1(NVal) Step 8: Simplify the goal by computation Step 9: Apply tactic: Definition nenv := NE Step 10: Split a conjunction into separate goals Step 11: Apply tactic: Definition nreg (ne: nenv) (r: reg) := NE Step 12: Apply a theorem or hypothesis Step 13: Apply tactic: get r ne Step 14: Apply tactic: ge_lub_left Step 15: Apply tactic: Definition eagree (e1 e2: regset) (ne: nenv) : Pro Step 16: Introduce variables and assumptions Step 17: Apply tactic: forall r, vagree e1#r e2#r (NE Step 18: Apply a theorem or hypothesis Step 19: Apply tactic: get r ne) Step 20: Solve automatically using known facts Step 21: Apply tactic: Lemma nreg_agree: Step 22: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:ge_lub_right", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y, ge (lub x y) y Step 2: We need to prove that forall x y, ge (lub x y) y Step 3: Apply tactic: End NVal Step 4: Unfold a definition Step 5: Apply tactic: Module NE := LPMap1(NVal) Step 6: Case analysis by destructing a value Step 7: Apply tactic: Definition nenv := NE Step 8: Simplify the goal by computation Step 9: Apply tactic: Definition nreg (ne: nenv) (r: reg) := NE Step 10: Split a conjunction into separate goals Step 11: Apply tactic: get r ne Step 12: Apply a theorem or hypothesis Step 13: Apply tactic: Definition eagree (e1 e2: regset) (ne: nenv) : Pro Step 14: Apply tactic: ge_lub_right Step 15: Apply tactic: forall r, vagree e1#r e2#r (NE Step 16: Introduce variables and assumptions Step 17: Apply tactic: get r ne) Step 18: Apply a theorem or hypothesis Step 19: Apply tactic: Lemma nreg_agree: Step 20: Solve automatically using known facts Step 21: Apply tactic: forall rs1 rs2 ne r, eagree rs1 rs2 ne -> vagree r Step 22: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:nreg_agree", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall rs1 rs2 ne r, eagree rs1 rs2 ne -> vagree rs1#r rs2#r (nreg ne r) Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:eagree_ge", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall e1 e2 ne ne', eagree e1 e2 ne -> NE Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: get r ne) Step 7: Solve automatically using known facts Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:eagree_bot", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall e1 e2, eagree e1 e2 NE Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: get_bot Step 7: Apply tactic: exact Logic Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:eagree_same", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall e ne, eagree e e ne Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:eagree_update_1", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall e1 e2 ne v1 v2 nv r, eagree e1 e2 ne -> vagree v1 v2 nv -> eagree (e1#r <- v1) (e2#r <- v2) (NE Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: gsspec Step 7: Rewrite using an equality Step 8: Apply tactic: gsspec Step 9: Case analysis by destructing a value Step 10: Solve automatically using known facts Step 11: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:eagree_update", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall e1 e2 ne v1 v2 r, vagree v1 v2 (nreg ne r) -> eagree e1 e2 (NE Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: specialize (H0 r0) Step 6: Rewrite using an equality Step 7: Apply tactic: gsspec in H0 Step 8: Rewrite using an equality Step 9: Apply tactic: gsspec Step 10: Case analysis by destructing a value Step 11: Apply tactic: subst r0", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:eagree_update_dead", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall e1 e2 ne v1 r, nreg ne r = Nothing -> eagree e1 e2 ne -> eagree (e1#r <- v1) e2 ne Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: gsspec Step 7: Case analysis by destructing a value Step 8: Solve automatically using known facts Step 9: Apply tactic: subst Step 10: Unfold a definition Step 11: Rewrite using an equality", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:nlive_all", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall b ofs, nlive nmem_all b ofs Step 2: Introduce variables and assumptions Step 3: Apply tactic: constructor Step 4: Introduce variables and assumptions Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: In_empty Step 7: Rewrite using an equality Step 8: Apply tactic: gempty in H0 Step 9: Apply tactic: discriminate Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:nlive_add", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: Gl id ofs Step 2: We need to prove that forall bc b ofs p nm sz i, genv_match bc ge -> bc sp = BCstack -> pmatch bc b ofs p -> Ptrofs Step 3: Introduce variables and assumptions Step 4: Unfold a definition Step 5: Case analysis by destructing a value Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: inv H1 Step 8: Apply tactic: try (apply nlive_all) Step 9: Apply tactic: assert (Genv Step 10: Apply tactic: find_symbol ge id = Some b) by (eapply H Step 11: Apply tactic: eauto) Step 12: Case analysis by destructing a value", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:incl_nmem_add", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: Gl id ofs Step 2: We need to prove that forall nm b i p sz, nlive nm b i -> nlive (nmem_add nm p sz) b i Step 3: Introduce variables and assumptions Step 4: Apply tactic: inversion H Step 5: Apply tactic: subst Step 6: Unfold a definition Step 7: Case analysis by destructing a value Step 8: Apply tactic: try (apply nlive_all) Step 9: Case analysis by destructing a value Step 10: Apply tactic: + split Step 11: Simplify the goal by computation Step 12: Introduce variables and assumptions", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:nlive_remove", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: Gl id ofs Step 2: We need to prove that forall bc b ofs p nm sz b' i, genv_match bc ge -> bc sp = BCstack -> pmatch bc b ofs p -> nlive nm b' i -> b' <> b \\/ i < Ptrofs Step 3: Introduce variables and assumptions Step 4: Apply tactic: inversion H2 Step 5: Apply tactic: subst Step 6: Unfold a definition Step 7: Apply tactic: inv H1 Step 8: Solve automatically using known facts Step 9: Apply tactic: set (iv' := match gl!id with Step 10: Apply tactic: | Some iv => Step 11: Apply tactic: ISet Step 12: Apply tactic: add (Ptrofs", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:nlive_contains", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: Gl id ofs Step 2: We need to prove that forall bc b ofs p nm sz i, genv_match bc ge -> bc sp = BCstack -> pmatch bc b ofs p -> nmem_contains nm p sz = false -> Ptrofs Step 3: Unfold a definition Step 4: Introduce variables and assumptions Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Apply tactic: inv L Step 8: Apply tactic: inv H1 Step 9: Apply tactic: try discriminate Step 10: Apply tactic: assert (Genv Step 11: Apply tactic: find_symbol ge id = Some b) by (eapply H Step 12: Apply tactic: eauto)", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:nlive_dead_stack", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall sz b' i, b' <> sp \\/ ~(0 <= i < sz) -> nlive (nmem_dead_stack sz) b' i Step 2: Introduce variables and assumptions Step 3: Apply tactic: constructor Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Apply tactic: - rewrite ISet Step 7: Apply tactic: In_interval Step 8: Apply tactic: intuition Step 9: Apply tactic: - rewrite PTree Step 10: Apply tactic: gempty in H1 Step 11: Apply tactic: discriminate", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:nlive_lub_l", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall nm1 nm2 b i, nlive nm1 b i -> nlive (nmem_lub nm1 nm2) b i Step 2: Introduce variables and assumptions Step 3: Apply tactic: inversion H Step 4: Apply tactic: subst Step 5: Case analysis by destructing a value Step 6: Simplify the goal by computation Step 7: Solve automatically using known facts Step 8: Apply tactic: constructor Step 9: Simplify the goal by computation Step 10: Introduce variables and assumptions Step 11: Apply tactic: - rewrite ISet", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:nlive_lub_r", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall nm1 nm2 b i, nlive nm2 b i -> nlive (nmem_lub nm1 nm2) b i Step 2: Introduce variables and assumptions Step 3: Apply tactic: inversion H Step 4: Apply tactic: subst Step 5: Case analysis by destructing a value Step 6: Simplify the goal by computation Step 7: Solve automatically using known facts Step 8: Apply tactic: constructor Step 9: Simplify the goal by computation Step 10: Introduce variables and assumptions Step 11: Apply tactic: - rewrite ISet", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:nmem_beq_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall nm1 nm2 b ofs, nmem_beq nm1 nm2 = true -> (nlive nm1 b ofs <-> nlive nm2 b ofs) Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Case analysis by destructing a value Step 6: Apply tactic: try discriminate Step 7: Apply tactic: - split Step 8: Introduce variables and assumptions Step 9: Apply tactic: inv L Step 10: Apply tactic: - InvBooleans Step 11: Rewrite using an equality", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:eq_refl", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x, eq x x Step 2: Unfold a definition Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Split a conjunction into separate goals Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: eq_refl Step 8: Apply tactic: tauto Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:eq_sym", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y, eq x y -> eq y x Step 2: Unfold a definition Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Split a conjunction into separate goals Step 7: Apply a theorem or hypothesis Step 8: Apply tactic: eq_sym Step 9: Solve automatically using known facts Step 10: Introduce variables and assumptions Step 11: Rewrite using an equality", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:NeedDomain:eq_trans", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall x y z, eq x y -> eq y z -> eq x z Step 2: Unfold a definition Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Split a conjunction into separate goals Step 7: Apply tactic: eapply NE Step 8: Apply tactic: eq_trans Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Rewrite using an equality", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTL:semantics_receptive", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: receptiveness Step 2: trace length Step 3: We need to prove that forall (p: program), receptive (semantics p) Step 4: Introduce variables and assumptions Step 5: Apply tactic: constructor Step 6: Simplify the goal by computation Step 7: Introduce variables and assumptions Step 8: Apply tactic: assert (t1 = E0 -> exists s2, step (Genv Step 9: Apply tactic: globalenv p) s t2 s2) Step 10: Introduce variables and assumptions Step 11: Apply tactic: subst Step 12: Apply tactic: inv H0 Step 13: Provide an existential witness", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTL:max_pc_function_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: extensionality Step 2: base case Step 3: inductive case Step 4: We need to prove that forall f pc i, f Step 5: Introduce variables and assumptions Step 6: Unfold a definition Step 7: Apply a theorem or hypothesis Step 8: Apply tactic: fold_rec with (P := fun c m => c!pc = Some i -> Pl Step 9: Introduce variables and assumptions Step 10: Apply a theorem or hypothesis Step 11: Rewrite using an equality Step 12: Solve automatically using known facts Step 13: Rewrite using an equality Step 14: Apply tactic: gempty", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTL:max_reg_instr_ge", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall m pc i, Ple m (max_reg_instr m pc i) Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (X: forall l n, Ple m n -> Ple m (fold_left Step 4: Apply tactic: max l n)) Step 5: Apply tactic: { induction l Step 6: Simplify the goal by computation Step 7: Introduce variables and assumptions Step 8: Solve automatically using known facts Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: extlia Step 11: Case analysis by destructing a value", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTL:max_reg_instr_def", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall m pc i r, instr_defs i = Some r -> Ple r (max_reg_instr m pc i) Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (X: forall l n, Ple r n -> Ple r (fold_left Step 4: Apply tactic: max l n)) Step 5: Apply tactic: { induction l Step 6: Simplify the goal by computation Step 7: Introduce variables and assumptions Step 8: Apply tactic: extlia Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: extlia Step 11: Case analysis by destructing a value", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTL:max_reg_instr_uses", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall m pc i r, In r (instr_uses i) -> Ple r (max_reg_instr m pc i) Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (X: forall l n, In r l \\/ Ple r n -> Ple r Step 4: Apply tactic: max l n)) Step 5: Apply tactic: { induction l Step 6: Simplify the goal by computation Step 7: Introduce variables and assumptions Step 8: Apply tactic: tauto Step 9: Apply a theorem or hypothesis Step 10: Case analysis by destructing a value Step 11: Apply tactic: right", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTL:max_reg_function_def", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f pc i r, f Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (Ple r (PTree Step 4: Apply tactic: fold max_reg_instr f Step 5: Apply tactic: (fn_code) 1%positive)) Step 6: Apply tactic: { revert H Step 7: Apply a theorem or hypothesis Step 8: Apply tactic: fold_rec with Step 9: Apply tactic: (P := fun c m => c!pc = Some i -> Ple r m) Step 10: Apply tactic: - intros Step 11: Rewrite using an equality", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTL:max_reg_function_use", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f pc i r, f Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (Ple r (PTree Step 4: Apply tactic: fold max_reg_instr f Step 5: Apply tactic: (fn_code) 1%positive)) Step 6: Apply tactic: { revert H Step 7: Apply a theorem or hypothesis Step 8: Apply tactic: fold_rec with Step 9: Apply tactic: (P := fun c m => c!pc = Some i -> Ple r m) Step 10: Apply tactic: - intros Step 11: Rewrite using an equality", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTL:max_reg_function_params", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f r, In r f Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (X: forall l n, In r l \\/ Ple r n -> Ple r Step 4: Apply tactic: max l n)) Step 5: Apply tactic: { induction l Step 6: Simplify the goal by computation Step 7: Introduce variables and assumptions Step 8: Apply tactic: tauto Step 9: Apply a theorem or hypothesis Step 10: Case analysis by destructing a value Step 11: Apply tactic: right", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:RTL:is_known_runtime_function_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall cu prog ros bf rs fd, is_known_runtime_function (prog_defmap cu) ros = Some bf -> linkorder cu prog -> find_function (Genv Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: try discriminate Step 6: Case analysis by destructing a value Step 7: Apply tactic: try discriminate Step 8: Case analysis by destructing a value Step 9: Apply tactic: try discriminate Step 10: Case analysis by destructing a value Step 11: Apply tactic: try discriminate", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Registers:regs_lessdef_regs", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall rs1 rs2, regs_lessdef rs1 rs2 -> forall rl, Val Step 2: Proceed by induction on rl Step 3: Apply tactic: constructor Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Registers:set_reg_lessdef", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall r v1 v2 rs1 rs2, Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: repeat rewrite Regmap Step 6: Apply tactic: gsspec Step 7: Case analysis by destructing a value Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Registers:set_res_lessdef", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall res v1 v2 rs1 rs2, Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:transf_program_match", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall p tp, transf_program p = OK tp -> match_prog p tp Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply match_transform_partial_program Step 4: Apply tactic: eauto Step 5: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:expand_moves_cons", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall m accu b, expand_moves (rev (m :: accu)) b = expand_moves (rev accu) (expand_move m :: b) Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Simplify the goal by computation Step 5: Rewrite using an equality Step 6: Rewrite using an equality Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:extract_moves_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: reg-reg move Step 2: stack-reg move Step 3: reg-stack move Step 4: We need to prove that forall b mv b', extract_moves nil b = (mv, b') -> wf_moves mv /\\ b = expand_moves mv b' Step 5: Apply tactic: assert (BASE: Step 6: Apply tactic: forall accu b, Step 7: Apply tactic: wf_moves accu -> Step 8: Apply tactic: wf_moves (List Step 9: Apply tactic: rev accu) /\\ expand_moves (List Step 10: Apply tactic: rev accu) b = expand_moves (List Step 11: Apply tactic: rev accu) b) Step 12: Apply tactic: { intros Step 13: Split a conjunction into separate goals Step 14: Solve automatically using known facts", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:extract_moves_ext_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: reg-reg move Step 2: makelong Step 3: highlong Step 4: stack-reg move Step 5: reg-stack move Step 6: We need to prove that forall b mv b', extract_moves_ext nil b = (mv, b') -> wf_moves mv /\\ b = expand_moves mv b' Step 7: Apply tactic: assert (BASE: Step 8: Apply tactic: forall accu b, Step 9: Apply tactic: wf_moves accu -> Step 10: Apply tactic: wf_moves (List Step 11: Apply tactic: rev accu) /\\ expand_moves (List Step 12: Apply tactic: rev accu) b = expand_moves (List Step 13: Apply tactic: rev accu) b) Step 14: Apply tactic: { intros Step 15: Split a conjunction into separate goals Step 16: Solve automatically using known facts", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:check_succ_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall s b, check_succ s b = true -> exists k, b = Lbranch s :: k Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Apply tactic: try discriminate Step 6: Case analysis by destructing a value Step 7: Apply tactic: try discriminate Step 8: Case analysis by destructing a value Step 9: Simplify the goal by computation Step 10: Apply tactic: inv H Step 11: Provide an existential witness", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:pair_instr_block_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: makelong Step 2: highlong Step 3: other ops Step 4: tailcall Step 5: jumptable Step 6: We need to prove that forall i b bsh, pair_instr_block i b = Some bsh -> expand_block_shape bsh i b Step 7: Apply tactic: assert (OP: forall op args res s b bsh, Step 8: Apply tactic: pair_Iop_block op args res s b = Some bsh -> expan Step 9: Unfold a definition Step 10: Introduce variables and assumptions Step 11: Apply tactic: MonadInv Step 12: Case analysis by destructing a value Step 13: Apply tactic: MonadInv Step 14: Apply tactic: UseParsingLemmas Step 15: Case analysis by destructing a value Step 16: Apply tactic: MonadInv", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:matching_instr_block", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f1 f2 pc bsh i, (pair_codes f1 f2)!pc = Some bsh -> (RTL Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Rewrite using an equality Step 5: Apply tactic: gcombine in H Step 6: Solve automatically using known facts Step 7: Rewrite using an equality Step 8: Case analysis by destructing a value Step 9: Apply tactic: fn_code f2)!pc as [b|] Step 10: Provide an existential witness Step 11: Split a conjunction into separate goals", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:empty_eqs_satisf", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall rs ls, satisf rs ls empty_eqs Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: red Step 5: Introduce variables and assumptions Step 6: Apply tactic: ESD Step 7: Apply tactic: fsetdec Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:satisf_incr", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall rs ls (e1 e2: eqs), satisf rs ls e2 -> EqSet Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply a theorem or hypothesis Step 5: Apply tactic: ESD Step 6: Apply tactic: fsetdec Step 7: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:satisf_undef_reg", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall rs ls e r, satisf rs ls e -> satisf (rs#r <- Vundef) ls e Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: gsspec Step 7: Case analysis by destructing a value Step 8: Solve automatically using known facts Step 9: Case analysis by destructing a value Step 10: Simplify the goal by computation Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:add_equation_lessdef", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall rs ls q e, satisf rs ls (add_equation q e) -> Val Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Unfold a definition Step 5: Simplify the goal by computation Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: add_1 Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:add_equation_satisf", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall rs ls q e, satisf rs ls (add_equation q e) -> satisf rs ls e Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply satisf_incr Step 4: Apply tactic: eauto Step 5: Unfold a definition Step 6: Simplify the goal by computation Step 7: Apply tactic: ESD Step 8: Apply tactic: fsetdec Step 9: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:add_equations_satisf", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall rs ls rl ml e e', add_equations rl ml e = Some e' -> satisf rs ls e' -> satisf rs ls e Step 2: Proceed by induction on rl Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Apply tactic: MonadInv Step 7: Solve automatically using known facts Step 8: Apply tactic: eapply add_equation_satisf Step 9: Apply tactic: eauto Step 10: Apply tactic: Qed", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:add_equations_lessdef", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall rs ls rl ml e e', add_equations rl ml e = Some e' -> satisf rs ls e' -> Val Step 2: Proceed by induction on rl Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Apply tactic: MonadInv Step 7: Apply tactic: constructor Step 8: Apply tactic: constructor Step 9: Apply tactic: eauto Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: eapply add_equations_satisf", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:add_equations_args_satisf", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall rs ls rl tyl ll e e', add_equations_args rl tyl ll e = Some e' -> satisf rs ls e' -> satisf rs ls e Step 2: Introduce variables and assumptions Step 3: Apply tactic: functional induction (add_equations_args rl tyl ll Step 4: Introduce variables and assumptions Step 5: Apply tactic: - inv H Step 6: Solve automatically using known facts Step 7: Apply tactic: - eapply add_equation_satisf Step 8: Apply tactic: eauto Step 9: Apply tactic: - discriminate Step 10: Apply tactic: - eapply add_equation_satisf Step 11: Apply tactic: eapply add_equation_satisf", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:val_longofwords_eq_1", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v, Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: red in H Step 4: Case analysis by destructing a value Step 5: Apply tactic: try contradiction Step 6: Apply tactic: - reflexivity Step 7: Apply tactic: - simpl Step 8: Rewrite using an equality Step 9: Apply tactic: ofwords_recompose Step 10: Solve automatically using known facts Step 11: Apply tactic: - congruence", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:val_longofwords_eq_2", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v, Val Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Split a conjunction into separate goals Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: assumption Step 7: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:add_equations_args_lessdef", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall rs ls rl tyl ll e e', add_equations_args rl tyl ll e = Some e' -> satisf rs ls e' -> Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: functional induction (add_equations_args rl tyl ll Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Apply tactic: - inv H Step 7: Solve automatically using known facts Step 8: Apply tactic: - destruct H1 Step 9: Apply tactic: constructor Step 10: Solve automatically using known facts Step 11: Apply tactic: eapply add_equation_lessdef with (q := Eq Full r1", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:add_equation_ros_satisf", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall rs ls ros mos e e', add_equation_ros ros mos e = Some e' -> satisf rs ls e' -> satisf rs ls e Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Case analysis by destructing a value Step 6: Apply tactic: MonadInv Step 7: Apply tactic: eapply add_equation_satisf Step 8: Apply tactic: eauto Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:remove_equation_satisf", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall rs ls q e, satisf rs ls e -> satisf rs ls (remove_equation q e) Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply satisf_incr Step 4: Apply tactic: eauto Step 5: Unfold a definition Step 6: Simplify the goal by computation Step 7: Apply tactic: ESD Step 8: Apply tactic: fsetdec Step 9: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:remove_equation_res_satisf", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall rs ls r l e e', remove_equations_res r l e = Some e' -> satisf rs ls e -> satisf rs ls e' Step 2: Introduce variables and assumptions Step 3: Apply tactic: functional inversion H Step 4: Apply a theorem or hypothesis Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Apply a theorem or hypothesis Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:select_reg_l_monotone", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall r q1 q2, OrderedEquation Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: red in H Step 6: Apply tactic: congruence Step 7: Rewrite using an equality Step 8: Apply tactic: leb_le in * Step 9: Apply tactic: red in H Step 10: Case analysis by destructing a value Step 11: Apply tactic: red in A", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:select_reg_h_monotone", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall r q1 q2, OrderedEquation Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: red in H Step 6: Apply tactic: congruence Step 7: Rewrite using an equality Step 8: Apply tactic: leb_le in * Step 9: Apply tactic: red in H Step 10: Case analysis by destructing a value Step 11: Apply tactic: red in A", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:select_reg_charact", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall r q, select_reg_l r q = true /\\ select_reg_h r q = true <-> ereg q = r Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Split a conjunction into separate goals Step 5: Rewrite using an equality Step 6: Apply tactic: leb_le Step 7: Unfold a definition Step 8: Apply tactic: zify Step 9: Apply tactic: lia Step 10: Introduce variables and assumptions Step 11: Rewrite using an equality", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:reg_unconstrained_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall r e q, reg_unconstrained r e = true -> EqSet Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: red Step 5: Introduce variables and assumptions Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: assert (EqSet Step 8: Apply tactic: mem_between (select_reg_l r) (select_reg_h r) e = Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: mem_between_2 with q Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:reg_unconstrained_satisf", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall r e rs ls v, reg_unconstrained r e = true -> satisf rs ls e -> satisf (rs#r <- v) ls e Step 2: Apply tactic: red Step 3: Introduce variables and assumptions Step 4: Rewrite using an equality Step 5: Apply tactic: gso Step 6: Solve automatically using known facts Step 7: Apply tactic: eapply reg_unconstrained_sound Step 8: Apply tactic: eauto Step 9: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:select_loc_l_monotone", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall l q1 q2, OrderedEquation' Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: set (lb := OrderedLoc Step 5: Apply tactic: diff_low_bound l) in * Step 6: Case analysis by destructing a value Step 7: Apply tactic: red in H Step 8: Apply tactic: subst q2 Step 9: Solve automatically using known facts Step 10: Apply tactic: assert (eloc q1 = eloc q2 \\/ OrderedLoc Step 11: Apply tactic: lt (eloc q1) (eloc q2))", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:select_loc_h_monotone", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall l q1 q2, OrderedEquation' Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: set (lb := OrderedLoc Step 5: Apply tactic: diff_high_bound l) in * Step 6: Case analysis by destructing a value Step 7: Apply tactic: red in H Step 8: Apply tactic: subst q2 Step 9: Solve automatically using known facts Step 10: Apply tactic: assert (eloc q2 = eloc q1 \\/ OrderedLoc Step 11: Apply tactic: lt (eloc q2) (eloc q1))", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:select_loc_charact", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall l q, select_loc_l l q = false \\/ select_loc_h l q = false <-> Loc Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Split a conjunction into separate goals Step 5: Introduce variables and assumptions Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: outside_interval_diff Step 8: Case analysis by destructing a value Step 9: Apply tactic: left Step 10: Case analysis by destructing a value Step 11: Apply tactic: compare (eloc q) (OrderedLoc", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:loc_unconstrained_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall l e q, loc_unconstrained l e = true -> EqSet Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Case analysis by destructing a value Step 6: Apply tactic: assert (EqSet2 Step 7: Apply tactic: mem_between (select_loc_l l) (select_loc_h l) (eqs Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: mem_between_2 with q Step 10: Solve automatically using known facts Step 11: Apply tactic: exact (select_loc_l_monotone l)", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:loc_unconstrained_satisf", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall rs ls k r mr e v, let l := R mr in satisf rs ls (remove_equation (Eq k r l) e) -> loc_unconstrained (R mr) (remove_equation (Eq k r l) e) = true -> Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: eq_dec q (Eq k r l)) Step 7: Apply tactic: subst q Step 8: Simplify the goal by computation Step 9: Unfold a definition Step 10: Rewrite using an equality Step 11: Apply tactic: gss", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:reg_loc_unconstrained_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall r l e q, reg_loc_unconstrained r l e = true -> EqSet Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Split a conjunction into separate goals Step 5: Apply tactic: eapply reg_unconstrained_sound Step 6: Apply tactic: eauto Step 7: Apply tactic: eapply loc_unconstrained_sound Step 8: Apply tactic: eauto Step 9: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:parallel_assignment_satisf", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall k r mr e rs ls v v', let l := R mr in Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: eq_dec q (Eq k r l)) Step 7: Apply tactic: subst q Step 8: Simplify the goal by computation Step 9: Unfold a definition Step 10: Rewrite using an equality Step 11: Apply tactic: gss", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:parallel_assignment_satisf_2", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: One location Step 2: Two 32-bit halves Step 3: We need to prove that forall rs ls res res' e e' v v', remove_equations_res res res' e = Some e' -> satisf rs ls e' -> reg_unconstrained res e' = true -> forallb (fun l => loc_unconstrained l e') (map R (regs_of_rpair res')) = true -> Val Step 4: Introduce variables and assumptions Step 5: Apply tactic: functional inversion H Step 6: Apply tactic: subst Step 7: Simplify the goal by computation Step 8: Apply tactic: InvBooleans Step 9: Simplify the goal by computation Step 10: Apply a theorem or hypothesis Step 11: Solve automatically using known facts Step 12: Unfold a definition Step 13: Rewrite using an equality", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:in_elements_between_1", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall r1 s q, EqSet Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Apply tactic: elements_between_iff, select_reg_charact Step 5: Apply tactic: tauto Step 6: Apply tactic: exact (select_reg_l_monotone r1) Step 7: Apply tactic: exact (select_reg_h_monotone r1) Step 8: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:in_subst_reg", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall r1 r2 q (e: eqs), EqSet Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: set (f := fun (q: EqSet Step 5: Apply tactic: elt) e => add_equation (Eq (ekind q) r2 (eloc q)) Step 6: Apply tactic: generalize (in_elements_between_1 r1 e0) Step 7: Apply tactic: set (elt := EqSet Step 8: Apply tactic: elements_between (select_reg_l r1) (select_reg_h r Step 9: Introduce variables and assumptions Step 10: Apply tactic: set (P := fun e1 e2 => Step 11: Apply tactic: EqSet", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:subst_reg_satisf", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall src dst rs ls e, satisf rs ls (subst_reg dst src e) -> satisf (rs#dst <- (rs#src)) ls e Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: subst dst Step 7: Rewrite using an equality Step 8: Apply tactic: gss Step 9: Apply tactic: exploit H Step 10: Apply tactic: eauto Step 11: Rewrite using an equality", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:in_subst_reg_kind", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall r1 k1 r2 k2 q (e: eqs), EqSet Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: set (f := fun (q: EqSet Step 5: Apply tactic: elt) e => Step 6: Apply tactic: if IndexedEqKind Step 7: Apply tactic: eq (ekind q) k1 Step 8: Apply tactic: then add_equation (Eq k2 r2 (eloc q)) (remove_equa Step 9: Apply tactic: else e) Step 10: Apply tactic: generalize (in_elements_between_1 r1 e0) Step 11: Apply tactic: set (elt := EqSet", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:subst_reg_kind_satisf_makelong", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall src1 src2 dst rs ls e, let e1 := subst_reg_kind dst High src1 Full e in let e2 := subst_reg_kind dst Low src2 Full e1 in reg_unconstrained dst e2 = true -> satisf rs ls e2 -> satisf (rs#dst <- (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: fold e1 in B Step 7: Case analysis by destructing a value Step 8: Apply tactic: fold e2 in D Step 9: Simplify the goal by computation Step 10: Simplify the goal by computation Step 11: Apply tactic: inv C", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:subst_reg_kind_satisf_lowlong", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall src dst rs ls e, let e1 := subst_reg_kind dst Full src Low e in reg_unconstrained dst e1 = true -> satisf rs ls e1 -> satisf (rs#dst <- (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: fold e1 in B Step 7: Apply tactic: inversion A Step 8: Rewrite using an equality Step 9: Rewrite using an equality Step 10: Simplify the goal by computation Step 11: Rewrite using an equality", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:subst_reg_kind_satisf_highlong", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall src dst rs ls e, let e1 := subst_reg_kind dst Full src High e in reg_unconstrained dst e1 = true -> satisf rs ls e1 -> satisf (rs#dst <- (Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Case analysis by destructing a value Step 6: Apply tactic: fold e1 in B Step 7: Apply tactic: inversion A Step 8: Rewrite using an equality Step 9: Rewrite using an equality Step 10: Simplify the goal by computation Step 11: Rewrite using an equality", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:in_subst_loc", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall l1 l2 q (e e': eqs), EqSet Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: set (elt := EqSet2 Step 5: Apply tactic: elements_between (select_loc_l l1) (select_loc_h l Step 6: Apply tactic: set (f := fun q0 e => Step 7: Apply tactic: if Loc Step 8: Apply tactic: eq l1 (eloc q0) then Step 9: Apply tactic: Some (add_equation Step 10: Apply tactic: {| ekind := ekind q0 Step 11: Apply tactic: ereg := ereg q0", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:loc_type_compat_charact", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall env l e q, loc_type_compat env l e = true -> EqSet Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Rewrite using an equality Step 5: Apply tactic: for_all_between_iff in H Step 6: Case analysis by destructing a value Step 7: Case analysis by destructing a value Step 8: Apply tactic: left Step 9: Apply a theorem or hypothesis Step 10: Solve automatically using known facts Step 11: Apply a theorem or hypothesis", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:well_typed_move_charact", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall env l e k r rs, well_typed_move env l e = true -> EqSet Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Solve automatically using known facts Step 6: Apply tactic: exploit loc_type_compat_charact Step 7: Apply tactic: eauto Step 8: Introduce variables and assumptions Step 9: Simplify the goal by computation Step 10: Apply tactic: eapply Val Step 11: Apply tactic: has_subtype", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:val_lessdef_normalize", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v v' ty, Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Rewrite using an equality Step 5: Apply tactic: load_result_same Step 6: Solve automatically using known facts Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:subst_loc_satisf", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall env src dst rs ls e e', subst_loc dst src e = Some e' -> well_typed_move env dst e = true -> wt_regset env rs -> satisf rs ls e' -> satisf rs (Locmap Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: exploit in_subst_loc Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Apply tactic: subst dst Step 9: Rewrite using an equality Step 10: Apply tactic: gss Step 11: Case analysis by destructing a value", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:in_subst_loc_part", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall l1 l2 k q (e e': eqs), EqSet Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: set (elt := EqSet2 Step 5: Apply tactic: elements_between (select_loc_l l1) (select_loc_h l Step 6: Apply tactic: set (f := fun q0 e => Step 7: Apply tactic: if Loc Step 8: Apply tactic: eq l1 (eloc q0) then Step 9: Apply tactic: if IndexedEqKind Step 10: Apply tactic: eq (ekind q0) k then Step 11: Apply tactic: Some (add_equation", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:subst_loc_part_satisf_lowlong", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall src dst rs ls e e', subst_loc_part (R dst) (R src) Low e = Some e' -> satisf rs ls e' -> satisf rs (Locmap Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: exploit in_subst_loc_part Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Rewrite using an equality Step 9: Apply a theorem or hypothesis Step 10: Rewrite using an equality Step 11: Apply tactic: gss", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:subst_loc_part_satisf_highlong", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall src dst rs ls e e', subst_loc_part (R dst) (R src) High e = Some e' -> satisf rs ls e' -> satisf rs (Locmap Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: exploit in_subst_loc_part Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Rewrite using an equality Step 9: Apply a theorem or hypothesis Step 10: Rewrite using an equality Step 11: Apply tactic: gss", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:long_type_compat_charact", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall env l e q, long_type_compat env l e = true -> EqSet Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Rewrite using an equality Step 5: Apply tactic: for_all_between_iff in H Step 6: Case analysis by destructing a value Step 7: Case analysis by destructing a value Step 8: Apply tactic: left Step 9: Apply a theorem or hypothesis Step 10: Solve automatically using known facts Step 11: Apply a theorem or hypothesis", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:subst_loc_pair_satisf_makelong", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall env src1 src2 dst rs ls e e', subst_loc_pair (R dst) (R src1) (R src2) e = Some e' -> long_type_compat env (R dst) e = true -> wt_regset env rs -> satisf rs ls e' -> Archi Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: exploit in_subst_loc_pair Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Apply tactic: - rewrite A, B Step 9: Apply a theorem or hypothesis Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: assert (subtype (env (ereg q)) Tlong = true)", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:can_undef_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall e ml q, can_undef ml e = true -> EqSet Step 2: Proceed by induction on ml Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: tauto Step 6: Apply tactic: InvBooleans Step 7: Split a conjunction into separate goals Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: diff_sym Step 10: Apply tactic: eapply loc_unconstrained_sound Step 11: Apply tactic: eauto", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:undef_regs_outside", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ml ls l, Loc Step 2: Proceed by induction on ml Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Solve automatically using known facts Step 6: Rewrite using an equality Step 7: Apply tactic: gso Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: tauto Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: diff_sym", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:can_undef_satisf", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ml e rs ls, can_undef ml e = true -> satisf rs ls e -> satisf rs (undef_regs ml ls) e Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Rewrite using an equality Step 6: Apply tactic: eauto Step 7: Apply tactic: eapply can_undef_sound Step 8: Apply tactic: eauto Step 9: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:can_undef_except_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall lx e ml q, can_undef_except lx ml e = true -> EqSet Step 2: Proceed by induction on ml Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: tauto Step 6: Apply tactic: InvBooleans Step 7: Split a conjunction into separate goals Step 8: Case analysis by destructing a value Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: congruence Step 11: Apply a theorem or hypothesis", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:subst_loc_undef_satisf", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall env src dst rs ls ml e e', subst_loc dst src e = Some e' -> well_typed_move env dst e = true -> can_undef_except dst ml e = true -> wt_regset env rs -> satisf rs ls e' -> satisf rs (Locmap Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: exploit in_subst_loc Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Apply tactic: subst dst Step 9: Rewrite using an equality Step 10: Apply tactic: gss Step 11: Case analysis by destructing a value", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:transfer_use_def_satisf", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall args res args' res' und e e' rs ls, transfer_use_def args res args' res' und e = Some e' -> satisf rs ls e' -> Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: MonadInv Step 5: Split a conjunction into separate goals Step 6: Apply tactic: eapply add_equations_lessdef Step 7: Apply tactic: eauto Step 8: Introduce variables and assumptions Step 9: Apply tactic: eapply parallel_assignment_satisf Step 10: Apply tactic: eauto Step 11: Apply tactic: assumption", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:add_equations_res_lessdef", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall r ty l e e' rs ls, add_equations_res r ty l e = Some e' -> satisf rs ls e' -> Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: functional inversion H Step 4: Simplify the goal by computation Step 5: Apply tactic: - subst Step 6: Apply tactic: eapply add_equation_lessdef with (q := Eq Full r ( Step 7: Apply tactic: eauto Step 8: Apply tactic: - subst Step 9: Rewrite using an equality Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: longofwords_lessdef", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:return_regs_agree_callee_save", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall caller callee, agree_callee_save caller (return_regs caller callee) Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Unfold a definition Step 6: Apply tactic: red in H Step 7: Case analysis by destructing a value Step 8: Rewrite using an equality Step 9: Solve automatically using known facts Step 10: Case analysis by destructing a value Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:no_caller_saves_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall e q, no_caller_saves e = true -> EqSet Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: exploit EqSet Step 5: Apply tactic: for_all_2 Step 6: Apply tactic: eauto Step 7: Apply tactic: hnf Step 8: Introduce variables and assumptions Step 9: Simplify the goal by computation Step 10: Rewrite using an equality Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:val_hiword_longofwords", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v1 v2, Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Case analysis by destructing a value Step 7: Solve automatically using known facts Step 8: Unfold a definition Step 9: Apply tactic: hiword Step 10: Rewrite using an equality Step 11: Apply tactic: hi_ofwords", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:val_loword_longofwords", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v1 v2, Val Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Case analysis by destructing a value Step 7: Solve automatically using known facts Step 8: Unfold a definition Step 9: Apply tactic: loword Step 10: Rewrite using an equality Step 11: Apply tactic: lo_ofwords", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:function_return_satisf", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: One register Step 2: Two 32-bit halves Step 3: We need to prove that forall rs ls_before ls_after res res' sg e e' v, res' = loc_result sg -> remove_equations_res res res' e = Some e' -> satisf rs ls_before e' -> forallb (fun l => reg_loc_unconstrained res l e') (map R (regs_of_rpair res')) = true -> no_caller_saves e' = true -> Val Step 4: Introduce variables and assumptions Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Apply tactic: functional inversion H0 Step 8: Apply tactic: subst Step 9: Rewrite using an equality Step 10: Simplify the goal by computation Step 11: Apply tactic: InvBooleans Step 12: Apply tactic: set (e' := remove_equation {| ekind := Full Step 13: Apply tactic: ereg := res", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:compat_left_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall r l e q, compat_left r l e = true -> EqSet Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Rewrite using an equality Step 5: Apply tactic: for_all_between_iff in H Step 6: Apply a theorem or hypothesis Step 7: Case analysis by destructing a value Step 8: Apply tactic: exploit H Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Case analysis by destructing a value", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:compat_left2_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall r l1 l2 e q, compat_left2 r l1 l2 e = true -> EqSet Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Rewrite using an equality Step 5: Apply tactic: for_all_between_iff in H Step 6: Apply a theorem or hypothesis Step 7: Case analysis by destructing a value Step 8: Apply tactic: exploit H Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Case analysis by destructing a value", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:compat_entry_satisf", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: no params Step 2: a param in a single location Step 3: a param split across two locations Step 4: error case Step 5: We need to prove that forall rl ll e, compat_entry rl ll e = true -> forall vl ls, Val Step 6: Introduce variables and assumptions Step 7: Apply tactic: functional induction (compat_entry rl ll e) Step 8: Introduce variables and assumptions Step 9: Simplify the goal by computation Step 10: Apply tactic: red Step 11: Introduce variables and assumptions Step 12: Rewrite using an equality Step 13: Case analysis by destructing a value Step 14: Simplify the goal by computation Step 15: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:call_regs_param_values", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall sg ls, map (fun p => Locmap Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Rewrite using an equality Step 5: Apply a theorem or hypothesis Step 6: Introduce variables and assumptions Step 7: Apply tactic: symmetry Step 8: Apply tactic: assert (A: forall l, loc_argument_acceptable l -> Step 9: Apply tactic: { destruct l as [r | [] ofs ty] Step 10: Simplify the goal by computation Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:return_regs_arg_values", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall sg ls1 ls2, tailcall_is_possible sg = true -> map (fun p => Locmap Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Apply a theorem or hypothesis Step 5: Introduce variables and assumptions Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: getpair_exten Step 8: Introduce variables and assumptions Step 9: Apply tactic: assert (In l (regs_of_rpairs (loc_arguments sg))) Step 10: Apply tactic: eauto) Step 11: Apply tactic: exploit loc_arguments_acceptable_2", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:find_function_tailcall", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall tge ros ls1 ls2, ros_compatible_tailcall ros = true -> find_function tge ros (return_regs ls1 ls2) = find_function tge ros ls2 Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Solve automatically using known facts Step 6: Unfold a definition Step 7: Case analysis by destructing a value Step 8: Apply tactic: discriminate Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:add_equations_builtin_arg_satisf", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall env rs ls arg arg' e e', add_equations_builtin_arg env arg arg' e = Some e' -> satisf rs ls e' -> satisf rs ls e Step 2: Proceed by induction on arg Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Apply tactic: MonadInv Step 7: Apply tactic: eauto Step 8: Apply tactic: eapply add_equation_satisf Step 9: Apply tactic: eauto Step 10: Case analysis by destructing a value Step 11: Apply tactic: MonadInv", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:add_equations_builtin_args_satisf", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall env rs ls arg arg' e e', add_equations_builtin_args env arg arg' e = Some e' -> satisf rs ls e' -> satisf rs ls e Step 2: Proceed by induction on arg Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Apply tactic: MonadInv Step 7: Apply tactic: eauto using add_equations_builtin_arg_satisf Step 8: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:add_equations_debug_args_satisf", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall env rs ls arg arg' e e', add_equations_debug_args env arg arg' e = Some e' -> satisf rs ls e' -> satisf rs ls e Step 2: Proceed by induction on arg Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Apply tactic: MonadInv Step 7: Solve automatically using known facts Step 8: Case analysis by destructing a value Step 9: Apply tactic: eauto using add_equations_builtin_arg_satisf Step 10: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:parallel_set_builtin_res_satisf", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall env res res' e0 e1 rs ls v v', remove_equations_builtin_res env res res' e0 = Some e1 -> forallb (fun r => reg_unconstrained r e1) (params_of_builtin_res res) = true -> forallb (fun mr => loc_unconstrained (R mr) e1) (params_of_builtin_res res') = true -> satisf rs ls e1 -> Val Step 2: Introduce variables and assumptions Step 3: Rewrite using an equality Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: inv H Step 7: Apply tactic: - apply parallel_assignment_satisf with (k := Full Step 8: Solve automatically using known facts Step 9: Unfold a definition Step 10: Rewrite using an equality Step 11: Rewrite using an equality", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:analyze_successors", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f env bsh an pc bs s e, analyze f env bsh = Some an -> bsh!pc = Some bs -> In s (successors_block_shape bs) -> an!!pc = OK e -> exists e', transfer f env bsh s an!!s = OK e' /\\ EqSet Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Apply tactic: exploit DS Step 5: Apply tactic: fixpoint_allnodes_solution Step 6: Apply tactic: eauto Step 7: Rewrite using an equality Step 8: Unfold a definition Step 9: Case analysis by destructing a value Step 10: Introduce variables and assumptions Step 11: Provide an existential witness", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:satisf_successors", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f env bsh an pc bs s e rs ls, analyze f env bsh = Some an -> bsh!pc = Some bs -> In s (successors_block_shape bs) -> an!!pc = OK e -> satisf rs ls e -> exists e', transfer f env bsh s an!!s = OK e' /\\ satisf rs ls e' Step 2: Introduce variables and assumptions Step 3: Apply tactic: exploit analyze_successors Step 4: Apply tactic: eauto Step 5: Introduce variables and assumptions Step 6: Provide an existential witness Step 7: Split a conjunction into separate goals Step 8: Solve automatically using known facts Step 9: Apply tactic: eapply satisf_incr Step 10: Apply tactic: eauto Step 11: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:transf_function_inv", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f tf, transf_function f = OK tf -> transf_function_spec f tf Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: try discriminate Step 6: Case analysis by destructing a value Step 7: Apply tactic: try discriminate Step 8: Case analysis by destructing a value Step 9: Apply tactic: inv H Step 10: Unfold a definition Step 11: Case analysis by destructing a value", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:symbols_preserved", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall (s: ident), Genv Step 2: Apply tactic: Lemma senv_preserved: Step 3: Apply tactic: Senv Step 4: Apply tactic: equiv ge tge Step 5: Apply tactic: Lemma functions_translated: Step 6: Apply tactic: forall (v: val) (f: RTL Step 7: Apply tactic: fundef), Step 8: Apply tactic: Genv Step 9: Apply tactic: find_funct ge v = Some f -> Step 10: Provide an existential witness Step 11: Apply tactic: Genv", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:senv_preserved", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that Senv Step 2: Apply tactic: Lemma functions_translated: Step 3: Apply tactic: forall (v: val) (f: RTL Step 4: Apply tactic: fundef), Step 5: Apply tactic: Genv Step 6: Apply tactic: find_funct ge v = Some f -> Step 7: Provide an existential witness Step 8: Apply tactic: Genv Step 9: Apply tactic: find_funct tge v = Some tf /\\ transf_fundef f = OK Step 10: Apply tactic: Lemma function_ptr_translated: Step 11: Apply tactic: forall (b: block) (f: RTL", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:functions_translated", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall (v: val) (f: RTL Step 2: Apply tactic: Lemma function_ptr_translated: Step 3: Apply tactic: forall (b: block) (f: RTL Step 4: Apply tactic: fundef), Step 5: Apply tactic: Genv Step 6: Apply tactic: find_funct_ptr ge b = Some f -> Step 7: Provide an existential witness Step 8: Apply tactic: Genv Step 9: Apply tactic: find_funct_ptr tge b = Some tf /\\ transf_fundef f Step 10: Apply tactic: Lemma sig_function_translated: Step 11: Apply tactic: forall f tf,", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:function_ptr_translated", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall (b: block) (f: RTL Step 2: Apply tactic: Lemma sig_function_translated: Step 3: Apply tactic: forall f tf, Step 4: Apply tactic: transf_fundef f = OK tf -> Step 5: Apply tactic: LTL Step 6: Apply tactic: funsig tf = RTL Step 7: Apply tactic: funsig f Step 8: Introduce variables and assumptions Step 9: Case analysis by destructing a value Step 10: Apply tactic: monadInv H Step 11: Case analysis by destructing a value", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:sig_function_translated", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall f tf, transf_fundef f = OK tf -> LTL Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: monadInv H Step 5: Case analysis by destructing a value Step 6: Simplify the goal by computation Step 7: Solve automatically using known facts Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:find_function_translated", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: two regs Step 2: two symbols Step 3: We need to prove that forall ros rs fd ros' e e' ls, RTL Step 4: Unfold a definition Step 5: Apply tactic: find_function, LTL Step 6: Apply tactic: find_function Step 7: Introduce variables and assumptions Step 8: Case analysis by destructing a value Step 9: Case analysis by destructing a value Step 10: Simplify the goal by computation Step 11: Apply tactic: MonadInv Step 12: Apply tactic: exploit add_equation_lessdef Step 13: Apply tactic: eauto", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:exec_moves", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: loc-loc move Step 2: reg->stack Step 3: stack->reg Step 4: stack->stack Step 5: makelong Step 6: highlong Step 7: We need to prove that forall mv env rs s f sp bb m e e' ls, track_moves env mv e = Some e' -> wf_moves mv -> satisf rs ls e' -> wt_regset env rs -> exists ls', star step tge (Block s f sp (expand_moves mv bb) ls m) E0 (Block s f sp bb ls' m) /\\ satisf rs ls' e Step 8: Apply tactic: Opaque destroyed_by_op Step 9: Proceed by induction on mv Step 10: Simplify the goal by computation Step 11: Introduce variables and assumptions Step 12: Apply tactic: - unfold expand_moves Step 13: Simplify the goal by computation Step 14: Apply tactic: inv H Step 15: Provide an existential witness Step 16: Split a conjunction into separate goals Step 17: Apply a theorem or hypothesis", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:match_stackframes_change_sig", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall s ts sg sg', match_stackframes s ts sg -> sg' Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: constructor Step 5: Apply tactic: congruence Step 6: Apply tactic: econstructor Step 7: Apply tactic: eauto Step 8: Unfold a definition Step 9: Rewrite using an equality Step 10: Solve automatically using known facts Step 11: Introduce variables and assumptions", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:addressing_not_long", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall env f addr args dst s r, wt_instr f env (Iload Mint64 addr args dst s) -> Archi Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: assert (A: forall ty, In ty (type_of_addressing ad Step 5: Apply tactic: { intros Step 6: Apply tactic: try (apply diff_false_true in H0) Step 7: Case analysis by destructing a value Step 8: Simplify the goal by computation Step 9: Apply tactic: intuition auto Step 10: Apply tactic: assert (B: In (env r) (type_of_addressing addr)) Step 11: Apply tactic: { rewrite <- H5", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:step_simulation", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: op makelong Step 2: op lowlong Step 3: jumptable Step 4: without an argument Step 5: with an argument Step 6: internal function Step 7: external function Step 8: op highlong Step 9: op regular Step 10: load regular Step 11: load pair Step 12: load first word of a pair Step 13: load second word of a pair Step 14: load dead Step 15: tailcall Step 16: We need to prove that forall S1 t S2, RTL Step 17: Proceed by induction on 1 Step 18: Introduce variables and assumptions Step 19: Apply tactic: inv MS Step 20: Apply tactic: try UseShape Step 21: Apply tactic: - exploit exec_moves Step 22: Apply tactic: eauto Step 23: Introduce variables and assumptions Step 24: Apply tactic: econstructor Step 25: Split a conjunction into separate goals Step 26: Apply tactic: eapply plus_left", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:initial_states_simulation", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall st1, RTL Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: exploit function_ptr_translated Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Apply tactic: exploit sig_function_translated Step 8: Apply tactic: eauto Step 9: Introduce variables and assumptions Step 10: Provide an existential witness Step 11: Apply tactic: Callstate nil tf (Locmap", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:final_states_simulation", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall st1 st2 r, match_states st1 st2 -> RTL Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Apply tactic: inv H Step 5: Apply tactic: inv STACKS Step 6: Apply tactic: econstructor Step 7: Rewrite using an equality Step 8: Apply tactic: inv RES Step 9: Solve automatically using known facts Step 10: Rewrite using an equality Step 11: Solve automatically using known facts", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:wt_prog", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that wt_program prog Step 2: Apply tactic: red Step 3: Introduce variables and assumptions Step 4: Apply tactic: exploit list_forall2_in_left Step 5: Apply tactic: eexact (proj1 TRANSF) Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Simplify the goal by computation Step 9: Apply tactic: subst i' Step 10: Apply tactic: inv C Step 11: Case analysis by destructing a value", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Allocproof:transf_program_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forward_simulation (RTL Step 2: Apply tactic: set (ms := fun s s' => wt_state s /\\ match_states Step 3: Apply tactic: eapply forward_simulation_plus with (match_states Step 4: Apply tactic: - apply senv_preserved Step 5: Apply tactic: - intros Step 6: Apply tactic: exploit initial_states_simulation Step 7: Apply tactic: eauto Step 8: Introduce variables and assumptions Step 9: Provide an existential witness Step 10: Split a conjunction into separate goals Step 11: Solve automatically using known facts", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:transf_program_match", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall prog tprog, transf_program prog = OK tprog -> match_prog prog tprog Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply match_transform_partial_program_contextual Step 4: Apply tactic: eauto Step 5: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:wf_equation_incr", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall next1 next2 e, wf_equation next1 e -> Ple next1 next2 -> wf_equation next2 e Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Case analysis by destructing a value Step 6: Split a conjunction into separate goals Step 7: Apply a theorem or hypothesis Step 8: Apply tactic: lt_le_trans with next1 Step 9: Solve automatically using known facts Step 10: Apply tactic: red Step 11: Introduce variables and assumptions", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:valu_agree_refl", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall valu upto, valu_agree valu valu upto Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:valnums_val_exten", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall vl, (forall v, In v vl -> Plt v upto) -> map valu2 vl = map valu1 vl Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Introduce variables and assumptions Step 5: Apply tactic: symmetry Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:builtin_arg_val_exten", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall a v, eval_builtin_arg ge valu1 sp m a v -> (forall vn, In vn (params_of_builtin_arg a) -> Plt vn upto) -> eval_builtin_arg ge valu2 sp m a v Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: try (constructor Step 6: Apply tactic: eauto using in_or_app) Step 7: Apply tactic: - rewrite <- AGREE by eauto with coqlib Step 8: Apply a theorem or hypothesis Step 9: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:builtin_args_val_exten", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall al vl, eval_builtin_args ge valu1 sp m al vl -> (forall vn, In vn (params_of_builtin_args al) -> Plt vn upto) -> eval_builtin_args ge valu2 sp m al vl Step 2: Unfold a definition Step 3: Proceed by induction on 1 Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Apply tactic: constructor Step 7: Apply tactic: eauto using builtin_arg_val_exten, in_or_app Step 8: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:rhs_eval_to_exten", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall r v, rhs_eval_to valu1 ge sp m r v -> (forall v, In v (valnums_rhs r) -> Plt v upto) -> rhs_eval_to valu2 ge sp m r v Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Simplify the goal by computation Step 5: Apply tactic: - constructor Step 6: Rewrite using an equality Step 7: Solve automatically using known facts Step 8: Apply tactic: - econstructor Step 9: Apply tactic: eauto Step 10: Rewrite using an equality Step 11: Solve automatically using known facts", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:rhs_valid_exten", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall r, rhs_valid valu1 ge sp r -> (forall v, In v (valnums_rhs r) -> Plt v upto) -> rhs_valid valu2 ge sp r Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Simplify the goal by computation Step 5: Apply tactic: - constructor Step 6: Apply tactic: - econstructor Step 7: Apply tactic: eauto Step 8: Rewrite using an equality Step 9: Solve automatically using known facts Step 10: Apply tactic: - constructor Step 11: Apply tactic: Qed", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:equation_holds_exten", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall e, equation_holds valu1 ge sp m e -> wf_equation upto e -> equation_holds valu2 ge sp m e Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Case analysis by destructing a value Step 5: Apply tactic: inv H Step 6: Apply tactic: - constructor Step 7: Rewrite using an equality Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply a theorem or hypothesis Step 11: Solve automatically using known facts", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:numbering_holds_exten", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall n, numbering_holds valu1 ge sp rs m n -> Ple n Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Apply tactic: constructor Step 5: Introduce variables and assumptions Step 6: Apply tactic: - auto Step 7: Apply tactic: - apply equation_holds_exten Step 8: Solve automatically using known facts Step 9: Apply tactic: eapply wf_equation_incr Step 10: Apply tactic: eauto with cse Step 11: Apply tactic: - rewrite AGREE", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:valnum_reg_holds", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall valu1 ge sp rs m n r n' v, numbering_holds valu1 ge sp rs m n -> valnum_reg n r = (n', v) -> exists valu2, numbering_holds valu2 ge sp rs m n' /\\ rs#r = valu2 v /\\ valu_agree valu1 valu2 n Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: - inv H0 Step 6: Provide an existential witness Step 7: Split a conjunction into separate goals Step 8: Apply tactic: + auto Step 9: Apply tactic: + eauto with cse Step 10: Apply tactic: + red Step 11: Solve automatically using known facts", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:valnum_regs_holds", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall rl valu1 ge sp rs m n n' vl, numbering_holds valu1 ge sp rs m n -> valnum_regs n rl = (n', vl) -> exists valu2, numbering_holds valu2 ge sp rs m n' /\\ rs##rl = map valu2 vl /\\ valu_agree valu1 valu2 n Step 2: Proceed by induction on rl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - inv H0 Step 6: Provide an existential witness Step 7: Split a conjunction into separate goals Step 8: Solve automatically using known facts Step 9: Apply tactic: red Step 10: Solve automatically using known facts Step 11: Simplify the goal by computation", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:valnum_builtin_arg_holds", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall (ge: genv) sp rs m a v, eval_builtin_arg ge (fun r => rs#r) sp m a v -> forall valu1 n n' a', numbering_holds valu1 ge sp rs m n -> valnum_builtin_arg n a = (n', a') -> exists valu2, numbering_holds valu2 ge sp rs m n' /\\ eval_builtin_arg ge valu2 sp m a' v /\\ valu_agree valu1 valu2 n Step 2: Proceed by induction on 1 Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: 2-9: inv VB Step 6: Provide an existential witness Step 7: Simplify the goal by computation Step 8: Apply tactic: intuition eauto using eval_builtin_arg, Ple_refl, Step 9: Apply tactic: - destruct (valnum_reg nv x) as (nv1, vn) eqn:VR Step 10: Apply tactic: inv VB Step 11: Apply tactic: exploit valnum_reg_holds", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:valnum_builtin_args_holds", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall (ge: genv) sp rs m al vl, eval_builtin_args ge (fun r => rs#r) sp m al vl -> forall valu1 n n' al', numbering_holds valu1 ge sp rs m n -> valnum_builtin_args n al = (n', al') -> exists valu2, numbering_holds valu2 ge sp rs m n' /\\ eval_builtin_args ge valu2 sp m al' vl /\\ valu_agree valu1 valu2 n Step 2: Unfold a definition Step 3: Proceed by induction on 1 Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Apply tactic: - inv H0 Step 7: Simplify the goal by computation Step 8: Provide an existential witness Step 9: Apply tactic: intuition eauto using list_forall2, Ple_refl, valu Step 10: Apply tactic: - destruct (valnum_builtin_arg n a1) as [n1 a1'] e Step 11: Case analysis by destructing a value", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:eval_builtin_args_trivial", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall (ge: genv) sp rs m rl, eval_builtin_args ge (fun r => rs#r) sp m (map (@BA _) rl) rs##rl Step 2: Unfold a definition Step 3: Proceed by induction on rl Step 4: Simplify the goal by computation Step 5: Apply tactic: constructor Step 6: Solve automatically using known facts Step 7: Apply tactic: constructor Step 8: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:find_valnum_rhs_charact", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall rh v eqs, find_valnum_rhs rh eqs = Some v -> exists rh', In (Eq v true rh') eqs /\\ rhs_compat rh rh' Step 2: Proceed by induction on eqs Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - inv H Step 6: Apply tactic: - destruct a Step 7: Case analysis by destructing a value Step 8: Apply tactic: + InvBooleans Step 9: Apply tactic: inv H Step 10: Provide an existential witness Step 11: Solve automatically using known facts", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:find_valnum_num_charact", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall v r eqs, find_valnum_num v eqs = Some r -> In (Eq v true r) eqs Step 2: Proceed by induction on eqs Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - inv H Step 6: Apply tactic: - destruct a Step 7: Case analysis by destructing a value Step 8: Apply tactic: + InvBooleans Step 9: Apply tactic: inv H Step 10: Solve automatically using known facts Step 11: Apply tactic: + eauto", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:reg_valnum_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall n v r valu ge sp rs m, reg_valnum n v = Some r -> numbering_holds valu ge sp rs m n -> rs#r = valu v Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: inv H Step 6: Apply tactic: eapply num_holds_reg Step 7: Apply tactic: eauto Step 8: Apply tactic: eapply wf_num_val Step 9: Apply tactic: eauto with cse Step 10: Rewrite using an equality Step 11: Solve automatically using known facts", "retrieved_count": 9, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:regs_valnums_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall n valu ge sp rs m, numbering_holds valu ge sp rs m n -> forall vl rl, regs_valnums n vl = Some rl -> rs##rl = map valu vl Step 2: Proceed by induction on vl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - inv H0 Step 6: Solve automatically using known facts Step 7: Apply tactic: - destruct (reg_valnum n a) as [r1|] eqn:RV1 Step 8: Apply tactic: try discriminate Step 9: Case analysis by destructing a value Step 10: Apply tactic: inv H0 Step 11: Simplify the goal by computation", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:find_rhs_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall n rh r valu ge sp rs m, find_rhs n rh = Some r -> numbering_holds valu ge sp rs m n -> exists v, rhs_eval_to valu ge sp m rh v /\\ Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: try discriminate Step 6: Apply tactic: exploit find_valnum_rhs'_charact Step 7: Apply tactic: eauto Step 8: Introduce variables and assumptions Step 9: Apply tactic: erewrite reg_valnum_sound by eauto Step 10: Apply tactic: exploit num_holds_eq Step 11: Apply tactic: eauto", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:forget_reg_charact", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall n rd r v, wf_numbering n -> In r (PMap Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: get rd n Step 6: Apply tactic: (num_reg)) as [vd|] eqn:GET Step 7: Apply tactic: - rewrite PMap Step 8: Apply tactic: gsspec in H0 Step 9: Case analysis by destructing a value Step 10: Apply tactic: + subst v Step 11: Apply a theorem or hypothesis", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:update_reg_charact", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall n rd vd r v, wf_numbering n -> In r (PMap Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Rewrite using an equality Step 5: Apply tactic: gsspec in H0 Step 6: Case analysis by destructing a value Step 7: Apply tactic: - subst v Step 8: Case analysis by destructing a value Step 9: Apply tactic: + subst r Step 10: Apply a theorem or hypothesis Step 11: Apply tactic: gss", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:rhs_eval_to_inj", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall valu ge sp m rh v1 v2, rhs_eval_to valu ge sp m rh v1 -> rhs_eval_to valu ge sp m rh v2 -> v1 = v2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: inv H0 Step 5: Apply tactic: - congruence Step 6: Apply tactic: - congruence Step 7: Apply tactic: - assert (vargs0 = vargs) by eauto using eval_buil Step 8: Apply tactic: congruence Step 9: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:add_rhs_holds", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: A value number exists already Step 2: Assigning a new value number Step 3: We need to prove that forall valu1 ge sp rs m n rd rh rs', numbering_holds valu1 ge sp rs m n -> rhs_valid valu1 ge sp rh -> rhs_eval_to valu1 ge sp m rh (rs'#rd) -> wf_rhs n Step 4: Unfold a definition Step 5: Introduce variables and assumptions Step 6: Case analysis by destructing a value Step 7: Apply tactic: (num_eqs)) as [vres|] eqn:FIND Step 8: Apply tactic: exploit find_valnum_rhs_charact Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Apply tactic: exploit wf_num_eqs Step 12: Apply tactic: eauto with cse Step 13: Introduce variables and assumptions", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:add_op_holds", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: special case for moves Step 2: general case Step 3: We need to prove that forall valu1 ge sp rs m n op (args: list reg) v dst, numbering_holds valu1 ge sp rs m n -> eval_operation ge sp op rs##args m = Some v -> exists valu2, numbering_holds valu2 ge sp (rs#dst <- v) m (add_op n dst op args) Step 4: Unfold a definition Step 5: Introduce variables and assumptions Step 6: Case analysis by destructing a value Step 7: Apply tactic: exploit is_move_operation_correct Step 8: Apply tactic: eauto Step 9: Introduce variables and assumptions Step 10: Apply tactic: subst op args Step 11: Simplify the goal by computation Step 12: Apply tactic: inv H0 Step 13: Case analysis by destructing a value", "retrieved_count": 3, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:add_builtin_holds", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall valu1 ge sp rs m n bf args res vargs vres, numbering_holds valu1 ge sp rs m n -> eval_builtin_args ge (fun r => rs#r) sp m args vargs -> builtin_function_sem bf vargs = Some vres -> exists valu2, numbering_holds valu2 ge sp (regmap_setres res vres rs) m (add_builtin n res bf args) Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Simplify the goal by computation Step 6: Apply tactic: eauto Step 7: Case analysis by destructing a value Step 8: Apply tactic: exploit valnum_builtin_args_holds Step 9: Apply tactic: eauto Step 10: Introduce variables and assumptions Step 11: Apply tactic: eapply add_rhs_holds", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:set_unknown_holds", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall valu ge sp rs m n r v, numbering_holds valu ge sp rs m n -> numbering_holds valu ge sp (rs#r <- v) m (set_unknown n r) Step 2: Introduce variables and assumptions Step 3: Apply tactic: constructor Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Apply tactic: - constructor Step 7: Simplify the goal by computation Step 8: Introduce variables and assumptions Step 9: Apply tactic: + eauto with cse Step 10: Apply tactic: + rewrite PTree Step 11: Apply tactic: grspec in H0", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:set_res_unknown_holds", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall valu ge sp rs m n r v, numbering_holds valu ge sp rs m n -> numbering_holds valu ge sp (regmap_setres r v rs) m (set_res_unknown n r) Step 2: Introduce variables and assumptions Step 3: Case analysis by destructing a value Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:kill_eqs_charact", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall pred l strict r eqs, In (Eq l strict r) (kill_eqs pred eqs) -> pred r = false /\\ In (Eq l strict r) eqs Step 2: Proceed by induction on eqs Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - tauto Step 6: Apply tactic: - destruct a Step 7: Case analysis by destructing a value Step 8: Apply tactic: tauto Step 9: Apply tactic: inv H Step 10: Apply tactic: inv H0 Step 11: Solve automatically using known facts", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:kill_equations_hold", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall valu ge sp rs m n pred m', numbering_holds valu ge sp rs m n -> (forall r v, pred r = false -> rhs_valid valu ge sp r -> rhs_eval_to valu ge sp m r v -> rhs_eval_to valu ge sp m' r v) -> numbering_holds valu ge sp rs m' (kill_equations pred n) Step 2: Introduce variables and assumptions Step 3: Apply tactic: constructor Step 4: Simplify the goal by computation Step 5: Introduce variables and assumptions Step 6: Apply tactic: - constructor Step 7: Simplify the goal by computation Step 8: Introduce variables and assumptions Step 9: Apply tactic: eauto with cse Step 10: Case analysis by destructing a value Step 11: Apply tactic: exploit kill_eqs_charact", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:kill_all_loads_hold", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall valu ge sp rs m n m', numbering_holds valu ge sp rs m n -> numbering_holds valu ge sp rs m' (kill_all_loads n) Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply kill_equations_hold Step 4: Apply tactic: eauto Step 5: Unfold a definition Step 6: Introduce variables and assumptions Step 7: Apply tactic: inv H2 Step 8: Apply tactic: - constructor Step 9: Rewrite using an equality Step 10: Apply a theorem or hypothesis Step 11: Solve automatically using known facts", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:kill_cheap_computations_hold", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall valu ge sp rs m n, numbering_holds valu ge sp rs m n -> numbering_holds valu ge sp rs m (kill_cheap_computations n) Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply kill_equations_hold Step 4: Apply tactic: eauto Step 5: Apply tactic: Qed", "retrieved_count": 5, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:store_normalized_range_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall bc chunk v, vmatch bc v (store_normalized_range chunk) -> Val Step 2: Introduce variables and assumptions Step 3: Unfold a definition Step 4: Apply tactic: load_result Step 5: Apply tactic: remember Archi Step 6: Apply tactic: ptr64 as ptr64 Step 7: Case analysis by destructing a value Step 8: Simplify the goal by computation Step 9: Case analysis by destructing a value Step 10: Solve automatically using known facts Step 11: Apply tactic: - inv H", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:shift_memcpy_eq_wf", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall src sz delta e e' next, shift_memcpy_eq src sz delta e = Some e' -> wf_equation next e -> wf_equation next e' Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Case analysis by destructing a value Step 6: Case analysis by destructing a value Step 7: Apply tactic: try (rename i into ofs) Step 8: Case analysis by destructing a value Step 9: Apply tactic: unsigned ofs) && Step 10: Apply tactic: zle (Ptrofs Step 11: Apply tactic: unsigned ofs + size_chunk m) (src + sz) &&", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:shift_memcpy_eq_holds", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall src dst sz e e' m sp bytes m' valu ge, shift_memcpy_eq src sz (dst - src) e = Some e' -> Mem Step 2: Introduce variables and assumptions Step 3: Apply tactic: set (delta := dst - src) in * Step 4: Unfold a definition Step 5: Case analysis by destructing a value Step 6: Case analysis by destructing a value Step 7: Case analysis by destructing a value Step 8: Apply tactic: try (rename i into ofs) Step 9: Apply tactic: set (i1 := Ptrofs Step 10: Apply tactic: unsigned ofs) in * Step 11: Apply tactic: set (j := i1 + delta) in *", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:add_memcpy_eqs_charact", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall e' src sz delta eqs2 eqs1, In e' (add_memcpy_eqs src sz delta eqs1 eqs2) -> In e' eqs2 \\/ exists e, In e eqs1 /\\ shift_memcpy_eq src sz delta e = Some e' Step 2: Proceed by induction on eqs1 Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: - auto Step 6: Apply tactic: - destruct (shift_memcpy_eq src sz delta a) as [e' Step 7: Apply tactic: + destruct H Step 8: Apply tactic: subst e'' Step 9: Apply tactic: right Step 10: Provide an existential witness Step 11: Solve automatically using known facts", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:reduce_rec_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall niter op args op' rl' res, reduce_rec A f n niter op args = Some(op', rl') -> sem op (map valu args) = Some res -> sem op' (rs##rl') = Some res Step 2: Proceed by induction on niter Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: discriminate Step 6: Case analysis by destructing a value Step 7: Apply tactic: as [[op1 args1] | ] eqn:? Step 8: Apply tactic: assert (sem op1 (map valu args1) = Some res) Step 9: Rewrite using an equality Step 10: Apply tactic: eapply f_sound Step 11: Apply tactic: eauto", "retrieved_count": 7, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:reduce_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall op rl vl op' rl' res, reduce A f n op rl vl = (op', rl') -> map valu vl = rs##rl -> sem op rs##rl = Some res -> sem op' rs##rl' = Some res Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: inv H Step 6: Apply tactic: eapply reduce_rec_sound Step 7: Apply tactic: eauto Step 8: Apply tactic: congruence Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:reduce_rec_lessdef_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall niter op args op' rl' r, reduce_rec A f n niter op args = Some(op', rl') -> sem op (map valu args) = Some r -> exists r', sem op' (rs##rl') = Some r' /\\ Val Step 2: Proceed by induction on niter Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: discriminate Step 6: Case analysis by destructing a value Step 7: Apply tactic: as [[op1 args1] | ] eqn:? Step 8: Apply tactic: try discriminate Step 9: Apply tactic: assert (exists r': val, sem op1 (map valu args1) = Step 10: Apply tactic: lessdef r r') Step 11: Apply tactic: { exploit f_sound", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:reduce_lessdef_sound", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall op rl vl op' rl' r, reduce A f n op rl vl = (op', rl') -> map valu vl = rs##rl -> sem op rs##rl = Some r -> exists r', sem op' rs##rl' = Some r' /\\ Val Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: eapply reduce_rec_lessdef_sound Step 6: Apply tactic: eauto Step 7: Apply tactic: inv H Step 8: Apply tactic: eexact Heqo Step 9: Apply tactic: congruence Step 10: Provide an existential witness Step 11: Apply tactic: inv H", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:analysis_correct_entry", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge sp rs m f dm vapprox approx, analyze f dm vapprox = Some approx -> exists valu, numbering_holds valu ge sp rs m approx!!(f Step 2: Introduce variables and assumptions Step 3: Apply tactic: replace (approx!!(f Step 4: Apply tactic: (fn_entrypoint))) with Solver Step 5: Apply tactic: top Step 6: Provide an existential witness Step 7: Apply a theorem or hypothesis Step 8: Apply tactic: symmetry Step 9: Apply tactic: eapply Solver Step 10: Apply tactic: fixpoint_entry Step 11: Apply tactic: eauto", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:symbols_preserved", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall (s: ident), Genv Step 2: Apply tactic: Lemma senv_preserved: Step 3: Apply tactic: Senv Step 4: Apply tactic: equiv ge tge Step 5: Apply tactic: Lemma functions_translated: Step 6: Apply tactic: forall (v: val) (f: RTL Step 7: Apply tactic: fundef), Step 8: Apply tactic: Genv Step 9: Apply tactic: find_funct ge v = Some f -> Step 10: Provide an existential witness Step 11: Apply tactic: find_funct tge v = Some tf", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:senv_preserved", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that Senv Step 2: Apply tactic: Lemma functions_translated: Step 3: Apply tactic: forall (v: val) (f: RTL Step 4: Apply tactic: fundef), Step 5: Apply tactic: Genv Step 6: Apply tactic: find_funct ge v = Some f -> Step 7: Provide an existential witness Step 8: Apply tactic: find_funct tge v = Some tf Step 9: Apply tactic: /\\ transf_fundef (prog_defmap cu) (romem_for cu) f Step 10: Apply tactic: /\\ linkorder cu prog Step 11: Apply tactic: Lemma funct_ptr_translated:", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:functions_translated", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall (v: val) (f: RTL Step 2: Apply tactic: Lemma funct_ptr_translated: Step 3: Apply tactic: forall (b: block) (f: RTL Step 4: Apply tactic: fundef), Step 5: Apply tactic: Genv Step 6: Apply tactic: find_funct_ptr ge b = Some f -> Step 7: Provide an existential witness Step 8: Apply tactic: find_funct_ptr tge b = Some tf Step 9: Apply tactic: /\\ transf_fundef (prog_defmap cu) (romem_for cu) f Step 10: Apply tactic: /\\ linkorder cu prog Step 11: Apply tactic: Lemma sig_preserved:", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:sig_preserved", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall dm rm f tf, transf_fundef dm rm f = OK tf -> funsig tf = funsig f Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: monadInv H Step 6: Solve automatically using known facts Step 7: Unfold a definition Step 8: Case analysis by destructing a value Step 9: Apply tactic: try discriminate Step 10: Apply tactic: inv EQ Step 11: Solve automatically using known facts", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:regs_lessdef_regs", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall rs1 rs2, regs_lessdef rs1 rs2 -> forall rl, Val Step 2: Proceed by induction on rl Step 3: Apply tactic: constructor Step 4: Solve automatically using known facts Step 5: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:set_reg_lessdef", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall r v1 v2 rs1 rs2, Val Step 2: Introduce variables and assumptions Step 3: Apply tactic: red Step 4: Introduce variables and assumptions Step 5: Apply tactic: repeat rewrite Regmap Step 6: Apply tactic: gsspec Step 7: Case analysis by destructing a value Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:init_regs_lessdef", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall rl vl1 vl2, Val Step 2: Proceed by induction on rl Step 3: Simplify the goal by computation Step 4: Introduce variables and assumptions Step 5: Apply tactic: red Step 6: Introduce variables and assumptions Step 7: Rewrite using an equality Step 8: Solve automatically using known facts Step 9: Apply tactic: inv H Step 10: Apply tactic: red Step 11: Introduce variables and assumptions", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:find_function_translated", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ros rs fd rs', find_function ge ros rs = Some fd -> regs_lessdef rs rs' -> exists cu tfd, find_function tge ros rs' = Some tfd /\\ transf_fundef (prog_defmap cu) (romem_for cu) fd = OK tfd /\\ linkorder cu prog Step 2: Unfold a definition Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: - specialize (H0 r) Step 6: Apply tactic: inv H0 Step 7: Apply a theorem or hypothesis Step 8: Solve automatically using known facts Step 9: Rewrite using an equality Step 10: Apply tactic: discriminate Step 11: Apply tactic: - rewrite symbols_preserved", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:transf_step_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: unchanged Step 2: possibly optimized Step 3: the builtin function fails Step 4: other function Step 5: Itailcall Step 6: Ibuiltin Step 7: Ijumptable Step 8: internal function Step 9: external function Step 10: replaced by move Step 11: possibly simplified Step 12: replaced by move Step 13: load is preserved, but addressing is possibly simplified Step 14: known runtime function Step 15: turned into a move Step 16: left as a call Step 17: the builtin function succeeds Step 18: We need to prove that forall s1 t s2, step ge s1 t s2 -> forall s1' (MS: match_states s1 s1') (SOUND: sound_state prog s1), (exists s2', step tge s1' t s2' /\\ match_states s2 s2') \\/ (exists s2' n, plus step tge s1' t s2' /\\ eventually n s2 (fun s3 => match_states s3 s2')) Step 19: Proceed by induction on 1 Step 20: Introduce variables and assumptions Step 21: Apply tactic: inv MS Step 22: Apply tactic: try (TransfInstr Step 23: Apply tactic: intro C) Step 24: Apply tactic: left Step 25: Apply tactic: econstructor Step 26: Split a conjunction into separate goals Step 27: Apply tactic: eapply exec_Inop Step 28: Apply tactic: eauto", "retrieved_count": 2, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:transf_initial_states", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall st1, initial_state prog st1 -> exists st2, initial_state tprog st2 /\\ match_states st1 st2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inversion H Step 4: Apply tactic: exploit funct_ptr_translated Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Provide an existential witness Step 8: Split a conjunction into separate goals Step 9: Apply tactic: econstructor Step 10: Apply tactic: eauto Step 11: Apply tactic: eapply (Genv", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:transf_final_states", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall st1 st2 r, match_states st1 st2 -> final_state st1 r -> final_state st2 r Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Apply tactic: inv H Step 5: Apply tactic: inv RES Step 6: Apply tactic: inv STACK Step 7: Apply tactic: constructor Step 8: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:CSEproof:transf_program_correct", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forward_simulation (RTL Step 2: Apply tactic: eapply forward_simulation_eventually_plus with Step 3: Apply tactic: (match_states := fun s1 s2 => match_states s1 s2 / Step 4: Apply tactic: - apply senv_preserved Step 5: Apply tactic: - intros Step 6: Apply tactic: exploit transf_initial_states Step 7: Apply tactic: eauto Step 8: Introduce variables and assumptions Step 9: Provide an existential witness Step 10: Solve automatically using known facts Step 11: Apply tactic: - intros", "retrieved_count": 6, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:star_one", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge s1 t s2, step ge s1 t s2 -> star ge s1 t s2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply star_step Step 4: Apply tactic: eauto Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: traceEq Step 7: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:star_two", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge s1 t1 s2 t2 s3 t, step ge s1 t1 s2 -> step ge s2 t2 s3 -> t = t1 ** t2 -> star ge s1 t s3 Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply star_step Step 4: Apply tactic: eauto Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:star_three", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge s1 t1 s2 t2 s3 t3 s4 t, step ge s1 t1 s2 -> step ge s2 t2 s3 -> step ge s3 t3 s4 -> t = t1 ** t2 ** t3 -> star ge s1 t s4 Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply star_step Step 4: Apply tactic: eauto Step 5: Apply tactic: eapply star_two Step 6: Apply tactic: eauto Step 7: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:star_four", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge s1 t1 s2 t2 s3 t3 s4 t4 s5 t, step ge s1 t1 s2 -> step ge s2 t2 s3 -> step ge s3 t3 s4 -> step ge s4 t4 s5 -> t = t1 ** t2 ** t3 ** t4 -> star ge s1 t s5 Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply star_step Step 4: Apply tactic: eauto Step 5: Apply tactic: eapply star_three Step 6: Apply tactic: eauto Step 7: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:star_trans", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge s1 t1 s2, star ge s1 t1 s2 -> forall t2 s3 t, star ge s2 t2 s3 -> t = t1 ** t2 -> star ge s1 t s3 Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Rewrite using an equality Step 5: Simplify the goal by computation Step 6: Solve automatically using known facts Step 7: Apply tactic: eapply star_step Step 8: Apply tactic: eauto Step 9: Apply tactic: traceEq Step 10: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:star_left", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge s1 t1 s2 t2 s3 t, step ge s1 t1 s2 -> star ge s2 t2 s3 -> t = t1 ** t2 -> star ge s1 t s3 Step 2: Apply tactic: Lemma star_right: Step 3: Apply tactic: forall ge s1 t1 s2 t2 s3 t, Step 4: Apply tactic: star ge s1 t1 s2 -> step ge s2 t2 s3 -> t = t1 ** Step 5: Apply tactic: star ge s1 t s3 Step 6: Introduce variables and assumptions Step 7: Apply tactic: eapply star_trans Step 8: Apply tactic: eauto Step 9: Apply a theorem or hypothesis Step 10: Apply tactic: eauto Step 11: Solve automatically using known facts", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:star_right", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge s1 t1 s2 t2 s3 t, star ge s1 t1 s2 -> step ge s2 t2 s3 -> t = t1 ** t2 -> star ge s1 t s3 Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply star_trans Step 4: Apply tactic: eauto Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: eauto Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:star_E0_ind", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge (P: state -> state -> Prop), (forall s, P s s) -> (forall s1 s2 s3, step ge s1 E0 s2 -> P s2 s3 -> P s1 s3) -> forall s1 s2, star ge s1 E0 s2 -> P s1 s2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (forall s1 t s2, star ge s1 t s2 -> t = E0 Step 4: Proceed by induction on 1 Step 5: Introduce variables and assumptions Step 6: Apply tactic: subst Step 7: Solve automatically using known facts Step 8: Case analysis by destructing a value Step 9: Apply tactic: subst Step 10: Apply tactic: eauto Step 11: Apply tactic: eauto", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:plus_one", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge s1 t s2, step ge s1 t s2 -> plus ge s1 t s2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: econstructor Step 4: Apply tactic: eauto Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: traceEq Step 7: Apply tactic: Qed", "retrieved_count": 8, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:plus_two", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge s1 t1 s2 t2 s3 t, step ge s1 t1 s2 -> step ge s2 t2 s3 -> t = t1 ** t2 -> plus ge s1 t s3 Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply plus_left Step 4: Apply tactic: eauto Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:plus_three", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge s1 t1 s2 t2 s3 t3 s4 t, step ge s1 t1 s2 -> step ge s2 t2 s3 -> step ge s3 t3 s4 -> t = t1 ** t2 ** t3 -> plus ge s1 t s4 Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply plus_left Step 4: Apply tactic: eauto Step 5: Apply tactic: eapply star_two Step 6: Apply tactic: eauto Step 7: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:plus_four", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge s1 t1 s2 t2 s3 t3 s4 t4 s5 t, step ge s1 t1 s2 -> step ge s2 t2 s3 -> step ge s3 t3 s4 -> step ge s4 t4 s5 -> t = t1 ** t2 ** t3 ** t4 -> plus ge s1 t s5 Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply plus_left Step 4: Apply tactic: eauto Step 5: Apply tactic: eapply star_three Step 6: Apply tactic: eauto Step 7: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:plus_star", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge s1 t s2, plus ge s1 t s2 -> star ge s1 t s2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inversion H Step 4: Apply tactic: subst Step 5: Apply tactic: eapply star_step Step 6: Apply tactic: eauto Step 7: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:plus_right", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge s1 t1 s2 t2 s3 t, star ge s1 t1 s2 -> step ge s2 t2 s3 -> t = t1 ** t2 -> plus ge s1 t s3 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inversion H Step 4: Apply tactic: subst Step 5: Simplify the goal by computation Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Rewrite using an equality Step 9: Apply tactic: eapply plus_left Step 10: Apply tactic: eauto Step 11: Apply tactic: eapply star_right", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:plus_star_trans", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge s1 t1 s2 t2 s3 t, plus ge s1 t1 s2 -> star ge s2 t2 s3 -> t = t1 ** t2 -> plus ge s1 t s3 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inversion H Step 4: Apply tactic: subst Step 5: Apply tactic: econstructor Step 6: Apply tactic: eauto Step 7: Apply tactic: eapply star_trans Step 8: Apply tactic: eauto Step 9: Apply tactic: traceEq Step 10: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:star_plus_trans", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge s1 t1 s2 t2 s3 t, star ge s1 t1 s2 -> plus ge s2 t2 s3 -> t = t1 ** t2 -> plus ge s1 t s3 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inversion H Step 4: Apply tactic: subst Step 5: Simplify the goal by computation Step 6: Solve automatically using known facts Step 7: Rewrite using an equality Step 8: Apply tactic: econstructor Step 9: Apply tactic: eauto Step 10: Apply tactic: eapply star_trans Step 11: Apply tactic: eauto", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:plus_trans", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge s1 t1 s2 t2 s3 t, plus ge s1 t1 s2 -> plus ge s2 t2 s3 -> t = t1 ** t2 -> plus ge s1 t s3 Step 2: Introduce variables and assumptions Step 3: Apply tactic: eapply plus_star_trans Step 4: Apply tactic: eauto Step 5: Apply a theorem or hypothesis Step 6: Apply tactic: eauto Step 7: Solve automatically using known facts Step 8: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:plus_inv", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge s1 t s2, plus ge s1 t s2 -> step ge s1 t s2 \\/ exists s', exists t1, exists t2, step ge s1 t1 s' /\\ plus ge s' t2 s2 /\\ t = t1 ** t2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inversion H Step 4: Apply tactic: subst Step 5: Apply tactic: inversion H1 Step 6: Apply tactic: subst Step 7: Apply tactic: left Step 8: Rewrite using an equality Step 9: Solve automatically using known facts Step 10: Apply tactic: right Step 11: Provide an existential witness", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:star_inv", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge s1 t s2, star ge s1 t s2 -> (s2 = s1 /\\ t = E0) \\/ plus ge s1 t s2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: left Step 5: Solve automatically using known facts Step 6: Apply tactic: right Step 7: Apply tactic: econstructor Step 8: Apply tactic: eauto Step 9: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:plus_ind2", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge (P: state -> trace -> state -> Prop), (forall s1 t s2, step ge s1 t s2 -> P s1 t s2) -> (forall s1 t1 s2 t2 s3 t, step ge s1 t1 s2 -> plus ge s2 t2 s3 -> P s2 t2 s3 -> t = t1 ** t2 -> P s1 t s3) -> forall s1 t s2, plus ge s1 t s2 -> P s1 t s2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: assert (forall s1 t s2, star ge s1 t s2 -> Step 4: Apply tactic: forall s0 t0, step ge s0 t0 s1 -> Step 5: Apply tactic: P s0 (t0 ** t) s2) Step 6: Proceed by induction on 1 Step 7: Introduce variables and assumptions Step 8: Rewrite using an equality Step 9: Apply a theorem or hypothesis Step 10: Solve automatically using known facts Step 11: Apply tactic: eapply IND", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:plus_E0_ind", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge (P: state -> state -> Prop), (forall s1 s2 s3, step ge s1 E0 s2 -> star ge s2 E0 s3 -> P s1 s3) -> forall s1 s2, plus ge s1 E0 s2 -> P s1 s2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Apply tactic: exploit Eapp_E0_inv Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Apply tactic: subst Step 8: Apply tactic: eauto Step 9: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:starN_star", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge n s t s', starN ge n s t s' -> star ge s t s' Step 2: Proceed by induction on 1 Step 3: Apply tactic: econstructor Step 4: Apply tactic: eauto Step 5: Apply tactic: Qed", "retrieved_count": 1, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:star_starN", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge s t s', star ge s t s' -> exists n, starN ge n s t s' Step 2: Proceed by induction on 1 Step 3: Provide an existential witness Step 4: Apply tactic: constructor Step 5: Case analysis by destructing a value Step 6: Provide an existential witness Step 7: Apply tactic: econstructor Step 8: Apply tactic: eauto Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:star_forever", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge s1 t s2, star ge s1 t s2 -> forall T, forever ge s2 T -> forever ge s1 (t *** T) Step 2: Proceed by induction on 1 Step 3: Introduce variables and assumptions Step 4: Simplify the goal by computation Step 5: Solve automatically using known facts Step 6: Apply tactic: subst t Step 7: Rewrite using an equality Step 8: Apply tactic: econstructor Step 9: Apply tactic: eauto Step 10: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:forever_N_inv", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: star case Step 2: no transition Step 3: at least one transition Step 4: plus case Step 5: We need to prove that forall ge a s T, forever_N ge a s T -> exists t, exists s', exists a', exists T', step ge s t s' /\\ forever_N ge a' s' T' /\\ T = t *** T' Step 6: Introduce variables and assumptions Step 7: Apply tactic: pattern a0 Step 8: Apply a theorem or hypothesis Step 9: Introduce variables and assumptions Step 10: Apply tactic: inv H0 Step 11: Apply tactic: inv H1 Step 12: Apply tactic: change (E0 *** T2) with T2 Step 13: Apply a theorem or hypothesis Step 14: Solve automatically using known facts Step 15: Solve automatically using known facts", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:forever_N_forever", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge a s T, forever_N ge a s T -> forever ge s T Step 2: Apply tactic: cofix COINDHYP Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Rewrite using an equality Step 6: Apply a theorem or hypothesis Step 7: Solve automatically using known facts Step 8: Apply a theorem or hypothesis Step 9: Solve automatically using known facts Step 10: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:forever_plus_inv", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge s T, forever_plus ge s T -> exists s', exists t, exists T', step ge s t s' /\\ forever_plus ge s' T' /\\ T = t *** T' Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H Step 4: Apply tactic: inv H0 Step 5: Provide an existential witness Step 6: Provide an existential witness Step 7: Provide an existential witness Step 8: Split a conjunction into separate goals Step 9: Solve automatically using known facts Step 10: Split a conjunction into separate goals Step 11: Apply tactic: exploit star_inv", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:forever_plus_forever", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge s T, forever_plus ge s T -> forever ge s T Step 2: Apply tactic: cofix COINDHYP Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply tactic: subst Step 6: Apply tactic: econstructor Step 7: Apply tactic: eauto Step 8: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:forever_silent_N_inv", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: star case Step 2: no transition Step 3: at least one transition Step 4: plus case Step 5: We need to prove that forall ge a s, forever_silent_N ge a s -> exists s', exists a', step ge s E0 s' /\\ forever_silent_N ge a' s' Step 6: Introduce variables and assumptions Step 7: Apply tactic: pattern a0 Step 8: Apply a theorem or hypothesis Step 9: Introduce variables and assumptions Step 10: Apply tactic: inv H0 Step 11: Apply tactic: inv H1 Step 12: Apply a theorem or hypothesis Step 13: Solve automatically using known facts Step 14: Solve automatically using known facts Step 15: Apply tactic: exploit Eapp_E0_inv", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:forever_silent_N_forever", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge a s, forever_silent_N ge a s -> forever_silent ge s Step 2: Apply tactic: cofix COINDHYP Step 3: Introduce variables and assumptions Step 4: Case analysis by destructing a value Step 5: Apply a theorem or hypothesis Step 6: Solve automatically using known facts Step 7: Apply a theorem or hypothesis Step 8: Solve automatically using known facts Step 9: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:star_forever_reactive", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge s1 t s2 T, star ge s1 t s2 -> forever_reactive ge s2 T -> forever_reactive ge s1 (t *** T) Step 2: Introduce variables and assumptions Step 3: Apply tactic: inv H0 Step 4: Rewrite using an equality Step 5: Apply tactic: econstructor Step 6: Apply tactic: eapply star_trans Step 7: Apply tactic: eauto Step 8: Apply tactic: red Step 9: Apply tactic: intro Step 10: Apply tactic: exploit Eapp_E0_inv Step 11: Apply tactic: eauto", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:eventually_one", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge s (P: state -> Prop), (forall r, ~ final_state s r) -> (forall t s', step ge s t s' -> t = E0 /\\ P s') -> eventually ge 1%nat s P Step 2: Introduce variables and assumptions Step 3: Apply a theorem or hypothesis Step 4: Solve automatically using known facts Step 5: Introduce variables and assumptions Step 6: Apply a theorem or hypothesis Step 7: Apply tactic: intuition auto using eventually Step 8: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:eventually_trans", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge n1 s1 P1 n2 P2, eventually ge n1 s1 P1 -> (forall s2, P1 s2 -> eventually ge n2 s2 P2) -> eventually ge (n1 + n2)%nat s1 P2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: revert n1 s1 H Step 4: Proceed by induction on n1 Step 5: Introduce variables and assumptions Step 6: Apply tactic: inv EV Step 7: Simplify the goal by computation Step 8: Apply tactic: - apply H0 Step 9: Apply tactic: assumption Step 10: Apply tactic: - apply eventually_later Step 11: Solve automatically using known facts", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:eventually_implies", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge n s (P1 P2: state -> Prop), eventually ge n s P1 -> (forall s, P1 s -> P2 s) -> eventually ge n s P2 Step 2: Introduce variables and assumptions Step 3: Apply tactic: replace n with (n + 0)%nat by lia Step 4: Apply tactic: eapply eventually_trans Step 5: Apply tactic: eauto using eventually_now Step 6: Apply tactic: Qed", "retrieved_count": 10, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:eventually_and_invariant", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forall ge (Inv: state -> Prop) n s P, (forall s t s', step ge s t s' -> Inv s -> Inv s') -> eventually ge n s P -> Inv s -> eventually ge n s (fun s' => P s' /\\ Inv s') Step 2: Introduce variables and assumptions Step 3: Apply tactic: revert n s H0 H1 Step 4: Proceed by induction on n Step 5: Introduce variables and assumptions Step 6: Apply tactic: inv EV Step 7: Apply tactic: - apply eventually_now Step 8: Solve automatically using known facts Step 9: Apply tactic: - apply eventually_later Step 10: Solve automatically using known facts Step 11: Introduce variables and assumptions", "retrieved_count": 4, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:forward_simulation_star_wf", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forward_simulation L1 L2 Step 2: Apply a theorem or hypothesis Step 3: Apply tactic: constructor Step 4: Apply tactic: - auto Step 5: Apply tactic: - intros Step 6: Apply tactic: exploit match_initial_states Step 7: Apply tactic: eauto Step 8: Introduce variables and assumptions Step 9: Provide an existential witness Step 10: Provide an existential witness Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:forward_simulation_star", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forward_simulation L1 L2 Step 2: Apply a theorem or hypothesis Step 3: Apply a theorem or hypothesis Step 4: Introduce variables and assumptions Step 5: Apply tactic: exploit simulation Step 6: Apply tactic: eauto Step 7: Introduce variables and assumptions Step 8: Provide an existential witness Step 9: Solve automatically using known facts Step 10: Provide an existential witness Step 11: Split a conjunction into separate goals", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:forward_simulation_plus", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forward_simulation L1 L2 Step 2: Apply a theorem or hypothesis Step 3: Introduce variables and assumptions Step 4: Apply tactic: exploit simulation Step 5: Apply tactic: eauto Step 6: Apply tactic: Qed", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:forward_simulation_step", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forward_simulation L1 L2 Step 2: Apply a theorem or hypothesis Step 3: Introduce variables and assumptions Step 4: Apply tactic: exploit simulation Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Provide an existential witness Step 8: Split a conjunction into separate goals Step 9: Solve automatically using known facts Step 10: Apply a theorem or hypothesis Step 11: Solve automatically using known facts", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
{"id": "CompCert:Smallstep:forward_simulation_opt", "draft": "Lemma placeholder: forall (A : Type) (x : A), x = x.\nProof. reflexivity. Qed.", "nl_proof": "Step 1: We need to prove that forward_simulation L1 L2 Step 2: Apply a theorem or hypothesis Step 3: Introduce variables and assumptions Step 4: Apply tactic: exploit simulation Step 5: Apply tactic: eauto Step 6: Introduce variables and assumptions Step 7: Apply tactic: left Step 8: Provide an existential witness Step 9: Split a conjunction into separate goals Step 10: Solve automatically using known facts Step 11: Apply a theorem or hypothesis", "retrieved_count": 0, "metadata": {"source": "data/nl_steps/all_proofs_grouped.jsonl", "top_k": 10, "threshold": 0.8}}
