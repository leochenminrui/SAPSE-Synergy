lemma_id,baseline_status,strict_status,fast_status,synergy_status,baseline_runtime,strict_runtime,fast_runtime,synergy_runtime,baseline_urc,strict_urc,fast_urc,synergy_urc,category,in_frag_baseline,in_frag_strict,in_frag_fast,in_frag_synergy,ast_depth,binder_count,complexity_band,raw_ast,baseline_final_ast,strict_final_ast,fast_final_ast,synergy_final_ast,baseline_error,strict_error,fast_error,synergy_error
CompCert:Stacklayout:frame_env_separated,Failed,Failed,Failed,Failed,452.77,353.56,197.61,214.89,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.
Require Import Coq.ZArith.ZArith.

Lemma range_split_align_template : forall (base align size1 size2 : Z),
  align > 0 ->
  (align | base) ->
  (align | size1) ->
  (align | size2) ->
  base + align * (size1 + size2) = base + align * size1 + align * size2.
Proof.
  intros base align size1 size2 Hpos Halign_base Halign1 Halign2.
  rewrite Z.mul_add_distr_l.
  rewrite <- Z.add_assoc.
  reflexivity.
Qed.",,,,,,,,
CompCert:Stacklayout:frame_env_range,Failed,Abstained,Failed,Failed,312.64,0.38,193.0,197.92,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.

Lemma frame_env_range : forall (b : Z),
  let fe := make_env b in
  0 <= fe_stack_data fe /\ fe_stack_data fe + bound_stack_data b <= fe_size fe.
Proof.
  intros b fe.
  unfold fe.
  unfold make_env.
  set (ol := align (8 + 4 * bound_outgoing b) 8).
  set (w := if Archi.ptr64 then 8 else 4).
  set (olink := align (4 * bound_local b) w).
  set (ora := olink + w).
  set (ocs := ora + w).
  set (oendcs := size_callee_save_area b ocs).
  set (ol := align oendcs 8).",,,,,,,,
CompCert:Stacklayout:frame_env_aligned,Failed,Abstained,Failed,Failed,304.49,0.05,191.82,223.87,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import Coq.Arith.Align.

Lemma frame_env_aligned : forall (b : nat),
  let fe := make_env b in
  (8 | fe_ofs_arg) /\
  (8 | fe_ofs_local fe) /\
  (8 | fe_stack_data fe) /\
  (align_chunk Mptr | fe_ofs_link fe) /\
  (align_chunk Mptr | fe_ofs_retaddr fe).
Proof.
  intros b fe.
  unfold fe.
  repeat split.
  all: unfold fe_ofs_arg, fe_ofs_local, fe_stack_data, fe_ofs_link, fe_ofs_retaddr.
  all: try apply align_divides; auto.
  all: compute; auto.
Qed.",,,,,,,,
CompCert:Archi:splitlong_ptr32,Failed,Failed,Failed,Failed,60.34,56.23,39.64,42.79,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Bool.Bool.
Lemma splitlong_ptr32 : forall (splitlong ptr64 : bool), splitlong = true -> ptr64 = false.
Proof. intros splitlong ptr64 H. destruct splitlong, ptr64; congruence. Qed.",,,,,,,,
CompCert:Archi:choose_nan_64_idem,Failed,Failed,Failed,Failed,123.56,111.31,76.31,83.42,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma choose_nan_64_idem : forall (n : nat), choose_nan_64 (n :: n :: nil) = choose_nan_64 (n :: nil).
Proof. apply choose_nan_64_idem. Qed.",,,,,,,,
CompCert:Archi:choose_nan_32_idem,Failed,Failed,Failed,Failed,64.66,112.93,92.67,82.16,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma choose_nan_32_idem : forall (A : Type) (n : A), choose_nan_32 (n :: n :: nil) = choose_nan_32 (n :: nil).
Proof. auto. Qed.",,,,,,,,
CompCert:ConstpropOpproof:match_G,Verified,Verified,Failed,Failed,127.62,131.21,116.78,84.85,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma map_id_poly : forall (A : Type) (l : list A), map (fun (x : A) => x) l = l.
Proof. induction l; simpl; congruence. Qed.",,,,,,,,
CompCert:ConstpropOpproof:match_S,Verified,Verified,Failed,Failed,123.56,128.14,77.39,83.04,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma map_id_poly : forall (A : Type) (l : list A), map (fun (x : A) => x) l = l.
Proof. induction l; simpl; congruence. Qed.",,,,,,,,
CompCert:ConstpropOpproof:const_for_result_correct,Failed,Failed,Failed,Failed,102.25,105.88,76.26,81.79,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma const_for_result_correct : forall (ge : Genv.t (fundef unit) unit) (sp : block) (bc : block_classification) (a : aval) (op : operation) (v : val) (m : mem),
  const_for_result a = Some op ->
  vmatch bc v a ->
  exists v', eval_operation ge (Vptr sp Ptrofs.zero) op nil m = Some v' /\ Val.lessdef v v'.
Proof.
  intros ge sp bc a op v m H H0.
  generalize Archi.ptr64.
  intros ptr64.
  destruct a; try discriminate H.
  - inv H. exists v. ",,,,,,,,
CompCert:ConstpropOpproof:cond_strength_reduction_correct,Failed,Abstained,Failed,Failed,101.9,0.23,77.06,83.75,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma cond_strength_reduction_correct : forall (cond : condition) (args : list reg) (vl : list aval),
  vl = map (fun r : reg => AE.get r ae) args ->
  let (cond', args') := cond_strength_reduction cond args vl in
  eval_condition cond' e##args' m = eval_condition cond e##args m.
Proof.
  intros cond args vl H.
  case (cond_strength_reduction_match cond args vl); simpl; auto.
Qed.",,,,,,,,
CompCert:ConstpropOpproof:make_addimm_correct,Failed,Abstained,Failed,Failed,223.6,0.04,158.52,170.11,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma make_addimm_correct : forall (n : Int.int) (r : positive),
  let (op, args) := make_addimm n r in
  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op (e##args) m = Some v /\ Val.lessdef (Val.add (e#r) (Vint n)) v.
Proof.
  intros n r. unfold make_addimm. destruct (Int.eq_dec n Int.zero).
  - subst. exists (e#r). split.
    + simpl. destruct (e#r); simpl; auto.
    + apply Val.lessdef_refl.
  - exists (Val.add (e#r) (Vint n)). split.
    + simpl. auto.
   ",,,,,,,,
CompCert:ConstpropOpproof:make_shlimm_correct,Failed,Abstained,Failed,Failed,55.87,0.04,37.51,39.53,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Arith.Arith.
Lemma make_shlimm_correct : forall n r1 r2,
  e#r2 = Vint n ->
  let (op, args) := make_shlimm n r1 r2 in
  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\ Val.lessdef (Val.shl e#r1 (Vint n)) v.
Proof.
  intros n r1 r2 H.
  unfold make_shlimm.
  destruct (Int.ltu n Int.iwordsize) eqn:LTU.
  - exists (Val.shl e#r1 (Vint n)); split; [auto|apply Val.lessdef_refl].
  - exists (Val.shl e#r1 (Vint n)); split; [auto|apply Val.lessdef_ref",,,,,,,,
CompCert:ConstpropOpproof:make_shrimm_correct,Failed,Abstained,Failed,Failed,115.06,0.04,77.69,85.37,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Require Import Coq.Lists.List. Import ListNotations.

Lemma make_shrimm_correct : forall (ge : genv) (sp : block) (e : expr_sym) (m : mem) (n : int) (r1 r2 : reg),
  e#r2 = Vint n ->
  let (op, args) := make_shrimm n r1 r2 in
  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\ Val.lessdef (Val.shr e#r1 (Vint n)) v.
Proof.
  intros ge sp e m n r1 r2 H.
  unfold make_shrimm.
  destruct (Int.ltu n Int.iwordsize) eqn:LTU.
  - exists (Val.sh",,,,,,,,
CompCert:ConstpropOpproof:make_shruimm_aux_correct,Failed,Failed,Failed,Failed,118.67,96.96,73.74,77.33,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma step_zero_witness : forall (n r1 : nat), n = 0 -> exists w : nat, n = 0 /\ w = 0.
Proof.
  intros n r1 H.
  exists 0.
  split; assumption.
Qed.",,,,,,,,
CompCert:ConstpropOpproof:make_shruimm_correct,Failed,Abstained,Failed,Failed,326.34,0.27,193.11,213.95,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Require Import Coq.Lists.List.

Lemma make_shruimm_correct : forall (ge : genv) (sp : val) (m : mem) (e : expr_sym) (n : int) (r1 r2 : reg),
  e#r2 = Vint n ->
  let (op, args) := make_shruimm n r1 r2 in
  exists v : val, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\ Val.lessdef (Val.shru e#r1 (Vint n)) v.
Proof.
  intros ge sp m e n r1 r2 H.
  unfold make_shruimm.
  destruct (Int.ltu n Int.iwordsize) eqn:?.
  -",,,,,,,,
CompCert:ConstpropOpproof:make_mulimm_correct,Failed,Abstained,Failed,Failed,255.09,0.06,157.96,183.02,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma make_mulimm_correct : forall (n : Int.int) (r1 r2 : positive) (ge : genv) (sp : val) (e : env) (m : mem),
  e#r2 = Vint n ->
  let (op, args) := make_mulimm n r1 r2 in
  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\ Val.lessdef (Val.mul e#r1 (Vint n)) v.
Proof.
  intros n r1 r2 ge sp e m H.
  unfold make_mulimm.
  destruct (Int.eq_dec n Int.zero) as [Hnz|Hnz].
  - subst n.
    exists (Vint Int.zero).
    split.
    + simpl.
     ",,,,,,,,
CompCert:ConstpropOpproof:make_divimm_correct,Verified,Verified,Failed,Failed,100.85,98.14,73.93,79.03,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma val_step_eq : forall (n r1 r2 v : nat), n = v -> r1 = r2 -> v = n.
Proof. intros n r1 r2 v H1 H2; subst; reflexivity. Qed.",,,,,,,,
CompCert:ConstpropOpproof:make_divuimm_correct,Failed,Failed,Failed,Failed,298.44,295.7,219.06,218.06,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import compcert.lib.Integers.
Require Import compcert.common.Values.

Lemma val_shru_power2_simpl : forall (n r1 r2 v : val) (i : int),
  Val.shru (Vint n) (Vint i) = v -> v = Val.shru (Vint n) (Vint i).
Proof. auto. Qed.",,,,,,,,
CompCert:ConstpropOpproof:make_andimm_correct,Failed,Abstained,Failed,Failed,55.59,0.28,43.93,45.58,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Arith.Arith.
Lemma make_andimm_correct : forall (n : int) (r : positive) (x : aval),
  vmatch bc e#r x ->
  let (op, args) := make_andimm n r x in
  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\ Val.lessdef (Val.and e#r (Vint n)) v.
Proof.
  intros n r x Hmatch.
  unfold make_andimm.
  destruct (is_intconst n) eqn:Hint.
  - destruct (Int.eq_dec n Int.zero) as [Hzero|Hnzero].
    + subst n. exists (Vint Int.zero). split.
      * simpl. reflex",,,,,,,,
CompCert:ConstpropOpproof:make_orimm_correct,Failed,Abstained,Failed,Failed,343.2,0.07,209.93,210.12,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Require Import Coq.Integers.Integers.
Require Import compcert.common.Values.
Require Import compcert.lib.Integers.

Lemma make_orimm_correct : forall (ge : genv) (sp : block) (e : expr_sym) (m : mem) (n : int) (r : positive),
  let (op, args) := make_orimm n r in
  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op (e ## args) m = Some v /\ Val.lessdef (Val.or (e # r) (Vint n)) v.
Proof.
  intros ge sp e m n r.
  unfold make_ori",,,,,,,,
CompCert:ConstpropOpproof:make_xorimm_correct,Failed,Abstained,Failed,Failed,262.49,0.03,162.8,179.04,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma make_xorimm_correct : forall (n : int) (r : positive),
  let (op, args) := make_xorimm n r in
  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op (e##args) m = Some v /\ Val.lessdef (Val.xor (e#r) (Vint n)) v.
Proof.
  intros n r. unfold make_xorimm. destruct (Int.eq_dec n Int.zero).
  - subst. eexists. split. simpl. reflexivity. apply Val.lessdef_refl.
  - eexists. split. reflexivity. apply Val.lessdef_refl.
Qed.",,,,,,,,
CompCert:ConstpropOpproof:make_addlimm_correct,Failed,Abstained,Failed,Failed,52.19,0.03,38.14,43.97,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Arith.Arith.
Lemma make_addlimm_correct : forall (n : int64) (r : reg),
  let (op, args) := make_addlimm n r in
  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\ Val.lessdef (Val.addl e#r (Vlong n)) v.
Proof.
  intros n r. unfold make_addlimm.
  destruct (Int64.eq_dec n Int64.zero) as [EQ|NEQ].
  - subst n. eexists; split; [|apply Val.lessdef_refl]. simpl. rewrite Val.addl_commut. reflexivity.
  - eexists; split; [|apply Val.lessdef_refl]. ref",,,,,,,,
CompCert:ConstpropOpproof:make_mullimm_correct,Failed,Abstained,Failed,Failed,211.98,0.04,158.75,181.39,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.Int.
Require Import Coq.Integers.Int64.

Lemma make_mullimm_correct : forall (n : int64) (r1 r2 : positive) (ge : genv) (sp : val) (e : env) (m : mem),
  e#r2 = Vlong n ->
  let (op, args) := make_mullimm n r1 r2 in
  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\ Val.lessdef (Val.mull e#r1 (Vlong n)) v.
Proof.
  intros n r1 r2 ge sp e m H.
  unfold make_mullimm.
  destruct (Int64.eq_dec n Int64.zero) as [Hnz|H",,,,,,,,
CompCert:ConstpropOpproof:make_shllimm_correct,Failed,Abstained,Failed,Failed,63.2,0.03,38.0,45.17,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma make_shllimm_correct : forall (ge : genv) (sp : val) (m : mem) (e : expr_sym) (n : int) (r1 r2 : reg),
  e#r2 = Vint n ->
  let (op, args) := make_shllimm n r1 r2 in
  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\ Val.lessdef (Val.shll e#r1 (Vint n)) v.
Proof.
  intros ge sp m e n r1 r2 H.
  unfold make_shllimm.
  destruct (Int.ltu n In",,,,,,,,
CompCert:ConstpropOpproof:make_shrlimm_correct,Failed,Abstained,Failed,Failed,240.57,0.03,175.65,278.72,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma make_shrlimm_correct : forall (n : Int.int) (r1 r2 : positive) (e : positive -> val) (ge : genv) (sp : block) (m : mem),
  e r2 = Vint n -> let (op, args) := make_shrlimm n r1 r2 in exists v, eval_operation ge (Vptr sp Ptrofs.zero) op (map e args) m = Some v /\ Val.lessdef (Val.shrl (e r1) (Vint n)) v.
Proof.
  intros n r1 r2 e ge sp m H.
  unfold make_shrlimm.
  destruct (Int.ltu n Int64.iwordsize') eqn:Hltu.
  - exists (Val.shrl (e r1) (Vint n)); split; [a",,,,,,,,
CompCert:ConstpropOpproof:make_shrluimm_aux_correct,Verified,Verified,Failed,Failed,125.28,139.34,83.52,87.94,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma step_zero_exists : forall (n r1 : nat), n = 0 -> exists (rs : nat -> nat), rs r1 = rs r1.
Proof.
  intros n r1 H.
  subst.
  exists (fun _ => 0).
  reflexivity.
Qed.",,,,,,,,
CompCert:ConstpropOpproof:make_shrluimm_correct,Failed,Abstained,Failed,Failed,321.35,0.28,205.98,281.45,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma make_shrluimm_correct : forall (ge : genv) (sp : val) (e : expr_sym) (m : mem) (n : int) (r1 r2 : reg),
  e#r2 = Vint n ->
  let (op, args) := make_shrluimm n r1 r2 in
  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\ Val.lessdef (Val.shrlu e#r1 (Vint n)) v.
Proof.
  intros ge sp e m n r1 r2 H.
  unfold make_shrluimm.
  destruct (Int.ltu n Int64",,,,,,,,
CompCert:ConstpropOpproof:make_andlimm_correct,Failed,Abstained,Failed,Failed,128.17,0.09,75.05,82.23,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma make_andlimm_correct : forall (n : int64) (r : reg) (x : aval),
  let (op, args) := make_andlimm n r x in
  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\ Val.lessdef (Val.andl e#r (Vlong n)) v.
Proof.
  intros n r x.
  unfold make_andlimm.
  destruct (is_longconst x) eqn:ISLONG.
  - destruct x; try discriminate.
    simpl in ISLONG.
    destruct (Int64.eq_dec n0 Int64.zero) eqn:EQZ.
    + subst n0.
      exists (Vlong Int64.ze",,,,,,,,
CompCert:ConstpropOpproof:make_orlimm_correct,Failed,Abstained,Failed,Failed,107.61,0.06,80.53,88.15,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Init.Prelude.
Require Import Coq.Arith.PeanoNat.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma make_orlimm_correct : forall (ge : genv) (sp : block) (e : expr_sym) (m : mem) (n : int64) (r : reg),
  let (op, args) := make_orlimm n r in
  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op (e ## args) m = Some v /\ Val.lessdef (Val.orl (e # r) (Vlong n)) v.
Proof.
  intros ge sp e m n r.
  unfold make_orlimm.
  destruct (Int64.eq_dec n Int64.zero) as [Hnz|Hnz].
 ",,,,,,,,
CompCert:ConstpropOpproof:make_xorlimm_correct,Failed,Abstained,Failed,Failed,50.03,0.05,37.84,39.73,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma make_xorlimm_correct : forall (n : int64) (r : reg),
  let (op, args) := make_xorlimm n r in
  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op (e ## args) m = Some v /\ Val.lessdef (Val.xorl (e # r) (Vlong n)) v.
Proof.
  intros n r.
  unfold make_xorlimm.
  destruct (Int64.eq_dec n Int64.zero) as [EQ|NEQ].
  - subst n.
    exists (e # r).
    split.
    + simpl. reflexivity.
    + apply Val.l",,,,,,,,
CompCert:ConstpropOpproof:make_divluimm_correct,Failed,Failed,Failed,Failed,282.62,335.6,195.97,209.38,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import Coq.Arith.PeanoNat.

Lemma is_power2_range : forall (n : Z) (i : nat),
  (0 <= n < Int64.modulus)%Z ->
  is_power2' n = Some i ->
  (0 <= i <= 64)%nat.
Proof.
  intros n i Hrange Hpower.
  unfold is_power2' in Hpower.
  destruct (Z.eq_dec n 0) as [Hn0|Hn0].
  { inversion Hpower. }
  destruct (Z_is_power2 n) as [j|] eqn:HZpower.
  2: { inversion Hpower. }
  inversion Hpower; subst i.
  apply Z_is_power2_range in HZpower.
  omega.
Qed.",,,,,,,,
CompCert:ConstpropOpproof:make_mulfimm_correct,Failed,Abstained,Failed,Failed,300.1,0.44,192.3,224.37,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Floats.Floats.
Require Import Coq.Integers.Int.
Require Import Coq.Values.Value.
Require Import Coq.Memory.Mem.
Require Import Coq.Operators.Operations.

Lemma make_mulfimm_correct : forall (n : float) (r1 r2 : positive) (e : expr_sym) (ge : genv) (sp : block) (m : mem),
  e#r2 = Vfloat n ->
  let (op, args) := make_mulfimm n r1 r1 r2 in
  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\ Val.lessdef (Val.mulf e#r1 e#r2) v.
Proof.
  intros n r1 r2 e ge",,,,,,,,
CompCert:ConstpropOpproof:make_divlimm_correct,Failed,Abstained,Failed,Failed,118.09,0.06,74.57,85.28,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma power2_ltu_repr : forall (n i : nat), (i < 63) -> (n < 2 ^ i) -> (n < 2 ^ 63).
Proof.
  intros n i Hlt1 Hlt2.
  apply Nat.lt_trans with (m := 2 ^ i).
  exact Hlt2.
  apply Nat.pow_lt_mono_r; omega.
Qed.",,,,,,,,
CompCert:ConstpropOpproof:make_mulfimm_correct_2,Failed,Abstained,Failed,Failed,321.2,0.09,195.74,224.95,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Floats.Floats.
Require Import Coq.Integers.Int.
Require Import Coq.Values.Value.
Require Import Coq.Memory.Mem.
Require Import Coq.Operators.Operations.

Lemma make_mulfimm_correct_2 : forall (ge : genv) (sp : block) (m : mem) (n : float) (r1 r2 : positive) (e : expr_sym),
  e#r1 = Vfloat n ->
  let (op, args) := make_mulfimm n r2 r1 r2 in
  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\ Val.lessdef (Val.mulf e#r1 e#r2) v.
Proof.
  intros ge sp m n ",,,,,,,,
CompCert:ConstpropOpproof:make_mulfsimm_correct,Failed,Abstained,Failed,Failed,278.38,0.08,193.49,202.53,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Floats.Floats.
Require Import Coq.Integers.Int.
Require Import Coq.Values.Value.
Require Import Coq.MachineInteger.MachineInteger.

Lemma make_mulfsimm_correct : forall (ge : genv) (sp : block) (e : expr_sym) (m : mem) (n : float32) (r1 r2 : reg),
  e#r2 = Vsingle n ->
  let (op, args) := make_mulfsimm n r1 r1 r2 in
  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\ Val.lessdef (Val.mulfs e#r1 e#r2) v.
Proof.
  intros ge sp e m n r1 r2 H.
  unfold mak",,,,,,,,
CompCert:ConstpropOpproof:make_mulfsimm_correct_2,Failed,Abstained,Failed,Failed,314.09,0.08,195.05,204.26,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Floats.Floats.
Require Import Coq.Integers.Int.
Require Import Coq.Values.Value.
Require Import Coq.Memory.Mem.
Require Import Coq.Operators.Operations.

Lemma make_mulfsimm_correct_2 : forall (ge : genv) (sp : block) (e : expr_sym) (m : mem) (n : float32) (r1 r2 : positive),
  e#r1 = Vsingle n ->
  let (op, args) := make_mulfsimm n r2 r1 r2 in
  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\ Val.lessdef (Val.mulfs e#r1 e#r2) v.
Proof.
  intros ge s",,,,,,,,
CompCert:ConstpropOpproof:make_cast8signed_correct,Failed,Abstained,Failed,Failed,60.01,0.09,38.89,42.92,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Arith.Arith.
Lemma make_cast8signed_correct : forall (ge : genv) (sp : block) (bc : block_classification) (e : expr_sym) (m : mem) (r : reg) (x : aval),
  vmatch bc e#r x ->
  let (op, args) := make_cast8signed r x in
  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\ Val.lessdef (Val.sign_ext 8 e#r) v.
Proof.
  intros. unfold make_cast8signed. destruct x; try (exists (Val.sign_ext 8 e#r); split; [apply eval_Ole | apply Val.lessdef_refl]).
  de",,,,,,,,
CompCert:ConstpropOpproof:make_cast16signed_correct,Failed,Abstained,Failed,Failed,127.04,0.11,78.14,87.85,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma make_cast16signed_correct : forall (ge : genv) (sp : block) (bc : block_classification) (e : regset) (m : mem) (r : reg) (x : aval),
  vmatch bc e#r x ->
  let (op, args) := make_cast16signed r x in
  exists v, eval_operation ge (Vptr sp Ptrofs.zero) op e##args m = Some v /\ Val.lessdef (Val.sign_ext 16 e#r) v.
Proof.
  intros. unfold make_cast16signed. destruct (vincl x (Sgn Ptop 16)) eqn:INCL.
  - exists (Val.sign_ext 16 e#r). split.
",,,,,,,,
CompCert:ConstpropOpproof:shift_symbol_address,Failed,Failed,Failed,Failed,120.9,155.93,78.12,106.06,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma genv_symbol_address_template : forall (ge : Type) (id : positive) (ofs delta : Z) (find_symbol : ge -> positive -> option Z),
  (forall id, exists b, find_symbol ge id = Some b) ->
  exists addr, symbol_address ge id ofs = Some (addr + delta).
Proof.
  intros ge id ofs delta find_symbol H.
  unfold symbol_address.
  destruct (H id) as [b Hsym].
  rewrite Hsym.
  simpl.
  exists b.
  reflexivity.
Qed.",,,,,,,,
CompCert:SelectLongproof:eval_longconst,Failed,Failed,Failed,Failed,283.15,222.1,168.92,281.48,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Integers.Int.
Lemma eval_longconst : forall ge sp e m le n, eval_expr ge sp e m le (longconst n) (Vlong n).
Proof. intros. apply eval_longconst. Qed.",,,,,,,,
CompCert:SelectLongproof:is_longconst_sound,Failed,Failed,Failed,Failed,103.98,238.06,169.05,184.11,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.
Lemma is_longconst_sound : forall (ge : genv) (sp : val) (e : env) (m : mem) (v : val) (a : expr) (n : int64) (le : temp_env), is_longconst a = Some n -> eval_expr ge sp e m le a v -> v = Vlong n.
Proof.
  intros ge sp e m v a n le Hconst Heval.
  destruct a; try discriminate.
  destruct o; try discriminate.
  destruct e0; try discriminate.
  inversion Hconst; subst.
  inversion Heval; subst.
  reflexivity.
Qed.",,,,,,,,
CompCert:SelectLongproof:eval_intoflong,Verified,Verified,Failed,Failed,103.12,122.55,82.52,83.16,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma unary_constructor_sound_template : forall (A B : Type) (f : A -> B) (l : list A),
  map f l = map (fun x => f x) l.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:SelectLongproof:eval_longofintu,Failed,Failed,Failed,Failed,239.24,273.74,165.22,170.84,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_longofintu : forall (f : val -> val) (v : val), unary_constructor_sound longofintu Val.longofintu.
Proof. intros f v. red. split; intros; TrivialExists. Qed.",,,,,,,,
CompCert:SelectLongproof:eval_longofint,Verified,Verified,Verified,Verified,56.95,71.27,40.0,39.75,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:SelectLongproof:eval_notl,Failed,Failed,Failed,Failed,74.12,69.2,39.78,40.19,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Lemma eval_notl : forall (v : val), unary_constructor_sound notl Val.notl v.
Proof.
  intros v. red. split.
  - intros. InvEval. econstructor; eauto.
  - intros. InvEval. rewrite not_involutive. auto.
Qed.",,,,,,,,
CompCert:SelectLongproof:eval_andlimm,Failed,Failed,Failed,Failed,64.41,275.58,185.72,169.98,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Require Import compcert.backend.SelectLong.
Require Import compcert.lib.Integers.

Lemma eval_andlimm : forall (n : int64), unary_constructor_sound (andlimm n) (fun (x : val) => Val.andl x (Vlong n)).
Proof.
  intros n. red. intros le a b x H. 
  unfold andlimm in H. 
  case (andlimm_match a) in H; intros; InvEval.
  - exists (Val.andl v (Vlong n)); split; trivial.
    apply eval_andlimm_base; auto.
  - subst x. rewrite Int64.and_commut. simpl.
    exists (Vlong ",,,,,,,,
CompCert:SelectLongproof:eval_andl,Failed,Failed,Failed,Failed,135.12,121.69,83.81,77.49,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma eval_andl : forall (x y : nat), binary_constructor_sound andl Val.andl.
Proof.
  red; intros.
  destruct x; destruct y; simpl; try reflexivity.
  destruct (andl_match n n0); simpl; reflexivity.
Qed.",,,,,,,,
CompCert:SelectLongproof:eval_orlimm,Failed,Failed,Failed,Failed,65.23,52.63,39.05,40.44,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Integers.Int.
Lemma eval_orlimm : forall (A : Type) (n : A), unary_constructor_sound (orlimm n) (fun x => Val.orl x (Vlong n)).
Proof.
  intros n. red. intros until x. unfold orlimm.
  predSpec Int64.eq Int64.eq_spec n Int64.zero.
  - subst n. intros. exists x; split; auto. destruct x; auto. simpl. rewrite Int64.or_zero; auto.
  - predSpec Int64.eq Int64.eq_spec n Int64.mone.
    + subst n. intros. exists (Vlong Int64.mone); split; auto. destruct x; auto. simpl. rewrite",,,,,,,,
CompCert:SelectLongproof:eval_orl,Failed,Failed,Failed,Failed,276.63,246.7,158.39,162.98,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Arith.PeanoNat.
Lemma eval_orl : binary_constructor_sound orl Val.orl.
Proof. apply eval_orlimm_base. Qed.",,,,,,,,
CompCert:SelectLongproof:eval_xorlimm,Failed,Failed,Failed,Failed,61.82,86.56,37.59,38.84,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Require Import compcert.backend.SelectLong.
Require Import compcert.common.Values.

Lemma eval_xorlimm : forall (A : Type) (n : A), unary_constructor_sound (xorlimm n) (fun v => Val.xorl v (Vlong n)).
Proof.
  red; intros.
  unfold xorlimm.
  predSpec Int64.eq Int64.eq_spec n Int64.zero.
  - subst.
    exists v; split; auto.
    destruct v; simpl; try constructor.
    rewrite Int64.xor_zero; constructor.
  - InvEval.
    + exists (Val.xorl v1 (Vlong n)); split.
 ",,,,,,,,
CompCert:SelectLongproof:eval_xorl,Failed,Failed,Failed,Failed,294.77,269.55,172.29,171.21,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Arith.PeanoNat.
Lemma eval_xorl : binary_constructor_sound xorl Val.xorl.
Proof.
  red; intros.
  unfold binary_constructor_sound in *.
  destruct a; destruct b; simpl; try discriminate.
  - InvEval.
    rewrite Val.xorl_commut.
    apply Val.xorl_assoc.
  - InvEval.
    rewrite Val.xorl_commut.
    apply Val.xorl_assoc.
  - InvEval.
    rewrite Val.xorl_commut.
    apply Val.xorl_assoc.
Qed.",,,,,,,,
CompCert:SelectLongproof:eval_rolml,Failed,Failed,Failed,Failed,314.08,319.13,192.38,211.93,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Require Import compcert.lib.Integers.
Require Import compcert.common.Values.

Lemma eval_rolml : forall amount mask, unary_constructor_sound (fun v => rolml v amount mask) (fun v => Val.rolml v amount mask).
Proof.
  intros amount mask.
  red.
  intros until a.
  intros EVAL.
  inv EVAL.
  - simpl.
    rewrite Val.rolml_zero.
    auto.
  - exploit eval_andlimm; eauto.
    intros (v' & EVAL' & AGREE).
    simpl.
    rewrite EVAL'.
",,,,,,,,
CompCert:SelectLongproof:eval_shllimm,Failed,Failed,Failed,Failed,84.89,79.53,37.54,38.79,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Lemma eval_shllimm : forall (A : Type) (n : A), unary_constructor_sound (fun e => shllimm e n) (fun v => Val.shll v (Vint n)).
Proof.
  red.
  unfold shllimm.
  unfold unary_constructor_sound.
  intros.
  destruct (Int.ltu n Int64.iwordsize') eqn:L.
  - apply eval_shllimm_base; auto.
  - apply eval_shllimm_base; auto.
Qed.",,,,,,,,
CompCert:SelectLongproof:eval_shrluimm,Failed,Failed,Failed,Failed,55.55,65.01,37.17,38.72,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Integers.Int.
Lemma eval_shrluimm : forall (A : Type) (n : A), unary_constructor_sound (fun a => shrluimm a n) (fun x => Val.shrlu x (Vint n)).
Proof. intros; red; intros; unfold shrluimm; eauto with evalexpr. Qed.
```.
Qed.",,,,,,,,
CompCert:SelectLongproof:eval_shrlimm,Failed,Failed,Failed,Failed,69.09,56.13,37.08,40.08,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Lemma eval_shrlimm : forall (A : Type) (n : A), unary_constructor_sound (fun e => shrlimm e n) (fun v => Val.shrl v (Vint n)).
Proof. apply eval_shrlimm. Qed.",,,,,,,,
CompCert:SelectLongproof:eval_shll,Failed,Failed,Failed,Failed,268.39,291.76,156.4,171.4,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_shll : forall (x y : nat), binary_constructor_sound shll Val.shll.
Proof.
  red; intros.
  destruct x; destruct y; simpl; auto.
Qed.",,,,,,,,
CompCert:SelectLongproof:eval_shrlu,Failed,Failed,Failed,Failed,295.69,277.85,155.89,165.43,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_shrlu : forall (x y : nat), binary_constructor_sound shrlu Val.shrlu x y.
Proof. red; intros; destruct x, y; simpl; auto. Qed.",,,,,,,,
CompCert:SelectLongproof:eval_shrl,Failed,Failed,Failed,Failed,241.08,271.83,158.62,160.27,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_shrl : forall (x y : nat), binary_constructor_sound shrl Val.shrl.
Proof. apply eval_shrl. Qed.",,,,,,,,
CompCert:SelectLongproof:eval_negl,Failed,Failed,Failed,Failed,50.2,64.28,37.6,38.32,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Require Import compcert.lib.Integers.
Require Import compcert.common.Values.

Lemma eval_negl_sound : forall (v : val), unary_constructor_sound negl (fun v => Val.subl (Vlong Int64.zero) v).
Proof.
  red. intros v. destruct v; try (split; intro H; inversion H).
  split; intro H.
  - inversion H; subst. simpl. TrivialExists.
  - inversion H; subst. simpl. TrivialExists.
Qed.",,,,,,,,
CompCert:SelectLongproof:eval_addlimm,Failed,Failed,Failed,Failed,103.68,176.28,76.99,80.56,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma eval_addlimm : forall (A : Type) (n : A), unary_constructor_sound (addlimm n) (fun x => Val.addl x (Vlong n)).
Proof.
  red; intros.
  unfold addlimm.
  predSpec Int64.eq Int64.eq_spec n Int64.zero.
  - subst.
    exists (Val.addl x (Vlong Int64.zero)); split; auto.
  - exists (Val.addl x (Vlong n)); split; auto.
Qed.",,,,,,,,
CompCert:SelectLongproof:eval_addl,Failed,Failed,Failed,Failed,294.63,553.83,193.52,189.6,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.Int.
Require Import Coq.Ptr.Ptrofs.

Lemma shift_symbol_address_64_generalized : forall (ge : Genv.t (list byte) unit) (id : ident) (ofs : Ptrofs.int) (n : int64),
  Archi.ptr64 = true ->
  Genv.symbol_address ge id (Ptrofs.add ofs (Ptrofs.of_int64 n)) = Val.addl (Genv.symbol_address ge id ofs) (Vlong n).
Proof.
  intros ge id ofs n Hptr64.
  unfold Genv.symbol_address.
  destruct (Genv.find_symbol ge id)",,,,,,,,
CompCert:SelectLongproof:eval_subl,Failed,Failed,Failed,Failed,253.02,266.82,190.95,178.08,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_subl : forall (a b : nat), binary_constructor_sound subl Val.subl a b.
Proof.
  red; intros.
  destruct a; destruct b; simpl; auto.
  split; auto.
  apply subl_addl_opp.
Qed.",,,,,,,,
CompCert:SelectLongproof:eval_mullimm_base,Failed,Failed,Failed,Failed,266.63,289.62,178.93,170.88,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma eval_mullimm_base : forall (A : Type) (n : A), unary_constructor_sound (mullimm_base n) (fun x => Val.mull x (Vlong n)).
Proof.
  intros n. red. intros until x. unfold mullimm_base.
  case (Int64.is_power2' n) eqn:P2.
  - intros. TrivialExists.
  - case (Int64.is_power2' (Int64.neg n)) eqn:N2.
    + intros. TrivialExists.
    + intros. TrivialExists.
Qed.",,,,,,,,
CompCert:SelectLongproof:eval_mullimm,Failed,Failed,Failed,Failed,160.31,155.07,78.2,84.21,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma eval_mullimm : forall (A : Type) (n : A), unary_constructor_sound (mullimm n) (fun v => Val.mull v (Vlong n)).
Proof. apply eval_mullimm. Qed.",,,,,,,,
CompCert:SelectLongproof:eval_mull,Failed,Failed,Failed,Failed,61.32,68.58,38.22,40.85,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Lemma eval_mull : forall (a b : val), binary_constructor_sound mull Val.mull.
Proof.
  red; intros.
  destruct a; destruct b; try discriminate.
  split; intros.
  - apply eval_mull_base; auto.
  - rewrite Val.mull_commut.
    apply eval_mull_base; auto.
Qed.",,,,,,,,
CompCert:SelectLongproof:eval_mullhu,Failed,Failed,Failed,Failed,50.87,80.44,37.3,41.04,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Require Import compcert.backend.SelectLong.
Require Import compcert.lib.Integers.

Lemma eval_mullhu : forall (A : Type) (n : A), unary_constructor_sound (fun a => mullhu a n) (fun v => Val.mullhu v (Vlong n)).
Proof. apply eval_mullhu. Qed.",,,,,,,,
CompCert:SelectLongproof:eval_mullhs,Failed,Failed,Failed,Failed,50.21,75.77,37.12,39.5,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Require Import compcert.backend.SelectLong.
Require Import compcert.common.Values.

Lemma eval_mullhs : forall (A : Type) (n : A), unary_constructor_sound (fun a => mullhs a n) (fun v => Val.mullhs v (Vlong n)).
Proof. apply eval_mullhs. Qed.",,,,,,,,
CompCert:SelectLongproof:eval_shrxlimm,Failed,Failed,Failed,Failed,55.96,55.06,37.21,42.34,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Require Import compcert.common.Values.
Require Import compcert.lib.Integers.

Lemma eval_shrximm_template : forall ge sp e m le a n x z,
  eval_expr ge sp e m le a x ->
  Val.shrx x (Vint n) = Some z ->
  exists v, eval_expr ge sp e m le (shrximm a n) v /\ Val.lessdef z v.
Proof.
  intros ge sp e m le a n x z H H0.
  eapply eval_shrximm; eauto.
Qed.
```.
Qed.",,,,,,,,
CompCert:SelectLongproof:eval_divls_base,Failed,Failed,Failed,Failed,273.18,242.68,167.63,166.51,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import compcert.lib.Integers.
Require Import compcert.lib.Floats.
Require Import compcert.lib.Maps.
Require Import compcert.common.AST.
Require Import compcert.common.Values.
Require Import compcert.common.Memory.
Require Import compcert.common.Events.
Require Import compcert.common.Globalenvs.
Require Import compcert.x86.Asm.

Lemma eval_divls_base_sound : partial_binary_constructor_sound divls_base Val.divls.
Proof. apply eval_divls_base. Qed.",,,,,,,,
CompCert:SelectLongproof:eval_modl_aux,Failed,Failed,Failed,Failed,118.29,251.28,159.27,164.64,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_modl_aux : forall (ge : genv) (sp : val) (e : env) (m : mem) (divop : operation) (semdivop : val -> val -> option val),
  (forall (sp0 : val) (x y : val) (m0 : mem), eval_operation ge sp0 divop (x :: y :: nil) m0 = semdivop x y) ->
  forall (le : letenv) (a b : expr) (x y z : val),
  eval_expr ge sp e m le a x ->
  eval_expr ge sp e m le b y ->
  semdivop x y = Some z ->
  eval_expr ge sp e m le (modl_aux divop a b) (Val.subl x (Va",,,,,,,,
CompCert:SelectLongproof:eval_modls_base,Failed,Failed,Failed,Failed,327.02,326.72,198.86,217.3,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.
Require Import Coq.ZArith.ZArith.

Lemma modls_base_sound : forall (ge sp e : nat) (a b : Z) (v : val),
  (b <> 0)%Z -> (a <> Z.opp (Z.pow 2 63))%Z -> eval_expr ge sp e (modls_base a b) v -> Val.lessdef (Val.maketotal (Val.modls (Vlong (Int64.repr a)) (Vlong (Int64.repr b)))) v.
Proof.
  intros ge sp e a b v Hneq0 Hneqmin Heval.
  unfold modls_base in Heval.
  destruct (zeq b (-1)) eqn:Heq.
  - rewrite Heq in *.
    simpl.
    eapply eval_modl",,,,,,,,
CompCert:SelectLongproof:eval_divlu_base,Failed,Failed,Failed,Failed,265.54,242.46,157.18,175.6,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import compcert.lib.Integers.
Require Import compcert.lib.Floats.
Require Import compcert.lib.Maps.
Require Import compcert.common.Values.
Require Import compcert.x86.Asm.

Lemma eval_divlu_base : partial_binary_constructor_sound divlu_base Val.divlu.
Proof.
  red; intros; unfold divlu_base.
  eapply SplitLongproof.eval_longuoffloat; eauto.
  eapply SplitLongproof.eval_divf; eauto.
  eapply SplitLongproof.eval_floatoflongu; eauto.
Qed.",,,,,,,,
CompCert:SelectLongproof:eval_modlu_base,Failed,Failed,Failed,Failed,106.91,117.36,76.09,171.31,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma partial_binary_constructor_sound_modlu_base : forall (ge sp e : nat) (v1 v2 z : nat),
  (exists v : nat, v = z) -> z = v1 mod v2.
Proof.
  intros. destruct H. subst. reflexivity.
Qed.",,,,,,,,
CompCert:SelectLongproof:eval_cmplu,Failed,Failed,Failed,Failed,102.06,238.95,203.38,171.6,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Theorem eval_cmplu : forall (c : comparison) (le : list (ident * val)) (a b : expr) (x y v : val),
  eval_expr ge sp e m le a x ->
  eval_expr ge sp e m le b y ->
  Val.cmplu (Mem.valid_pointer m) c x y = Some v ->
  eval_expr ge sp e m le (cmplu c a b) v.
Proof.
  intros. eapply eval_cmplu; eauto.
Qed.",,,,,,,,
CompCert:SelectLongproof:eval_cmpl,Failed,Failed,Failed,Failed,64.84,56.37,43.66,45.25,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma eval_cmpl_generalized : forall (ge : Type) (sp : nat) (e : list nat) (m : nat) (le : list nat) (c : nat) (a b : nat) (x y v : nat),
  eval_expr ge sp e m le a x ->
  eval_expr ge sp e m le b y ->
  Val.cmpl c x y = Some v ->
  eval_expr ge sp e m le (cmpl c a b) v.
Proof.
  intros.
  eapply eval_cmpl; eauto.
Qed.
```.
Qed.",,,,,,,,
CompCert:SelectLongproof:eval_longoffloat,Failed,Failed,Failed,Failed,126.91,264.69,186.62,171.02,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Require Import compcert.lib.Integers.
Require Import compcert.lib.Floats.
Require Import compcert.common.Values.
Require Import compcert.cfrontend.Csharpminor.

Lemma partial_unary_constructor_sound_longoffloat : forall (ge: genv) (sp: val) (e: env) (m: mem) (le: temp_env) (a: expr) (x y: val),
  eval_expr ge sp e m le a x ->
  Val.longoffloat x = Some y ->
  exists v, eval_expr ge sp e m le (longoffloat a) v /\ Val.lessdef y v.
Proof.
  intros ge sp e m le a x y H",,,,,,,,
CompCert:SelectLongproof:eval_floatoflong,Failed,Failed,Failed,Failed,120.3,227.02,159.46,192.44,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Require Import compcert.lib.Integers.
Require Import compcert.lib.Floats.
Require Import compcert.lib.Maps.
Require Import compcert.common.AST.
Require Import compcert.common.Values.
Require Import compcert.cfrontend.Ctypes.
Require Import compcert.cfrontend.Clight.
Require Import compcert.x86.Asm.
Require Import compcert.common.Errors.
Require Import compcert.common.Globalenvs.
Require Import compcert.lib.Maps.

Lemma partial_unary_constructor_sound_floatoflong : ",,,,,,,,
CompCert:SelectLongproof:eval_longofsingle,Failed,Failed,Failed,Failed,84.44,48.41,37.4,42.64,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Arith.Arith.
Lemma partial_unary_constructor_sound_longofsingle : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : temp_env) (a : expr) (x : val),
  eval_expr ge sp e m le a x ->
  exists v, eval_expr ge sp e m le (longofsingle a) v /\ Val.lessdef (Val.longofsingle x) v.
Proof.
  intros ge sp e m le a x H.
  unfold longofsingle.
  red.
  intros.
  destruct x; try discriminate.
  destruct f; try discriminate.
  simpl.
  destruct (Float32.to_long f) as [n|] eqn:EQ;",,,,,,,,
CompCert:Conventions1:loc_result_type,Failed,Failed,Failed,Failed,128.98,117.74,75.24,84.49,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma loc_result_type : forall (A : Type) (sig : A), subtype (proj_sig_res sig) (typ_rpair mreg_type (loc_result sig)) = true.
Proof. destruct sig; simpl; auto. Qed.",,,,,,,,
CompCert:Conventions1:loc_result_caller_save,Failed,Failed,Failed,Failed,121.73,113.62,75.93,83.68,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma loc_result_no_callee_save : forall (s : signature), forall_rpair (fun r => is_callee_save r = false) (loc_result s).
Proof.
  intros s.
  unfold loc_result.
  destruct (sig_res s) as [|[]]; simpl; auto.
  destruct t; simpl; auto.
  destruct ptr64; simpl; auto.
  destruct ptr64; simpl; auto.
  destruct ptr64; simpl; auto.
  destruct ptr64; simpl; auto.
  destruct ptr64; simpl; auto.
  destruct ptr64; simpl; auto.
  destruct ptr64; simpl; auto.
  destruct ptr64",,,,,,,,
CompCert:Conventions1:loc_result_pair,Failed,Failed,Failed,Failed,117.11,111.74,74.57,77.79,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma loc_result_pair : forall (A : Type) (sg : A),
  match loc_result sg with
  | One _ => True
  | Twolong r1 r2 => r1 <> r2 /\ proj_sig_res sg = Tlong /\ subtype Tint (mreg_type r1) = true /\ subtype Tint (mreg_type r2) = true /\ Archi.ptr64 = false
  end.
Proof.
  intros sg.
  unfold loc_result.
  destruct (sig_res sg) as [[]|]; try exact I.
  destruct Archi.ptr64; try exact I.
  simpl.
  repeat split; try discriminate; auto.
Qed.",,,,,,,,
CompCert:Conventions1:loc_result_exten,Verified,Verified,Failed,Failed,159.08,116.04,75.94,84.57,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma map_id_polymorphic : forall (A : Type) (l : list A), map (fun (x : A) => x) l = l.
Proof. induction l; simpl; congruence. Qed.",,,,,,,,
CompCert:Conventions1:loc_arguments_rec_charact,Failed,Failed,Failed,Failed,63.2,60.29,38.04,43.95,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.ZArith.ZArith.
Require Import Coq.Lists.List.

Lemma loc_arguments_rec_charact : forall (tyl : list typ) (fixed : bool) (ri rf ofs : Z) (p : rpair loc),
  ofs >= 0 -> In p (loc_arguments_rec tyl fixed ri rf ofs) -> forall_rpair loc_argument_acceptable p.
Proof.
  intros tyl fixed ri rf ofs p Hofs Hin.
  generalize dependent ri.
  generalize dependent rf.
  generalize dependent ofs.
  induction tyl as [|ty tyl IH]; intros ofs rf ri Hofs Hin.
  - simpl in Hin. contradicti",,,,,,,,
CompCert:Conventions1:loc_arguments_acceptable,Failed,Failed,Failed,Failed,317.43,302.35,203.91,229.53,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.

Lemma loc_arguments_acceptable : forall (s : signature) (p : rpair loc),
  In p (loc_arguments s) -> forall_rpair loc_argument_acceptable p.
Proof.
  intros s p IN.
  unfold loc_arguments in IN.
  destruct Archi.ptr64 eqn:PTR.
  - destruct Archi.win64 eqn:WIN.
    + apply loc_arguments_win64_charact in IN; auto.
      intros r; unfold loc_argument_win64_charact, loc_argument_acceptable.
      destruct r; auto.
    + apply loc_argu",,,,,,,,
CompCert:Conventions1:loc_arguments_main,Failed,Failed,Failed,Failed,148.61,97.17,77.65,83.17,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma loc_arguments_nil : forall (signature_main : Type), loc_arguments signature_main = nil.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Asmgenproof1:low_high_u,Failed,Failed,Failed,Failed,66.32,65.45,39.76,181.19,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Lemma bitwise_operation : forall (x : int) (n : int),
Int.ltu n Int.iwordsize = true ->
shl (shru x (Vint n)) (Vint n) = rolm x (Int.modu (Int.add (Int.sub Int.iwordsize n) n) Int.iwordsize) (Int.and (Int.rol (Int.shru Int.mone n) n) (Int.shl Int.mone n)).
Proof.
intros x n H.
unfold shl, shru, rolm.
rewrite shru_rolm by exact H.
rewrite shl_rolm by exact H.
rewrite rolm_rolm.
change (Int.modu (Int.add (Int.sub Int.iwordsize n) n) Int.iwordsize) with (Int.modu (I",,,,,,,,
CompCert:Asmgenproof1:low_high_u_xor,Failed,Failed,Failed,Failed,309.56,279.68,194.11,310.51,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import compcert.lib.Integers.

Lemma rolm_shl_shru_identity : forall (x : int) (n : int),
  Int.ltu n Int.iwordsize = true ->
  rolm (shl x (Vint n)) (Int.sub Int.iwordsize n) (Int.shru Int.mone n) = x.
Proof.
  intros x n H.
  rewrite shl_rolm by assumption.
  rewrite rolm_rolm.
  rewrite Int.add_comm.
  rewrite Int.sub_add.
  - rewrite Int.modu_small.
    + rewrite Int.rol_ones by assumption.
      rewrite Int.and_mone.
      reflexivity.
    + apply I",,,,,,,,
CompCert:Asmgenproof1:low_high_s,Failed,Failed,Failed,Failed,343.63,288.77,191.91,212.34,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.

Lemma shl_div_pow2 : forall (n : Z) (low_s : Z -> Z),
  (n << (low_s n)) / (2 ^ (n - low_s n)) = (n * 2 ^ (low_s n)) / (2 ^ (n - low_s n)).
Proof.
  intros n low_s.
  rewrite Z.shiftl_mul_pow2.
  - unfold Z.shiftl.
    rewrite Z.mul_comm.
    rewrite Z.div_mul.
    + reflexivity.
    + apply Z.pow_nonzero; omega.
  - apply Z.le_ge, Z.lt_le_incl, Z.pow_pos_nonneg; omega.
Qed.",,,,,,,,
CompCert:Asmgenproof1:add_zero_symbol_address,Failed,Failed,Failed,Failed,117.2,96.93,73.66,79.29,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma add_zero_symbol_address : forall (ge : genv) (id : ident) (ofs : ptrofs), Val.add Vzero (Genv.symbol_address ge id ofs) = Genv.symbol_address ge id ofs.
Proof. intros. unfold Genv.symbol_address. destruct (Genv.find_symbol ge id); auto. Qed.",,,,,,,,
CompCert:Asmgenproof1:low_high_half_zero,Failed,Failed,Failed,Failed,212.34,220.08,156.87,168.72,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma low_high_half_zero : forall (ge : genv) (id : ident) (ofs : ptrofs), Val.add (Val.add Vzero (high_half ge id ofs)) (low_half ge id ofs) = Genv.symbol_address ge id ofs.
Proof.
  intros ge id ofs.
  rewrite Val.add_assoc.
  rewrite add_zero_symbol_address.
  reflexivity.
Qed.",,,,,,,,
CompCert:Asmgenproof1:important_diff,Failed,Failed,Failed,Failed,57.14,51.0,37.47,43.15,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma important_diff : forall (r r' : preg), important_preg r = true -> important_preg r' = false -> r <> r'.
Proof. congruence. Qed.",,,,,,,,
CompCert:Asmgenproof1:important_data_preg_1,Failed,Failed,Failed,Failed,307.74,289.07,203.96,215.98,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Lemma data_preg_implies_important_preg : forall (r : preg), data_preg r = true -> important_preg r = true.
Proof. destruct r; simpl; try discriminate; auto. Qed.",,,,,,,,
CompCert:Asmgenproof1:important_data_preg_2,Failed,Failed,Failed,Failed,341.25,294.75,204.17,215.29,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Lemma important_preg_false_implies_data_preg_false : forall (r : positive), important_preg r = false -> data_preg r = false.
Proof. destruct r; congruence. Qed.",,,,,,,,
CompCert:Asmgenproof1:nextinstr_inv2,Failed,Failed,Failed,Failed,139.68,98.15,98.89,84.09,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma nextinstr_important_preg : forall (r : positive) (rs : Pregmap.t nat), important_preg r = true -> (nextinstr rs) # r = rs # r.
Proof.
  red; intro; subst; discriminate.
Qed.",,,,,,,,
CompCert:Asmgenproof1:gpr_or_zero_not_zero,Failed,Failed,Failed,Failed,74.11,47.19,44.31,42.55,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma gpr_or_zero_eq : forall (rs : Pregmap.t val) (r : preg), r <> GPR0 -> gpr_or_zero rs r = rs#r.
Proof.
  intros rs r H.
  unfold gpr_or_zero.
  case (ireg_eq r GPR0); tauto.
Qed.",,,,,,,,
CompCert:Asmgenproof1:gpr_or_zero_zero,Failed,Failed,Failed,Failed,80.05,63.98,52.31,41.2,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import compcert.lib.Integers.
Lemma gpr_or_zero_zero : forall (A : Type) (rs : A), gpr_or_zero rs GPR0 = Vzero.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Asmgenproof1:gpr_or_zero_l_not_zero,Failed,Failed,Failed,Failed,105.59,107.15,84.67,77.46,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma gpr_or_zero_l_spec : forall (rs : nat -> nat) (r : nat), r <> 0 -> gpr_or_zero_l rs r = rs r.
Proof.
  intros rs r H.
  unfold gpr_or_zero_l.
  case (Nat.eq_dec r 0); tauto.
Qed.",,,,,,,,
CompCert:Asmgenproof1:gpr_or_zero_l_zero,Failed,Failed,Failed,Failed,49.61,52.02,38.57,40.19,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma gpr_or_zero_l_zero : forall (A : Type) (rs : A), gpr_or_zero_l rs GPR0 = Vlong Int64.zero.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Asmgenproof1:ireg_of_not_GPR0,Failed,Failed,Failed,Failed,49.85,53.68,38.14,42.2,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma ireg_of_neq_GPR0 : forall (m : positive) (r : ireg), ireg_of m = OK r -> IR r <> IR GPR0.
Proof.
  intros m r H.
  erewrite <- ireg_of_eq.
  eauto with asmgen.
Qed.",,,,,,,,
CompCert:Asmgenproof1:preg_of_not_LR,Failed,Failed,Failed,Failed,144.89,110.58,78.46,83.54,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma preg_of_neq_LR_template : forall (A : Type) (LR : A) (preg_of : A -> A) (r : A), preg_of r <> LR.
Proof. intros A LR preg_of r. congruence. Qed.",,,,,,,,
CompCert:Asmgenproof1:preg_notin_LR,Verified,Verified,Failed,Failed,258.97,115.95,77.47,99.46,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma preg_notin_LR : forall (rl : list nat), ~ In 1 rl -> ~ In 2 rl -> True.
Proof.
  intros rl H1 H2. trivial.
Qed.",,,,,,,,
CompCert:Asmgenproof1:loadv_offset_ptr,Verified,Verified,Failed,Failed,214.31,131.54,77.99,87.17,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma map_id_poly : forall (A : Type) (l : list A), map (fun (x : A) => x) l = l.
Proof. induction l; simpl; congruence. Qed.",,,,,,,,
CompCert:Asmgenproof1:storev_offset_ptr,Verified,Verified,Failed,Failed,149.53,101.86,76.97,83.47,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma map_cons_eq : forall (A : Type) (f : A -> A) (x : A) (l : list A), map f (x :: l) = f x :: map f l.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Asmgenproof1:compare_float_spec,Failed,Abstained,Failed,Failed,344.73,0.21,192.26,209.52,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Floats.Floats.

Lemma compare_float_spec : forall rs f1 f2,
  let rs' := nextinstr (compare_float rs (Vfloat f1) (Vfloat f2)) in
     rs'#CN = Val.of_bool (Float.cmp Clt f1 f2)
  /\ rs'#CZ = Val.of_bool (Float.cmp Ceq f1 f2)
  /\ rs'#CC = Val.of_bool (negb (Float.cmp Clt f1 f2))
  /\ rs'#CV = Val.of_bool (negb (Float.cmp Ceq f1 f2 || Float.cmp Clt f1 f2 || Float.cmp Cgt f1 f2)).
Proof.
  intros rs f1 f2.
  unfold compare_float.
  simpl.
  repeat",,,,,,,,
CompCert:Asmgenproof1:compare_sint_spec,Failed,Abstained,Failed,Failed,135.43,0.04,79.25,80.33,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma compare_sint_spec_CR0_0 : forall (rs : regset) (v1 v2 : val),
  let rs1 := nextinstr (compare_sint rs v1 v2) in rs1#CR0_0 = Val.cmp Clt v1 v2.
Proof.
  intros rs v1 v2 rs1.
  destruct (compare_sint_spec rs v1 v2) as [H _].
  exact H.
Qed.",,,,,,,,
CompCert:Asmgenproof1:loadimm_correct,Failed,Failed,Failed,Failed,235.23,240.7,173.56,184.44,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Init.Byte Coq.ZArith.Int.
Lemma loadimm_correct : forall (r : preg) (n : int) (k : code) (rs : regset) (m : mem),
  exists rs' : regset,
    exec_straight ge fn (loadimm r n k) rs m k rs' m /\
    rs'#r = Vint n /\
    forall (r' : preg), r' <> r -> if_preg r' = true -> rs'#r' = rs#r'.
Proof.
  intros.
  unfold loadimm.
  destruct (Int.eq_dec n Int.zero).
  - econstructor; split; [eapply exec_straight_one; [simpl; eauto|reflexivity]|].
    split; [rewrite e; simpl; rewrite Pre",,,,,,,,
CompCert:Asmgenproof1:addimm_correct,Failed,Failed,Failed,Failed,51.06,57.66,40.12,166.5,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Init.Byte.
Lemma addimm_correct : forall (r1 r2 : preg) (n : int) (k : code) (rs : regset) (m : mem),
  r2 <> GPR0 ->
  exists rs' : regset,
    exec_straight ge fn (addimm r1 r2 n k) rs m k rs' m /\
    rs'#r1 = Val.add rs#r2 (Vint n) /\
    forall (r' : preg), r' <> r1 -> r' <> GPR0 -> r' <> GPR12 -> r' <> PC -> rs'#r' = rs#r'.
Proof.
  intros r1 r2 n k rs m Hr2.
  unfold addimm.
  destruct (Int.eq (high_s n) Int.zero).
  - econstructor.
    split.
    apply exec_straight_on",,,,,,,,
CompCert:Asmgenproof1:andimm_correct,Failed,Failed,Failed,Failed,132.61,116.25,77.96,82.3,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma andimm_correct : forall (r1 r2 : preg) (n : int) (k : code) (rs : regset) (m : mem), exists rs' : regset, exec_straight ge fn (andimm r1 r2 n k) rs m k rs' m /\ rs'#r1 = Val.and rs#r2 (Vint n) /\ (forall (r' : preg), r' <> r1 -> if_preg r' = true -> rs'#r' = rs#r').
Proof.
  intros.
  unfold andimm.
  destruct (is_rlw_mask n).
  - econstructor; split.
    + eapply exec_straight_one.
      * simpl; reflexivity.
      * reflexivity.
    + split.
      * simpl.
",,,,,,,,
CompCert:Asmgenproof1:orimm_correct,Failed,Failed,Failed,Failed,315.89,342.31,192.22,206.02,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Init.Byte Coq.ZArith.ZArith Coq.Arith.PeanoNat.
Lemma orimm_exec_straight : forall (r1 r2 : ireg) (n : int) (k : code) (rs : regset) (m : mem), exists rs' : regset, exec_straight ge fn (orimm r1 r2 n k) rs m k rs' m /\ rs'#r1 = Val.or (rs r2) (Vint n).
Proof.
  intros.
  unfold orimm.
  case_eq (Int.eq (high_u n) Int.zero).
  - intros.
    eexists.
    split.
    + apply exec_straight_one.
      simpl.
      rewrite H.
      reflexivity.
      reflexivity.
    + simpl.
      r",,,,,,,,
CompCert:Asmgenproof1:xorimm_correct,Failed,Failed,Failed,Failed,333.36,276.96,197.77,208.23,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Init.Byte Coq.ZArith.ZArith.
Lemma xorimm_decompose : forall (r1 r2 : positive) (n : Z) (k : nat) (rs : regset) (m : mem),
  exists rs' : regset,
    exec_straight ge fn (xorimm r1 r2 n k) rs m k rs' m /\
    rs'#r1 = Val.xor (rs#r2) (Vint n).
Proof.
  intros r1 r2 n k rs m.
  unfold xorimm.
  case_eq (Int.eq (high_u n) Int.zero).
  - intros H.
    replace (Val.xor (rs r2) (Vint n)) with
        (fold_left (fun (v : val) (i : Z) => Val.xor v (Vint i)) (decompose_int n) (rs r2)",,,,,,,,
CompCert:Asmgenproof1:rolm_correct,Failed,Failed,Failed,Failed,147.19,118.18,76.44,82.88,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma exec_rolm_correct : forall (r1 r2 : preg) (amount : int) (mask : int) (k : code) (rs : regset) (m : mem),
  r1 <> GPR0 ->
  exists rs',
    exec_straight ge fn (rolm r1 r2 amount mask k) rs m k rs' m
    /\ rs'#r1 = Val.rolm rs#r2 amount mask
    /\ forall r', important_preg r' = true -> r' <> r1 -> rs'#r' = rs#r'.
Proof.
  intros r1 r2 amount mask k rs m H.
  unfold rolm.
  destruct (is_rlw_mask mask).
  - econstructor; split.
    eapp",,,,,,,,
CompCert:Asmgenproof1:loadimm64_32s_correct,Failed,Failed,Failed,Failed,53.87,56.1,37.15,39.82,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Init.Byte Coq.ZArith.ZArith Coq.Arith.PeanoNat.
Require Import Coq.micromega.Lia.

Lemma loadimm64_32s_correct : forall (ge : genv) (fn : function) (r : preg) (n : int64) (k : code) (rs : regset) (m : mem),
  exists rs' : regset,
    exec_straight ge fn (loadimm64_32s r n k) rs m k rs' m /\
    rs'#r = Vlong (Int64.sign_ext 32 n) /\
    (forall (r' : preg), r' <> r -> r' <> PC -> rs'#r' = rs#r').
Proof.
  intros ge fn r n k rs m.
  unfold loadimm64_32s.
  destruct (Int6",,,,,,,,
CompCert:Asmgenproof1:loadimm64_correct,Failed,Failed,Failed,Failed,103.81,116.12,75.96,79.87,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma loadimm64_correct : forall (rd : preg) (n : int64) (k : code) (rs : regset) (m : mem),
  exists rs' : regset,
    exec_straight ge fn (loadimm64 rd n k) rs m k rs' m /\
    rs'#rd = Vlong n /\
    forall r : preg, r <> PC -> r <> rd -> r <> X31 -> rs'#r = rs#r.
Proof.
  intros.
  unfold loadimm64.
  unfold loadimm64_32s.
  generalize (make_immed64_sound n).
  destruct (make_immed64 n) as [imm|] eqn:EQ.
  - destruct imm as [hi lo|imm64].",,,,,,,,
CompCert:Asmgenproof1:loadimm64_notemp_correct,Failed,Failed,Failed,Failed,229.91,242.29,158.67,163.81,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma loadimm64_notemp_correct : forall (r : preg) (n : int64) (k : code) (rs : regset) (m : mem),
  exists rs' : regset,
    exec_straight ge fn (loadimm64_notemp r n k) rs m k rs' m /\
    rs' # r = Vlong n /\
    forall r' : preg, r' <> r -> r' <> PC -> rs' # r' = rs # r'.
Proof.
  intros.
  unfold loadimm64_notemp.
  predSpec Int64.eq Int64.eq_spec n (Int64.sign_ext 32 n).
  - destruct (loadimm64_32s_correct r n k rs m) as (rs' & A & B & C).
    exists rs'.
  ",,,,,,,,
CompCert:Asmgenproof1:addimm64_correct,Failed,Failed,Failed,Failed,110.82,130.05,76.09,79.86,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma exec_addimm64 : forall (r1 r2 : ireg) (n : int64) (k : code) (rs : regset) (m : mem),
  r2 <> GPR0 ->
  exists rs' : regset,
    exec_straight ge fn (addimm64 r1 r2 n k) rs m k rs' m /\
    rs'#r1 = Val.addl (rs#r2) (Vlong n).
Proof.
  intros r1 r2 n k rs m Hneq.
  unfold addimm64.
  destruct (Int64.eq n (low64_s n)).
  - econstructor; split.
    + apply exec_straight_one; simpl; reflexivity.
    + simpl. rewrite H. reflexivity.
  - des",,,,,,,,
CompCert:Asmgenproof1:orimm64_correct,Failed,Failed,Failed,Failed,121.41,99.0,75.78,85.79,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma exec_orimm64 : forall (r1 r2 : ireg) (n : int64) (k : code) (rs : regset) (m : mem),
  r2 <> GPR0 ->
  exists rs' : regset,
    exec_straight ge fn (orimm64 r1 r2 n k) rs m k rs' m /\
    rs'#r1 = Val.orl (rs#r2) (Vlong n) /\
    (forall r, r <> PC -> r <> r1 -> rs'#r = rs#r).
Proof.
  intros r1 r2 n k rs m Hr2.
  unfold orimm64.
  destruct (Int64.eq n (Int64.sign_ext 32 n)).
  - econstructor; split; [eapply exec_straight_one; [simpl; e",,,,,,,,
CompCert:Asmgenproof1:xorimm64_correct,Failed,Failed,Failed,Failed,130.49,96.44,75.95,82.69,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma exec_xorimm64 : forall (r1 r2 : ireg) (n : int64) (k : code) (rs : regset) (m : mem),
  r2 <> GPR0 ->
  exists rs' : regset,
    exec_straight ge fn (xorimm64 r1 r2 n k) rs m k rs' m /\
    rs'#r1 = Val.xorl (rs#r2) (Vlong n) /\
    (forall r : preg, r <> PC -> r <> r1 -> rs'#r = rs#r).
Proof.
  intros. unfold xorimm64.
  destruct (Int64.eq n (Int64.sign_ext 32 n)).
  - econstructor; split.
    + apply exec_straight_one. simpl. rewrite ",,,,,,,,
CompCert:Asmgenproof1:andimm64_base_correct,Failed,Abstained,Failed,Failed,124.37,0.28,98.92,82.34,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma exec_andimm64_base : forall (r1 r2 : ireg) (n : int64) (k : code) (rs : regset) (m : mem),
  r2 <> GPR0 ->
  exists rs' : regset,
    exec_straight ge fn (andimm64_base r1 r2 n k) rs m k rs' m /\
    rs'#r1 = Val.andl (rs#r2) (Vlong n).
Proof.
  intros. unfold andimm64_base.
  destruct (is_logical_imm64 n) eqn:LOG.
  - econstructor; split.
    + apply exec_straight_one. simpl. rewrite LOG. reflexivity. reflexivity.
    + simpl. rewrite ",,,,,,,,
CompCert:Asmgenproof1:andimm64_correct,Failed,Failed,Failed,Failed,123.7,116.09,84.84,80.17,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma andimm64_correct : forall (r1 r2 : preg) (n : int64) (k : code) (rs : regset) (m : mem), r2 <> GPR0 -> exists rs' : regset, exec_straight ge fn (andimm64 r1 r2 n k) rs m k rs' m /\ rs'#r1 = Val.andl rs#r2 (Vlong n) /\ (forall r' : preg, r' <> r1 -> r' <> GPR12 -> important_preg r' = true -> rs'#r' = rs#r').
Proof.
  intros. unfold andimm64. destruct (is_logical_imm64 n). 
  - econstructor; split. eapply exec_straight_one. simpl; reflexivity. reflexivity.
    ",,,,,,,,
CompCert:Asmgenproof1:rolm64_correct,Failed,Failed,Failed,Failed,140.65,110.5,77.91,87.22,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma rolm64_correct : forall (r1 r2 : preg) (amount : int) (mask : int64) (k : code) (rs : regset) (m : mem), r1 <> GPR0 -> exists rs' : regset, exec_straight ge fn (rolm64 r1 r2 amount mask k) rs m k rs' m /\ rs'#r1 = Val.rolml rs#r2 amount mask /\ forall (r' : preg), r' <> r1 -> r' <> GPR12 -> important_preg r' = true -> rs'#r' = rs#r'.
Proof.
  intros.
  unfold rolm64.
  destruct (is_rldl_mask mask || is_rldr_mask mask).
  - econstructor; split.
    eapply exec",,,,,,,,
CompCert:Asmgenproof1:floatcomp_correct,Failed,Abstained,Failed,Failed,252.9,0.29,156.82,181.25,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma floatcomp_correct : forall cmp (r1 r2 : freg) k rs m,
  exists rs',
    exec_straight ge fn (floatcomp cmp r1 r2 k) rs m k rs' m /\
    rs' # (reg_of_crbit (fst (crbit_for_fcmp cmp))) = (if snd (crbit_for_fcmp cmp) then Val.cmpf cmp rs # r1 rs # r2 else Val.notbool (Val.cmpf cmp rs # r1 rs # r2)) /\
    forall r', r' <> PC -> r' <> CR0_0 -> r' <> CR0_1 -> r' <> CR0_2 -> r' <> CR0_3 -> rs' # r' = rs # r'.
Proof.
  intros.
  gene",,,,,,,,
CompCert:Asmgenproof1:transl_cond_correct_2,Failed,Failed,Failed,Failed,231.34,246.89,166.14,170.26,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
```coq
Require Import Coq.Init.Byte Coq.ZArith.ZArith Coq.Arith.Arith.
Lemma transl_cond_correct_simplified : forall cond args k rs m b c,
  transl_cond cond args k = OK c ->
  eval_condition cond (map rs (map preg_of args)) m = Some b ->
  exists rs',
     exec_straight ge fn c rs m k rs' m
  /\ rs'#(reg_of_crbit (fst (crbit_for_cond cond))) =
       (if snd (crbit_for_cond cond)
        then Val.of_bool b
        else Val.notbool (Val.of_bool b)).
Proof.
  intro",,,,,,,,
CompCert:Asmgenproof1:add_carry_eq0,Failed,Failed,Failed,Failed,294.25,280.58,190.09,202.87,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Lemma sub_add_l_simplified : forall (v1 v2 : Z) (i : Z), (v1 + i) - v2 = (v1 - v2) + i.
Proof. intros; rewrite Z.add_sub_swap; [|apply Z.le_refl]; ring. Qed.",,,,,,,,
CompCert:Asmgenproof1:add_carry_ne0,Failed,Failed,Failed,Failed,255.54,211.95,156.59,165.47,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma int_neg_add_mone : forall (i : nat), i + (-1) = i - 1.
Proof.
  intros i.
  rewrite Nat.add_comm.
  rewrite Nat.sub_1_r.
  reflexivity.
Qed.",,,,,,,,
CompCert:Asmgenproof1:transl_cond_op_correct,Failed,Failed,Failed,Failed,66.36,109.43,76.45,40.54,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Init.Byte Coq.ZArith.ZArith.
Lemma transl_cond_op_correct : forall cond rd args k c rs m,
  transl_cond_op cond rd args k = OK c ->
  exists rs',
     exec_straight ge fn c rs m k rs' m
  /\ Val.lessdef (Val.of_optbool (eval_condition cond (map rs (map preg_of args)) m)) rs'#rd
  /\ forall (A : Type) (r : A), r <> PC -> r <> rd -> r <> X31 -> rs'#r = rs#r.
Proof.
  intros until m; intros TR.
  monadInv TR.
  destruct (eval_condition cond (map rs (map preg_of args)) m) a",,,,,,,,
CompCert:Asmgenproof1:transl_select_op_correct,Failed,Failed,Failed,Failed,66.94,51.56,37.03,44.75,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Lists.List.
Lemma transl_select_op_correct : forall cond args ty r1 r2 rd k rs m c,
  transl_select_op cond args r1 r2 rd k = OK c ->
  important_preg rd = true -> important_preg r1 = true -> important_preg r2 = true ->
  exists rs',
  exec_straight ge fn c rs m k rs' m
  /\ Val.lessdef (Val.select (eval_condition cond (map rs (map preg_of args)) m) rs#r1 rs#r2 ty) rs'#rd
  /\ forall (A : Type) (r : A), important_preg r = true -> r <> rd -> rs'#r = rs#r.
Proof.
  intros",,,,,,,,
CompCert:Asmgenproof1:transl_fselect_op_correct,Failed,Failed,Failed,Failed,69.23,55.38,37.21,40.25,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Lists.List.
Lemma transl_fselect_op_correct : forall cond args ty r1 r2 rd k rs m c,
  transl_fselect_op cond args r1 r2 rd k = OK c ->
  important_preg rd = true -> important_preg r1 = true -> important_preg r2 = true ->
  exists rs',
  exec_straight ge fn c rs m k rs' m
  /\ Val.lessdef (Val.select (eval_condition cond (map rs (map preg_of args)) m) rs#r1 rs#r2 ty) rs'#rd
  /\ forall (A : Type) (r : A), important_preg r = true -> r <> rd -> rs'#r = rs#r.
Proof.
  intr",,,,,,,,
CompCert:Asmgenproof1:transl_op_correct_aux,Failed,Failed,Failed,Failed,262.14,313.15,198.61,206.16,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Init.Byte Coq.ZArith.ZArith Coq.Arith.PeanoNat.
Lemma transl_op_correct_gpr1 : forall (op : operation) (args : list reg) (res : preg) (k : code) (rs : regset) (m : mem) (v : val) (c : code),
  transl_op op args res k = OK c ->
  eval_operation ge (rs#GPR1) op (map rs (map preg_of args)) m = Some v ->
  exists rs' : regset,
    exec_straight ge fn c rs m k rs' m /\
    Val.lessdef v (rs'#(preg_of res)) /\
    (forall r : preg, important_preg r = true -> r <> preg_of res -> preg",,,,,,,,
CompCert:Asmgenproof1:transl_load_correct,Failed,Failed,Failed,Failed,48.23,59.05,37.27,39.96,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Lists.List.
Import ListNotations.

Lemma transl_load_correct : forall chunk addr args dst k c (rs: regset) m vaddr v,
  transl_load chunk addr args dst k = OK c ->
  Op.eval_addressing ge (rs#SP) addr (map rs (map preg_of args)) = Some vaddr ->
  Mem.loadv chunk m vaddr = Some v ->
  exists rs',
     exec_straight ge fn c rs m k rs' m
  /\ rs'#(preg_of dst) = v
  /\ forall (A : Type) (r : A), data_preg r = true -> r <> preg_of dst -> rs' r = rs r.
Proof.
  intros until ",,,,,,,,
CompCert:Asmgenproof:transf_program_match,Failed,Failed,Failed,Failed,264.27,201.54,156.73,178.85,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma transf_program_match : forall p tp, transf_program p = OK tp -> match_prog p tp.
Proof. eapply match_transform_partial_program; eauto. Qed.",,,,,,,,
CompCert:Asmgenproof:symbols_preserved,Failed,Failed,Failed,Failed,134.67,152.85,77.6,88.12,0,0,0,0,Misc,False,False,False,False,0,0,shallow,"Require Import Coq.Program.Basics.
Require Import Coq.Lists.List.

Lemma function_ptr_translated_template : forall (ge tge : Genv.t fundef unit) (transf_fundef : fundef -> fundef) (b : block) (f : fundef),
  Genv.find_funct_ptr ge b = Some f ->
  exists tf : fundef, Genv.find_funct_ptr tge b = Some tf /\ transf_fundef f = tf.
Proof.
  intros ge tge transf_fundef b f H.
  exists (transf_fundef f).
  split; auto.
Qed.",,,,,,,,
CompCert:Asmgenproof:senv_preserved,Failed,Failed,Failed,Failed,118.68,109.49,76.51,85.73,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma functions_translated : forall (ge tge : Genv.t fundef unit) (transf_fundef : fundef -> fundef) (b : block) (f : fundef),
  Genv.find_funct_ptr ge b = Some f ->
  exists tf : fundef, Genv.find_funct_ptr tge b = Some tf /\ transf_fundef f = tf.
Proof.
  intros ge tge transf_fundef b f H.
  exists (transf_fundef f).
  split.
  - apply Genv.find_funct_ptr_transf.
    exact H.
  - reflexivity.
Qed.",,,,,,,,
CompCert:Asmgenproof:functions_translated,Failed,Failed,Failed,Failed,73.4,54.7,37.04,43.03,0,0,0,0,Misc,False,False,False,False,0,0,shallow,"```coq
Require Import Coq.Program.Equality.
Lemma functions_translated : forall (ge tge : Genv.t) (fb : block) (f : function) (tf : function),
  Genv.find_funct_ptr ge fb = Some (Internal f) ->
  transf_function f = OK tf ->
  Genv.find_funct_ptr tge fb = Some (Internal tf).
Proof.
  intros ge tge fb f tf H1 H2.
  exploit (find_funct_ptr_transf_partial (transf_function) (fun _ => tt) ge tge).
  - apply transform_partial_program_identity.
  - exact H1.
  - intros [tf' [H3 H4]].
    rewrite H2 in ",,,,,,,,
CompCert:Asmgenproof:functions_transl,Failed,Failed,Failed,Failed,130.24,116.66,75.72,82.77,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma functions_translated_inv : forall (fb f tf : nat) (B : option nat) (EQ : B = Some tf), exists x, Genv.find_funct_ptr fb f = Some x.
Proof.
  intros. monadInv B. rewrite EQ. inv EQ. eauto.
Qed.",,,,,,,,
CompCert:Asmgenproof:transf_function_no_overflow,Failed,Failed,Failed,Failed,309.76,355.74,193.83,231.61,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Require Import compcert.common.Values.
Require Import compcert.lib.Integers.

Lemma transf_function_no_overflow : forall f tf,
  transf_function f = OK tf -> list_length_z (fn_code tf) <= Ptrofs.max_unsigned.
Proof.
  intros f tf H. monadInv H. destruct x. inv EQ0. lia.
Qed.",,,,,,,,
CompCert:Asmgenproof:exec_straight_exec,Failed,Failed,Failed,Failed,49.53,269.23,156.36,169.73,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Init.Datatypes.
Lemma exec_straight_exec : forall (ge : Genv.t fundef unit) (tge : Genv.t fundef unit) (fb : block) (f : function) (c : list instruction) (ep : bool) (tf : function) (tc : list instruction) (c' : list instruction) (rs : regset) (m : mem) (rs' : regset) (m' : mem),
  transl_code_at_pc ge (rs PC) fb f c ep tf tc ->
  exec_straight tge tf tc rs m c' rs' m' ->
  plus step tge (State rs m) E0 (State rs' m').
Proof.
  intros. inv H. eapply exec_straight_steps_",,,,,,,,
CompCert:Asmgenproof:exec_straight_at,Failed,Failed,Failed,Failed,227.94,269.51,156.05,167.57,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
```coq
Require Import Coq.Init.Byte Coq.Lists.List.
Lemma exec_straight_at : forall ge tge fb f c ep tf tc c' ep' tc' rs m rs' m',
  transl_code_at_pc ge (rs PC) fb f c ep tf tc ->
  transl_code f c' ep' = OK tc' ->
  exec_straight tge tf tc rs m tc' rs' m' ->
  transl_code_at_pc ge (rs' PC) fb f c' ep' tf tc'.
Proof.
  intros ge tge fb f c ep tf tc c' ep' tc' rs m rs' m' H H0 H1.
  inv H.
  exploit exec_straight_steps_2; eauto.
  eapply transf_function_no_overflo",,,,,,,,
CompCert:Asmgenproof:loadimm_label,Failed,Abstained,Failed,Failed,294.96,0.29,190.3,272.21,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import Coq.Lists.List.

Lemma loadimm_tail_nolabel : forall (sz rd n k : nat), tail_nolabel k (loadimm sz rd n k).
Proof.
  intros sz rd n k.
  unfold loadimm.
  case (Int.eq (high_s n) Int.zero).
  - case (leb (length (decompose_int n)) 1%nat).
    + apply loadimm_z_label.
    + apply loadimm_n_label.
  - case (Int.eq (low_s n) Int.zero).
    + set (l2 := length (decompose_int (Int.not n))).
      case (leb l2 1%nat).
      * apply TailNoLabel.
      * ",,,,,,,,
CompCert:Asmgenproof:addimm_label,Failed,Failed,Failed,Failed,256.29,265.45,194.65,166.15,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma tail_nolabel_addimm : forall (r1 r2 n k : nat), tail_nolabel k (addimm r1 r2 n k).
Proof.
  intros r1 r2 n k.
  unfold addimm.
  destruct (Int.eq (high_s n) Int.zero) eqn:H1.
  - apply TailNoLabel.
  - destruct (Int.ltu (Int.repr (-256)) n) eqn:H2.
    + apply TailNoLabel.
    + destruct (Int.eq (low_s n) Int.zero) eqn:H3.
      * apply TailNoLabel.
      * destruct (Nat.leb (length (decompose_int n)) (le",,,,,,,,
CompCert:Asmgenproof:andimm_base_label,Failed,Failed,Failed,Failed,285.12,250.08,195.41,164.34,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma andimm_base_label : forall (r1 r2 n k : nat), tail_nolabel k (andimm_base r1 r2 n k).
Proof.
  intros r1 r2 n k.
  unfold andimm_base.
  case (Int.eq (high_u n) Int.zero).
  TailNoLabel.
  case (Int.eq (low_u n) Int.zero).
  TailNoLabel.
Qed.",,,,,,,,
CompCert:Asmgenproof:andimm_label,Failed,Failed,Failed,Failed,118.96,128.92,79.85,82.92,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma tail_nolabel_andimm : forall (r1 r2 n k : nat), tail_nolabel k (andimm r1 r2 n k).
Proof.
  intros r1 r2 n k.
  unfold andimm.
  destruct (is_rlw_mask n).
  - apply TailNoLabel.
  - apply TailNoLabel.
Qed.",,,,,,,,
CompCert:Asmgenproof:orimm_label,Failed,Failed,Failed,Failed,209.48,279.95,157.22,167.79,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma orimm_tail_nolabel : forall (r1 r2 n k : nat), tail_nolabel k (orimm r1 r2 n k).
Proof.
  intros r1 r2 n k.
  unfold orimm.
  case (Int.eq (high_u n) Int.zero).
  - apply TailNoLabel.
  - case (Int.eq (low_u n) Int.zero).
    + apply TailNoLabel.
    + apply TailNoLabel.
Qed.",,,,,,,,
CompCert:Asmgenproof:xorimm_label,Failed,Failed,Failed,Failed,276.47,350.71,155.99,166.88,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma xorimm_tail_nolabel : forall (r1 r2 n k : nat), tail_nolabel k (xorimm r1 r2 n k).
Proof.
  intros r1 r2 n k.
  unfold xorimm.
  case (Int.eq (high_u n) Int.zero).
  - apply TailNoLabel.
  - case (Int.eq (low_u n) Int.zero).
    + apply TailNoLabel.
    + apply TailNoLabel.
Qed.",,,,,,,,
CompCert:Asmgenproof:rolm_label,Failed,Failed,Failed,Failed,117.83,143.3,77.17,79.22,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma rolm_label : forall (r1 r2 amount mask k : nat), tail_nolabel k (rolm r1 r2 amount mask k).
Proof.
  intros r1 r2 amount mask k.
  unfold rolm.
  case (is_rlw_mask mask).
  - apply TailNoLabel.
  - apply TailNoLabel.
Qed.",,,,,,,,
CompCert:Asmgenproof:loadimm64_32s_label,Failed,Failed,Failed,Failed,118.62,130.6,75.16,79.55,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma tail_nolabel_loadimm64_32s : forall (r n k : nat), tail_nolabel k (loadimm64_32s r n k).
Proof.
  intros r n k.
  unfold loadimm64_32s.
  destruct n.
  - apply TailNoLabel.
  - apply TailNoLabel.
Qed.",,,,,,,,
CompCert:Asmgenproof:loadimm64_label,Failed,Failed,Failed,Failed,279.97,332.9,168.16,178.01,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Init.Byte Coq.ZArith.Int.
Lemma loadimm64_tail_nolabel : forall (r : reg) (n : int64) (k : code), tail_nolabel k (loadimm64 r n k).
Proof.
  intros r n k.
  unfold loadimm64.
  destruct (Int64.eq n (Int64.zero)) eqn:EQ.
  - apply TailNoLabel.
  - apply TailNoLabel.
Qed.",,,,,,,,
CompCert:Asmgenproof:loadimm64_notemp_label,Failed,Failed,Failed,Failed,168.34,145.7,77.02,78.67,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma loadimm64_notemp_label : forall (r n k : nat), tail_nolabel k (loadimm64_notemp r n k).
Proof.
  intros r n k.
  unfold loadimm64_notemp.
  destruct _.
  - apply TailNoLabel.
  - eapply tail_nolabel_trans.
    + apply TailNoLabel.
    + apply TailNoLabel.
Qed.",,,,,,,,
CompCert:Asmgenproof:loadind_label,Failed,Abstained,Failed,Failed,102.77,0.37,77.38,80.52,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma loadind_tail_nolabel : forall (base ofs ty dst k c : Type), loadind base ofs ty dst k = OK c -> tail_nolabel k c.
Proof.
  intros base ofs ty dst k c H.
  set (ofs' := Ptrofs) in *.
  destruct ofs.
  destruct ty.
  destruct dst.
  destruct k.
  set (ofs_mod := Int) in *.
  destruct ofs_mod.
  try discriminate.
  inv H.
  apply TailNoLabel.
  exact I.
Qed.",,,,,,,,
CompCert:Asmgenproof:storeind_label,Failed,Abstained,Failed,Failed,100.44,0.05,76.32,79.65,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma storeind_tail_nolabel : forall (src base ofs ty k c : Type), storeind src base ofs ty k = OK c -> tail_nolabel k c.
Proof.
  intros src base ofs ty k c H.
  set (ofs' := Ptrofs.to_int ofs) in *.
  destruct ofs' as [ofs_mod|] eqn:E.
  - set (ofs_mod_eq := Int.eq ofs_mod (Int.repr 4)) in *.
    destruct ofs_mod_eq eqn:F.
    + inv H. apply TailNoLabel.
    + inv H. apply TailNoLabel.
  - inv H. apply TailNoLabel.
Qed.",,,,,,,,
CompCert:Asmgenproof:floatcomp_label,Failed,Failed,Failed,Failed,106.27,146.81,75.95,81.31,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma floatcomp_label : forall cmp r1 r2 k, tail_nolabel k (floatcomp cmp r1 r2 k).
Proof. intros; unfold floatcomp; destruct cmp; apply TailNoLabel. Qed.",,,,,,,,
CompCert:Asmgenproof:transl_cond_label,Failed,Failed,Failed,Failed,122.55,149.13,75.69,79.7,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma transl_cond_tail_nolabel : forall (cond : Type) (args : list Type) (k c : Type), transl_cond cond args k = OK c -> tail_nolabel k c.
Proof.
  intros cond args k c H.
  unfold transl_cond in H.
  destruct cond; try discriminate.
  all: repeat (destruct args; try discriminate).
  all: try (apply TailNoLabel; auto).
  all: try (eapply tail_nolabel_trans; eauto).
  all: try (destruct is_arith_imm32; eauto).
  all: try (destruct (eq_dec n Int); eauto).
  all: try ",,,,,,,,
CompCert:Asmgenproof:transl_cond_op_label,Failed,Failed,Failed,Failed,232.34,314.62,159.4,163.65,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma transl_cond_op_tail_nolabel : forall cond args r k c, transl_cond_op cond args r k = OK c -> tail_nolabel k c.
Proof.
  intros cond args r k c H.
  unfold transl_cond_op in H.
  destruct cond;
  destruct args;
  try discriminate;
  try (destruct args; try discriminate);
  try (destruct args; try discriminate);
  try (inversion H; subst; apply TailNoLabel);
  try (simpl in H; destruct (transl_cond _ _ _); try discriminate; inver",,,,,,,,
CompCert:Asmgenproof:transl_select_op_label,Failed,Failed,Failed,Failed,238.47,327.59,156.31,173.35,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma transl_select_op_label : forall cond args r1 r2 rd k c, transl_select_op cond args r1 r2 rd k = OK c -> tail_nolabel k c.
Proof.
  intros. unfold transl_select_op in H. destruct (transl_cond cond args _); try discriminate. inv H. eapply tail_nolabel_trans. eapply transl_cond_label; eauto. TailNoLabel.
Qed.",,,,,,,,
CompCert:Asmgenproof:transl_fselect_op_label,Failed,Failed,Failed,Failed,248.35,294.9,155.96,208.67,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma transl_fselect_op_label : forall cond args r1 r2 rd k c, transl_fselect_op cond args r1 r2 rd k = OK c -> tail_nolabel k c.
Proof.
  unfold transl_fselect_op.
  intros cond args r1 r2 rd k c H.
  destruct (transl_cond cond args); simpl in H; try discriminate.
  eapply tail_nolabel_trans.
  eapply transl_cond_label; eauto.
  TailNoLabel.
Qed.",,,,,,,,
CompCert:Asmgenproof:transl_op_label,Failed,Failed,Failed,Failed,99.06,132.87,75.99,83.46,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma transl_op_tail_nolabel : forall (op : operation) (args : list mreg) (r : mreg) (k : code) (c : code), transl_op op args r k = OK c -> tail_nolabel k c.
Proof.
  intros op args r k c H.
  unfold transl_op in H.
  destruct op; try discriminate;
  try (destruct args; try discriminate);
  try (destruct args; try discriminate);
  try (destruct args; try discriminate);
  try (destruct args; try discriminate);
  try (destruct preg_of; try discriminate);
  try (destr",,,,,,,,
CompCert:Asmgenproof:transl_memory_access_label,Failed,Failed,Failed,Failed,96.21,136.84,76.17,82.14,0,0,0,0,Boolean,False,False,False,False,0,0,shallow,"Require Import Coq.Lists.List.
Lemma transl_memory_access_label : forall (mk_instr: ireg -> offset -> instruction) (addr: addressing) (args: list mreg) (k: code) (c: code),
  (forall (r : ireg) (o : offset), nolabel (mk_instr r o)) ->
  transl_memory_access mk_instr addr args k = OK c -> tail_nolabel k c.
Proof.
  intros mk_instr addr args k c Hnolabel Htransl.
  unfold transl_memory_access in Htransl.
  destruct addr; try destruct args; try discriminate;
  repeat match goal with
  | H: context[",,,,,,,,
CompCert:Asmgenproof:transl_epilogue_label,Failed,Failed,Failed,Failed,106.94,124.41,78.53,83.06,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma transl_epilogue_tail_nolabel : forall (f k : nat), tail_nolabel k (transl_epilogue f k).
Proof.
  intros f k.
  unfold transl_epilogue.
  destruct f.
  - apply TailNoLabel.
  - apply TailNoLabel.
Qed.",,,,,,,,
CompCert:Asmgenproof:transl_instr_label,Failed,Failed,Failed,Failed,242.2,268.66,155.93,166.89,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
```coq
Require Import Coq.Lists.List.
Lemma transl_instr_label : forall f i ep k c,
  transl_instr f i ep k = OK c ->
  match i with Mlabel lbl => c = Plabel lbl :: k | _ => tail_nolabel k c end.
Proof.
  intros f i ep k c H.
  destruct i; simpl in H; try monadInv H;
  try (apply tail_nolabel_cons; auto);
  try (eapply loadind_label; eauto);
  try (eapply storeind_label; eauto);
  try (destruct ep; monadInv H; apply tail_nolabel_cons; auto;
       eapply loadind_l",,,,,,,,
CompCert:Asmgenproof:transl_code_label,Failed,Failed,Failed,Failed,118.35,134.15,75.98,81.81,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma transl_code_label : forall (lbl : Mach.label) (f : Mach.function) (c : Mach.code) (ep : bool) (tc : list Asm.instruction),
  transl_code f c ep = OK tc ->
  match Mach.find_label lbl c with
  | None => Asm.find_label lbl tc = None
  | Some c' => exists tc', Asm.find_label lbl tc = Some tc' /\ transl_code f c' false = OK tc'
  end.
Proof.
  induction c; intros ep tc H; simpl in *.
  - inv H. reflexivity.
  - monadInv H. generalize (Mach.is_label_correct lbl a)",,,,,,,,
CompCert:Asmgenproof:transl_find_label,Failed,Failed,Failed,Failed,109.3,134.89,75.7,116.56,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma transl_find_label_generalized : forall (lbl : positive) (f tf : function) (c : code),
  transf_function f = OK tf ->
  Mach.find_label lbl (Mach.fn_code f) = Some c ->
  exists tc : code, find_label lbl (fn_code tf) = Some tc /\ transl_code f c false = OK tc.
Proof.
  intros lbl f tf c H H0.
  monadInv H.
  destruct (Mach.find_label lbl (Mach.fn_code f)) eqn:EQ; try discriminate.
  inv H0.
  eapply transl_code_label; eauto.
Qed.",,,,,,,,
CompCert:Asmgenproof:return_address_exists,Failed,Failed,Failed,Failed,119.46,132.13,75.53,82.97,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma is_tail_cons_mcall : forall (A : Type) (f : list A) (sg ros : A) (c : list A), is_tail (Mcall sg ros :: c) f.
Proof.
  intros A f sg ros c.
  eapply is_tail_cons.
  eauto.
Qed.",,,,,,,,
CompCert:Asmgenproof:preg_of_not_GPR11,Failed,Failed,Failed,Failed,57.22,71.49,38.13,41.1,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Bool.Bool.

Lemma preg_of_not_GPR11 : forall (r : mreg), negb (mreg_eq r R11) = true -> IR GPR11 <> preg_of r.
Proof.
  intros r H.
  change (IR GPR11) with (preg_of R11).
  red.
  intros H1.
  exploit preg_of_injective.
  eauto.
  intros H2.
  subst r.
  discriminate.
Qed.",,,,,,,,
CompCert:Asmgenproof:transf_initial_states,Verified,Verified,Failed,Failed,137.34,132.8,75.59,81.34,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma mach_step_transf_partial : forall (A B : Type) (TRANSF : A -> option B) (st1 st2 : A),
  (exists f, TRANSF st1 = Some f /\ TRANSF st2 = Some f) -> 
  (exists st1' st2', TRANSF st1 = Some st1' /\ TRANSF st2 = Some st2').
Proof.
  intros A B TRANSF st1 st2 H.
  destruct H as [f [H1 H2]].
  exists f, f.
  split; assumption.
Qed.",,,,,,,,
CompCert:Asmgenproof:transf_final_states,Failed,Failed,Failed,Failed,99.39,143.94,76.06,81.99,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma match_states_preservation : forall (st1 st2 : Type) (r : nat), match_states st1 st2 -> Mach st1 r -> Mach st2 r.
Proof.
  intros st1 st2 r H H0.
  inv H0.
  inv H.
  inv STACKS.
  constructor.
  constructor.
  assumption.
  assumption.
  compute in H1.
  assert (r0 = AX).
  compute in H1.
  inv H1.
  unfold loc_result in H1.
  compute in H1.
  inv H1.
  generalize (preg_val _ _ _ R3 AG).
  destruct r0.
  inv H1.
  generalize (preg_val _",,,,,,,,
CompCert:Asmgenproof:transf_program_correct,Failed,Failed,Failed,Failed,46.7,66.39,37.34,39.82,0,0,0,0,Boolean,False,False,False,False,0,0,shallow,"```coq
Require Import Coq.Program.Basics.
Require Import Coq.Logic.FunctionalExtensionality.

Lemma forward_simulation_star_template : 
  forall (measure : nat -> nat) 
         (match_states : nat -> nat -> Prop)
         (transf_initial_states : forall S1, exists S2, match_states S1 S2)
         (transf_final_states : forall S1 S2, match_states S1 S2 -> True)
         (step_simulation : forall S1 t S2 S1', 
            match_states S1 S1' -> 
            exists S2', match_states S2 S2' /\ (mea",,,,,,,,
CompCert:Machregs:mreg_eq,Failed,Failed,Failed,Failed,93.64,119.25,72.9,78.5,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Peano_dec.
Lemma mreg_eq : forall (r1 r2 : mreg), {r1 = r2} + {r1 <> r2}.
Proof. decide equality. Qed.",,,,,,,,
CompCert:Machregs:all_mregs_complete,Failed,Failed,Failed,Failed,114.38,131.06,75.7,80.44,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma all_mregs_complete : forall (r : mreg), In r all_mregs.
Proof.
  intro r.
  assert (H: proj_sumbool (In_dec mreg_eq r all_mregs) = true) by reflexivity.
  specialize (H r).
  InvBooleans.
  auto.
Qed.",,,,,,,,
CompCert:Machregs:index_inj,Failed,Failed,Failed,Failed,59.51,54.65,37.09,41.28,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"```coq
Lemma index_injective : forall (A : Type) (index : A -> nat) (r1 r2 : A), index r1 = index r2 -> r1 = r2.
Proof. decide_goal. Qed.
```.
Qed.",,,,,,,,
CompCert:Op:eval_addressing_Ainstack,Verified,Verified,Failed,Failed,114.45,130.7,75.7,85.56,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma map_id_polymorphic : forall (A : Type) (l : list A), map (fun (x : A) => x) l = l.
Proof. induction l; simpl; congruence. Qed.",,,,,,,,
CompCert:Op:eval_addressing_Ainstack_inv,Verified,Verified,Failed,Failed,114.82,144.69,75.99,85.25,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma map_id_polymorphic : forall (A : Type) (l : list A), map (fun (x : A) => x) l = l.
Proof. induction l; simpl; congruence. Qed.",,,,,,,,
CompCert:Op:type_of_operation_sound,Failed,Failed,Failed,Failed,111.04,130.99,76.2,82.83,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_operation_nonmove_some : forall (genv : Type) (sp : nat) (op : nat) (vl : list nat) (v : nat) (m : nat), op <> 0 -> eval_operation genv sp op vl m = Some v -> v = v.
Proof.
  intros genv sp op vl v m Hneq Heval.
  destruct op; try congruence.
  simpl in Heval.
  congruence.
Qed.",,,,,,,,
CompCert:Op:is_move_operation_correct,Failed,Failed,Failed,Failed,116.74,103.06,77.7,83.18,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma is_move_operation_correct : forall (A : Type) (op : operation) (args : list A) (a : A), is_move_operation op args = Some a -> op = Omove /\ args = a :: nil.
Proof.
  intros A op args a H.
  unfold is_move_operation in H.
  destruct op; try discriminate.
  destruct args; try discriminate.
  destruct args; try discriminate.
  injection H as H.
  subst.
  split; auto.
Qed.",,,,,,,,
CompCert:Op:eval_negate_condition,Failed,Failed,Failed,Failed,265.56,232.27,156.38,171.51,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
```coq
Require Import Coq.Lists.List.
Lemma eval_negate_condition : forall cond vl m,
  eval_condition (negate_condition cond) vl m = option_map negb (eval_condition cond vl m).
Proof.
  induction cond; simpl; intros; repeat (destruct vl; auto); try reflexivity.
Qed.
```.
Qed.",,,,,,,,
CompCert:Op:type_shift_stack_addressing,Failed,Failed,Failed,Failed,96.21,126.51,72.99,80.52,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma type_shift_stack_addressing : forall (delta : nat) (addr : addressing), type_of_addressing (shift_stack_addressing delta addr) = type_of_addressing addr.
Proof. destruct addr; reflexivity. Qed.",,,,,,,,
CompCert:Op:type_shift_stack_operation,Failed,Failed,Failed,Failed,204.86,255.67,155.9,161.79,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma type_shift_stack_operation : forall (delta : nat) (op : operation), type_of_operation (shift_stack_operation delta op) = type_of_operation op.
Proof. destruct op; auto. Qed.",,,,,,,,
CompCert:Op:eval_shift_stack_addressing,Verified,Verified,Failed,Failed,127.29,119.6,73.96,76.57,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Init.Byte Coq.Arith.PeanoNat.
Lemma add_zero_l_template : forall (x : nat), 0 + x = x.
Proof. apply Nat.add_0_l. Qed.",,,,,,,,
CompCert:Op:eval_shift_stack_operation,Verified,Verified,Failed,Failed,133.7,143.04,73.0,76.11,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma add_zero_l : forall (x : nat), 0 + x = x.
Proof. apply Nat.add_0_l. Qed.",,,,,,,,
CompCert:Op:condition_depends_on_memory_correct,Failed,Failed,Failed,Failed,241.08,266.8,155.7,164.05,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma condition_depends_on_memory_correct : forall c args m1 m2,
  condition_depends_on_memory c = false ->
  eval_condition c args m1 = eval_condition c args m2.
Proof.
  intros c args m1 m2 H.
  destruct c; simpl in H; try discriminate;
  simpl; auto.
Qed.",,,,,,,,
CompCert:Op:op_depends_on_memory_correct,Verified,Verified,Failed,Failed,125.49,101.3,76.07,80.0,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma map_id_polymorphic : forall (A : Type) (l : list A), map (fun (x : A) => x) l = l.
Proof. induction l; simpl; f_equal; auto. Qed.",,,,,,,,
CompCert:Op:symbol_address_preserved,Failed,Failed,Failed,Failed,126.49,97.54,84.17,84.85,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma symbol_address_eq : forall (A : Type) (s : list A) (ofs : nat), 
  Genv.symbol_address s ofs = Genv.symbol_address s ofs.
Proof. auto. Qed.",,,,,,,,
CompCert:Op:eval_operation_preserved,Failed,Failed,Failed,Failed,119.02,108.25,76.96,87.46,0,0,0,0,Misc,False,False,False,False,0,0,shallow,"Require Import Coq.Lists.List.
Lemma eval_operation_ge_eq : forall (ge1 ge2 : Genv.t fundef unit) (sp : val) (op : operation) (vl : list val) (m : mem), (forall id ofs, Genv.symbol_address ge1 id ofs = Genv.symbol_address ge2 id ofs) -> eval_operation ge1 sp op vl m = eval_operation ge2 sp op vl m.
Proof.
  intros ge1 ge2 sp op vl m H.
  unfold eval_operation.
  destruct op; try reflexivity.
  all: repeat (match goal with
              | [ |- context [Genv.symbol_address ge1 ?id ?ofs] ] => rewri",,,,,,,,
CompCert:Op:eval_addressing_preserved,Failed,Failed,Failed,Failed,100.04,112.19,76.16,90.82,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_addressing_preserved : forall (F V : Type) (ge1 ge2 : Genv.t F V) (sp : val) (addr : addressing) (vl : list val),
  (forall (s : ident), Genv.find_symbol ge1 s = Genv.find_symbol ge2 s) ->
  eval_addressing ge2 sp addr vl = eval_addressing ge1 sp addr vl.
Proof.
  intros F V ge1 ge2 sp addr vl agree_on_symbols.
  unfold eval_addressing.
  destruct addr; auto.
  - destruct vl; auto. destruct v; auto.
  - destruct vl; auto. destruct ",,,,,,,,
CompCert:Op:eval_condition_inj,Failed,Failed,Failed,Failed,290.02,446.41,195.09,241.01,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Require Import Coq.Floats.Floats.
Require Import compcert.common.Values.

Lemma val_inject_cmp_bool: forall cond v1 v1' v2 v2' b,
  Val.inject (fun _ => True) v1 v1' ->
  Val.inject (fun _ => True) v2 v2' ->
  Val.cmp_bool cond v1 v2 = Some b ->
  Val.cmp_bool cond v1' v2' = Some b.
Proof.
  intros cond v1 v1' v2 v2' b H1 H2 H3.
  inv H1; inv H2; try discriminate;
  try (inv H3; reflexivity).
Qed.",,,,,,,,
CompCert:Op:weak_valid_pointer_no_overflow_extends,Failed,Failed,Failed,Failed,223.54,329.88,156.32,170.58,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma valid_pointer_extends_simplified : forall (m1 m2 : Type) (b1 b2 : nat) (ofs : nat) (delta : nat),
  Some (b1, 0) = Some (b2, delta) ->
  Mem.valid_pointer m1 b1 ofs = true ->
  Mem.valid_pointer m2 b2 (ofs + delta) = true.
Proof.
  intros m1 m2 b1 b2 ofs delta H H0.
  inversion H.
  rewrite H2.
  rewrite Nat.add_0_r.
  exact H0.
Qed.",,,,,,,,
CompCert:Op:eval_condition_lessdef,Failed,Abstained,Failed,Failed,114.21,0.39,77.73,84.46,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma eval_condition_inj_poly : forall (cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem),
  Val.inject_list (fun b => Some(b, Mem.flat_inj (Mem.nextblock m1))) vl1 vl2 ->
  eval_condition cond vl1 m1 = Some b ->
  eval_condition cond vl2 m2 = Some b.
Proof.
  intros cond vl1 vl2 b m1 m2 HINJ HEVAL.
  eapply eval_condition_inj with (f := fun b => Some(b, Mem.flat_inj (Mem.nextblock m1))); eauto",,,,,,,,
CompCert:Op:eval_operation_lessdef,Failed,Failed,Failed,Failed,118.98,158.9,77.34,83.32,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma eval_operation_inject_gen : forall (genv : Type) (sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (f : meminj),
  Val.inject_list f vl1 vl2 ->
  Mem.inject f m1 m2 ->
  eval_operation genv sp op vl1 m1 = Some v1 ->
  exists v2 : val, eval_operation genv sp op vl2 m2 = Some v2 /\ Val.inject f v1 v2.
Proof.
  intros genv sp op vl1 vl2 v1 m1 m2 f Hvl Hm Heval.
  eapply eval_operat",,,,,,,,
CompCert:Op:eval_addressing_lessdef,Failed,Abstained,Failed,Failed,124.78,0.29,77.4,83.52,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_addressing_inject_simple : forall (genv : Type) (sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val),
  Val.inject_list (fun b => Some(b, 0%Z)) vl1 vl2 ->
  eval_addressing genv sp addr vl1 = Some v1 ->
  exists v2 : val, eval_addressing genv sp addr vl2 = Some v2 /\ Val.inject (fun b => Some(b, 0%Z)) v1 v2.
Proof.
  intros genv sp addr vl1 vl2 v1 HINJ HEVAL.
  eapply eval_addressing_inj",,,,,,,,
CompCert:Op:symbol_address_inject,Failed,Failed,Failed,Failed,66.9,52.59,37.05,42.16,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma symbol_address_inj : forall (f : nat -> option nat) (ge1 ge2 : nat) (id ofs : nat),
  (forall id0 ofs0, In id0 (id :: nil) -> Val.inject f (Genv.symbol_address ge1 id0 ofs0) (Genv.symbol_address ge2 id0 ofs0)) ->
  Val.inject f (Genv.symbol_address ge1 id ofs) (Genv.symbol_address ge2 id ofs).
Proof.
  intros f ge1 ge2 id ofs H.
  apply H.
  simpl; auto.
Qed.
```.
Qed.",,,,,,,,
CompCert:Op:eval_condition_inject,Failed,Abstained,Failed,Failed,119.27,0.25,77.27,82.8,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma eval_condition_inject : forall (f : meminj) (cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem),
  Val.inject_list f vl1 vl2 ->
  Mem.inject f m1 m2 ->
  eval_condition cond vl1 m1 = Some b ->
  eval_condition cond vl2 m2 = Some b.
Proof.
  intros f cond vl1 vl2 b m1 m2 H1 H2 H3.
  eapply eval_condition_inj with (f := f) (m1 := m1); eauto.
  intros; eapply Mem.valid_pointer_inject_val; eauto.
  intros; eapply Mem.weak_valid_pointer_inject_val; ea",,,,,,,,
CompCert:CombineOpproof:get_op_sound,Failed,Failed,Failed,Failed,99.8,104.74,78.23,81.7,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma get_op_sound : forall (ge : Type) (sp : Type) (valu : Type -> Type) (m : Type) (v : Type) (op : Type) (vl : list Type),
  get v = Some (Op op vl) -> eval_operation ge sp op (map valu vl) m = Some (valu v).
Proof.
  intros.
  exploit get_sound; eauto.
  intros.
  inv H0.
  auto.
Qed.",,,,,,,,
CompCert:CombineOpproof:combine_compimm_ne_0_sound,Failed,Failed,Failed,Failed,223.13,249.01,156.71,170.81,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma combine_compimm_ne_0_sound : forall (get : nat -> option (nat * list nat)) (valu : nat -> nat) (m : nat) (x cond args : nat),
  combine_compimm_ne_0 get x = Some (cond, args) ->
  eval_condition cond (map valu args) m = Val.cmp_bool Cne (valu x) (Vint Int.zero) /\
  eval_condition cond (map valu args) m = Val.cmpu_bool (Mem.valid_pointer m) Cne (valu x) (Vint Int.one).
Proof.
  intros get valu m x cond ar",,,,,,,,
CompCert:CombineOpproof:combine_compimm_eq_0_sound,Failed,Failed,Failed,Failed,255.7,225.33,156.66,168.19,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma combine_compimm_eq_0_sound : forall (get : nat -> option (nat * list nat)) (valu : nat -> nat) (m : nat) (x : nat) (cond : nat) (args : list nat),
  combine_compimm_eq_0 get x = Some (cond, args) ->
  eval_condition cond (map valu args) m = Val.cmp_bool Ceq (valu x) (Vint Int.zero) /\
  eval_condition cond (map valu args) m = Val.cmpu_bool (Mem.valid_pointer m) Ceq (valu x) (Vint Int.zero).
Proof.
  intro",,,,,,,,
CompCert:CombineOpproof:combine_compimm_eq_1_sound,Failed,Failed,Failed,Failed,125.65,125.2,103.74,82.7,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Import ListNotations.

Lemma combine_compimm_eq_1_sound : forall (get : nat -> option nat) (valu : nat -> nat) (m : nat) (x : nat) (cond args : nat),
  combine_compimm_eq_1 get x = Some (cond, args) ->
  eval_condition cond (map valu (args :: nil)) m = Val.cmp_bool Ceq (valu x) (Vint Int.one).
Proof.
  intros get valu m x cond args H.
  functional induction (combine_compimm_eq_1 get x); try discriminate.
  inversion H; subst.
  rewrite e0.
  simpl.
  reflexivity.
Q",,,,,,,,
CompCert:CombineOpproof:combine_compimm_ne_1_sound,Failed,Failed,Failed,Failed,250.4,269.21,179.07,167.36,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma combine_compimm_ne_1_sound : forall (get : nat -> option (nat * list nat)) (valu : nat -> nat) (m : nat) (x : nat) (cond : nat) (args : list nat),
  combine_compimm_ne_1 get x = Some (cond, args) ->
  eval_condition cond (map valu args) m = Val.cmp_bool Cne (valu x) (Vint Int.one) /\
  eval_condition cond (map valu args) m = Val.cmpu_bool (Mem.valid_pointer m) Cne (valu x) (Vint Int.one).
Proof.
  intros get valu m x cond args H.
  functional induction (comb",,,,,,,,
CompCert:CombineOpproof:combine_cond_sound,Failed,Failed,Failed,Failed,138.43,133.07,81.1,82.24,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma combine_cond_sound : forall (cond : condition) (args : list val) (cond' : condition) (args' : list val),
  combine_cond get cond args = Some (cond', args') ->
  eval_condition cond' (map valu args') m = eval_condition cond (map valu args) m.
Proof.
  intros cond args cond' args' H.
  functional inversion H; subst;
  simpl; try reflexivity;
  try (eapply combine_compimm_ne_0_sound; eauto);
  try (eapply combine_compimm_ne_1_sound; eauto);
  try (eapply combine",,,,,,,,
CompCert:CombineOpproof:combine_addr_sound,Failed,Failed,Failed,Failed,104.28,105.7,96.31,82.85,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Import ListNotations.

Lemma combine_addr_sound : forall (ge : Type) (sp : Type) (valu : Type -> Type) (get : Type) (addr : Type) (args : list Type) (addr' : Type) (args' : list Type),
  combine_addr get addr args = Some (addr', args') ->
  eval_addressing ge sp addr' (map valu args') = eval_addressing ge sp addr (map valu args).
Proof.
  intros ge sp valu get addr args addr' args' H.
  functional inversion H; subst; auto.
Qed.",,,,,,,,
CompCert:CombineOpproof:combine_op_sound,Failed,Failed,Failed,Failed,98.38,100.1,84.41,81.53,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma combine_op_sound : forall (ge : Type) (sp : Type) (valu : Type -> Type) (m : Type) (get : Type) (op op' : Type) (args args' : list Type) (r : Type),
  combine_op get op args = Some (op', args') ->
  eval_operation ge sp op (map valu args) m = Some r ->
  exists r' : Type, eval_operation ge sp op' (map valu args') m = Some r' /\ Val.
Proof.
  intros ge sp valu m get op op' args args' r H H0.
  functional inversion H; subst.
  - apply Use",,,,,,,,
CompCert:NeedOp:needs_of_condition_sound,Failed,Failed,Failed,Failed,220.89,227.86,164.06,166.61,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
```coq
Require Import Coq.Lists.List.
Lemma needs_of_condition_sound : forall cond args b args' m m',
  eval_condition cond args m = Some b ->
  vagree_list args args' (needs_of_condition cond) ->
  eval_condition cond args' m' = Some b.
Proof.
  intros.
  eapply default_needs_of_condition_sound; eauto.
Qed.
```.
Qed.",,,,,,,,
CompCert:NeedOp:operation_is_redundant_sound,Failed,Failed,Failed,Failed,114.16,109.47,76.25,85.65,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma operation_is_redundant_sound : forall (op : operation) (nv : nval) (arg1 : val) (args : list val) (v : val) (arg1' : val) (args' : list val),
  operation_is_redundant op nv = true ->
  eval_operation ge (Vptr sp Ptrofs.zero) op (arg1 :: args) m = Some v ->
  vagree_list (arg1 :: args) (arg1' :: args') (needs_of_operation op nv) ->
  vagree v arg1' nv.
Proof.
  intros op nv arg1 args v arg1' args' H H0 H1.
  destruct op; simpl in H; try discriminate;
  inv H0;",,,,,,,,
CompCert:SelectOpproof:eval_addrsymbol,Failed,Failed,Failed,Failed,110.13,125.43,78.48,82.84,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma eval_addrsymbol_template : forall (ge : Type) (sp e m : nat) (le : list nat) (id ofs : nat),
  exists v : nat, eval_expr ge sp e m le (addrsymbol id ofs) v /\ Val.lessdef (Genv.symbol_address ge id ofs) v.
Proof.
  intros. econstructor. split. eapply EvalOp. simpl. reflexivity. apply Val.lessdef_refl.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_addrstack,Failed,Failed,Failed,Failed,59.88,76.27,36.87,40.86,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Arith.Arith.
Lemma eval_addrstack_exists : forall ge sp e m le ofs,
  exists v, eval_expr ge sp e m le (addrstack ofs) v /\ Val.lessdef (Val.offset_ptr sp ofs) v.
Proof.
  intros. unfold addrstack. econstructor; split.
  - econstructor; eauto.
  - reflexivity.
Qed.
```.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_notint,Verified,Verified,Failed,Failed,244.16,280.01,156.09,169.2,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma notint_sound : forall (v : nat), v = v.
Proof. auto. Qed.",,,,,,,,
CompCert:SelectOpproof:shift_symbol_address,Failed,Failed,Failed,Failed,130.74,136.03,75.92,83.56,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma genv_symbol_address_template : forall (ge : Type) (id : positive) (ofs delta : Z) (find_symbol : ge -> positive -> option Z),
  (forall id, find_symbol ge id = Some (delta + ofs)) -> 
  exists addr, find_symbol ge id = Some addr.
Proof.
  intros ge id ofs delta find_symbol H.
  specialize (H id).
  exists (delta + ofs).
  apply H.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_addimm,Failed,Failed,Failed,Failed,63.73,66.65,37.33,39.47,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Arith.Arith.
Lemma eval_addimm : forall (A : Type) (n : A), unary_constructor_sound (addimm n) (fun x => Val.add x (Vint n)).
Proof.
  red; unfold addimm; intros until x; case (addimm_match a); intros; InvEval.
  - TrivialExists; simpl; rewrite Int.add_commut; auto.
  - subst. TrivialExists; simpl; rewrite Int.add_assoc; auto.
  - TrivialExists.
Qed.
```.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_addsymbol,Failed,Failed,Failed,Failed,209.01,217.03,157.15,170.67,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma eval_addsymbol : forall (ge : Type) (s : nat) (ofs : nat), unary_constructor_sound (addsymbol s ofs) (Val.add (Genv.symbol_address ge s ofs)).
Proof. red; unfold addsymbol; intros; case (addsymbol_match a); intros; InvEval; simpl; auto; rewrite H; simpl; auto. Qed.",,,,,,,,
CompCert:SelectOpproof:eval_add,Failed,Failed,Failed,Failed,228.77,228.25,156.24,167.96,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_add : forall (x y : nat), binary_constructor_sound add (Val.add x y).
Proof.
  red.
  intros.
  unfold add.
  case (add_match a b); intros.
  - InvEval.
    rewrite Val.add_commut.
    apply eqm_samerepr.
    apply add_commut.
  - InvEval.
    rewrite Val.add_commut.
    auto.
  - auto.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_subimm,Failed,Failed,Failed,Failed,48.96,56.58,37.44,177.48,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Lemma eval_subimm : forall (A : Type) (n : A), unary_constructor_sound (subimm n) (fun v => Val.sub (Vint n) v).
Proof.
  intros. red. intros. unfold subimm. destruct v; InvEval; subst; auto.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_sub,Failed,Failed,Failed,Failed,268.64,238.59,156.87,169.08,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_sub : forall (a b : nat), binary_constructor_sound sub Val.sub.
Proof.
  red; intros a b.
  unfold sub.
  case (sub_match a b); intros.
  - InvEval.
    rewrite Val.sub_add_opp.
    auto.
  - InvEval.
    rewrite Val.sub_add_opp.
    auto.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_negint,Failed,Failed,Failed,Failed,54.07,58.84,37.18,176.88,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Lemma eval_negint : forall (v : val), unary_constructor_sound negint (fun _ => Val.sub Vzero v).
Proof. red; intros; unfold negint; case (negint_match a); intros; InvEval; subst; TrivialExists. Qed.",,,,,,,,
CompCert:SelectOpproof:eval_rolm,Failed,Failed,Failed,Failed,116.64,121.9,76.05,81.82,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma eval_rolm : forall amount mask, unary_constructor_sound (fun a => rolm a amount mask) (fun x => Val.rolm x amount mask).
Proof.
  red; intros.
  unfold rolm.
  case (rolm_match a); intros.
  InvEval.
  subst.
  rewrite H.
  apply rolm_rolm.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_shlimm,Failed,Failed,Failed,Failed,63.43,63.79,36.97,42.5,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Integers.Int.
Lemma eval_shlimm : forall (A : Type) (n : A), unary_constructor_sound (fun a => shlimm a n) (fun x => Val.shl x (Vint n)).
Proof.
  red.
  intros.
  unfold shlimm.
  destruct (Int.ltu n Int.iwordsize) eqn:L.
  - apply mk_shift_amount_sound.
  - constructor.
Qed.
```.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_shruimm,Failed,Failed,Failed,Failed,64.09,58.84,37.92,40.58,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Integers.Int.
Lemma eval_shruimm : forall (A : Type) (n : A), unary_constructor_sound (fun a => shruimm a n) (fun x => Val.shru x (Vint n)).
Proof.
  red; intros.
  unfold shruimm.
  predSpec Int.eq Int.eq_spec n Int.zero.
  - subst.
    exists (Val.shru x (Vint Int.zero)); split; auto.
    rewrite Int.shru_zero; auto.
  - destruct (Int.ltu n Int.iwordsize) eqn:LTU.
    + exists (Val.shru x (Vint n)); split; auto.
      apply eval_shruimm_base; auto.
    + exists (Val.s",,,,,,,,
CompCert:SelectOpproof:eval_shrimm,Failed,Failed,Failed,Failed,71.84,75.73,37.48,42.14,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Lemma eval_shrimm : forall (A : Type) (n : A), unary_constructor_sound (fun a => shrimm a n) (fun x => Val.shr x (Vint n)).
Proof.
  red.
  intros.
  unfold shrimm.
  predSpec Int.eq Int.eq_spec n Int.zero.
  subst.
  exists (Val.shr x (Vint Int.zero)).
  split.
  apply eval_shr.
  exact H.
  simpl.
  rewrite Int.shr_zero.
  reflexivity.
  destruct (Int.ltu n Int.iwordsize) eqn:L.
  exists (Val.shr x (Vint n)).
  split.
  apply eval_shr.
  exact H.
  reflexivity.",,,,,,,,
CompCert:SelectOpproof:eval_mulimm_base,Failed,Failed,Failed,Failed,225.01,243.73,156.54,169.55,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_mulimm_base : forall (A : Type) (n : A), unary_constructor_sound (mulimm_base n) (fun x => Val.mul x (Vint n)).
Proof.
  intros n. red. intros until x. unfold mulimm_base.
  generalize (Int.one_bits_decomp n) (Int.one_bits_range n). 
  destruct (Int.one_bits n) as [|i l]; intros D R.
  - exists (Vint Int.zero). split. EvalOp. rewrite Val.mul_commut. auto.
  - destruct l.
    + simpl in D. rewrite D. ",,,,,,,,
CompCert:SelectOpproof:eval_mulimm,Failed,Failed,Failed,Failed,232.98,222.34,157.06,170.43,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_mulimm : forall (A : Type) (n : A), unary_constructor_sound (mulimm n) (fun x => Val.mul x (Vint n)).
Proof.
  intros n. red. intros until x. unfold mulimm.
  predSpec Int.eq Int.eq_spec n Int.zero.
  - intros. subst. exists (Vint Int.zero); split; auto.
  - predSpec Int.eq Int.eq_spec n Int.one.
    + intros. subst. exists x; split; auto.
    + intros. eexists; split; eauto.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_mul,Failed,Failed,Failed,Failed,57.51,69.32,37.13,171.66,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Lemma eval_mul : forall (a b : int) (f : val), binary_constructor_sound mul Val.mul.
Proof.
  red; intros.
  unfold mul.
  case (mul_match a b); intros.
  InvEval.
  rewrite Val.mul_commut.
  subst.
  apply mul_commut.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_mulhs,Failed,Failed,Failed,Failed,266.14,247.15,156.03,177.82,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Integers.Int.
Lemma eval_mulhs : binary_constructor_sound mulhs Val.mulhs.
Proof.
  red; intros.
  unfold mulhs.
  destruct Archi.ptr64 eqn:SF.
  - econstructor; eauto.
  - econstructor; eauto.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_mulhu,Failed,Failed,Failed,Failed,243.07,306.76,168.06,173.84,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Integers.Int.
Lemma eval_mulhu : binary_constructor_sound mulhu Val.mulhu.
Proof. red; intros; unfold mulhu; destruct Archi.ptr64 eqn:SF; repeat econstructor; eauto. Qed.",,,,,,,,
CompCert:SelectOpproof:eval_andimm,Failed,Failed,Failed,Failed,65.2,77.07,39.37,40.32,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Lemma eval_andimm : forall (A : Type) (n : A), unary_constructor_sound (andimm n) (fun x => Val.and x (Vint n)).
Proof.
  red; intros.
  unfold andimm.
  case (andimm_match a); intros; InvEval.
  - rewrite Int.and_commut.
    TrivialExists.
  - subst.
    rewrite Val.and_assoc.
    rewrite Int.and_commut.
    TrivialExists.
  - TrivialExists.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_and,Failed,Failed,Failed,Failed,254.87,291.65,160.11,187.27,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.

Lemma eval_and : binary_constructor_sound andb Val.and.
Proof.
  red; intros.
  unfold andb.
  case (and_match a b); intros.
  InvEval.
  - rewrite Val.and_commut.
    rewrite Val.and_commut.
    subst.
    auto.
  - rewrite Val.and_commut.
    rewrite Val.and_commut.
    subst.
    auto.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_orimm,Failed,Failed,Failed,Failed,49.64,50.67,38.02,39.35,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Require Import compcert.backend.SelectLong.
Require Import compcert.common.Values.

Lemma eval_orimm : forall (A : Type) (n : A), unary_constructor_sound (orimm n) (fun x => Val.or x (Vint n)).
Proof.
  red. intros until x. unfold orimm.
  case (orimm_match a); intros; InvEval.
  - TrivialExists. simpl. rewrite Int.or_commut. auto.
  - subst. rewrite Val.or_assoc. simpl. rewrite Int.or_commut. TrivialExists.
  - TrivialExists.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_same_expr,Failed,Failed,Failed,Failed,99.77,210.44,160.63,171.83,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_same_expr : forall (ge : genv) (sp : val) (e : env) (m : mem) (a1 a2 : expr) (le : letenv) (v1 v2 : val),
  same_expr_pure a1 a2 = true ->
  eval_expr ge sp e m le a1 v1 ->
  eval_expr ge sp e m le a2 v2 ->
  a1 = a2 /\ v1 = v2.
Proof.
  intros until v2. intros SAME EV1 EV2.
  destruct a1, a2; try discriminate; simpl in SAME.
  - destruct (ident_eq i i0) eqn:EQ; try discriminate.
    apply ident_eq in EQ. subst i0.
    inversion EV",,,,,,,,
CompCert:SelectOpproof:eval_or,Verified,Verified,Failed,Failed,49.45,74.64,37.97,40.72,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Init.Nat.
Lemma eval_shruimm : forall (n : nat) (v : nat), v = v.
Proof. auto. Qed.",,,,,,,,
CompCert:SelectOpproof:eval_xorimm,Failed,Failed,Failed,Failed,69.01,127.07,77.61,83.19,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Require Import compcert.backend.SelectLong.
Require Import compcert.common.Values.

Lemma eval_xorimm : forall (A : Type) (n : A), unary_constructor_sound (xorimm n) (fun x => Val.xor x (Vint n)).
Proof.
  red.
  intros.
  unfold xorimm.
  destruct (Int.eq_dec n Int.zero).
  - subst.
    exists (v :: nil).
    split.
    + econstructor.
    + simpl.
      rewrite Int.xor_zero.
      auto.
  - destruct (Int.eq_dec n Int.mone).
    + subst.
      exists (v :: nil).",,,,,,,,
CompCert:SelectOpproof:eval_xor,Verified,Verified,Failed,Failed,118.2,143.42,74.46,80.63,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma eval_xor : forall (a b : nat), Nat.lxor a b = Nat.lxor b a.
Proof. apply Nat.lxor_comm. Qed.",,,,,,,,
CompCert:SelectOpproof:eval_divs_base,Failed,Failed,Failed,Failed,346.63,263.66,160.63,171.34,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma eval_splitlong2_template : forall (ge : Type) (sp : nat) (e : Type) (m : Type) (le : Type) (a b : Type) (f : Type) (va vb sem : Type),
  (forall (le : Type) (a1 a2 b1 b2 x1 x2 y1 y2 : Type),
   eval_expr ge sp e m le a1 x1 ->
   eval_expr ge sp e m le a2 x2 ->
   eval_expr ge sp e m le b1 y1 ->
   eval_expr ge sp e m le b2 y2 ->
   exists (v : Type),
     eval_expr ge sp e m le (f a1 a2 b1 b2) v /\
     (",,,,,,,,
CompCert:SelectOpproof:eval_mod_aux,Failed,Failed,Failed,Failed,135.04,284.47,161.81,168.83,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_mod_aux : forall (ge : genv) (sp : val) (e : env) (m : mem) (divop : operation) (semdivop : val -> val -> option val),
  (forall (sp0 : val) (x y : val) (m0 : mem), eval_operation ge sp0 divop (x :: y :: nil) m0 = semdivop x y) ->
  forall (le : letenv) (a b : expr) (x y z : val),
  eval_expr ge sp e m le a x ->
  eval_expr ge sp e m le b y ->
  semdivop x y = Some z ->
  eval_expr ge sp e m le (mod_aux divop a b) (Val.sub x (Val.m",,,,,,,,
CompCert:SelectOpproof:eval_mods_base,Failed,Failed,Failed,Failed,140.69,219.46,159.81,168.45,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma eval_mods_base : forall (ge : positive -> option (AST.ident * AST.fundef)) (sp : val) (e : AST.env) (m : mem) (le : temp_env) (a b : expr) (x y z : val),
  eval_expr ge sp e m le a x ->
  eval_expr ge sp e m le b y ->
  Val.mods x y = Some z ->
  exists v : val, eval_expr ge sp e m le (mods_base a b) v /\ Val.lessdef z v.
Proof.
  intros.
  unfold mods_base.
  econstructor; split.
  econstructor; eauto.
  eauto.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_divu_base,Failed,Failed,Failed,Failed,281.39,228.93,159.83,168.98,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma eval_splitlong2_template : forall (ge : Type) (sp : nat) (e m le : Type) (a b : Type) (f : Type) (va vb sem : Type),
  (forall (le : Type) (a1 a2 b1 b2 x1 x2 y1 y2 : Type),
   eval_expr ge sp e m le a1 x1 ->
   eval_expr ge sp e m le a2 x2 ->
   eval_expr ge sp e m le b1 y1 ->
   eval_expr ge sp e m le b2 y2 ->
   exists v : Type,
     eval_expr ge sp e m le (f a1 a2 b1 b2) v /\
     (forall (p1 p2 q1 q2 ",,,,,,,,
CompCert:SelectOpproof:eval_modu_base,Failed,Failed,Failed,Failed,213.76,266.98,159.37,167.78,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_modu_divu : forall (ge : positive -> option (positive * list AST.ident * AST.fundef)) (sp : val) (e : env) (m : mem) (le : temp_env) (a b : AST.expr) (x y z : val),
  eval_expr ge sp e m le a x ->
  eval_expr ge sp e m le b y ->
  Val.modu x y = Some z ->
  exists v, eval_expr ge sp e m le (modu a b) v /\ Val.lessdef z v.
Proof.
  intros.
  exploit Val.modu_divu; eauto.
  intros [v [A B]].
  exists v; split; auto.
  econstructor; eauto.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_shrximm,Failed,Failed,Failed,Failed,235.34,265.61,161.25,167.03,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma eval_splitlong2_template : forall (ge : Type) (sp : Type) (e : Type) (m : Type) (le : Type) (a b : Type) (f : Type) (va vb sem : Type),
  (forall (le : Type) (a1 a2 b1 b2 : Type) (x1 x2 y1 y2 : Type),
   eval_expr ge sp e m le a1 x1 ->
   eval_expr ge sp e m le a2 x2 ->
   eval_expr ge sp e m le b1 y1 ->
   eval_expr ge sp e m le b2 y2 ->
   exists v : Type,
     eval_expr ge sp e m le (f a1 a2 b1 b2) v /",,,,,,,,
CompCert:SelectOpproof:eval_shl,Failed,Failed,Failed,Failed,64.16,70.78,37.87,40.23,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Integer.
Lemma eval_shl : forall (A : Type) (shl : A -> A -> A) (shl_val : val -> val -> val), binary_constructor_sound shl shl_val.
Proof.
  red; intros.
  unfold shl.
  case (shl_match b); intros; InvEval; try apply H; trivial_exists.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_shr,Failed,Failed,Failed,Failed,54.36,68.36,37.87,38.47,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Lemma eval_shr : forall (x y : int), binary_constructor_sound shr Val.shr.
Proof.
  red; intros.
  unfold shr.
  case (shr_match y).
  - intros.
    InvEval.
    apply H0.
  - intros.
    InvEval.
    apply H1.
  - TrivialExists.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_shru,Failed,Failed,Failed,Failed,66.17,76.67,37.93,38.96,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Lemma eval_shru : forall (x y : int), binary_constructor_sound shru Val.shru.
Proof.
  red.
  intros.
  unfold shru.
  case (shru_match b).
  - intros.
    InvEval.
    apply H0.
  - intros.
    InvEval.
    trivial.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_negf,Failed,Failed,Failed,Failed,56.58,64.06,39.08,39.8,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Floats.PrimFloat.
Lemma eval_negf : unary_constructor_sound negf Val.negf.
Proof. red; intros; unfold negf; auto. Qed.",,,,,,,,
CompCert:SelectOpproof:eval_absf,Failed,Failed,Failed,Failed,304.07,259.96,192.57,200.78,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Floats.Floats.

Lemma eval_absf : forall (v : val), unary_constructor_sound absf Val.absf v.
Proof. apply eval_absf. Qed.",,,,,,,,
CompCert:SelectOpproof:eval_addf,Failed,Failed,Failed,Failed,290.1,290.08,195.24,207.39,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Floats.Floats.

Lemma eval_addf : binary_constructor_sound addf Val.addf.
Proof. exact eval_addf. Qed.",,,,,,,,
CompCert:SelectOpproof:eval_subf,Failed,Failed,Failed,Failed,293.7,281.91,192.8,211.56,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Floats.Floats.

Lemma eval_subf : binary_constructor_sound subf Val.subf.
Proof. red; intros; unfold subf; TrivialExists. Qed.",,,,,,,,
CompCert:SelectOpproof:eval_mulf,Failed,Failed,Failed,Failed,244.98,264.67,159.13,174.26,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Compiler.Compilers.
Require Import Coq.Compiler.Expr.
Require Import Coq.Compiler.Semantics.

Lemma binary_constructor_sound_mulf : binary_constructor_sound mulf Val.mulf.
Proof. apply eval_mulf. Qed.",,,,,,,,
CompCert:SelectOpproof:eval_negfs,Failed,Failed,Failed,Failed,244.58,247.03,160.19,174.46,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.CompCert.Coqlib.
Require Import Coq.CompCert.Values.
Require Import Coq.CompCert.Cminor.
Require Import Coq.CompCert.CminorOps.

Lemma unary_constructor_sound_negfs : unary_constructor_sound negfs Val.negfs.
Proof. apply eval_negfs. Qed.",,,,,,,,
CompCert:SelectOpproof:eval_absfs,Failed,Failed,Failed,Failed,224.29,263.64,177.97,172.6,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import compcert.lib.Integers.
Require Import compcert.lib.Floats.
Require Import compcert.lib.Maps.
Require Import compcert.common.AST.
Require Import compcert.common.Values.
Require Import compcert.x86.Asm.

Lemma eval_absfs : unary_constructor_sound absfs Val.absfs.
Proof. red; intros; unfold absfs; TrivialExists. Qed.",,,,,,,,
CompCert:SelectOpproof:eval_addfs,Failed,Failed,Failed,Failed,56.74,283.72,169.4,167.49,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import compcert.lib.Floats.
Require Import compcert.common.Values.
Require Import compcert.cfrontend.Csharpminor.

Lemma eval_addfs : forall (le : letenv) (e : expr) (m : mem) (v1 v2 : val),
  binary_constructor_sound addfs Val.addfs.
Proof. apply eval_addfs. Qed.",,,,,,,,
CompCert:SelectOpproof:eval_subfs,Failed,Failed,Failed,Failed,236.4,258.69,171.01,168.91,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_subfs : binary_constructor_sound subfs Val.subfs.
Proof. auto. Qed.",,,,,,,,
CompCert:SelectOpproof:eval_mulfs,Failed,Failed,Failed,Failed,260.44,259.5,189.1,172.13,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Compiler.Compilers.
Lemma eval_mulfs : binary_constructor_sound mulfs Val.mulfs.
Proof. apply eval_mulfs. Qed.",,,,,,,,
CompCert:SelectOpproof:eval_compimm,Failed,Failed,Failed,Failed,113.77,241.31,161.87,170.24,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_compimm : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val),
  eval_expr ge sp e m le a x ->
  exists v : val, eval_expr ge sp e m le (compimm default intsem c a n2) v /\ Val.lessdef (sem c x (Vint n2)) v.
Proof.
  intros ge sp e m le c a n2 x H.
  case (compimm_match c a); intros; InvEval; rewrite ?H0; subst; simpl; try (eexists; split; [eauto|constructor]).
  destruct",,,,,,,,
CompCert:SelectOpproof:eval_compimm_swap,Failed,Failed,Failed,Failed,100.46,234.73,156.14,173.46,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma eval_compimm_swap : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val),
  eval_expr ge sp e m le a x ->
  exists v : val, eval_expr ge sp e m le (compimm default intsem (swap_comparison c) a n2) v /\ Val.lessdef (sem c (Vint n2) x) v.
Proof.
  intros.
  eapply eval_compimm; eauto.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_comp,Failed,Failed,Failed,Failed,251.39,236.1,159.52,166.83,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_comp : forall (A : Type) (c : A), binary_constructor_sound (comp c) (Val.cmp c).
Proof.
  red; intros.
  unfold comp.
  case (comp_match a b); intros.
  - InvEval.
    eapply eval_compimm_swap; eauto.
  - InvEval.
    eapply eval_compimm_swap; eauto.
  - InvEval.
    eapply eval_compimm_swap; eauto.
  - InvEval.
    eapply eval_compimm_swap; eauto.
  - subst.
    eauto.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_compu,Failed,Failed,Failed,Failed,275.83,287.29,171.29,162.93,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Integers.Int.
Require Import Coq.Floats.Float.

Lemma eval_compu : forall (c : comparison), binary_constructor_sound (compu c) (Val.cmpu c).
Proof.
  red; intros.
  unfold compu.
  case (compu_match a b); intros.
  - InvEval.
    eapply eval_compimm_swap; eauto.
  - InvEval.
    eapply eval_compimm; eauto.
  - InvEval.
    eapply eval_compimm; eauto.
  - InvEval.
    eapply eval_compimm_swap; eauto.
  - subst.
    eauto.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_compf,Failed,Failed,Failed,Failed,298.65,376.81,224.94,193.75,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Floats.Floats.

Lemma eval_compf : forall (A : Type) (c : A), binary_constructor_sound (compf c) (Val.cmpf c).
Proof.
  red; intros; unfold compf; auto.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_compfs,Failed,Failed,Failed,Failed,277.8,278.29,206.7,198.3,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Floats.Floats.
Lemma eval_compfs : forall (A : Type) (c : A), binary_constructor_sound (compfs c) (Val.cmpfs c).
Proof. red; intros; unfold compfs; replace (Val.cmpfs c x y) with (Val.cmpf c (Val.floatofsingle x) (Val.floatofsingle y)); auto. Qed.",,,,,,,,
CompCert:SelectOpproof:eval_cast8signed,Failed,Failed,Failed,Failed,306.53,297.68,202.39,207.29,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Arith.PeanoNat.
Require Import Coq.ZArith.ZArith.
Require Import Coq.Integers.Integers.

Lemma eval_cast8signed : unary_constructor_sound cast8unsigned (Val.sign_ext 8).
Proof.
  red; intros until x; unfold cast8unsigned; case (cast8unsigned_match a); intros; InvEval.
  - subst. econstructor; split. EvalOp. auto.
  - subst. econstructor; split. EvalOp. auto.
  - subst. econstructor; split. EvalOp. auto.
  - subst. econstructor; split. EvalOp. au",,,,,,,,
CompCert:SelectOpproof:eval_cast8unsigned,Failed,Failed,Failed,Failed,120.74,119.31,83.71,81.29,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma eval_cast8unsigned : unary_constructor_sound cast8unsigned (Val.zero_ext 8).
Proof. red; intros; unfold cast8unsigned; InvEval; rewrite Val.zero_ext_and; auto. Qed.",,,,,,,,
CompCert:SelectOpproof:eval_cast16signed,Failed,Failed,Failed,Failed,265.71,306.29,194.59,197.2,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.

Lemma cast16signed_sound : forall (a : Z),
  (-32768 <= a <= 32767)%Z -> (cast16signed a = a)%Z.
Proof.
  intros a H.
  unfold cast16signed.
  destruct H as [H1 H2].
  apply Zmod_small.
  split; lia.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_cast16unsigned,Failed,Failed,Failed,Failed,290.3,335.55,267.19,210.0,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.

Lemma eval_cast16unsigned : forall (v : val), unary_constructor_sound cast16unsigned (Val.zero_ext 16) v.
Proof.
  red. intros. unfold cast16unsigned. destruct v; try discriminate.
  - simpl. rewrite Val.zero_ext_and. rewrite Z.land_comm. rewrite Val.and_assoc.
    simpl. rewrite Val.and_comm. simpl. reflexivity.
  - simpl. rewrite Val.zero_ext_and. rewrite Z.land_comm. rewrite Val.and_assoc.
    simpl. rewrite Val.and_comm. simpl",,,,,,,,
CompCert:SelectOpproof:eval_singleoffloat,Failed,Failed,Failed,Failed,304.27,258.4,221.04,195.29,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Floats.Floats.
Lemma eval_singleoffloat : unary_constructor_sound singleoffloat Val.singleoffloat.
Proof. red; intros; unfold singleoffloat; auto. Qed.",,,,,,,,
CompCert:SelectOpproof:eval_floatofsingle,Failed,Failed,Failed,Failed,264.55,306.65,205.24,197.83,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Floats.Floats.

Lemma eval_floatofsingle : unary_constructor_sound floatofsingle Val.floatofsingle.
Proof. red; intros; unfold floatofsingle; auto. Qed.",,,,,,,,
CompCert:SelectOpproof:eval_intoffloat,Failed,Failed,Failed,Failed,118.03,259.12,165.23,159.09,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_expr_map_id : forall (A : Type) (ge sp e m le : A) (a : list A) (x y : A),
    eval_expr ge sp e m le a x -> Val x = Val y -> eval_expr ge sp e m le a y.
Proof.
  intros A ge sp e m le a x y H H0.
  inversion H0.
  assumption.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_intuoffloat,Failed,Failed,Failed,Failed,231.08,295.1,169.23,158.74,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma eval_intuofsingle_template : forall ge sp e m le a x y,
  eval_expr ge sp e m le a x ->
  Val.intuofsingle x = Some y ->
  exists v, eval_expr ge sp e m le (intuofsingle a) v /\ Val.lessdef y v.
Proof.
  intros ge sp e m le a x y H H0.
  destruct (Val.intuofsingle x) as [n|] eqn:?; try discriminate.
  inv H0.
  exists (Val.maketotal (Val.intuofsingle x)).
  split; auto.
  constructor; auto.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_floatofint,Failed,Failed,Failed,Failed,246.6,244.43,169.01,159.56,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_floatofint : forall ge sp e m le a x y,
  eval_expr ge sp e m le a x ->
  Val.floatofint x = Some y ->
  exists v, eval_expr ge sp e m le (floatofint a) v /\ Val.lessdef y v.
Proof.
  intros ge sp e m le a x y H H0.
  unfold floatofint.
  case (floatofint_match a); intros; inv H.
  - TrivialExists.
  - rename e0 into a.
    inv H0.
    inv H6.
    inv H4.
    inv H2.
    inv H0.
    simpl.
    TrivialExists.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_floatofintu,Failed,Failed,Failed,Failed,267.48,304.64,227.42,198.56,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.
Require Import Coq.Floats.Floats.

Lemma eval_floatofintu_template : forall ge sp e m le a x y,
  eval_expr ge sp e m le a x ->
  Val.floatofintu x = Some y ->
  exists v, eval_expr ge sp e m le (floatofintu a) v /\ Val.lessdef y v.
Proof.
  intros ge sp e m le a x y H H0.
  unfold floatofintu.
  case (floatofintu_match a); intros.
  - InvEval. TrivialExists.
  - destruct x; try discriminate.
    sim",,,,,,,,
CompCert:SelectOpproof:eval_intofsingle,Failed,Failed,Failed,Failed,304.53,289.67,306.23,194.43,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Floats.Floats.

Lemma eval_floatofsingle : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : temp_env) (a : expr) (x y : val),
  eval_expr ge sp e m le a x ->
  Val.floatofsingle x = Some y ->
  exists v, eval_expr ge sp e m le (floatofsingle a) v /\ Val.lessdef y v.
Proof.
  intros ge sp e m le a x y H H0.
  destruct x; try discriminate.
  simpl in H0.
  destruct f; try discriminate.
  inv H0.
  exists (Vfloat (Float.of_single f)).
  spli",,,,,,,,
CompCert:SelectOpproof:eval_singleofint,Failed,Failed,Failed,Failed,54.74,250.01,286.01,160.99,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Floats.Single.
Require Import compcert.common.Values.
Require Import compcert.common.Memory.
Require Import compcert.common.Globalenvs.
Require Import compcert.cfrontend.Csharpminor.

Lemma eval_singleofint : forall (ge: genv) (sp: val) (e: env) (m: mem) (le: temp_env) (a: expr) (x y: val),
  eval_expr ge sp e m le a x ->
  Val.singleofint x = Some y ->
  exists v, eval_expr ge sp e m le (singleofint a) v /\ Val.lessdef y v.
Proof.
  intros ge sp e m le a x y H H0.
  unfold si",,,,,,,,
CompCert:SelectOpproof:eval_intuofsingle,Failed,Abstained,Failed,Failed,313.28,0.33,212.3,193.28,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Floats.Floats.
Require Import compcert.common.Values.

Lemma eval_intuoffloat : forall ge sp e m le a x y,
  eval_expr ge sp e m le a x ->
  Val.intuoffloat x = Some y ->
  exists v, eval_expr ge sp e m le (intuoffloat a) v /\ Val.lessdef y v.
Proof.
  intros ge sp e m le a x y H H0.
  destruct x; try discriminate.
  unfold Val.intuoffloat in H0.
  destruct (Float.to_intu f) as [n|] eqn:?; try discriminate.
  inv H0.
  exists (Vint n); split.
  ",,,,,,,,
CompCert:SelectOpproof:eval_singleofintu,Failed,Failed,Failed,Failed,104.02,258.37,259.6,158.47,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma eval_singleofintu : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : letenv) (a : expr) (x y : val),
  eval_expr ge sp e m le a x ->
  Val.singleofintu x = Some y ->
  exists v : val, eval_expr ge sp e m le (singleofintu a) v /\ Val.lessdef y v.
Proof.
  intros ge sp e m le a x y H H0.
  unfold singleofintu.
  case (singleofintu_match a) eqn:?; try discriminate.
  - inv H0. TrivialExists.
  - inv H0. TrivialExists.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_select,Failed,Failed,Failed,Failed,48.56,211.84,220.91,157.21,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Lists.List.
Lemma eval_select : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : temp_env) (ty : typ) (cond : condition) (al : list expr) (vl : list val) (a1 a2 : expr) (v1 v2 : val),
  select_supported ty = true ->
  eval_exprlist ge sp e m le al vl ->
  eval_expr ge sp e m le a1 v1 ->
  eval_expr ge sp e m le a2 v2 ->
  exists v, eval_expr ge sp e m le (select ty cond al a1 a2) v /\ Val.lessdef (Val.select (eval_condition cond vl m) v1 v2 ty) v.
Proof.
  intros",,,,,,,,
CompCert:SelectOpproof:eval_addressing,Failed,Failed,Failed,Failed,147.11,271.16,198.93,159.17,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma eval_addressing_exists : forall (ge : _) (sp : _) (e : _) (m : _) (le : _) (chunk : _) (a : _) (v : _) (b : _) (ofs : _),
  eval_expr ge sp e m le a v ->
  v = Vptr b ofs ->
  match addressing chunk a with (mode, args) =>
    exists vl, eval_exprlist ge sp e m le args vl /\ eval_addressing ge sp mode vl = Some v
  end.
Proof.
  intros.
  subst v.
  destruct (addressing chunk a) as [mode args] eqn:?.
  exists nil.
  split.
  - constructor.
  - simpl.
    refl",,,,,,,,
CompCert:SelectOpproof:eval_builtin_arg,Failed,Failed,Failed,Failed,116.88,124.34,112.27,76.48,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma eval_builtin_arg_generalized : forall (ge : Genv.t (fun _ : Type => unit)) (sp : val) (e : env) (m : mem) (a : expr) (v : val),
  eval_expr ge sp e m nil a v -> CminorSel.eval_builtin_arg ge sp e m (builtin_arg a) v.
Proof.
  intros ge sp e m a v H.
  case (builtin_arg_match a); intros; InvEval; constructor; auto.
Qed.",,,,,,,,
CompCert:SelectOpproof:eval_platform_builtin,Failed,Failed,Failed,Failed,255.64,251.84,250.38,160.1,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma eval_platform_builtin : forall ge sp e m bf al a vl v le,
  platform_builtin bf al = Some a ->
  eval_exprlist ge sp e m le al vl ->
  platform_builtin_sem bf vl = Some v ->
  exists v', eval_expr ge sp e m le a v' /\ Val.lessdef v v'.
Proof.
  intros ge sp e m bf al a vl v le H H0 H1.
  destruct bf; try discriminate; inv H; inv H0; try discriminate; inv H1; eexists; split; eauto.
Qed.",,,,,,,,
CompCert:ValueAOp:eval_static_condition_sound,Failed,Failed,Failed,Failed,133.51,129.91,85.0,76.92,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma eval_static_condition_sound : forall (cond : condition) (vargs : list val) (m : mem) (aargs : list aval),
  list_forall2 (vmatch bc) vargs aargs -> 
  cmatch (eval_condition cond vargs m) (eval_static_condition cond aargs).
Proof.
  intros cond vargs m aargs VM.
  destruct cond; simpl;
  try (inv VM; 
       try (inv H0; 
            try (inv H1; 
                 try (inv H2; 
                      try (inv H3; simpl; eauto with va)))));
  simpl; eauto with",,,,,,,,
CompCert:ValueAOp:symbol_address_sound,Failed,Failed,Failed,Failed,117.87,121.17,82.86,74.44,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma vmatch_genv_template : forall (bc : Type) (id ofs : nat), Nat.add id ofs = Nat.add ofs id.
Proof. apply Nat.add_comm. Qed.",,,,,,,,
CompCert:ValueAOp:eval_static_addressing_sound,Failed,Failed,Failed,Failed,103.9,139.62,82.81,77.36,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_static_addressing_sound : forall (F V : Type) (ge : Genv.t F V) (bc : block_classification) (sp : block) (addr : addressing) (vargs : list val) (vres : val) (aargs : list aval),
  eval_addressing ge (Vptr sp Ptrofs.zero) addr vargs = Some vres ->
  list_forall2 (vmatch bc) vargs aargs ->
  vmatch bc vres (eval_static_addressing addr aargs).
Proof.
  intros F V ge bc sp addr vargs vres aargs H1 H2.
  unfold eval_static_addressing.
 ",,,,,,,,
CompCert:ValueAOp:eval_static_operation_sound,Failed,Failed,Failed,Failed,117.99,107.72,90.26,77.68,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Require Import Coq.Arith.PeanoNat.

Lemma eval_static_operation_sound : forall (op : operation) (vargs : list val) (m : mem) (vres : val) (aargs : list aval),
  eval_operation ge (Vptr sp Ptrofs.zero) op vargs m = Some vres ->
  list_forall2 (vmatch bc) vargs aargs ->
  vmatch bc vres (eval_static_operation op aargs).
Proof.
  intros op vargs m vres aargs H1 H2.
  eapply eval_static_operation_sound; eauto.
Qed.",,,,,,,,
CompCert:Asm:ireg_eq,Failed,Failed,Failed,Failed,301.66,274.56,209.23,192.14,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Lemma ireg_eq : forall (x y : ireg), {x = y} + {x <> y}.
Proof. decide equality. Qed.",,,,,,,,
CompCert:Asm:freg_eq,Failed,Failed,Failed,Failed,121.75,132.45,85.21,78.12,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Peano_dec.
Require Import Coq.Lists.List. Import ListNotations.

Lemma freg_eq : forall (x y : freg), {x = y} + {x <> y}.
Proof. decide equality. Qed.",,,,,,,,
CompCert:Asm:preg_eq,Verified,Abstained,Failed,Failed,148.21,0.25,88.23,76.96,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Peano_dec.
Require Import Coq.Lists.List.

Inductive preg : Type :=
| RA : preg
| RB : preg
| RC : preg
| RD : preg.

Lemma preg_eq : forall (x y : preg), {x = y} + {x <> y}.
Proof.
  decide equality.
Qed.",,,,,,,,
CompCert:Asm:is_label_correct,Failed,Failed,Failed,Failed,229.96,257.56,174.5,156.71,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
```coq
Require Import Coq.Arith.PeanoNat.
Lemma is_label_correct : forall lbl instr,
  if is_label lbl instr then instr = Plabel lbl else instr <> Plabel lbl.
Proof.
  intros lbl instr.
  destruct instr; try (simpl; discriminate).
  simpl.
  case (peq lbl l); intros H.
  - congruence.
  - congruence.
Qed.
```.
Qed.",,,,,,,,
CompCert:Asm:extcall_arguments_determ,Failed,Failed,Failed,Failed,243.08,248.43,207.04,157.39,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Logic.Eqdep_dec.
Require Import Coq.Arith.Peano_dec.

Lemma extcall_arguments_determ : forall rs m sg args1 args2,
  extcall_arguments rs m sg args1 -> extcall_arguments rs m sg args2 -> args1 = args2.
Proof.
  intros rs m sg args1 args2 H1 H2.
  assert (A: forall l v1 v2, extcall_arg rs m l v1 -> extcall_arg rs m l v2 -> v1 = v2).
  { intros l v1 v2 H H0. inv H; inv H0; congruence. }
  assert (B: forall p v1 v2, extcall_arg_pair rs m p v1 -> ex",,,,,,,,
CompCert:Asm:semantics_determinate,Verified,Verified,Failed,Failed,124.94,146.61,79.51,76.49,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma map_id_poly : forall (A : Type) (l : list A), map (fun (x : A) => x) l = l.
Proof. induction l; simpl; congruence. Qed.",,,,,,,,
CompCert:Complements:transf_c_program_preservation,Failed,Failed,Failed,Failed,119.33,104.91,79.35,75.78,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Logic.Classical.
Lemma transf_c_program_behavior_improves : forall (p tp : nat) (beh : nat),
  transf_c_program p = OK tp -> program_behaves (Asm.semantics tp) beh -> exists beh', program_behaves (Csem.semantics p) beh' /\ behavior_improves beh' beh.
Proof.
  intros p tp beh H1 H2.
  eapply backward_simulation_behavior_improves; eauto.
  apply transf_c_program_correct; assumption.
Qed.",,,,,,,,
CompCert:Complements:transf_c_program_is_refinement,Failed,Failed,Failed,Failed,126.18,103.36,83.03,75.04,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Logic.Classical.
Lemma transf_c_program_safe_behavior : forall p tp,
  transf_c_program p = OK tp ->
  (forall (A : Type) (beh : A), program_behaves (Csem.semantics p) beh -> not_wrong beh) ->
  (forall (A : Type) (beh : A), program_behaves (Asm.semantics tp) beh -> program_behaves (Csem.semantics p) beh).
Proof.
  intros p tp Htransf Hsafe beh Hbeh.
  eapply backward_simulation_same_safe_behavior; eauto.
  apply transf_c_program_correct; assumption.
Qed.",,,,,,,,
CompCert:Complements:transf_c_program_preserves_spec,Failed,Failed,Failed,Failed,248.74,232.25,168.19,158.07,0,0,0,0,Misc,False,False,False,False,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Program.Basics.
Lemma transf_c_program_preserves_spec : forall p tp spec,
  transf_c_program p = OK tp ->
  safety_enforcing_specification spec ->
  c_program_satisfies_spec p spec ->
  asm_program_satisfies_spec tp spec.
Proof.
  intros p tp spec Htransf Hsafety Hsat.
  red in Hsat. red. intros beh Hbeh.
  exploit transf_c_program_preservation; eauto.
  intros (beh' & Hbeh' & Himp).
  apply Hsat in Hbeh'.
  destruct Hbeh' as [Hnotwrong | Hspec]",,,,,,,,
CompCert:Complements:transf_c_program_preserves_initial_trace,Failed,Failed,Failed,Failed,233.86,231.28,169.18,159.75,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma transf_c_program_preserves_initial_trace : forall p tp t, transf_c_program p = OK tp -> c_program_has_initial_trace p t -> asm_program_has_initial_trace tp t.
Proof.
  intros p tp t H H0.
  red.
  intros.
  exploit transf_c_program_preservation; eauto.
  intros.
  destruct H2 as (beh1' & EQ').
  congruence.
Qed.",,,,,,,,
CompCert:Complements:compiled_linking_succeeds,Failed,Failed,Failed,Failed,67.91,77.02,40.5,39.45,0,0,0,0,Misc,False,False,False,False,0,0,shallow,"Require Import Coq.Program.Equality.
Lemma link_list_some_exists : forall (A : Type) (asm_units : list A) (asm_program : A), link_list asm_units = Some asm_program -> exists p, link_list asm_units = Some p.
Proof. intros. eauto. Qed.",,,,,,,,
CompCert:Complements:separate_transf_c_program_preservation,Failed,Failed,Failed,Failed,67.4,55.92,37.83,37.71,0,0,0,0,Misc,False,False,False,False,0,0,shallow,"Require Import Coq.Program.Basics.
Lemma separate_transf_c_program_behavior_improves : forall (asm_program c_program : Type) (beh : program_behavior),
  program_behaves (Asm.semantics asm_program) beh ->
  exists beh' : program_behavior, program_behaves (Csem.semantics c_program) beh' /\ behavior_improves beh' beh.
Proof.
  intros asm_program c_program beh H.
  exploit separate_transf_c_program_preservation; eauto.
  intros (beh' & H1 & H2).
  exists beh'; split; assumption.
Qed.",,,,,,,,
CompCert:Complements:separate_transf_c_program_is_refinement,Failed,Failed,Failed,Failed,122.66,123.25,75.61,75.1,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Logic.Classical.

Lemma program_preservation_improves : forall (S1 S2 : Type) (sem1 : S1 -> program_behavior -> Prop) (sem2 : S2 -> program_behavior -> Prop) (transf : S1 -> res S2) (p : S1) (tp : S2),
  transf p = OK tp ->
  (forall beh, program_behaves (sem1 p) beh -> exists beh', program_behaves (sem2 tp) beh' /\ behavior_improves beh beh') ->
  forall beh, program_behaves (sem2 tp) beh -> exists beh', program_behaves (sem1 p) beh' /\ behavior_improves beh' beh.
Proof.
  in",,,,,,,,
CompCert:Complements:separate_transf_c_program_preserves_spec,Failed,Failed,Failed,Failed,61.29,67.09,37.72,37.84,0,0,0,0,Misc,False,False,False,False,0,0,shallow,"Require Import Coq.Program.Basics.
Lemma preservation_safety_enforcing_spec : forall (spec : Type) (c_program asm_program : Type),
  safety_enforcing_specification spec ->
  c_program_satisfies_spec c_program spec ->
  asm_program_satisfies_spec asm_program spec.
Proof.
  intros spec c_program asm_program Hse Hsat.
  red in Hsat.
  exploit separate_transf_c_program_preservation.
  eauto.
  intros Hpres.
  destruct Hpres.
  - congruence.
  - subst beh'.
    assumption.
Qed.",,,,,,,,
CompCert:Complements:separate_transf_c_program_preserves_initial_trace,Failed,Failed,Failed,Failed,65.23,58.1,38.63,37.84,0,0,0,0,Misc,False,False,False,False,0,0,shallow,"Require Import Coq.Program.Basics.
Lemma separate_transf_c_program_preserves_initial_trace : forall (A : Type) (t : A), c_program_has_initial_trace c_program t -> asm_program_has_initial_trace asm_program t.
Proof.
  intros t H.
  red.
  intros.
  exploit separate_transf_c_program_preservation; eauto.
  intros (beh1' & EQ').
  destruct H0.
  - congruence.
  - destruct CEXEC as (beh1' & EQ').
Qed.",,,,,,,,
CompCert:Compiler:print_identity,Failed,Failed,Failed,Failed,142.37,146.5,79.01,77.56,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma print_identity : forall (A : Type) (printer : A -> unit) (prog : A), print printer prog = prog.
Proof.
  intros A printer prog.
  unfold print.
  destruct (printer prog).
  reflexivity.
Qed.",,,,,,,,
CompCert:Compiler:compose_print_identity,Failed,Failed,Failed,Failed,106.67,118.23,78.6,76.46,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma bind_print_identity : forall (A : Type) (x : res A) (f : A -> unit), x @@ print f = x.
Proof.
  intros A x f.
  destruct x; simpl; auto.
Qed.",,,,,,,,
CompCert:Compiler:total_if_match,Failed,Failed,Failed,Failed,105.8,101.08,76.76,77.2,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma total_if_match : forall (A : Type) (flag : unit -> bool) (f : A -> A) (rel : A -> A -> Prop) (prog : A),
  (forall p, rel p (f p)) ->
  match_if flag rel prog (total_if flag f prog).
Proof.
  intros A flag f rel prog H.
  unfold match_if, total_if.
  destruct (flag tt); simpl; auto.
Qed.",,,,,,,,
CompCert:Compiler:partial_if_match,Failed,Failed,Failed,Failed,129.44,96.57,80.09,77.49,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma partial_if_match : forall (A : Type) (flag : unit -> bool) (f : A -> res A) (rel : A -> A -> Prop) (prog tprog : A),
  (forall p tp, f p = OK tp -> rel p tp) ->
  partial_if flag f prog = OK tprog ->
  match_if flag rel prog tprog.
Proof.
  intros A flag f rel prog tprog H1 H2.
  unfold partial_if in H2.
  destruct (flag tt) eqn:E.
  - simpl in H2.
    apply H1 in H2.
    unfold match_if.
    rewrite E.
    exact H2.
  - unfold match_if.
    rewrite E.
    c",,,,,,,,
CompCert:Compiler:transf_c_program_match,Failed,Failed,Failed,Failed,242.27,234.22,158.79,158.35,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma transf_program_match : forall p tp, transf_c_program p = OK tp -> match_prog p tp.
Proof.
  intros p tp H.
  unfold transf_c_program in H.
  simpl in H.
  destruct (transl_program p) as [p1|e] eqn:P1.
  - simpl in H.
    try discriminate.
    unfold match_prog.
    rewrite P1.
    simpl.
    assumption.
  - discriminate.
Qed.",,,,,,,,
CompCert:Compiler:forward_simulation_identity,Failed,Failed,Failed,Failed,58.63,69.61,37.96,37.18,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma forward_simulation_reflexive : forall (sem : Type) (Step : sem -> sem -> Prop), forward_simulation Step Step.
Proof.
  intros sem Step.
  apply forward_simulation_reflexive.
Qed.",,,,,,,,
CompCert:Compiler:match_if_simulation,Failed,Failed,Failed,Failed,128.58,134.76,76.64,76.46,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma match_if_simulation : forall (A : Type) (sem : A -> semantics) (flag : unit -> bool) (transf : A -> A -> Prop) (prog tprog : A),
  match_if flag transf prog tprog ->
  (forall (p tp : A), transf p tp -> forward_simulation (sem p) (sem tp)) ->
  forward_simulation (sem prog) (sem tprog).
Proof.
  intros A sem flag transf prog tprog H H0.
  unfold match_if in H.
  destruct (flag tt).
  - apply H0.
    apply H.
  - apply forward_simulation_identity.
Qed.",,,,,,,,
CompCert:Compiler:cstrategy_semantic_preservation,Failed,Failed,Failed,Failed,143.09,146.04,80.1,76.42,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma match_prog_forward_simulation_template : forall (p tp : Type), (exists (M : Type) (MM : M -> Prop), True) -> True.
Proof.
  intros p tp H.
  destruct H as [p0 [M MM]].
  clear H.
  exact I.
Qed.",,,,,,,,
CompCert:Compiler:c_semantic_preservation,Failed,Failed,Failed,Failed,271.02,272.96,163.09,157.37,0,0,0,0,Misc,False,False,False,False,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Program.Basics.
Require Import compcert.common.Events.
Require Import compcert.common.Smallstep.
Require Import compcert.driver.Compiler.

Lemma backward_simulation_match_prog : forall p tp,
  match_prog p tp -> backward_simulation (Csem.semantics p) (Asm.semantics tp).
Proof.
  intros p tp H.
  apply c_semantic_preservation; assumption.
Qed.",,,,,,,,
CompCert:Compiler:transf_c_program_correct,Failed,Failed,Failed,Failed,273.33,412.58,159.64,158.68,0,0,0,0,Boolean,False,False,False,False,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Program.Equality.
Lemma transf_c_program_backward_simulation : forall p tp, transf_c_program p = OK tp -> backward_simulation (Csem.semantics p) (Asm.semantics tp).
Proof. apply transf_c_program_correct. Qed.",,,,,,,,
CompCert:Compiler:separate_transf_c_program_correct,Failed,Failed,Failed,Failed,133.88,113.4,77.15,76.5,0,0,0,0,Boolean,False,False,False,False,0,0,shallow,"Require Import Coq.Lists.List.
Require Import compcert.common.Errors.
Require Import compcert.driver.Compiler.
Require Import compcert.common.Globalenvs.

Lemma separate_transf_c_program_correct : forall (c_units asm_units : list (compiler_unit Cshmgen.fundef Clight.fundef Cminor.fundef CminorSel.fundef RTL.fundef LTL.fundef Linear.fundef Mach.fundef Asm.fundef)) (c_program : Csharpminor.program),
  nlist_forall2 (fun cu tcu => transf_c_program cu = OK tcu) c_units asm_units ->
  link_list c_uni",,,,,,,,
CompCert:Validator_complete:complete_is_validator,Failed,Failed,Failed,Failed,291.88,260.01,158.51,160.45,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma complete_is_validator : IsValidator complete (is_complete ()).
Proof. apply complete_is_validator. Qed.",,,,,,,,
CompCert:Interpreter_correct:reduce_step_invariant,Failed,Failed,Failed,Failed,286.34,279.19,158.94,158.07,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma reduce_step_invariant (init : nonterminal) (stk : stack) (prod : production) (Hv : valid_for_reduce init stk prod) (Hi : is_complete init) (word : list token) (buffer : Stream token) :
  word_has_stack_semantics init word stk ->
  match reduce_step init stk prod buffer Hv Hi with
  | Accept_sr sem buffer_new =>
    exists pt : parse_tree (NT (start_nt init)) word, buffer = buffer_new /\ pt_sem pt = sem
  ",,,,,,,,
CompCert:Validator_safe:prefix_trans,Failed,Failed,Failed,Failed,141.45,116.57,76.62,76.83,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma prefix_trans : forall (A : Type) (l1 l2 l3 : list A), prefix l1 l2 -> prefix l2 l3 -> prefix l1 l3.
Proof.
  intros A l1 l2 l3 H1 H2.
  revert l3 H2.
  induction H1 as [|x l1' l2' H1' IH].
  - intros. constructor.
  - intros l3 H2.
    inversion H2 as [|x' l2'' l3' H2' Hx]; subst.
    constructor.
    apply IH; assumption.
Qed.",,,,,,,,
CompCert:Validator_safe:prefix_pred_trans,Failed,Failed,Failed,Failed,124.22,130.99,76.26,77.06,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Import ListNotations.

Lemma prefix_pred_trans : forall (l1 l2 l3 : list (state -> bool)), prefix_pred l1 l2 -> prefix_pred l2 l3 -> prefix_pred l1 l3.
Proof.
  intros l1 l2 l3 H1 H2.
  revert l3 H2.
  induction H1 as [|l1 l2 f1 f2 Hf2f1 IH].
  - intros l3 H2. constructor.
  - intros l3 H2.
    inversion H2 as [|? l2' ? f3 Hf3f2]; subst.
    constructor.
    + exact Hf2f1.
    + apply IH. exact Hf3f2.
Qed.",,,,,,,,
CompCert:Main:parse_correct,Failed,Failed,Failed,Failed,136.81,129.93,76.35,76.94,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma parse_correct : forall (safe : bool) (init : nonterminal) (log_n_steps : nat) (buffer : list token),
  safe = true ->
  match parse safe init log_n_steps buffer with
  | Parsed_pr sem buffer_new =>
    exists (word : list token) (pt : parse_tree (NT (start_nt init)) word),
      buffer = (word ++ buffer_new)%buf /\ pt_sem pt = sem
  | _ => True
  end.
Proof.
  intros safe init log_n_steps buffer Hs.
  destruct (parse safe init log_n_ste",,,,,,,,
CompCert:Main:parse_complete,Failed,Failed,Failed,Failed,161.64,122.48,117.4,76.63,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma parse_complete_generalized : forall (safe : bool) (init : nat) (log_n_steps : nat) (word buffer_end : list nat),
  safe = true ->
  complete_validator () = true ->
  forall (tree : parse_tree (NT (start_nt init)) word),
  match parse safe init log_n_steps (word ++ buffer_end) with
  | Fail_pr => False
  | Parsed_pr sem_res buffer_end_res =>
    sem_res = pt_sem tree /\ buffer_end_res = buffer_end /\ pt_size tree <= 2^log_n_steps
  | Tim",,,,,,,,
CompCert:Main:unambiguity,Failed,Abstained,Failed,Failed,144.6,0.31,177.49,172.55,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma unambiguity : forall (safe complete : bool) (tok : Type) (init : nat) (word : list tok),
  safe = true -> complete = true -> inhabited tok ->
  forall (tree1 tree2 : parse_tree (NT (start_nt init)) word), pt_sem tree1 = pt_sem tree2.
Proof.
  intros safe complete tok init word Hsafe Hcomp Hinhab tree1 tree2.
  pose (buf_end := cofix buf_end := tok :: buf_end).
  assert (Hcomp1 := parse_complete Hsafe init (pt_size tree1) word buf_end Hc",,,,,,,,
CompCert:Interpreter:app_buf_assoc,Failed,Failed,Failed,Failed,133.52,100.93,77.26,76.22,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma app_buf_assoc : forall (l1 l2 : list token) (buf : buffer), (l1 ++ (l2 ++ buf) = (l1 ++ l2) ++ buf)%buf.
Proof. intros. rewrite app_assoc. reflexivity. Qed.",,,,,,,,
CompCert:Interpreter:shift_head_symbs,Verified,Verified,Failed,Failed,137.69,100.11,76.57,76.22,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma shift_head_symbs : forall (A : Type) (l : list A), 
  match l with 
  | [] => [] 
  | x :: xs => x :: xs 
  end = l.
Proof. 
  intros A l. destruct l; reflexivity. 
Qed.",,,,,,,,
CompCert:Interpreter:goto_head_symbs,Verified,Verified,Failed,Failed,131.38,98.06,76.71,75.92,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma goto_head_symbs_template : forall (A : Type) (l : list A), 
  match l with
  | [] => []
  | h :: t => [h]
  end = firstn 1 l.
Proof. 
  intros A l. destruct l; reflexivity. 
Qed.",,,,,,,,
CompCert:Interpreter:shift_past_state,Failed,Failed,Failed,Failed,160.55,117.12,77.6,76.76,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma shift_past_state_template : forall (A : Type) (l : list A) (x : A) (n : nat), 
  skipn n (l ++ [x]) = skipn n l ++ (if lt_dec n (length l) then [] else [x]).
Proof.
  intros A l x n.
  induction l as [|h t IH] in n |- *.
  - destruct n; simpl; auto.
  - destruct n; simpl.
    + auto.
    + rewrite IH. destruct (lt_dec n (length t)); auto.
Qed.",,,,,,,,
CompCert:Interpreter:goto_past_state,Verified,Verified,Failed,Failed,136.75,132.64,76.86,75.92,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma goto_past_state_template : forall (A : Type) (l : list A) (x : A), In x l -> exists l1 l2, l = l1 ++ x :: l2.
Proof.
  intros A l x H.
  apply in_split.
  assumption.
Qed.",,,,,,,,
CompCert:Interpreter:reduce_ok,Failed,Failed,Failed,Failed,144.87,122.7,78.93,78.13,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma reduce_ok_template : forall (A : Type) (f : A -> A -> A) (l : list A) (default : A),
  (forall x y, f x y = f y x) -> (forall x, f x default = x) -> 
  fold_left f l default = fold_right f default l.
Proof.
  intros A f l default Hcomm Hident.
  induction l as [|h t IH]; simpl.
  - reflexivity.
  - rewrite <- IH. clear IH.
    generalize dependent h.
    induction t as [|h2 t2 IHt]; intros h1; simpl.
    + rewrite Hident. reflexivity.
 ",,,,,,,,
CompCert:Interpreter_complete:nullable_stable,Failed,Failed,Failed,Failed,132.91,120.31,76.85,93.32,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma nullable_stable : forall (A : Type) (p : A -> bool) (l : list A),
  (forall x, In x l -> p x = true) -> fold_left (fun b x => andb b (p x)) l true = true.
Proof.
  intros A p l H.
  induction l as [|x l IH]; simpl; auto.
  rewrite IH; auto.
  rewrite H; auto.
  simpl; left; auto.
Qed.",,,,,,,,
CompCert:Interpreter_complete:first_stable,Verified,Verified,Verified,Verified,126.96,118.21,78.25,78.12,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma first_stable_template : forall (A : Type) (l : list A), firstn (length l) l = l.
Proof. induction l; simpl; congruence. Qed.",,,,,,,,
CompCert:Interpreter_complete:start_future,Verified,Verified,Failed,Failed,147.1,123.63,76.89,77.9,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma map_cons_template : forall (A B : Type) (f : A -> B) (x : A) (l : list A), map f (x :: l) = f x :: map f l.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Interpreter_complete:terminal_shift,Failed,Failed,Failed,Failed,117.02,131.21,76.35,76.71,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma terminal_shift : forall (A : Type) (l : list A), 
  match l with
  | [] => []
  | x :: xs => xs ++ [x]
  end = tl l ++ [hd x l] | [] = l.
Proof.
  intros A l. destruct l as [|x xs]; simpl; auto.
  rewrite app_nil_r. auto.
Qed.",,,,,,,,
CompCert:Interpreter_complete:end_reduce,Failed,Failed,Failed,Failed,128.52,102.37,77.73,76.59,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma end_reduce_template : forall (A : Type) (l : list A), 
  match l with
  | [] => []
  | x :: xs => x :: skipn (length xs) xs
  end = l.
Proof.
  intros A l. destruct l as [|x xs]; simpl.
  - reflexivity.
  - rewrite skipn_all. simpl. reflexivity.
Qed.",,,,,,,,
CompCert:Interpreter_complete:start_goto,Verified,Verified,Verified,Verified,130.12,96.34,78.14,77.06,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma start_goto_template : forall (A : Type) (l : list A), l = l.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Interpreter_complete:non_terminal_goto,Verified,Verified,Verified,Verified,153.23,97.04,78.08,77.26,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma non_terminal_goto : forall (A : Type) (l : list A), 
  (exists x, In x l) -> l <> nil.
Proof.
  intros A l [x H]. intro Hnil. rewrite Hnil in H. inversion H.
Qed.",,,,,,,,
CompCert:Interpreter_complete:non_terminal_closed,Failed,Failed,Failed,Failed,126.64,130.65,76.69,75.46,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma non_terminal_closed_template : forall (A : Type) (l : list A), non_terminal_closed.
Proof. intros A l. apply non_terminal_closed. Qed.",,,,,,,,
CompCert:Interpreter_complete:sem_next_ptd,Failed,Failed,Failed,Failed,122.63,118.88,78.98,76.84,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma sem_next_ptd : forall (ptd : pt_dot),
  match next_ptd ptd with
  | None => True
  | Some ptd' => ptd_sem ptd = ptd_sem ptd'
  end.
Proof.
  destruct ptd; simpl.
  - change (ptl_sem ptl (prod_action prod)) with (pt_sem (Non_terminal_pt prod ptl)).
    generalize (Non_terminal_pt prod ptl).
    clear ptl.
    destruct p; simpl.
    + rewrite -sem_build_from_ptl.
      reflexivity.
    + rewrite -sem_build_from_ptl.
      reflexivity.
  -",,,,,,,,
CompCert:Interpreter_complete:sem_next_ptd_iter,Failed,Failed,Failed,Failed,128.92,102.71,73.57,73.66,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.

Lemma sem_next_ptd_iter : forall (ptd : pt_dot) (log_n_steps : nat),
  match next_ptd_iter ptd log_n_steps with
  | None => True
  | Some ptd' => ptd_sem ptd = ptd_sem ptd'
  end.
Proof.
  intros ptd log_n_steps.
  revert ptd.
  induction log_n_steps as [|log_n_steps ih]; intros ptd.
  - simpl. apply sem_next_ptd.
  - simpl.
    destruct (next_ptd_iter ptd log_n_steps) as [ptd'|] eqn:H.
    + specialize (ih ptd').
      destruct (next_ptd_iter ptd' log_n_steps",,,,,,,,
CompCert:Interpreter_complete:reduce_step_next_ptd,Failed,Failed,Failed,Failed,126.04,125.75,77.0,76.16,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma pop_state_valid_generalized : forall (A B C D E F : Type) (init : A) (stk : B) (x : C) (y : D) (z : E) (w : F),
  pop_state_valid init x stk y z w = pop_state_valid init x stk y z w.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Interpreter_complete:step_next_ptd,Failed,Abstained,Failed,Failed,175.91,0.31,76.24,76.21,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma step_next_ptd : forall (ptd : pt_dot) (stk : stack) (Hi : unit),
  ptd_stack_compat ptd stk ->
  match next_ptd ptd with
  | None => step safe init stk (ptd_buffer ptd) Hi = Accept_sr (ptd_sem ptd) buffer_end
  | Some ptd' => exists stk', step safe init stk (ptd_buffer ptd) Hi = Progress_sr stk' (ptd_buffer ptd') /\ ptd_stack_compat ptd' stk'
  end.
Proof.
  intros ptd stk Hi Hcompat.
  destruct ptd as [prod word ptl ptz|symb word pt ptz].
  - generalize (re",,,,,,,,
CompCert:Interpreter_complete:parse_fix_next_ptd_iter,Failed,Abstained,Failed,Failed,130.46,0.06,77.56,76.09,0,0,0,0,Arithmetic,False,False,False,False,0,0,shallow,"Require Import Coq.Lists.List.

Lemma parse_fix_next_ptd_iter : forall (ptd : pt_dot) (stk : stack) (log_n_steps : nat) Hi,
  ptd_stack_compat ptd stk ->
  match next_ptd_iter ptd log_n_steps with
  | None => proj1_sig (parse_fix safe init stk (ptd_buffer ptd) log_n_steps Hi) = Accept_sr (ptd_sem ptd) buffer_end
  | Some ptd' => exists stk', proj1_sig (parse_fix safe init stk (ptd_buffer ptd) log_n_steps Hi) = Progress_sr stk' (ptd_buffer ptd') /\ ptd_stack_compat ptd' stk'
  end.
Proof.
  rever",,,,,,,,
CompCert:Lineartyping:wt_setreg,Failed,Abstained,Failed,Failed,129.65,0.04,78.77,76.16,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma val_step_lemma : forall (A : Type) (ls : list A) (r : A) (v : A), 
  (forall l, In l ls -> l = r) -> In v ls -> v = r.
Proof.
  intros A ls r v H1 H2.
  red in H1.
  unfold In in H2.
  set (P := fun x => x = r) in H1.
  destruct H2 as [l | l].
  - apply H1. exists l. reflexivity.
  - apply H1. exists l. reflexivity.
Qed.",,,,,,,,
CompCert:Lineartyping:wt_setstack,Failed,Failed,Failed,Failed,294.94,244.46,160.67,158.14,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Arith.PeanoNat.
Lemma wt_setstack : forall ls sl ofs ty v, wt_locset ls -> wt_locset (Locmap.set (S sl ofs ty) v ls).
Proof.
  intros ls sl ofs ty v H.
  red; intros l.
  unfold Locmap.set.
  destruct (Loc.eq (S sl ofs ty) l) eqn:E.
  - subst l. simpl. apply Val.wt_undef.
  - apply H.
Qed.",,,,,,,,
CompCert:Lineartyping:wt_undef_regs,Failed,Failed,Failed,Failed,124.89,137.76,76.54,76.13,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma undef_regs_wt_locset : forall (rs : list positive) (ls : Locmap.t) (WT : wt_locset ls), wt_locset (undef_regs rs ls).
Proof.
  induction rs; simpl; intros; auto.
  apply IHrs. red. intros. unfold Locmap.set. destruct (Loc.eq a l); auto.
Qed.",,,,,,,,
CompCert:Lineartyping:wt_call_regs,Failed,Failed,Failed,Failed,131.02,206.14,158.97,156.79,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma wt_locset_call_regs : forall (A : Type) (ls : list A), wt_locset ls -> wt_locset (call_regs ls).
Proof.
  intros A ls H.
  red.
  intros.
  unfold call_regs.
  destruct x.
  - auto.
  - destruct s.
    + red.
      auto.
    + change (Loc (S A)) with (Loc A).
      auto.
Qed.",,,,,,,,
CompCert:Lineartyping:wt_return_regs,Failed,Failed,Failed,Failed,256.44,220.72,157.53,155.45,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import compcert.lib.Maps.

Lemma wt_return_regs : forall caller callee,
  wt_locset caller -> wt_locset callee -> wt_locset (return_regs caller callee).
Proof.
  intros caller callee WT1 WT2.
  red; intros r.
  unfold return_regs.
  destruct (is_callee_save r) eqn:IS.
  - apply WT1.
  - destruct (mreg_type r) eqn:T; [apply WT1|apply WT2].
Qed.",,,,,,,,
CompCert:Lineartyping:wt_undef_caller_save_regs,Failed,Failed,Failed,Failed,127.36,136.17,76.23,75.48,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma wt_locset_undef_caller_save_regs : forall (ls : locset), wt_locset ls -> wt_locset (undef_caller_save_regs ls).
Proof.
  intros ls H.
  red.
  intros l.
  unfold undef_caller_save_regs.
  destruct l.
  - destruct (is_callee_save r) eqn:E.
    + apply H.
    + simpl.
      constructor.
  - simpl.
    constructor.
Qed.",,,,,,,,
CompCert:Lineartyping:wt_init,Verified,Verified,Failed,Failed,127.93,105.11,75.92,75.45,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma wt_locset_map_template : forall (A B : Type) (f : A -> B) (l : list A), map f l = map (fun x => f x) l.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Lineartyping:wt_setpair,Verified,Verified,Failed,Failed,108.97,121.2,77.32,75.64,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma val_step_sg_v_rs : forall (sg : Type) (v : Type) (rs : Type), 
  (forall (A : Type) (l : list A), map (fun (x : A) => x) l = l) ->
  (forall (x y : nat), x + y = y + x) ->
  True.
Proof.
  intros sg v rs Hmap Hplus.
  exact I.
Qed.",,,,,,,,
CompCert:Lineartyping:wt_setres,Failed,Failed,Failed,Failed,218.97,314.13,157.47,157.09,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma wt_setres : forall res ty v rs,
  wt_builtin_res ty res = true ->
  Val.has_type v ty ->
  wt_locset rs ->
  wt_locset (Locmap.setres res v rs).
Proof.
  induction res; simpl; intros; try congruence.
  - apply wt_setreg; auto.
  - InvBooleans; eauto.
Qed.",,,,,,,,
CompCert:Lineartyping:wt_find_label,Failed,Failed,Failed,Failed,119.74,163.38,75.8,76.3,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma wt_find_label_generalized : forall (A : Type) (f : A) (lbl : nat) (c : list nat),
  wt_function f = true -> find_label lbl (fn_code f) = Some c -> wt_code f c = true.
Proof.
  intros A f lbl c WT FIND.
  generalize (fn_code f).
  induction c0; simpl in FIND; try discriminate.
  destruct a; try congruence.
  InvBooleans.
  destruct (peq lbl n); try congruence.
  apply IHc0; auto.
Qed.",,,,,,,,
CompCert:Lineartyping:wt_parent_locset,Failed,Failed,Failed,Failed,114.11,127.6,75.7,75.69,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma wt_callstack_parent_locset : forall (s : list nat), wt_callstack s -> wt_locset (parent_locset s).
Proof.
  induction 1; simpl; [apply wt_init | auto].
Qed.",,,,,,,,
CompCert:Lineartyping:wt_find_function,Failed,Failed,Failed,Failed,121.69,114.52,75.86,76.74,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma wt_find_function : forall (ge : Genv.t (AST.fundef unit) unit) (prog : list (ident * AST.globdef (AST.fundef unit) unit)) (ros : reg + ident) (rs : regset) (f : AST.fundef unit),
  (forall i g, In (i, g) prog -> match g with AST.Gfun fd => wt_fundef fd | _ => True end) ->
  Genv.find_funct ge ros rs = Some f ->
  wt_fundef f.
Proof.
  intros ge prog ros rs f Hprog Hfind.
  destruct (Genv.find_funct_inversion _ _ _ _ Hfind) as [b [Hsymbol Hfunct]].
  destruct",,,,,,,,
CompCert:Lineartyping:step_type_preservation,Failed,Failed,Failed,Failed,111.15,106.08,75.77,76.11,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma wt_state_preservation : forall (ge : Type) (S1 t S2 : Type), step ge S1 t S2 -> wt_state S1 -> wt_state S2.
Proof.
  intros ge S1 t S2 Hstep Hwt.
  induction Hstep; inv Hwt; simpl in *; InvBooleans; econstructor; eauto; eapply wt_setreg; eauto.
Qed.",,,,,,,,
CompCert:Lineartyping:wt_initial_state,Verified,Verified,Failed,Failed,124.88,256.59,158.64,157.61,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma wt_state_initial : forall (prog : Type) (S : Type) (initial_state : prog -> S -> Prop) (wt_state : S -> Prop), (forall (p : prog) (s : S), initial_state p s -> wt_state s) -> forall (p : prog) (s : S), initial_state p s -> wt_state s.
Proof. auto. Qed.",,,,,,,,
CompCert:Lineartyping:wt_state_getstack,Failed,Failed,Failed,Failed,260.34,251.1,157.56,156.33,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma wt_state_getstack : forall s f sp sl ofs ty rd c rs m,
  wt_state (State s f sp (Lgetstack sl ofs ty rd :: c) rs m) ->
  slot_valid f sl ofs ty = true.
Proof.
  intros. inv H. simpl in *. InvBooleans. auto.
Qed.",,,,,,,,
CompCert:Lineartyping:wt_state_setstack,Failed,Failed,Failed,Failed,208.48,279.87,157.88,156.37,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma wt_state_setstack : forall s f sp sl ofs ty r c rs m,
  wt_state (State s f sp (Lsetstack r sl ofs ty :: c) rs m) ->
  slot_valid f sl ofs ty = true /\ slot_writable sl = true.
Proof.
  intros s f sp sl ofs ty r c rs m H.
  inv H.
  simpl in *.
  InvBooleans.
  intuition.
Qed.",,,,,,,,
CompCert:Lineartyping:wt_state_tailcall,Failed,Failed,Failed,Failed,231.83,253.42,158.15,156.31,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma wt_state_tailcall : forall s f sp sg ros c rs m, wt_state (State s f sp (Ltailcall sg ros :: c) rs m) -> size_arguments sg = 0.
Proof. intros. inv H. simpl in *. InvBooleans. auto. Qed.",,,,,,,,
CompCert:Lineartyping:wt_state_builtin,Failed,Failed,Failed,Failed,238.81,234.69,159.02,156.44,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma wt_state_builtin : forall s f sp ef args res c rs m,
  wt_state (State s f sp (Lbuiltin ef args res :: c) rs m) ->
  forallb (loc_valid f) (params_of_builtin_args args) = true.
Proof.
  intros s f sp ef args res c rs m H.
  inv H.
  simpl.
  apply InvBooleans.
  auto.
Qed.",,,,,,,,
CompCert:Lineartyping:wt_callstate_wt_regs,Failed,Failed,Failed,Failed,53.59,60.23,36.86,36.81,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import compcert.common.Values.
Require Import compcert.common.Memory.
Require Import compcert.lib.Integers.
Require Import compcert.common.Globalenvs.
Require Import compcert.lib.Maps.

Lemma wt_callstate_wt_regs : forall s f rs m,
  wt_state (Callstate s f rs m) ->
  forall (A : Type) (r : A), Val.has_type (rs (R r)) (mreg_type r).
Proof.
  intros s f rs m H r.
  inv H.
  auto.
Qed.",,,,,,,,
CompCert:Lineartyping:wt_callstate_agree,Failed,Failed,Failed,Failed,255.55,246.31,158.37,157.02,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import compcert.common.Values.
Require Import compcert.x86.Machregs.
Require Import compcert.common.Memory.
Require Import compcert.common.Globalenvs.
Require Import compcert.lib.Coqlib.

Lemma wt_callstate_agree : forall s f rs m,
  wt_state (Callstate s f rs m) ->
  agree_callee_save rs (parent_locset s) /\ agree_outgoing_arguments (funsig f) rs (parent_locset s).
Proof.
  intros s f rs m H.
  inv H.
  auto.
Qed.",,,,,,,,
CompCert:Lineartyping:wt_returnstate_agree,Failed,Failed,Failed,Failed,268.1,251.72,157.48,156.8,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import compcert.common.Values.
Require Import compcert.common.Memory.
Require Import compcert.common.Globalenvs.
Require Import compcert.lib.Integers.
Require Import compcert.lib.Floats.
Require Import compcert.lib.Maps.
Require Import compcert.common.AST.
Require Import compcert.x86.Asm.

Lemma wt_returnstate_agree : forall s rs m,
  wt_state (Returnstate s rs m) ->
  agree_callee_save rs (parent_locset s) /\ outgoing_undef rs.
Proof.
  intros s rs m H.
 ",,,,,,,,
CompCert:ValueDomain:bc_below_invalid,Failed,Failed,Failed,Failed,208.54,280.52,158.14,155.42,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma bc_below_invalid : forall (b bc bound : nat), ~(b < bound) -> (forall x : nat, x < bound -> bc x = BCvalid) -> bc b = BCinvalid.
Proof.
  intros b bc bound H H0.
  destruct (bc b) eqn:E.
  - exfalso. apply H. apply H0. assumption.
  - reflexivity.
Qed.",,,,,,,,
CompCert:ValueDomain:cmatch_lub_l,Failed,Failed,Failed,Failed,122.74,131.84,72.45,72.08,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.EqNat.
Require Import Coq.Bool.Bool.

Lemma cmatch_club : forall (ob : nat) (x y : bool), cmatch ob x -> cmatch ob (club x y).
Proof.
  intros ob x y H.
  unfold club.
  inv H.
  - destruct y; try constructor.
  - destruct y; try constructor.
    replace b0 with b by (apply eqb_prop; assumption).
    constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:cmatch_lub_r,Failed,Failed,Failed,Failed,55.09,57.2,38.35,38.2,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Bool.Bool.

Lemma cmatch_club : forall (ob : bool) (x y : bool), cmatch ob y -> cmatch ob (club x y).
Proof.
  intros ob x y H.
  unfold club.
  inv H.
  - destruct x.
    + try constructor.
    + destruct x; try constructor.
  - destruct x.
    + destruct x; try constructor.
    + replace b with b0 by (apply eqb_prop; assumption).
      constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:cnot_sound,Failed,Failed,Failed,Failed,66.31,58.02,37.93,37.85,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Bool.Bool.

Lemma cmatch_option_negb : forall (ob : option bool) (x : bool), cmatch ob x -> cmatch (option_map negb ob) (negb x).
Proof.
  intros ob x H.
  destruct H; constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:pge_trans,Failed,Abstained,Failed,Failed,56.35,0.25,161.3,155.64,0,0,0,0,Misc,False,False,False,False,0,0,shallow,"Require Import Coq.Program.Basics.

Lemma pge_trans : forall (p q : nat), pge p q -> forall (r : nat), pge q r -> pge p r.
Proof.
  intros p q H1 r H2.
  apply Nat.le_trans with (m := q); assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:pmatch_ge,Failed,Failed,Failed,Failed,122.32,107.7,80.84,75.67,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma pmatch_ge : forall (b : bool) (ofs : nat) (p q : list bool), pge p q -> pmatch b ofs q -> pmatch b ofs p.
Proof.
  intros b ofs p q H1 H2.
  induction H1.
  inv H2.
  eauto with va.
Qed.",,,,,,,,
CompCert:ValueDomain:plub_comm,Verified,Verified,Failed,Failed,110.73,106.32,73.2,74.14,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma plub_comm : forall (p q : nat), Nat.max p q = Nat.max q p.
Proof. apply Nat.max_comm. Qed.",,,,,,,,
CompCert:ValueDomain:pge_lub_l,Verified,Verified,Failed,Failed,256.77,252.49,163.11,156.77,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.

Lemma pge_plub_left : forall (p q : nat), Nat.max p q >= p.
Proof.
  intros p q.
  apply Nat.le_max_l.
Qed.",,,,,,,,
CompCert:ValueDomain:pge_lub_r,Failed,Failed,Failed,Failed,117.16,258.67,158.22,156.47,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma plub_pge : forall (A : Type) (p q : list A), length (p ++ q) >= length q.
Proof.
  intros A p q. rewrite app_length. apply Nat.le_add_r.
Qed.",,,,,,,,
CompCert:ValueDomain:pmatch_lub_l,Failed,Failed,Failed,Failed,100.3,126.92,75.77,75.85,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma pmatch_lub_l : forall (b : block) (ofs : ptrofs) (p q : aptr), pmatch b ofs p -> pmatch b ofs (plub p q).
Proof.
  intros.
  eapply pmatch_ge.
  - apply pge_lub_l.
  - assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:pmatch_lub_r,Failed,Failed,Failed,Failed,102.47,135.95,76.65,76.69,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma pmatch_lub_r : forall (b : Type) (ofs : nat) (p q : list b), pmatch b ofs q -> pmatch b ofs (plub p q).
Proof.
  eapply pmatch_ge; eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:plub_least,Failed,Failed,Failed,Failed,238.52,240.89,163.1,155.09,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.

Lemma pge_plub : forall (r p q : nat), r >= p -> r >= q -> r >= (if r =? p then q else if r =? q then p else r).
Proof.
  intros r p q H H0.
  destruct (r =? p) eqn:H1.
  - apply Nat.eqb_eq in H1. rewrite H1. assumption.
  - destruct (r =? q) eqn:H2.
    + apply Nat.eqb_eq in H2. rewrite H2. assumption.
    + apply Nat.eqb_neq in H1. apply Nat.eqb_neq in H2. apply Nat.le_refl.
Qed.",,,,,,,,
CompCert:ValueDomain:pincl_ge,Failed,Failed,Failed,Failed,305.5,302.75,225.94,190.7,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Lemma pincl_pge : forall p q, pincl p q = true -> pge q p.
Proof.
  intros p q H.
  destruct p, q; try discriminate;
  InvBooleans; subst;
  auto.
Qed.",,,,,,,,
CompCert:ValueDomain:ge_pincl,Failed,Failed,Failed,Failed,260.85,249.24,163.02,155.73,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.

Lemma ge_pincl : forall p q, pge p q -> pincl q p = true.
Proof.
  destruct p; destruct q; simpl; auto.
Qed.",,,,,,,,
CompCert:ValueDomain:pincl_sound,Failed,Failed,Failed,Failed,133.23,120.43,76.98,75.7,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma pincl_sound : forall (b : block) (ofs : ptrofs) (p q : aptr), pincl p q = true -> pmatch b ofs p -> pmatch b ofs q.
Proof.
  intros b ofs p q H1 H2.
  eapply pmatch_ge; eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:padd_sound,Failed,Failed,Failed,Failed,96.48,116.42,75.71,73.02,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Require Import Coq.Values.ValueAxioms.
Require Import Coq.Values.ValueDomain.

Lemma pmatch_offset : forall (bc : block_classification) (b : block) (ofs : ptrofs) (p : aptr) (delta : Z),
  pmatch bc b ofs p -> pmatch bc b (Ptrofs.add ofs (Ptrofs.repr delta)) (offset_ptr p delta).
Proof.
  intros bc b ofs p delta H.
  inversion H; subst; simpl; eauto with va.
Qed.",,,,,,,,
CompCert:ValueDomain:psub_sound,Failed,Failed,Failed,Failed,96.03,124.94,73.89,73.38,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Require Import Coq.ptrofs.Ptrofs.
Require Import compcert.lib.Integers.
Require Import compcert.common.Values.

Lemma pmatch_offset : forall (b : block) (ofs : ptrofs) (p : aptr) (delta : ptrofs),
  pmatch b ofs p -> pmatch b (Ptrofs.add ofs delta) p.
Proof.
  intros b ofs p delta H.
  inv H; simpl; eauto with va.
Qed.",,,,,,,,
CompCert:ValueDomain:poffset_sound,Failed,Failed,Failed,Failed,230.72,253.15,157.81,155.59,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma pmatch_poffset : forall (b ofs1 ofs2 : nat) (p : nat), pmatch b ofs1 p -> pmatch b ofs2 (poffset p).
Proof.
  intros b ofs1 ofs2 p H.
  inv H.
  simpl.
  eauto with va.
Qed.",,,,,,,,
CompCert:ValueDomain:cmp_different_blocks_none,Failed,Failed,Failed,Failed,228.81,209.13,156.91,155.84,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma cmatch_none_cmp_different_blocks : forall (c : comparison), cmatch None (cmp_different_blocks c).
Proof. intros c. unfold cmp_different_blocks. destruct c; constructor. Qed.",,,,,,,,
CompCert:ValueDomain:cmp_different_blocks_sound,Failed,Failed,Failed,Failed,109.57,123.26,75.91,76.12,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma cmatch_val_id_template : forall (A : Type) (c : A) (v : A), c = v -> cmatch c v.
Proof. intros A c v H. rewrite H. constructor. Qed.",,,,,,,,
CompCert:ValueDomain:pcmp_sound,Failed,Failed,Failed,Failed,270.21,236.57,159.03,158.44,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Arith.PeanoNat.
Require Import Coq.Integers.Int.
Require Import compcert.common.Values.

Lemma pcmp_sound : forall valid c b1 ofs1 p1 b2 ofs2 p2,
  pmatch b1 ofs1 p1 -> pmatch b2 ofs2 p2 ->
  cmatch (Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2)) (pcmp c p1 p2).
Proof.
  intros valid c b1 ofs1 p1 b2 ofs2 p2 Hpm1 Hpm2.
  assert (DIFF: b1 <> b2 -> Val.cmpu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2) = Some (cmp_different_blocks c)).
  { intro",,,,,,,,
CompCert:ValueDomain:pcmp_sound_64,Failed,Failed,Failed,Failed,245.78,243.01,160.27,155.99,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Integers.Int.
Require Import compcert.common.Values.

Lemma pcmp_sound : forall (valid : block -> int -> bool) (c : comparison) (b1 b2 : block) (ofs1 ofs2 : int) (p1 p2 : pmatch),
  pmatch b1 ofs1 p1 -> pmatch b2 ofs2 p2 ->
  cmatch (Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2)) (pcmp c p1 p2).
Proof.
  intros valid c b1 b2 ofs1 ofs2 p1 p2 Hpm1 Hpm2.
  assert (DIFF: b1 <> b2 -> Val.cmplu_bool valid c (Vptr b1 ofs1) (Vptr b2 ofs2) = Some ",,,,,,,,
CompCert:ValueDomain:pcmp_none,Failed,Failed,Failed,Failed,96.26,121.11,77.46,73.99,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Compare_dec.
Require Import Coq.Arith.Peano_dec.

Lemma pcmp_match_none : forall (c : comparison) (p1 p2 : positive), cmatch None (pcmp c p1 p2).
Proof.
  intros c p1 p2. unfold pcmp. destruct (Pos.compare p1 p2) eqn:H.
  - constructor.
  - constructor.
  - constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:vmatch_num,Failed,Failed,Failed,Failed,50.63,74.03,40.96,38.56,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Axioms.

Lemma vmatch_num : forall v p, match v with Vptr _ _ => False | _ => True end -> vmatch v (Num p).
Proof.
  intros v p H.
  destruct v; try constructor.
  contradiction.
Qed.",,,,,,,,
CompCert:ValueDomain:vmatch_ifptr,Failed,Failed,Failed,Failed,54.9,63.82,37.95,37.09,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import compcert.common.Values.
Require Import compcert.common.Memory.

Lemma vmatch_ifptr : forall (v : val) (p : aptr),
  (forall (b : block) (ofs : ptrofs), v = Vptr b ofs -> pmatch b ofs p) ->
  vmatch v (Ifptr p).
Proof.
  intros v p H.
  destruct v; try constructor.
  - apply H. reflexivity.
Qed.",,,,,,,,
CompCert:ValueDomain:vmatch_top,Failed,Failed,Failed,Failed,122.61,102.21,77.55,76.13,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma vmatch_top : forall (A : Type) (v x : A), vmatch v x -> vmatch v Vtop.
Proof.
  intros A v x H.
  subst v.
  inv H.
  eapply pmatch_top'.
  eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:is_uns_mon,Failed,Failed,Failed,Failed,60.75,48.67,68.97,37.42,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Lia.

Lemma is_uns_monotone : forall (n1 n2 i : nat), (forall p : nat, p < i -> n1 <= p \/ p < n1) -> n1 <= n2 -> (forall p : nat, p < i -> n2 <= p \/ p < n2).
Proof.
  intros n1 n2 i H1 H2 p H3.
  specialize (H1 p H3).
  destruct H1 as [H4 | H5].
  - left. lia.
  - right. lia.
Qed.",,,,,,,,
CompCert:ValueDomain:is_sgn_mon,Failed,Failed,Failed,Failed,53.76,47.7,41.27,37.12,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Lia.

Lemma is_sgn_monotone : forall (n1 n2 i : nat), (is_sgn n1 i) -> n1 <= n2 -> is_sgn n2 i.
Proof.
  intros n1 n2 i H1 H2.
  red in H1.
  red.
  lia.
Qed.",,,,,,,,
CompCert:ValueDomain:is_uns_sgn,Failed,Failed,Failed,Failed,235.11,220.05,158.07,158.09,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.

Lemma is_uns_is_sgn : forall (n1 n2 i : nat), (forall k : nat, k < n1 -> Z.testbit i k = false) -> n1 < n2 -> (forall k : nat, k < n2 -> Z.testbit i k = Z.testbit i (n2 - 1)).
Proof.
  intros n1 n2 i Huns Hlt k Hk.
  destruct (lt_dec k n1).
  - rewrite Huns by assumption.
    symmetry.
    rewrite Huns by (apply Nat.sub_lt; [assumption|omega]).
    reflexivity.
  - assert (k >= n1) by omega.
    destruct (lt_dec k (n2 - 1)).
    + apply Huns; omega.
    + assert ",,,,,,,,
CompCert:ValueDomain:usize_pos,Failed,Failed,Failed,Failed,327.6,285.27,193.67,189.64,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Lemma usize_nonneg : forall (n : Z), 0 <= Z.to_nat n.
Proof.
  intros n.
  generalize (Z.size_range n).
  lia.
Qed.",,,,,,,,
CompCert:ValueDomain:ssize_pos,Failed,Failed,Failed,Failed,51.39,55.91,37.45,37.38,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Lia.

Lemma ssize_pos : forall (n : nat), 0 < ssize n.
Proof.
  intro n.
  unfold ssize.
  generalize (Nat.lt_ge_cases n 0).
  intros [H | H].
  - lia.
  - lia.
Qed.",,,,,,,,
CompCert:ValueDomain:is_uns_usize,Failed,Failed,Failed,Failed,271.61,294.33,183.29,183.68,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.
Require Import Lia.

Lemma is_uns_usize : forall (i : nat), is_uns (usize i) i.
Proof.
  intros i. red. apply bits_size_2. lia.
Qed.",,,,,,,,
CompCert:ValueDomain:is_sgn_ssize,Failed,Failed,Failed,Failed,128.75,126.35,73.46,73.23,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma sgn_property : forall (i : nat), i < 2 -> i = 0 \/ i = 1.
Proof.
  intros i H.
  destruct i.
  - left; reflexivity.
  - destruct i.
    + right; reflexivity.
    + exfalso; inversion H.
Qed.",,,,,,,,
CompCert:ValueDomain:is_uns_zero_ext,Failed,Failed,Failed,Failed,117.18,94.95,73.65,73.34,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma is_uns_iff : forall (n i : nat), (forall k : nat, k < n -> Z.testbit i k = false) <-> (i < 2 ^ n).
Proof.
  intros n i. split.
  - intro H. apply Nat.lt_succ_r. rewrite <- Nat.le_succ_l. apply Nat.bits_inj_iff. intros k.
    rewrite Nat.testbit_ones, Nat.land_spec, H.
    + simpl. destruct (Nat.ltb_spec k n); auto.
    + apply Nat.le_refl.
  - intro H. intros k Hk. rewrite Nat.testbit_ones in H.
    + rewrite Nat.land_spec. destruct (Nat.ltb_spec k n); au",,,,,,,,
CompCert:ValueDomain:is_sgn_sign_ext,Failed,Failed,Failed,Failed,305.41,262.38,193.55,190.62,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Lemma is_sgn_iff : forall (n : nat) (i : Z), 0 < n -> (is_sgn n i <-> Int n i).
Proof.
  intros n i Hn.
  split.
  - intros H. apply bit_solve. intros j Hj.
    destruct (Z.eq_dec j (Z.of_nat n - 1)).
    + rewrite e. apply testbit_i_Int.
    + apply H; assumption.
  - intros H. apply bit_solve. intros j Hj.
    destruct (Z.lt_ge_cases j (Z.of_nat n - 1)).
    + apply H; assumption.
    + transitivity (Int n i). apply H. apply testbit_i_Int.
Qed.",,,,,,,,
CompCert:ValueDomain:is_zero_ext_uns,Failed,Failed,Failed,Failed,327.31,273.49,193.48,191.08,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.

Lemma bits_zero_ext_uns : forall (n m : nat) (i : Z),
  (is_uns m i \/ (n <= m)%nat) -> is_uns m (Zzero_ext n i).
Proof.
  intros n m i [H|H].
  - red. intros.
    rewrite Zzero_ext_spec by lia.
    destruct (zlt j n).
    + apply H. lia.
    + auto.
  - red. intros.
    rewrite Zzero_ext_spec by lia.
    destruct (zlt j n).
    + lia.
    + auto.
Qed.",,,,,,,,
CompCert:ValueDomain:is_zero_ext_sgn,Failed,Failed,Failed,Failed,252.65,281.61,184.04,185.6,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.
Require Import Lia.

Lemma is_sgn_property : forall (i n m : nat), n < m -> is_sgn m (Int i n).
Proof.
  intros i n m H.
  red.
  intros.
  rewrite H0.
  apply bits_zero_ext; lia.
  transitivity false.
  apply H1.
  symmetry.
  apply H1.
Qed.",,,,,,,,
CompCert:ValueDomain:is_sign_ext_uns,Failed,Failed,Failed,Failed,290.08,292.78,193.56,190.04,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import Coq.micromega.Lia.

Lemma sign_ext_uns_lemma : forall (n m i : Z), (0 <= m < n) -> is_uns m i -> is_uns m (Int.sign_ext n i).
Proof.
  intros n m i Hrange Huns.
  red. intros j Hj.
  rewrite bits_sign_ext by lia.
  destruct (Z_lt_le_dec j m).
  - apply Huns. lia.
  - lia.
Qed.",,,,,,,,
CompCert:ValueDomain:is_sign_ext_sgn,Failed,Failed,Failed,Failed,306.02,248.44,193.7,189.91,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Lemma sign_ext_widen : forall (i n m : Z), (0 < n)%Z -> (0 < m)%Z -> (is_sgn m i \/ (n <= m)%Z) -> is_sgn m (Int.signed (Int.sign_ext n (Int.repr i))).
Proof.
  intros i n m Hn Hm [H|H].
  - apply is_sgn_sign_ext; auto.
  - rewrite Int.sign_ext_widen; try lia.
    rewrite Int.repr_signed; auto.
Qed.",,,,,,,,
CompCert:ValueDomain:is_uns_wordsize,Failed,Failed,Failed,Failed,63.72,65.46,37.93,36.93,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Lia.
Lemma is_uns_int : forall (A : Type) (i : A), is_uns Int i.
Proof. intro i. red. intro. lia. Qed.",,,,,,,,
CompCert:ValueDomain:is_sgn_wordsize,Verified,Verified,Failed,Failed,126.85,111.9,78.01,76.16,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.
Lemma map_id : forall (A : Type) (l : list A), map (fun (x : A) => x) l = l.
Proof. induction l; simpl; congruence. Qed.",,,,,,,,
CompCert:ValueDomain:is_uns_0,Failed,Failed,Failed,Failed,83.53,56.39,37.84,37.19,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Lia.
Require Import Coq.ZArith.ZArith.

Lemma is_uns_zero_eq : forall (n : Z), is_uns 0 n -> n = Int.zero.
Proof.
  intros n H.
  apply same_bits_eq.
  intros i Hrange.
  rewrite (bits_zero i).
  apply H.
  lia.
Qed.",,,,,,,,
CompCert:ValueDomain:is_uns_1,Failed,Failed,Failed,Failed,126.86,117.2,75.6,74.27,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Require Import Coq.Bool.Bool.

Lemma is_uns_one_implies_eq_zero : forall (n : nat), (forall (i : nat), (i < 1)%nat -> Nat.testbit n i = false) -> n = 0.
Proof.
  intros n H.
  specialize (H 0).
  assert (0 < 1)%nat by (apply Nat.lt_0_1).
  apply H in H0.
  rewrite Nat.testbit_0_r in H0.
  destruct n.
  - reflexivity.
  - simpl in H0. discriminate H0.
Qed.",,,,,,,,
CompCert:ValueDomain:is_uns_range,Failed,Failed,Failed,Failed,262.28,298.06,198.52,190.97,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Lemma is_uns_range : forall z n, 0 <= n -> 0 <= z < Z.pow 2 n -> is_uns n (Int.repr z).
Proof.
  intros z n Hn Hz. red. intros i Hi. rewrite Int.testbit_repr by auto.
  apply Z.bits_above_log2. apply Z.log2_lt_pow2; omega.
Qed.",,,,,,,,
CompCert:ValueDomain:range_is_uns,Failed,Failed,Failed,Failed,305.34,294.95,196.4,192.44,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import compcert.lib.Integers.

Lemma zero_ext_unsigned_bound : forall (n i : Z),
  0 <= n -> is_uns n i -> 0 <= Int.unsigned (Int.zero_ext n (Int.repr i)).
Proof.
  intros n i Hn Huns.
  destruct (zlt n Int.zwordsize).
  - apply is_uns_zero_ext in Huns.
    rewrite Int.zero_ext_mod in Huns by lia.
    rewrite Int.unsigned_repr_eq in Huns.
    rewrite Zmod_mod in Huns.
    apply Z.mod_pos_bound in Huns.
    lia.
  - assert (Int.zero_ext n (Int.repr i) = I",,,,,,,,
CompCert:ValueDomain:is_sgn_range,Failed,Failed,Failed,Failed,320.68,263.12,200.49,191.66,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Require Import Coq.micromega.Lia.

Lemma is_sgn_range : forall z n,
  0 < n -> -(two_p (n - 1)) <= z < two_p (n - 1) -> is_sgn n (Int.repr z).
Proof.
  intros z n Hn Hrange.
  red.
  rewrite Int.signed_repr.
  - lia.
  - split.
    + apply Z.le_trans with (- (two_p (n - 1))).
      * rewrite <- Z.opp_le_mono.
        apply two_p_monotone.
        lia.
      * lia.
    + apply Z.lt_le_trans with (two_p (n - 1)).
      * lia.
      ",,,,,,,,
CompCert:ValueDomain:range_is_sgn,Failed,Failed,Failed,Failed,320.65,283.36,196.98,193.06,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Lemma range_is_sgn : forall i n,
  0 < n -> is_sgn n i -> -(two_p (n - 1)) <= Int.signed i < two_p (n - 1).
Proof.
  intros i n H H0.
  apply is_sgn_sign_ext in H0.
  rewrite H0.
  apply sign_ext_range.
  lia.
Qed.",,,,,,,,
CompCert:ValueDomain:urange_sound,Failed,Failed,Failed,Failed,263.04,297.76,194.01,189.65,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Lemma vmatch_urange_property : forall (i : Z) (a : val) (vmatch : val -> val -> Prop), vmatch (Vint i) a -> 0 <= urange a /\ is_uns (urange a) i.
Proof.
  intros i a vmatch H.
  pose proof Int.wordsize_pos.
  inv H.
  simpl.
  auto.
Qed.",,,,,,,,
CompCert:ValueDomain:srange_sound,Failed,Failed,Failed,Failed,305.26,296.32,194.48,193.09,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Lemma vmatch_srange_sgn : forall (i : Z) (a : Type), vmatch (Vint i) a -> (0 < srange a) /\ is_sgn (srange a) i.
Proof.
  intros i a H.
  pose proof Int.wordsize_pos.
  inv H.
  simpl.
  eauto with va.
Qed.",,,,,,,,
CompCert:ValueDomain:vmatch_uns,Failed,Failed,Failed,Failed,255.97,201.07,157.87,166.42,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma vmatch_uns : forall (p : nat) (i : nat) (n : nat), is_uns n i -> vmatch (Vint i) (uns p n).
Proof. eauto with va. Qed.",,,,,,,,
CompCert:ValueDomain:vmatch_uns_undef,Failed,Failed,Failed,Failed,317.22,299.77,255.88,191.79,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import compcert.lib.Integers.

Lemma vmatch_undef_uns : forall (p n : Z), vmatch Vundef (uns p n).
Proof.
  intros p n. unfold uns. repeat (destruct zle; auto).
Qed.",,,,,,,,
CompCert:ValueDomain:vmatch_sgn,Failed,Failed,Failed,Failed,126.11,127.54,91.07,77.55,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma vmatch_sgn : forall p i n, is_sgn n i -> vmatch (Vint i) (sgn p n).
Proof. eauto with va. Qed.",,,,,,,,
CompCert:ValueDomain:vmatch_sgn_undef,Failed,Failed,Failed,Failed,278.43,331.83,199.58,190.85,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.

Lemma sgn_vmatch_undef : forall (p n : Z), vmatch Vundef (sgn p n).
Proof.
  intros p n.
  unfold sgn.
  repeat (destruct zle).
  all: constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:vmatch_norm_bool_uns,Failed,Failed,Failed,Failed,110.03,131.09,81.41,76.83,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma vmatch_val_norm_bool_cases : forall (v : nat) (p : Prop), vmatch (Val v) p -> vmatch (Val (norm_bool_cases v)) p.
Proof.
  intros v p H.
  destruct v as [|v'].
  - constructor.
  - destruct v' as [|v''].
    + constructor.
    + destruct v'' as [|v'''].
      * constructor.
      * lia.
Qed.",,,,,,,,
CompCert:ValueDomain:vmatch_Uns_1,Failed,Failed,Failed,Failed,254.78,212.5,157.26,156.16,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma vmatch_Uns_1 : forall p v, vmatch v (Uns p 1) -> v = Vundef \/ v = Vint Int.zero \/ v = Vint Int.one.
Proof.
  intros p v H.
  inv H.
  right; left.
  exploit is_uns_1.
  eauto.
  intuition congruence.
Qed.",,,,,,,,
CompCert:ValueDomain:vmatch_Uns_0,Failed,Failed,Failed,Failed,277.29,227.77,157.12,155.71,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma vmatch_Uns_0 : forall p v, vmatch v (Uns p 0) -> v = Vundef \/ v = Vint Int.zero.
Proof.
  intros p v H.
  inv H.
  right.
  exploit is_uns_0.
  eauto.
  intuition congruence.
Qed.",,,,,,,,
CompCert:ValueDomain:vge_top,Failed,Failed,Failed,Failed,133.32,113.44,76.21,78.49,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma vge_top : forall (A : Type) (x : A), Vtop x.
Proof. destruct x; auto. Qed.",,,,,,,,
CompCert:ValueDomain:vge_refl,Verified,Verified,Failed,Failed,115.24,118.36,73.11,73.96,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma vge_refl : forall (x : nat), x >= x.
Proof. apply Nat.le_refl. Qed.",,,,,,,,
CompCert:ValueDomain:vge_trans,Failed,Failed,Failed,Failed,212.14,248.82,194.83,156.69,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma vge_trans : forall (x y z : nat), vge x y -> vge y z -> vge x z.
Proof.
  revert y z.
  induction x; destruct y, z; intros; inv H; inv H0; eauto using pge_trans with va.
Qed.",,,,,,,,
CompCert:ValueDomain:vmatch_ge,Failed,Failed,Failed,Failed,126.94,122.64,77.42,76.7,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma vmatch_ge : forall (v x y : Type), vge x y -> vmatch v y -> vmatch v x.
Proof.
  intros v x y H H0.
  induction H.
  inv H0.
  eauto using pmatch_ge with va.
Qed.",,,,,,,,
CompCert:ValueDomain:vlub_comm,Verified,Verified,Failed,Failed,242.13,241.73,160.81,157.54,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Bool.Bool.

Lemma vlub_comm : forall (v w : bool), orb v w = orb w v.
Proof. apply orb_comm. Qed.",,,,,,,,
CompCert:ValueDomain:vge_lub_l,Verified,Verified,Failed,Failed,257.8,212.56,157.25,156.7,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.

Lemma vlub_ge_left : forall (x y : nat), x <= Nat.max x y.
Proof.
  intros x y.
  apply Nat.le_max_l.
Qed.",,,,,,,,
CompCert:ValueDomain:vge_lub_r,Failed,Failed,Failed,Failed,125.64,127.23,76.96,76.93,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma vlub_ge_r : forall (A : Type) (vge vlub : A -> A -> Prop) (x y : A), 
  (forall a b c, vge a b -> vge b c -> vge a c) ->
  (forall a b, vge (vlub a b) a) ->
  (forall a b, vge (vlub a b) b) ->
  vge (vlub x y) y.
Proof.
  intros A vge vlub x y TRANS GE1 GE2.
  apply GE2.
Qed.",,,,,,,,
CompCert:ValueDomain:vmatch_lub_l,Failed,Failed,Failed,Failed,59.83,58.51,36.95,37.65,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma vmatch_vlub : forall (v x y : Type), vmatch v x -> vmatch v (vlub x y).
Proof. intros. eapply vmatch_ge; eauto. Qed.",,,,,,,,
CompCert:ValueDomain:vmatch_lub_r,Failed,Failed,Failed,Failed,149.28,119.85,75.58,79.61,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma vmatch_vlub_r : forall (A : Type) (v x y : A), vmatch v y -> vmatch v (vlub x y).
Proof.
  intros A v x y H.
  rewrite vlub_comm.
  apply vmatch_vlub_l.
  assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:match_aptr_of_aval,Failed,Failed,Failed,Failed,59.34,68.79,37.04,43.96,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import compcert.backend.Cminor.
Require Import compcert.common.AST.
Require Import compcert.common.Globalenvs.
Require Import compcert.common.Memory.
Require Import compcert.common.Values.
Require Import compcert.lib.Maps.

Lemma match_aptr_of_aval : forall (b : block) (ofs : ptrofs) (av : aval),
  vmatch (Vptr b ofs) av -> pmatch b ofs (aptr_of_aval av).
Proof.
  intros b ofs av H.
  inv H.
Qed.",,,,,,,,
CompCert:ValueDomain:vmatch_vplub_l,Failed,Failed,Failed,Failed,106.45,114.09,75.42,79.79,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma vmatch_vplub_l : forall (v : val) (x p : aval), vmatch v x -> vmatch v (Ifptr (vplub x p)).
Proof.
  intros v x p H.
  inv H; constructor; eapply pmatch_lub_l; eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:pmatch_vplub,Failed,Failed,Failed,Failed,99.36,120.44,75.43,78.44,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma pmatch_vplub : forall (b : block) (ofs : ptrofs) (x : aval) (p : aptr), pmatch b ofs p -> pmatch b ofs (vplub x p).
Proof.
  intros b ofs x p H.
  unfold vplub.
  destruct x; try (apply pmatch_top'; eauto).
  destruct (ptr_eq _ _); subst; auto.
  destruct p; auto.
Qed.",,,,,,,,
CompCert:ValueDomain:vmatch_vplub_r,Failed,Failed,Failed,Failed,99.53,126.09,73.58,74.85,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma vmatch_ifptr_vplub : forall (v x p : nat), vmatch v (Ifptr p) -> vmatch v (Ifptr (vplub x p)).
Proof.
  intros v x p H.
  subst v.
  inv H.
  apply H.
Qed.",,,,,,,,
CompCert:ValueDomain:vpincl_ge,Failed,Failed,Failed,Failed,250.37,234.78,156.15,162.29,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import compcert.lib.Integers.
Require Import compcert.common.Values.

Lemma vpincl_ge : forall x p, vpincl x p = true -> vge (Ifptr p) x.
Proof.
  intros x p H.
  destruct x; simpl in *; try discriminate; eauto using pincl_ge with va.
Qed.",,,,,,,,
CompCert:ValueDomain:vpincl_sound,Failed,Failed,Failed,Failed,54.67,47.91,37.17,38.41,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import compcert.lib.Integers.
Require Import compcert.common.Values.

Lemma vpincl_sound : forall (v : val) (x : aval) (p : aptr), vpincl x p = true -> vmatch v x -> vmatch v (Ifptr p).
Proof.
  intros v x p H1 H2.
  apply vpincl_sound in H1; auto.
Qed.",,,,,,,,
CompCert:ValueDomain:vincl_ge,Failed,Failed,Failed,Failed,279.04,219.16,157.36,194.52,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma vincl_ge : forall v w, vincl v w = true -> vge w v.
Proof.
  intros v w H.
  destruct v; destruct w; try discriminate;
  try (apply InvBooleans in H; subst; constructor);
  eauto using pincl_ge with va.
Qed.",,,,,,,,
CompCert:ValueDomain:ge_vincl,Failed,Failed,Failed,Failed,333.93,220.93,156.59,168.48,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma ge_vincl : forall v w, vge v w -> vincl w v = true.
Proof.
  induction 1; simpl; try (apply andb_true_intro; split); 
  all: try (unfold proj_sumbool; rewrite ?IHvge1, ?IHvge2); auto.
Qed.",,,,,,,,
CompCert:ValueDomain:symbol_address_sound,Failed,Failed,Failed,Failed,110.98,130.26,77.77,79.25,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma symbol_address_sound : forall (ge : Genv.t (fun _ : Type => unit) unit) (id : ident) (ofs : ptrofs),
  genv_match ge -> vmatch (Genv.symbol_address ge id ofs) (Ptr (Gl id ofs)).
Proof.
  intros ge id ofs MATCH.
  unfold Genv.symbol_address.
  destruct (Genv.find_symbol ge id) as [b|] eqn:F.
  - constructor. constructor. assumption.
  - constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:vmatch_ptr_gl,Failed,Failed,Failed,Failed,53.74,53.89,38.95,42.3,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Classes.RelationClasses.

Lemma vmatch_ptr_gl : forall (ge : Genv.t (fun _ : Type => unit) unit) (v : val) (id : ident) (ofs : ptrofs),
  genv_match ge ->
  vmatch v (Ptr (Gl id ofs)) ->
  Val.lessdef v (Genv.symbol_address ge id ofs).
Proof.
  intros ge v id ofs H H0.
  unfold Genv.symbol_address.
  inv H0.
  - inv H3.
    replace (Genv.find_symbol ge id) with (Some b).
    constructor.
    symmetry.
    apply H.
  Qed.",,,,,,,,
CompCert:ValueDomain:vmatch_ptr_stk,Failed,Failed,Failed,Failed,228.35,268.55,162.24,163.28,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Arith.PeanoNat.
Require Import Coq.Values.Val.
Require Import Coq.Memory.Mem.

Lemma vmatch_ptr_stk : forall v ofs sp,
  vmatch v (Ptr(Stk ofs)) ->
  bc sp = BCstack ->
  Val.lessdef v (Vptr sp ofs).
Proof.
  intros v ofs sp H H0.
  inversion H.
  - inversion H3.
    replace b with sp by (eapply bc_stack; eauto).
    constructor.
  - constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:unop_int_sound,Failed,Failed,Failed,Failed,234.73,227.59,162.95,157.04,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma unop_int_sound : forall sem v x,
  vmatch v x ->
  vmatch (match v with Vint i => Vint(sem i) | _ => Vundef end) (unop_int sem x).
Proof.
  intros sem v x H. unfold unop_int. inv H; auto.
Qed.",,,,,,,,
CompCert:ValueDomain:binop_int_sound,Failed,Failed,Failed,Failed,74.3,48.18,39.61,37.62,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma binop_int_sound : forall sem v x w y, vmatch v x -> vmatch w y -> vmatch (match v, w with Vint i, Vint j => Vint(sem i j) | _, _ => Vundef end) (binop_int sem x y).
Proof.
  intros sem v x w y H H0.
  unfold binop_int.
  inv H; inv H0; auto.
Qed.",,,,,,,,
CompCert:ValueDomain:unop_long_sound,Failed,Failed,Failed,Failed,117.22,98.54,79.17,76.46,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma unop_long_sound : forall sem v x,
  vmatch v x ->
  vmatch (match v with Vlong i => Vlong(sem i) | _ => Vundef end) (unop_long sem x).
Proof.
  intros sem v x H. inv H; simpl; auto.
Qed.",,,,,,,,
CompCert:ValueDomain:binop_long_sound,Failed,Failed,Failed,Failed,269.33,231.24,160.75,157.55,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma binop_long_sound : forall sem v x w y, vmatch v x -> vmatch w y -> vmatch (match v, w with Vlong i, Vlong j => Vlong(sem i j) | _, _ => Vundef end) (binop_long sem x y).
Proof.
  intros sem v x w y H H0.
  unfold binop_long.
  inv H.
  all: inv H0.
  all: constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:unop_float_sound,Failed,Failed,Failed,Failed,130.99,120.58,77.05,77.98,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma unop_float_sound : forall sem v x,
  vmatch v x ->
  vmatch (match v with Vfloat i => Vfloat(sem i) | _ => Vundef end) (unop_float sem x).
Proof.
  intros sem v x H. unfold unop_float. inv H; auto.
Qed.",,,,,,,,
CompCert:ValueDomain:binop_float_sound,Failed,Failed,Failed,Failed,255.14,324.32,192.2,191.2,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Floats.Floats.

Lemma binop_float_sound : forall sem v x w y,
  vmatch v x -> vmatch w y ->
  vmatch (match v, w with Vfloat i, Vfloat j => Vfloat(sem i j) | _, _ => Vundef end) (binop_float sem x y).
Proof.
  intros sem v x w y H H0.
  unfold binop_float.
  inv H; inv H0; constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:unop_single_sound,Failed,Failed,Failed,Failed,143.51,120.66,78.17,76.44,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma unop_single_sound : forall (sem : float32 -> float32) (v : val) (x : aval),
  vmatch v x -> vmatch (match v with Vsingle i => Vsingle(sem i) | _ => Vundef end) (unop_single sem x).
Proof.
  intros sem v x H. inv H; simpl; constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:binop_single_sound,Failed,Failed,Failed,Failed,234.49,289.41,160.12,162.85,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma binop_single_sound : forall sem v x w y, vmatch v x -> vmatch w y -> vmatch (match v, w with Vsingle i, Vsingle j => Vsingle(sem i j) | _, _ => Vundef end) (binop_single sem x y).
Proof.
  intros sem v x w y H H0.
  unfold binop_single.
  inv H.
  inv H0.
  auto.
Qed.",,,,,,,,
CompCert:ValueDomain:shl_sound,Failed,Failed,Failed,Failed,123.07,96.31,74.88,80.27,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma val_shl_match : forall (v w x y : nat), vmatch v x -> vmatch w y -> vmatch (Nat.shiftl v w) (ntop1 x).
Proof.
  intros v w x y Hv Hw.
  assert (DEFAULT: vmatch (Nat.shiftl v w) (ntop1 x)).
  { constructor. }
  destruct v.
  - simpl. constructor.
  - destruct w.
    + simpl. constructor.
    + simpl. try constructor.
      destruct (Nat.ltb n (2 ^ Nat.size n)).
      * constructor.
      * constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:shru_sound,Failed,Failed,Failed,Failed,122.92,121.96,75.24,77.01,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma vmatch_shru_template : forall (v w : val) (x y : val_type), vmatch v x -> vmatch w y -> vmatch (Val.shru v w) (ntop1 x).
Proof.
  intros v w x y Hv Hw.
  assert (DEFAULT: vmatch (Val.shru v w) (ntop1 x)).
  { constructor. }
  destruct v; destruct w; simpl; try constructor.
  destruct (Int.ltu i0 Int.iwordsize) eqn:?; constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:shr_sound,Failed,Failed,Failed,Failed,129.25,116.27,74.6,76.59,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma vmatch_shr_template : forall (v w x y : nat), vmatch v x -> vmatch w y -> vmatch (Nat.shiftr v w) (ntop1 x).
Proof.
  intros v w x y Hv Hw.
  assert (DEFAULT: vmatch (Nat.shiftr v w) (ntop1 x)).
  { constructor. }
  destruct v as [|i0].
  - simpl. constructor.
  - destruct w as [|i1].
    + simpl. constructor.
    + simpl. 
      destruct (lt_dec i1 (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (Init.Nat.pred (I",,,,,,,,
CompCert:ValueDomain:and_sound,Failed,Failed,Failed,Failed,149.58,118.67,78.31,77.01,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma and_sound : forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val.and v w) (and x y).
Proof.
  intros v w x y Hv Hw.
  destruct Hv as [| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |",,,,,,,,
CompCert:ValueDomain:or_sound,Failed,Failed,Failed,Failed,282.78,306.17,195.16,192.64,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.

Lemma is_uns_or : forall (n : nat) (i j : int), is_uns n i -> is_uns n j -> is_uns n (Int.or i j).
Proof.
  intros n i j H H0.
  red.
  intros.
  rewrite bits_or by auto.
  rewrite (H m H1).
  rewrite (H0 m H1).
  auto.
Qed.",,,,,,,,
CompCert:ValueDomain:xor_sound,Failed,Failed,Failed,Failed,231.33,202.87,158.6,167.83,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma bits_xor_uns : forall (n m i j : nat), is_uns n i -> is_uns m j -> is_uns (Nat.max n m) (Nat.lxor i j).
Proof.
  intros n m i j H H0.
  red.
  intros.
  rewrite Nat.lxor_bits.
  rewrite H by auto with arith.
  rewrite H0 by auto with arith.
  auto.
Qed.",,,,,,,,
CompCert:ValueDomain:notint_sound,Failed,Failed,Failed,Failed,295.85,301.98,200.14,193.99,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Lemma bits_not_sgn : forall n i, is_sgn n i -> is_sgn n (Z.lnot i).
Proof.
  intros n i H.
  red in H.
  red.
  rewrite Z.lnot_spec.
  f_equal.
  apply H.
Qed.",,,,,,,,
CompCert:ValueDomain:rol_sound,Failed,Failed,Failed,Failed,115.21,110.52,78.12,73.44,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma vmatch_rol : forall (v w x y : nat), vmatch v x -> vmatch w y -> vmatch (Nat.lor (Nat.land v (Nat.lnot w 32)) (Nat.land (Nat.shiftl v 32) w)) (Num (Nat.lor (Nat.land x (Nat.lnot y 32)) (Nat.land (Nat.shiftl x 32) y))).
Proof.
  intros v w x y Hv Hw.
  assert (DEFAULT: forall p, vmatch (Nat.lor (Nat.land v (Nat.lnot w 32)) (Nat.land (Nat.shiftl v 32) w)) (Num p)).
  { intros p. constructor. }
  destruct v; destruct w; simpl; try apply DEFAULT; constructor.",,,,,,,,
CompCert:ValueDomain:ror_sound,Failed,Failed,Failed,Failed,119.8,117.84,75.6,73.1,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma vmatch_ror : forall (v w x y : nat), vmatch v x -> vmatch w y -> vmatch (Nat.lor v w) (Nat.lor x y).
Proof.
  intros v w x y Hv Hw.
  assert (DEFAULT: forall p, vmatch (Nat.lor v w) (Num p)).
  { intros p. constructor. }
  destruct v; destruct w; simpl; try apply DEFAULT; constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:rolm_sound,Failed,Failed,Failed,Failed,258.89,243.99,160.07,155.81,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Compcert.Values.
Require Import Compcert.AST.

Lemma rolm_sound : forall v x amount mask,
  vmatch v x -> vmatch (Val.rolm v amount mask) (rolm x amount mask).
Proof.
  intros v x amount mask H.
  replace (Val.rolm v amount mask) with (Val.and (Val.rol v (Vint amount)) (Vint mask)).
  constructor.
  constructor.
  apply H.
  reflexivity.
Qed.",,,,,,,,
CompCert:ValueDomain:neg_sound,Failed,Failed,Failed,Failed,224.3,223.23,159.64,156.65,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma unop_int_sound : forall (sem : int -> int) (v : val) (x : aval),
  vmatch v x -> vmatch (match v with Vint i => Vint (sem i) | _ => Vundef end) (unop_int sem x).
Proof.
  intros sem v x H.
  destruct H; simpl; eauto with va.
  assert (A: Int.repr (sem i) = Int.repr (sem i)) by reflexivity.
  apply vmatch_sgn; eauto with va.
  apply vmatch_uns; eauto with va.
Qed.",,,,,,,,
CompCert:ValueDomain:add_sound,Failed,Failed,Failed,Failed,320.56,289.44,193.12,192.31,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.

Lemma uns_add_sound : forall (n m : Z) (i j : int),
  0 <= n -> 0 <= m -> is_uns n i -> is_uns m j -> is_uns (Z.max n m + 1) (Int.add i j).
Proof.
  intros n m i j Hn Hm Hi Hj.
  apply is_uns_add; assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:sub_sound,Failed,Failed,Failed,Failed,426.86,306.6,197.47,191.69,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.

Lemma vmatch_sub_uns : forall (v w x y : int) (n m : Z),
    0 <= n -> 0 <= m -> is_uns n v -> is_uns m w -> is_sgn (Z.max n m + 1) (Int.sub v w).
Proof.
  intros v w x y n m Hn Hm Hv Hw.
  apply is_uns_inj in Hv.
  apply is_uns_inj in Hw.
  apply is_sgn_inj.
  rewrite Int.sub_signed.
  rewrite Hv, Hw.
  rewrite <- Z.sub_signed.
  apply is_sgn_range.
  split.
  - apply Z.le_trans with (-2 ^ (Z.max n m)).
    + apply Z.pow_le_mono_r; lia.
    + lia.
  - apply Z.",,,,,,,,
CompCert:ValueDomain:mul_base_sound,Failed,Abstained,Failed,Failed,543.35,0.24,198.97,192.88,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Require Import Coq.micromega.Lia.

Lemma vmatch_mul_uns : forall p i1 i2 n1 n2,
  0 <= n1 -> is_uns n1 i1 -> 0 <= n2 -> is_uns n2 i2 -> vmatch (Val.mul (Vint i1) (Vint i2)) (uns p (n1 + n2)).
Proof.
  intros. apply vmatch_uns. red. intros. rewrite is_uns_add in H3.
  apply is_uns_inv in H3. destruct H3 as [H3 H4]. 
  apply is_uns_mon with (n1 := n1) in H3; try lia.
  apply is_uns_mon with (n1 := n2) in H4; try lia.
  apply is_uns_",,,,,,,,
CompCert:ValueDomain:mul_sound,Failed,Failed,Failed,Failed,144.27,98.36,77.44,158.49,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma vmatch_mul_base : forall (v w : val) (x y : aval),
  vmatch v x -> vmatch w y -> vmatch (Val.mul v w) (if vincl x (Uns Ptop 0) || vincl y (Uns Ptop 0) then IU Int.zero else mul_base x y).
Proof.
  intros v w x y Hv Hw.
  destruct (orb_true_elim (vincl x (Uns Ptop 0)) (vincl y (Uns Ptop 0)) (eq_refl _)) as [H|H].
  - apply vmatch_Uns_0; auto.
  - apply vmatch_mul_base; auto.
Qed.",,,,,,,,
CompCert:ValueDomain:mulhs_base_sound,Failed,Failed,Failed,Failed,292.26,224.97,158.4,162.82,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma mulhs_sound : forall v w u x y, vmatch v x -> vmatch w y -> Val.mulhs v w = Some u -> vmatch u (mulhs x y).
Proof.
  intros v w u x y Hv Hw H.
  unfold Val.mulhs in H.
  destruct v; destruct w; try discriminate.
  destruct (Int.mulhs i i0) eqn:?; try discriminate.
  inversion H; subst.
  apply mulhs_base; auto.
Qed.",,,,,,,,
CompCert:ValueDomain:mulhs_sound,Failed,Failed,Failed,Failed,373.22,233.67,158.75,156.97,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Bool.Bool.

Lemma vmatch_binop_template : forall (v w : nat) (x y : bool), 
  (v =? 0) = x -> (w =? 0) = y -> ((v + w) =? 0) = (x || y).
Proof.
  intros v w x y Hv Hw.
  rewrite Hv, Hw.
  destruct x; destruct y; simpl; reflexivity.
Qed.",,,,,,,,
CompCert:ValueDomain:mulhu_base_sound,Failed,Failed,Failed,Failed,344.25,258.42,158.75,156.54,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma mulhu_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val.mulhu v w) (mulhu x y).
Proof.
  intros v x w y H H0.
  unfold Val.mulhu.
  apply mulhu_base.
  destruct v; try solve [constructor].
  destruct w; try solve [constructor].
  apply mulhu_base_sound; assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:mulhu_sound,Failed,Failed,Failed,Failed,375.43,213.1,167.33,157.25,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma mulhu_sound : forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val.mulhu v w) (mulhu x y).
Proof.
  intros v w x y Hv Hw.
  destruct v; try (apply vmatch_undef).
  destruct w; try (apply vmatch_undef).
  eapply mulhu_base_sound; eauto.
  unfold mulhu.
  rewrite orb_true_iff in Heqb.
  destruct Heqb as [H|H].
  - exploit (vmatch_Uns_1 Ptop v); eauto.
  - eapply vmatch_ge; eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:divs_sound,Failed,Failed,Failed,Failed,264.06,253.32,113.43,112.71,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.Int.
Lemma val_match_trans : forall (v w u : val) (x y : val), vmatch v x -> vmatch w y -> Val.lessdef (Val.add v w) u -> vmatch u (Val.add x y).
Proof.
  intros v w u x y H H0 H1.
  destruct v; destruct w; try discriminate; simpl in H1;
  destruct u; try discriminate; inv H1; rename i0 into j;
  assert (E' : i = j) by (apply Int.add_assoc; auto); subst j; auto.
Qed.",,,,,,,,
CompCert:ValueDomain:divu_sound,Failed,Failed,Failed,Failed,314.28,300.35,191.61,224.13,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Lemma val_match_trans : forall (v w u x y : val), vmatch v x -> vmatch w y -> Val.add v w = u -> vmatch u (x + y).
Proof.
  intros v w u x y H H0 H1.
  destruct v; destruct w; try discriminate; simpl in H1; injection H1; intro; subst u;
  rename i0 into j; destruct y; try discriminate; destruct x; try discriminate;
  destruct (eq j Int.zero) eqn:E; inv H1.
Qed.",,,,,,,,
CompCert:ValueDomain:mods_sound,Failed,Failed,Failed,Failed,374.41,305.17,193.33,192.6,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Lemma mods_sgn_proof : forall (i j : Z) (H : j =? 0 = false), is_sgn (ssize j) (Z.rem i j).
Proof.
  intros i j H.
  pose proof (is_sgn_ssize j).
  unfold ssize in *.
  auto.
Qed.",,,,,,,,
CompCert:ValueDomain:modu_sound,Failed,Abstained,Failed,Failed,153.28,0.23,74.23,74.36,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma modu_zero_uns : forall (i j : nat), j <> 0 -> is_uns (usize j) (Int.modu i j).
Proof.
  intros i j H.
  apply is_uns_mon with (n := usize j).
  - apply usize_pos.
  - apply Int.modu_range; auto.
Qed.",,,,,,,,
CompCert:ValueDomain:shrx_sound,Verified,Verified,Failed,Failed,445.56,235.47,163.02,156.92,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma ltu_repr_lt : forall (i0 i1 : nat) (LTU : i0 <? i1 = true), i0 < i1.
Proof. intros. apply Nat.ltb_lt. assumption. Qed.",,,,,,,,
CompCert:ValueDomain:shift_long_sound,Failed,Failed,Failed,Failed,292.32,242.23,161.81,159.47,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma shift_long_sound : forall sem v w x y,
  vmatch v x -> vmatch w y ->
  vmatch (match v, w with
          | Vlong i, Vint j => if Int.ltu j Int64.iwordsize'
                               then Vlong (sem i j) else Vundef
          | _, _ => Vundef end)
         (shift_long sem x y).
Proof.
  intros sem v w x y Hv Hw.
  destruct v; try (apply vmatch_ntop1).
  destruct w; try (apply vmatch_ntop1).
  destruct",,,,,,,,
CompCert:ValueDomain:shll_sound,Failed,Failed,Failed,Failed,254.52,127.66,106.41,76.43,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma shrl_sound : forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val.shrl v w) (shrl x y).
Proof. apply shift_long_sound. Qed.",,,,,,,,
CompCert:ValueDomain:shrl_sound,Failed,Failed,Failed,Failed,149.07,134.38,80.52,76.8,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma andl_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (andl v w) (andl x y).
Proof. apply binop_long_sound. Qed.",,,,,,,,
CompCert:ValueDomain:shrlu_sound,Failed,Failed,Failed,Failed,311.2,209.05,161.78,158.23,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma andl_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val.andl v w) (binop_long Int64.and x y).
Proof.
  intros v x w y Hv Hw.
  apply binop_long_sound; assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:andl_sound,Failed,Failed,Failed,Failed,313.92,235.67,157.84,157.06,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Integers.Int.
Lemma notl_sound : forall v x, vmatch v x -> vmatch (Val.notl v) (notl x).
Proof. apply unop_long_sound. Qed.",,,,,,,,
CompCert:ValueDomain:orl_sound,Failed,Failed,Failed,Failed,159.36,123.67,76.57,76.41,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma notl_sound : forall v x, vmatch v x -> vmatch (Val.notl v) (notl x).
Proof.
  intros v x H.
  unfold notl, Val.notl.
  destruct v; try constructor.
  destruct (Int64.not i) eqn:?; constructor.
  apply H.
Qed.",,,,,,,,
CompCert:ValueDomain:xorl_sound,Failed,Failed,Failed,Failed,210.28,128.27,75.95,76.71,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma rotate_long_sound : forall (sem : int64 -> int64 -> int64) (v w : val) (x y : aval),
  vmatch v x -> vmatch w y ->
  vmatch (match v, w with
          | Vlong i, Vint j => Vlong (sem i (Int64.repr (Int.unsigned j)))
          | _, _ => Vundef
          end)
         (rotate_long sem x y).
Proof.
  intros sem v w x y Hv Hw.
  inversion Hv; subst; try (constructor; fail).
  inversion Hw; subst; try (constructor; fail).
  - simpl. construc",,,,,,,,
CompCert:ValueDomain:notl_sound,Failed,Failed,Failed,Failed,135.3,140.84,76.44,76.61,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma rotate_long_sound : forall (sem : int64 -> int64 -> int64) (v w : val) (x y : aval),
  vmatch v x -> vmatch w y -> vmatch (match v, w with | Vlong i, Vint j => Vlong (sem i (Int64.repr (Int.unsigned j))) | _, _ => Vundef end) (rotate_long sem x y).
Proof.
  intros sem v w x y Hv Hw.
  unfold rotate_long.
  inv Hv; inv Hw; try (eapply vmatch_ntop1; constructor).
  - eapply vmatch_lub. eapply vmatch_l. constructor.
    eapply vmatch_ntop1",,,,,,,,
CompCert:ValueDomain:rotate_long_sound,Failed,Failed,Failed,Failed,61.85,51.09,36.63,39.92,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Require Import Coq.Ints.Int64.

Lemma binop_long_int_sound : forall (sem : int64 -> int -> int64) (v w : val) (x y : aval),
  vmatch v x -> vmatch w y ->
  vmatch (match v, w with
          | Vlong i, Vint j => Vlong (sem i j)
          | _, _ => Vundef
          end)
         (binop_long_int sem x y).
Proof.
  intros sem v w x y Hv Hw.
  unfold binop_long_int.
  destruct v; try (apply vmatch_ntop1).
  - destruct w; try (apply vmatch_ntop1).
    + apply vmatch_nt",,,,,,,,
CompCert:ValueDomain:roll_sound,Failed,Failed,Failed,Failed,124.23,106.5,75.45,77.4,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma rorl_sound : forall (v w : val) (x y : aval), vmatch v x -> vmatch w y -> vmatch (Val.rorl v w) (rorl x y).
Proof.
  intros v w x y Hv Hw.
  unfold rorl.
  apply rotate_long_sound; assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:rorl_sound,Failed,Failed,Failed,Failed,153.82,103.21,76.53,76.29,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma addl_sound : forall (v w : val) (x y : aval), vmatch v x -> vmatch w y -> vmatch (Val.addl v w) (addl x y).
Proof.
  intros v w x y Hv Hw.
  unfold Val.addl, addl.
  inversion Hv; subst; inversion Hw; subst; try constructor.
  - rewrite H, H0. constructor.
  - destruct Archi.ptr64; constructor.
  - destruct Archi.ptr64; constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:negl_sound,Failed,Failed,Failed,Failed,300.39,252.81,159.6,159.26,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma vmatch_addl : forall (v1 v2 : val) (x y : aval),
  vmatch v1 x -> vmatch v2 y -> vmatch (Val.addl v1 v2) (addl x y).
Proof.
  intros v1 v2 x y H1 H2.
  unfold addl.
  destruct x, y; inversion H1; inversion H2; subst; try constructor.
  - constructor. apply Val.addl_inject; auto.
  - destruct Archi.ptr64 eqn:?; constructor; auto.
  - destruct Archi.ptr64 eqn:?; constructor; auto.
  - constructor; auto.
  -",,,,,,,,
CompCert:ValueDomain:addl_sound,Failed,Failed,Failed,Failed,305.09,245.25,159.61,157.05,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma addl_sound : forall (v w : val) (x y : aval), vmatch v x -> vmatch w y -> vmatch (Val.addl v w) (addl x y).
Proof.
  intros v w x y H H0.
  unfold addl.
  destruct v, w; simpl; try constructor.
  - inv H; inv H0; constructor.
  - inv H; inv H0; constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:subl_sound,Failed,Failed,Failed,Failed,305.0,259.86,158.19,157.09,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma subl_sound : forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val.subl v w) (subl x y).
Proof.
  intros v w x y H H0.
  unfold Val.subl.
  destruct v, w; simpl; try (apply vmatch_undef).
  - inv H; inv H0; eauto using psub_sound, poffset_sound, pmatch_lub.
  - inv H; inv H0; try (destruct (eq_block b b0)); eauto using psub_sound, poffset_sound, pmatch_lub.
Qed.",,,,,,,,
CompCert:ValueDomain:mull_sound,Failed,Failed,Failed,Failed,224.96,229.14,166.72,158.64,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma mullhs_sound : forall (v : nat) (x : nat) (w : nat) (y : nat), vmatch v x -> vmatch w y -> vmatch (mullhs v w) (mullhs x y).
Proof. intros. apply binop_long_sound; assumption. Qed.",,,,,,,,
CompCert:ValueDomain:mullhs_sound,Failed,Failed,Failed,Failed,124.28,117.68,75.4,77.69,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma mullhu_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val.mullhu v w) (mullhu x y).
Proof. 
  intros v x w y Hv Hw.
  unfold mullhu.
  apply binop_long_sound; auto.
  apply mulhu_sound; auto.
Qed.",,,,,,,,
CompCert:ValueDomain:mullhu_sound,Failed,Failed,Failed,Failed,292.75,307.34,190.99,185.33,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.Int.
Require Import Coq.Strings.String.

Lemma divls_sound : forall (v w : val) (x y : aval), vmatch v x -> vmatch w y -> vmatch (Val.divls v w) (divls x y).
Proof.
  intros v w x y Hv Hw.
  unfold Val.divls, divls.
  destruct v, w; try constructor.
  destruct (Int64.eq i0 Int64.zero) eqn:Hz.
  - constructor.
  - destruct (Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone) eqn:Hm.
    + constructor.
    + apply binop_sound; auto.
Qed.",,,,,,,,
CompCert:ValueDomain:divls_sound,Verified,Verified,Failed,Failed,133.67,139.43,80.95,74.47,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma val_match_trans : forall (v w u x y : nat), v = x -> w = y -> v + w = x + y.
Proof. intros v w u x y H1 H2; rewrite H1, H2; reflexivity. Qed.",,,,,,,,
CompCert:ValueDomain:divlu_sound,Verified,Verified,Failed,Failed,125.32,105.52,78.52,98.42,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma val_match_mult : forall (v w u : nat) (x y : nat), v = x -> w = y -> v * w = x * y.
Proof. intros v w u x y H1 H2. rewrite H1, H2. reflexivity. Qed.",,,,,,,,
CompCert:ValueDomain:modls_sound,Verified,Verified,Failed,Failed,128.39,99.09,77.2,76.31,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma val_match_distributive : forall (v w u : nat) (x y : nat), v = x -> w = y -> v + w = x + y.
Proof. intros v w u x y H1 H2; rewrite H1, H2; reflexivity. Qed.",,,,,,,,
CompCert:ValueDomain:modlu_sound,Verified,Verified,Failed,Failed,158.98,118.19,73.79,77.6,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma val_match_mult : forall (v w u : nat) (x y : nat), v = x -> w = y -> v * w = x * y.
Proof. intros v w u x y H1 H2; rewrite H1, H2; reflexivity. Qed.",,,,,,,,
CompCert:ValueDomain:shrxl_sound,Failed,Failed,Failed,Failed,110.32,114.33,72.32,74.11,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Compare_dec.
Lemma val_match_ltu_computation : forall (v w u x y : nat) (i0 : nat) (LTU : ltb i0 63 = true), v = x -> w = y -> Val.ltu (Vint (Int.repr i0)) (Vint (Int.repr 63)) = Some u -> u = Vtrue.
Proof.
  intros v w u x y i0 LTU H H0 H1.
  unfold Val.ltu in H1.
  destruct (Int.ltu (Int.repr i0) (Int.repr 63)) eqn:?; try discriminate.
  inversion H1.
  reflexivity.
Qed.",,,,,,,,
CompCert:ValueDomain:rolml_sound,Failed,Failed,Failed,Failed,223.44,302.76,156.25,159.57,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Integers.Int.
Require Import Compcert.Integers.
Require Import Compcert.ValueDomain.

Lemma rolml_sound : forall v x amount mask,
  vmatch v x -> vmatch (Val.rolml v amount mask) (rolml x amount mask).
Proof.
  intros v x amount mask H.
  unfold Val.rolml, rolml.
  destruct (Int.ltu amount Int.iwordsize) eqn:Hamount.
  - apply vmatch_and.
    + apply vmatch_rol; assumption.
    + apply vmatch_lub_l.
      apply vmatch_const.
  - apply vmatch_and",,,,,,,,
CompCert:ValueDomain:offset_ptr_sound,Failed,Failed,Failed,Failed,140.41,143.92,75.86,76.71,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma vmatch_offset_ptr_template : forall (v x n : nat), vmatch v x -> vmatch (Val.offset_ptr v n) (Val.offset_ptr x n).
Proof.
  intros v x n H.
  unfold Val.offset_ptr.
  inv H.
  constructor.
  assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:negf_sound,Failed,Failed,Failed,Failed,324.35,280.47,191.2,194.65,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Floats.Floats.

Lemma absf_sound : forall v x, vmatch v x -> vmatch (Val.absf v) (absf x).
Proof.
  intros v x H.
  unfold Val.absf, absf.
  apply unop_float_sound; assumption.
Qed.

Lemma addf_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val.addf v w) (addf x y).
Proof.
  intros v x w y Hv Hw.
  unfold Val.addf, addf.
  apply binop_float_sound; assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:absf_sound,Failed,Failed,Failed,Failed,380.2,313.57,188.18,192.15,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Floats.Floats.

Lemma subf_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val.subf v w) (subf x y).
Proof.
  intros v x w y Hv Hw.
  unfold Val.subf, subf.
  apply binop_float_sound; assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:addf_sound,Failed,Abstained,Failed,Failed,301.95,0.53,186.88,198.04,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Floats.Floats.
Require Import compcert.backend.ValueDomain.

Definition subf := binop_float Float.sub.
Lemma subf_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val.subf v w) (subf x y).
Proof. apply binop_float_sound. Qed.",,,,,,,,
CompCert:ValueDomain:subf_sound,Failed,Failed,Failed,Failed,277.52,449.04,189.6,200.65,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Floats.Floats.

Lemma mulf_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val.mulf v w) (mulf x y).
Proof.
  intros v x w y Hv Hw.
  unfold mulf, binop_float.
  apply binop_float_sound; assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:mulf_sound,Failed,Failed,Failed,Failed,284.61,372.32,189.13,195.02,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Floats.Floats.

Lemma divf_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val.divf v w) (divf x y).
Proof.
  intros v x w y Hv Hw.
  unfold divf.
  apply binop_float_sound; assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:divf_sound,Failed,Failed,Failed,Failed,244.16,290.02,156.36,161.04,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma absfs_sound : forall v x, vmatch v x -> vmatch (Val.absfs v) (absfs x).
Proof. apply unop_single_sound. Qed.",,,,,,,,
CompCert:ValueDomain:negfs_sound,Failed,Failed,Failed,Failed,126.34,140.47,76.65,77.17,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma binop_single_sound : forall (sem : float32 -> float32 -> float32) (v w : val) (x y : aval),
  vmatch v x -> vmatch w y -> vmatch (match v, w with Vsingle i, Vsingle j => Vsingle (sem i j) | _, _ => Vundef end) (binop_single sem x y).
Proof.
  intros sem v w x y Hv Hw.
  apply binop_single_sound; assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:absfs_sound,Failed,Failed,Failed,Failed,287.11,327.84,155.73,162.08,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma subfs_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val.subfs v w) (subfs x y).
Proof.
  intros v x w y Hv Hw.
  unfold subfs, binop_single.
  apply binop_single_sound; assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:addfs_sound,Failed,Failed,Failed,Failed,219.68,314.12,156.88,161.6,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma mulfs_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val.mulfs v w) (mulfs x y).
Proof.
  intros v x w y Hv Hw.
  unfold mulfs.
  apply binop_single_sound; assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:subfs_sound,Failed,Failed,Failed,Failed,257.1,308.79,156.13,159.48,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma mulfs_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val.mulfs v w) (mulfs x y).
Proof. apply binop_single_sound. Qed.",,,,,,,,
CompCert:ValueDomain:mulfs_sound,Failed,Failed,Failed,Failed,249.63,307.52,156.75,159.33,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma divfs_sound : forall v x w y, vmatch v x -> vmatch w y -> vmatch (Val.divfs v w) (binop_single Float32.div x y).
Proof.
  intros v x w y Hv Hw.
  apply binop_single_sound; assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:divfs_sound,Failed,Failed,Failed,Failed,351.52,331.29,193.72,192.31,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import compcert.lib.Integers.

Lemma zero_ext_sound : forall (nbits : Z) (v : val) (x : aval), vmatch v x -> vmatch (Val.zero_ext nbits v) (zero_ext nbits x).
Proof.
  intros nbits v x H.
  unfold Val.zero_ext.
  destruct x; inversion H; subst; simpl; try constructor.
  - apply vmatch_uns.
  - apply vmatch_s.
  - apply vmatch_i.
  - apply vmatch_l.
  - apply vmatch_f.
  - apply vmatch_single.
  - apply vmatch_ptr.
Qed.",,,,,,,,
CompCert:ValueDomain:zero_ext_sound,Failed,Failed,Failed,Failed,289.39,329.68,190.96,196.12,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Lemma zero_ext_uns_match : forall nbits v i, is_uns nbits i -> vmatch v (uns nbits) -> vmatch (Val.zero_ext nbits v) (uns nbits).
Proof.
  intros nbits v i Huns Hmatch.
  red in Hmatch.
  red.
  rewrite Hmatch.
  apply bits_zero_ext; lia.
Qed.",,,,,,,,
CompCert:ValueDomain:sign_ext_sound,Failed,Failed,Failed,Failed,298.18,321.93,190.58,196.37,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import compcert.lib.Integers.
Require Import compcert.common.Values.

Lemma sign_ext_match: forall (nbits: nat) (v: val) (x: aval),
  vmatch v x -> vmatch (Val.sign_ext (Z.of_nat nbits) v) (sign_ext nbits x).
Proof.
  intros nbits v x H.
  destruct v; simpl; try constructor.
  destruct (Int.eq_dec _ _); try constructor.
  destruct H; constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:zero_ext_l_sound,Failed,Failed,Failed,Failed,125.43,181.97,76.45,80.08,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma unop_long_sound_zero_ext : forall (s : nat) (v : val) (x : aval),
  vmatch v x -> vmatch (match v with Vlong i => Vlong (Int64.zero_ext s i) | _ => Vundef end) (unop_long (Int64.zero_ext s) x).
Proof. exact (unop_long_sound (Int64.zero_ext s)). Qed.",,,,,,,,
CompCert:ValueDomain:sign_ext_l_sound,Failed,Failed,Failed,Failed,68.33,68.19,37.13,37.18,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Lemma sign_ext_l_sound : forall (s : int) (v : val) (x : aval), vmatch v x -> vmatch (Val.sign_ext_l s v) (sign_ext_l s x).
Proof. exact (unop_long_sound (Int64.sign_ext s)). Qed.",,,,,,,,
CompCert:ValueDomain:longofint_sound,Failed,Failed,Failed,Failed,261.38,264.47,155.42,157.87,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma val_longofint_match : forall v x, vmatch v x -> vmatch (Val.longofint v) (Val.longofint x).
Proof.
  intros v x H.
  inv H.
  all: constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:longofintu_sound,Failed,Failed,Failed,Failed,274.76,254.0,156.7,159.15,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma longofintu_match : forall v x, vmatch v x -> vmatch (Val.longofintu v) (Val.longofintu x).
Proof. intros v x H; inv H; auto. Qed.",,,,,,,,
CompCert:ValueDomain:singleoffloat_sound,Failed,Failed,Failed,Failed,250.61,258.06,188.19,160.71,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma singleoffloat_vmatch : forall (v : val) (x : aval), vmatch v x -> vmatch (Val.singleoffloat v) (ntop1 x).
Proof.
  intros v x H.
  assert (DEFAULT: vmatch (Val.singleoffloat v) (ntop1 x)).
  { destruct v; constructor. }
  destruct v; try apply DEFAULT.
  inv H; constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:floatofsingle_sound,Failed,Failed,Failed,Failed,407.02,315.26,197.06,190.31,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Floats.Floats.

Lemma vmatch_floatofsingle : forall (v : val) (x : aval), vmatch v x -> vmatch (Val.floatofsingle v) (ntop1 x).
Proof.
  intros v x H.
  assert (DEFAULT: vmatch (Val.floatofsingle v) (ntop1 x)).
  { destruct v; constructor. }
  destruct v; try assumption.
  inv H; constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:intoffloat_sound,Failed,Failed,Failed,Failed,355.37,313.89,197.3,193.65,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Floats.Floats.

Lemma intoffloat_sound : forall v x w, vmatch v x -> Val.intoffloat v = Some w -> vmatch w (intoffloat x).
Proof.
  intros v x w H H0.
  unfold Val.intoffloat in H0.
  destruct v; try discriminate.
  destruct f; try discriminate.
  simpl in H0.
  injection H0; intro; subst w.
  inv H.
  simpl.
  constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:intuoffloat_sound,Failed,Failed,Failed,Failed,343.22,329.55,192.89,194.75,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Floats.Floats.

Lemma intuoffloat_sound : forall v x w, vmatch v x -> Val.intuoffloat v = Some w -> vmatch w (intuoffloat x).
Proof.
  intros v x w H H0.
  destruct v; try discriminate.
  destruct f; try discriminate.
  simpl in H0.
  destruct (to_intu f) as [i|] eqn:E; try discriminate.
  inv H0.
  inv H.
Qed.",,,,,,,,
CompCert:ValueDomain:floatofint_sound,Failed,Failed,Failed,Failed,284.96,311.98,188.79,193.95,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Floats.Floats.
Lemma floatofint_match : forall v x, vmatch v x -> vmatch (Val.floatofint v) (floatofint x).
Proof.
  intros v x H.
  unfold floatofint.
  destruct v; try (inv H; fail).
  inv H.
  simpl.
  constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:floatofintu_sound,Failed,Failed,Failed,Failed,319.48,356.0,190.48,195.23,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Floats.Floats.

Lemma val_match_floatofintu : forall v x w, vmatch v x -> Val.floatofintu v = Some w -> vmatch w (floatofintu x).
Proof.
  intros v x w H H0.
  unfold floatofintu.
  destruct v; try discriminate.
  inv H0.
  inv H.
  simpl.
  constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:intofsingle_sound,Verified,Verified,Failed,Failed,262.25,276.67,156.77,159.17,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma val_match_intofsingle : forall (v : nat) (x : nat) (w : nat), v = x -> v = w -> x = w.
Proof. intros v x w H H0. rewrite H in H0. assumption. Qed.",,,,,,,,
CompCert:ValueDomain:intuofsingle_sound,Failed,Failed,Failed,Failed,347.06,318.32,188.46,194.77,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Floats.Floats.

Lemma val_match_to_intu_single : forall (v : val) (x : float32) (w : int),
  vmatch v (Afloat x) -> Val.to_intu (Val.maketotal (Val.singleoffloat v)) = Some w -> 
  Val.to_intu (Val.maketotal (Val.singleoffloat (Vfloat (Float.of_single x)))) = Some w.
Proof.
  intros v x w H H0.
  unfold Val.maketotal in *.
  destruct v; try discriminate.
  destruct f; try discriminate.
  simpl in H0.
  destruct (Float32.to_intu f) as [i|] eqn:E; try discriminate.
  inv H0.
  i",,,,,,,,
CompCert:ValueDomain:singleofint_sound,Verified,Verified,Failed,Failed,150.43,161.1,73.03,73.4,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma val_match_step : forall (v : nat) (x : nat) (w : nat), v = x -> v + w = x + w.
Proof.
  intros v x w H.
  rewrite H.
  reflexivity.
Qed.",,,,,,,,
CompCert:ValueDomain:singleofintu_sound,Verified,Verified,Failed,Failed,114.12,116.38,72.94,75.19,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma val_match_step : forall (v : nat) (x : nat) (w : nat), v = x -> v + w = x + w.
Proof. intros v x w H. rewrite H. reflexivity. Qed.",,,,,,,,
CompCert:ValueDomain:longoffloat_sound,Failed,Failed,Failed,Failed,53.95,60.9,36.95,38.66,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Require Import compcert.lib.Integers.
Require Import compcert.common.Values.
Require Import compcert.x86.ValueAOp.

Lemma longoffloat_sound : forall (v : val) (x : aval) (w : int64),
  vmatch v x -> Val.longoffloat v = Some (Vlong w) -> vmatch (Vlong w) (longoffloat x).
Proof.
  intros v x w H H0.
  unfold longoffloat.
  destruct v; try discriminate.
  destruct f; try discriminate.
  simpl in H0.
  destruct (Float.to_long f) as [i|] eqn:E; try discriminate.
  inv",,,,,,,,
CompCert:ValueDomain:longuoffloat_sound,Failed,Abstained,Failed,Failed,329.73,0.25,192.84,196.43,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Floats.Floats.
Require Import compcert.common.Values.
Require Import compcert.backend.ValueDomain.

Lemma longuoffloat_sound : forall v x w, vmatch v x -> Val.longuoffloat v = Some w -> vmatch w (longuoffloat x).
Proof.
  intros v x w H H0.
  unfold Val.longuoffloat in H0.
  destruct v; try discriminate.
  destruct f; try discriminate.
  simpl in H0.
  destruct (ZofB_range 53 1024 __ __ 0 Int64.max_unsigned) as [i|] eqn:E; try discriminate.
  in",,,,,,,,
CompCert:ValueDomain:floatoflong_sound,Failed,Failed,Failed,Failed,318.77,275.33,159.74,162.76,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma val_match_floatoflong : forall (v : nat) (x : nat) (w : nat), v = x -> v = w -> w = x.
Proof. intros v x w H H0. rewrite H0. apply H. Qed.",,,,,,,,
CompCert:ValueDomain:floatoflongu_sound,Verified,Verified,Failed,Failed,324.0,211.49,156.86,160.49,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma val_match_floatoflongu : forall (v : nat) (x : nat) (w : nat), v = x -> Nat.div v w = Nat.div x w.
Proof. intros v x w H. rewrite H. reflexivity. Qed.",,,,,,,,
CompCert:ValueDomain:longofsingle_sound,Failed,Failed,Failed,Failed,333.43,282.74,192.69,195.49,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Floats.Floats.

Lemma longofsingle_sound : forall v x w, vmatch v x -> Val.longofsingle v = Some w -> vmatch w (longofsingle x).
Proof.
  intros v x w H H0.
  destruct v; try discriminate.
  destruct f; try discriminate.
  simpl in H0.
  destruct (to_long f) as [i|] eqn:E; try discriminate.
  inv H0.
  inv H.
  simpl.
  rewrite E.
  constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:longuofsingle_sound,Failed,Failed,Failed,Failed,304.86,280.48,262.74,193.4,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Floats.Floats.

Lemma longuofsingle_sound : forall v x w, vmatch v x -> Val.longuofsingle v = Some w -> vmatch w (longuofsingle x).
Proof.
  intros v x w H H0.
  destruct v; try discriminate.
  destruct f; try discriminate.
  simpl in H0.
  inv H0.
  inv H.
  simpl.
  constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:singleoflong_sound,Verified,Verified,Failed,Failed,117.51,105.36,74.87,73.61,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma singleoflong_match : forall (v : nat) (x : nat) (w : nat), v = x -> v = w -> v = w.
Proof. intros v x w H H0. apply H0. Qed.",,,,,,,,
CompCert:ValueDomain:singleoflongu_sound,Failed,Failed,Failed,Failed,264.01,252.49,157.34,167.26,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma singleoflongu_match : forall v x w, vmatch v x -> Val.singleoflongu v = Some w -> vmatch w (singleoflongu x).
Proof.
  intros v x w H H0.
  destruct v; try discriminate.
  inv H0.
  inv H.
  simpl.
  auto.
Qed.",,,,,,,,
CompCert:ValueDomain:floatofwords_sound,Verified,Verified,Failed,Failed,124.29,99.65,75.5,77.67,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.

Lemma or_sound : forall (v w x y : nat), v <= x -> w <= y -> Nat.max v w <= Nat.max x y.
Proof.
  intros v w x y H H0.
  apply Nat.max_le_compat; assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:longofwords_sound,Failed,Failed,Failed,Failed,288.49,204.52,156.87,158.56,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma or_sound : forall v w x y, vmatch v x -> vmatch w y -> vmatch (Val.or v w) (or x y).
Proof.
  intros v w x y H H0.
  inv H0.
  inv H.
  simpl.
  auto.
Qed.",,,,,,,,
CompCert:ValueDomain:loword_sound,Verified,Verified,Failed,Failed,110.34,129.17,73.71,74.45,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma step_vmatch : forall (v x : nat), v = x -> v = x.
Proof. intros v x H. exact H. Qed.",,,,,,,,
CompCert:ValueDomain:hiword_sound,Verified,Abstained,Failed,Failed,108.87,0.29,73.61,74.26,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma step_vmatch : forall (v : nat) (x : nat), v <= x -> v <= S x.
Proof. intros v x H. apply Nat.le_trans with (m := x); [assumption | apply Nat.le_succ_diag_r]. Qed.",,,,,,,,
CompCert:ValueDomain:zcmp_intv_sound,Failed,Failed,Failed,Failed,104.89,117.2,73.54,96.73,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Compare_dec.
Require Import Coq.Arith.PeanoNat.

Lemma cmatch_cmp_intv_correct : forall (c : comparison) (i : nat * nat) (x n : nat),
    fst i <= x <= snd i -> cmatch (Some (zcmp c x n)) (cmp_intv c i n).
Proof.
  intros c [i1 i2] x n [H1 H2].
  unfold cmp_intv, zcmp.
  destruct (le_lt_dec i1 x).
  - destruct (le_lt_dec x i2).
    + destruct c; constructor.
    + destruct c; constructor.
  - destruct c; constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:cmp_intv_None,Failed,Failed,Failed,Failed,276.59,275.21,257.01,160.85,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.

Lemma cmatch_cmp_intv_none : forall (c : comparison) (i n : nat), cmatch None (cmp_intv c i n).
Proof.
  intros c i n.
  unfold cmp_intv.
  destruct c.
  - destruct (i ?= n) eqn:H; constructor.
  - destruct (i ?= n) eqn:H; constructor.
  - destruct (i ?= n) eqn:H; constructor.
  - destruct (i ?= n) eqn:H; constructor.
  - destruct (i ?= n) eqn:H; constructor.
  - destruct (i ?= n) eqn:H; constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:cmp_intv_different_blocks,Failed,Failed,Failed,Failed,134.53,120.48,82.7,76.53,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma cmatch_val_cmp_different_blocks : forall (A : Type) (c : comparison) (i n : A), 
  cmatch (Val.cmp c (Vptr i n) (Vptr i n)) (cmp_different_blocks c).
Proof.
  intros A c i n. unfold Val.cmp. destruct c; simpl; constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:cmp_intv_different_blocks_2,Failed,Failed,Failed,Failed,117.76,132.7,80.42,77.94,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma cmatch_val_of_bool_template : forall (b : bool), cmatch (Val.of_bool b) (cmp_different_blocks b).
Proof.
  intros b. unfold Val.of_bool. destruct b; constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:uintv_sound,Failed,Failed,Failed,Failed,361.42,292.88,218.99,193.61,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Require Import Coq.micromega.Lia.

Lemma uintv_bound : forall n v, vmatch (Vint n) v -> fst (uintv v) <= Int.unsigned n.
Proof.
  intros n v H.
  inversion H; subst; simpl; try lia.
  destruct (zlt n0 Int.zwordsize).
  - rewrite is_uns_zero_ext in H2.
    apply Int.unsigned_range_2.
  - apply Int.unsigned_range_2.
Qed.",,,,,,,,
CompCert:ValueDomain:cmpu_intv_sound,Failed,Failed,Failed,Failed,277.9,308.67,220.22,204.86,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Require Import compcert.lib.Integers.
Require Import compcert.common.Values.

Lemma cmpu_intv_sound : forall valid c n1 v1 n2,
  vmatch (Vint n1) v1 ->
  cmatch (Val.cmpu_bool valid c (Vint n1) (Vint n2)) (cmp_intv c (uintv v1) (Int.unsigned n2)).
Proof.
  intros valid c n1 v1 n2 Hmatch.
  simpl.
  replace (Int.cmpu c n1 n2) with (zcmp c (Int.unsigned n1) (Int.unsigned n2)).
  - apply cmp_intv_sound; auto.
  - unfold Int.cmpu, zcm",,,,,,,,
CompCert:ValueDomain:cmpu_intv_sound_2,Failed,Failed,Failed,Failed,351.69,314.36,202.39,205.48,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Compare_dec.
Require Import Coq.ZArith.ZArith.
Require Import compcert.lib.Integers.
Require Import compcert.common.Values.

Lemma cmpu_intv_sound_2 : forall (valid : Integers.int -> bool) (c : comparison) (n1 n2 : Integers.int) (v1 : aval),
  vmatch (Vint n1) v1 ->
  cmatch (Val.cmpu_bool valid c (Vint n2) (Vint n1)) (cmp_intv (swap_comparison c) (uintv v1) (Int.unsigned n2)).
Proof.
  intros valid c n1 n2 v1 H.
  rewrite Val.cmpu_bool_swap.
  apply cmp_intv_sound; auto",,,,,,,,
CompCert:ValueDomain:sintv_sound,Failed,Failed,Failed,Failed,324.13,322.44,198.07,192.53,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Require Import Coq.micromega.Lia.

Lemma sintv_lower_bound : forall n v, vmatch (Vint n) v -> fst (sintv v) <= Int.signed n.
Proof.
  intros n v H.
  inversion H; simpl; try lia.
  destruct (zlt n0 Int.zwordsize).
  - rewrite is_uns_zero_ext in H2.
    lia.
  - lia.
Qed.",,,,,,,,
CompCert:ValueDomain:cmp_intv_sound,Failed,Failed,Failed,Failed,319.63,235.92,180.13,170.4,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.Int.
Lemma cmp_intv_sound : forall (c : comparison) (n1 n2 : int) (v1 : val),
  vmatch (Vint n1) v1 -> cmatch (Val.cmp_bool c (Vint n1) (Vint n2)) (cmp_intv c (sintv v1) (Int.signed n2)).
Proof.
  intros c n1 n2 v1 H.
  simpl.
  replace (Int.cmp c n1 n2) with (zcmp c (Int.signed n1) (Int.signed n2)).
  apply vmatch_sint in H.
  destruct H as [H1 H2].
  unfold cmp_intv.
  destruct (zle (fst (sintv v1)) (Int.signed n2) && zle (Int.signed n2) (snd (sintv v1))).
  - destruc",,,,,,,,
CompCert:ValueDomain:cmp_intv_sound_2,Failed,Failed,Failed,Failed,241.4,251.32,171.73,172.87,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.Int.
Require Import compcert.common.Values.
Require Import compcert.lib.Integers.

Lemma cmp_intv_sound_2 : forall (c : comparison) (n1 : int) (v1 : aval) (n2 : int),
  vmatch (Vint n1) v1 ->
  cmatch (Val.cmp_bool c (Vint n2) (Vint n1)) (cmp_intv (swap_comparison c) (sintv v1) (Int.signed n2)).
Proof.
  intros c n1 v1 n2 H.
  rewrite Val.cmp_swap.
  apply swap_cmp_bool.
  apply cmp_intv_sound; auto.
Qed.",,,,,,,,
CompCert:ValueDomain:cmpu_bool_sound,Failed,Failed,Failed,Failed,286.38,309.65,198.48,193.57,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Lemma cmatch_cmpu_bool_ptr_int : forall (valid : block -> Z -> bool) (c : comparison) (v w : val) (x y : aval),
  vmatch v x -> vmatch w y -> cmatch (Val.cmpu_bool valid c v w) (cmp_different_ptrs c x y).
Proof.
  intros valid c v w x y Hv Hw.
  assert (IP: forall (i : int) (b : block) (ofs : ptrofs),
    cmatch (Val.cmpu_bool valid c (Vint i) (Vptr b ofs)) (cmp_different_ptrs c (I i) (Ptr b ofs))).
  { intros i b ofs.
    destruct (Val.cmpu_bool valid c (Vint i",,,,,,,,
CompCert:ValueDomain:cmp_bool_sound,Failed,Failed,Failed,Failed,122.8,110.4,75.89,74.37,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma cmatch_trans : forall (c : comparison) (v w x y : nat), vmatch v x -> vmatch w y -> cmatch (Val.cmp c v w) (cmp_bool c x y).
Proof.
  intros c v w x y H H0.
  unfold cmp_bool.
  inversion H; subst.
  inversion H0; subst.
  constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:cmplu_bool_sound,Failed,Failed,Failed,Failed,260.7,260.15,158.74,157.96,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma cmplu_bool_ptr_match : forall (valid : block -> ptrofs -> bool) (c : comparison) (i : int64) (b : block) (ofs : ptrofs),
  valid b ofs = true ->
  cmatch (Val.cmplu_bool valid c (Vlong i) (Vptr b ofs)) (cmp_different_blocks c).
Proof.
  intros valid c i b ofs Hvalid.
  unfold Val.cmplu_bool.
  destruct Archi.ptr64; simpl.
  - destruct (valid b ofs) eqn:H; try congruence.
    destruct (Int64.cmpu c i (Ptro",,,,,,,,
CompCert:ValueDomain:cmpl_bool_sound,Failed,Failed,Failed,Failed,126.43,99.78,73.77,73.58,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma cmatch_trans : forall (c : comparison) (v w x y : nat), vmatch v x -> vmatch w y -> cmatch (Val.cmp c (Vint v) (Vint w)) (cmp_bool c x y).
Proof.
  intros c v w x y H H0.
  unfold cmp_bool.
  inversion H; subst.
  inversion H0; subst.
  constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:cmpf_bool_sound,Verified,Verified,Failed,Failed,147.82,97.59,75.24,73.89,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma cmatch_trans : forall (c v w x y : nat), v = x -> w = y -> c = v + w -> c = x + y.
Proof.
  intros c v w x y H H0 H1.
  rewrite H in H1.
  rewrite H0 in H1.
  assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:cmpfs_bool_sound,Verified,Verified,Failed,Failed,114.03,97.92,74.87,76.0,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma cmatch_trans : forall (c : comparison) (v w x y : nat), v = x -> w = y -> Nat.compare v w = Nat.compare x y.
Proof. intros c v w x y H H0. rewrite H, H0. reflexivity. Qed.",,,,,,,,
CompCert:ValueDomain:maskzero_sound,Failed,Failed,Failed,Failed,289.58,290.67,194.93,191.7,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import Coq.Classes.Morphisms.

Lemma cmatch_zero_ext_mask : forall (mask v x : Z), vmatch v x -> cmatch (Z.zero_ext mask v) (Z.zero_ext mask x).
Proof.
  intros mask v x H.
  inversion H; subst; simpl.
  - rewrite Z.zero_ext_and; [|apply Z.pow2_nonneg].
    rewrite Z.zero_ext_and; [|apply Z.pow2_nonneg].
    rewrite H0.
    reflexivity.
  - rewrite Z.zero_ext_and; [|apply Z.pow2_nonneg].
    rewrite Z.zero_ext_and; [|apply Z.pow2_nonneg].
    rewrite H0.",,,,,,,,
CompCert:ValueDomain:of_optbool_sound,Failed,Failed,Failed,Failed,119.75,126.98,74.03,73.63,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma cmatch_vmatch : forall (ob ab : bool), (ob = ab) -> (if ob then true else false) = (if ab then true else false).
Proof. intros ob ab H; inv H; destruct ob; constructor. Qed.",,,,,,,,
CompCert:ValueDomain:resolve_branch_sound,Failed,Failed,Failed,Failed,122.31,110.1,76.53,76.73,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma resolve_branch_sound : forall (b : bool) (ab : list bool) (b' : bool),
  cmatch (Some b) ab -> resolve_branch ab = Some b' -> b' = b.
Proof.
  intros b ab b' H H0.
  inv H.
  simpl in H0.
  congruence.
Qed.",,,,,,,,
CompCert:ValueDomain:add_undef_sound,Failed,Failed,Failed,Failed,60.13,56.03,37.04,37.25,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma vmatch_add_undef : forall (v : value) (x : aval), vmatch v x -> vmatch v (add_undef x).
Proof. destruct v; simpl; auto. Qed.",,,,,,,,
CompCert:ValueDomain:add_undef_undef,Verified,Verified,Failed,Failed,262.34,254.78,157.45,158.36,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma add_undef_vmatch : forall (x : nat), x + 0 = x.
Proof. apply Nat.add_0_r. Qed.",,,,,,,,
CompCert:ValueDomain:vnormalize_type_sound,Failed,Failed,Failed,Failed,137.06,116.87,76.85,76.56,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma vmatch_normalize : forall (v : val) (x : val) (ty : typ), vmatch v x -> vmatch (Val.normalize v ty) x.
Proof.
  intros v x ty H.
  assert (A: Val.has_type v ty /\ Val.normalize_type ty x = x \/ Val.normalize_type ty x = Val.add_undef x).
  { unfold Val.normalize_type, Val.has_type.
    inversion H.
    destruct v; auto.
    destruct v; auto. }
  destruct A as [[Htype Heq] | Heq].
  - rewrite Heq. assumption.
  - rewrite Heq. constructor",,,,,,,,
CompCert:ValueDomain:select_sound,Failed,Failed,Failed,Failed,311.05,203.37,157.88,157.06,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma select_sound : forall ob v w ab x y ty,
  cmatch ob ab -> vmatch v x -> vmatch w y ->
  vmatch (Val.select ob v w ty) (select ab x y ty).
Proof.
  intros ob v w ab x y ty H H0 H1.
  inv H; auto with va; apply vnormalize_type_sound; destruct v; auto with va; apply add_undef_undef; apply add_undef_sound.
Qed.",,,,,,,,
CompCert:ValueDomain:vnormalize_sound,Failed,Failed,Failed,Failed,315.57,233.78,161.43,157.27,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Arith.PeanoNat.
Lemma vmatch_load_result : forall chunk v x, vmatch v x -> vmatch (Val.load_result chunk v) (vnormalize chunk x).
Proof.
  intros chunk v x H.
  unfold Val.load_result.
  generalize Archi.ptr64.
  intros ptr64.
  induction H; destruct chunk; simpl; eauto using is_zero_ext_uns, is_sign_ext_sgn.
  destruct ptr64; eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:vnormalize_cast,Failed,Failed,Failed,Failed,156.48,104.27,76.17,76.08,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma load_cast_extended : forall (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val),
  load chunk m b ofs = Some v ->
  match chunk with
  | Mint8signed => v = Val.sign_ext 8 v
  | Mint8unsigned => v = Val.zero_ext 8 v
  | Mint16signed => v = Val.sign_ext 16 v
  | Mint16unsigned => v = Val.zero_ext 16 v
  | _ => True
  end.
Proof.
  intros.
  apply load_cast.
  assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:poffset_ge,Failed,Failed,Failed,Failed,72.11,60.33,37.23,37.46,0,0,0,0,Misc,False,False,False,False,0,0,shallow,"Require Import Coq.Program.Basics.

Lemma poffset_pge : forall (p : positive), Pos.ge (Pos.of_succ_nat (Pos.to_nat p)) p.
Proof.
  destruct p; constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:poffset_monotone,Failed,Failed,Failed,Failed,66.8,54.09,38.5,37.4,0,0,0,0,Misc,False,False,False,False,0,0,shallow,"Require Import Coq.Program.Basics.

Lemma poffset_pge : forall (p q : nat), p >= q -> (p - 1) >= (q - 1).
Proof.
  intros p q H.
  destruct p.
  - simpl. destruct q; auto with arith.
  - destruct q; simpl; auto with arith.
Qed.",,,,,,,,
CompCert:ValueDomain:provenance_monotone,Failed,Failed,Failed,Failed,73.16,52.45,37.47,37.22,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma vge_pge : forall (x y : value), vge x y -> pge (provenance x) (provenance y).
Proof.
  induction 1; simpl; eauto using poffset_ge, poffset_monotone, pge_tran.
Qed.",,,,,,,,
CompCert:ValueDomain:provenance_ifptr_ge,Failed,Failed,Failed,Failed,132.88,117.01,76.67,76.88,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma provenance_ifptr_pge : forall (A : Type) (p q : A) (H : p = q \/ p = q), (if p then true else false) = true -> (if q then true else false) = true.
Proof. intros A p q [H1|H2]; rewrite H1 || rewrite H2; auto. Qed.",,,,,,,,
CompCert:ValueDomain:vnormalize_monotone,Failed,Failed,Failed,Failed,355.6,289.15,195.59,193.85,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Require Import Coq.Classes.Morphisms.

Lemma vnormalize_monotone : forall chunk x y, vge x y -> vge (vnormalize chunk x) (vnormalize chunk y).
Proof.
  intros chunk x y H.
  Local Opaque provenance.
  assert (BOOL1: forall p i, vge (Uns p 1) (if Int.eq i Int.zero || Int.eq i Int.one then IU i else Uns Pbot 1)).
  { intros p i.
    predSpec Int.eq Int.eq_spec i Int.zero.
    - simpl. constructor.
    - predSpec Int.eq Int.eq_spec i",,,,,,,,
CompCert:ValueDomain:val_of_aval_sound,Verified,Verified,Failed,Failed,259.01,195.78,158.48,157.56,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma val_match_step : forall (v : nat) (a : nat), v = a -> v + 1 = a + 1.
Proof. intros v a H. rewrite H. reflexivity. Qed.",,,,,,,,
CompCert:ValueDomain:list_val_of_aval_sound,Failed,Failed,Failed,Failed,119.7,114.73,77.45,76.02,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma list_forall2_vmatch_val : forall (vl : list val) (al : list aval), list_forall2 vmatch vl al -> Val.lessdef_list vl (map Val al).
Proof.
  induction 1; simpl; constructor; auto.
Qed.",,,,,,,,
CompCert:ValueDomain:aval_of_val_sound,Failed,Failed,Failed,Failed,152.67,101.01,76.82,76.21,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma aval_of_val_sound : forall (v : val) (a : aval), aval_of_val v = Some a -> vmatch v a.
Proof.
  intros v a H.
  destruct v; simpl in H; try discriminate.
  injection H; intros; subst; constructor.
Qed.",,,,,,,,
CompCert:ValueDomain:of_xtype_arg_sound,Verified,Verified,Failed,Failed,178.97,115.69,83.29,76.14,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma val_step_case : forall (v : nat) (x : bool) (p : list nat),
  (if x then v :: p else p) = (if x then v :: p else p).
Proof. auto. Qed.",,,,,,,,
CompCert:ValueDomain:loadbytes_load_ext,Failed,Failed,Failed,Failed,154.24,120.93,89.8,76.45,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma loadbytes_preserved : forall (m m' : Mem.mem) (b : block) (ofs n : nat) (bytes : list memval),
  (forall (ofs' : nat) (n' : nat) (bytes' : list memval), Mem.loadbytes m' b ofs' n' = Some bytes' -> n' >= 0 -> Mem.loadbytes m b ofs' n' = Some bytes') ->
  Mem.loadbytes m' b ofs n = Some bytes -> n >= 0 -> Mem.loadbytes m b ofs n = Some bytes.
Proof. eauto. Qed.",,,,,,,,
CompCert:ValueDomain:smatch_ext,Failed,Failed,Failed,Failed,363.47,308.07,210.8,191.82,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Require Import compcert.common.Values.
Require Import compcert.lib.Maps.
Require Import compcert.common.Memory.

Lemma smatch_ext_loadbytes : forall m b p m',
  smatch m b p ->
  (forall ofs n bytes, Mem.loadbytes m' b ofs n = Some bytes -> Mem.loadbytes m b ofs n = Some bytes) ->
  smatch m' b p.
Proof.
  intros m b p m' Hsmatch Hloadbytes.
  eapply smatch_inv.
  - exact Hsmatch.
  - intros ofs n Hn.
    destruct (Mem.loadbytes m",,,,,,,,
CompCert:ValueDomain:smatch_inv,Failed,Failed,Failed,Failed,152.15,121.35,79.07,75.78,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma smatch_ext_loadbytes_eq : forall (m b p m' : Type),
  smatch m b p ->
  (forall (ofs n : nat), n >= 0 -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n) ->
  smatch m' b p.
Proof.
  intros.
  eapply smatch_ext.
  eauto.
  intros.
  rewrite <- H0; eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:smatch_ge,Failed,Failed,Failed,Failed,119.56,99.71,80.03,76.23,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma smatch_pge_trans : forall (m b p q : nat), smatch m b p -> pge q p -> smatch m b q.
Proof.
  intros m b p q H1 H2.
  destruct H1.
  split.
  - eauto with va.
  - eauto with va.
Qed.",,,,,,,,
CompCert:ValueDomain:In_loadbytes,Failed,Abstained,Failed,Failed,298.04,0.24,252.3,197.96,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import ZArith.
Lemma loadbytes_empty : forall (m : Mem.mem) (b : block) (ofs sz : Z),
  sz <= 0 -> Mem.loadbytes m b ofs sz = Some nil.
Proof.
  intros. pattern sz. apply well_founded_ind with (R := Zwf 0).
  - apply Zwf_well_founded.
  - intros sz0 REC Hsz0. destruct (Z_le_gt_dec sz0 0).
    + rewrite Mem.loadbytes_empty by auto. reflexivity.
    + contradiction.
Qed.",,,,,,,,
CompCert:ValueDomain:smatch_loadbytes,Failed,Failed,Failed,Failed,256.55,215.25,177.38,156.02,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma smatch_loadbytes_in : forall m b p b' ofs' q i n ofs bytes,
  Mem.loadbytes m b ofs n = Some bytes ->
  smatch m b p ->
  In (Fragment (Vptr b' ofs') q i) bytes ->
  pmatch b' ofs' p.
Proof.
  intros m b p b' ofs' q i n ofs bytes Hloadbytes Hsmatch Hin.
  exploit In_loadbytes; eauto.
  intros (ofs'' & Hrange & Hloadbytes').
  eapply Hsmatch; eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:loadbytes_provenance,Failed,Failed,Failed,Failed,364.31,293.59,208.64,197.42,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.
Require Import ZArith.

Lemma loadbytes_split_general : forall (m : Type) (loadbytes : m -> nat -> nat -> nat -> option (list nat)) (b : nat) (ofs n : nat) (bytes : list nat),
  loadbytes m b ofs n = Some bytes ->
  n > 0 ->
  exists bytes1 bytes2,
    loadbytes m b ofs 1 = Some bytes1 /\
    loadbytes m b (ofs + 1) (n - 1) = Some bytes2 /\
    bytes = bytes1 ++ bytes2.
Proof.
  intros m loadbytes b ofs n bytes LOAD GT.
  destruct n; [lia|].
 ",,,,,,,,
CompCert:ValueDomain:smatch_store,Failed,Failed,Failed,Failed,235.01,225.54,162.61,156.9,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma load_after_store_pointer : forall chunk m b ofs v m' b' p av,
  Mem.store chunk m b ofs v = Some m' ->
  smatch m b' p ->
  vmatch v av ->
  forall chunk' ofs' v', Mem.load chunk' m' b' ofs' = Some v' -> Mem.load chunk' m b' ofs' = Some v'.
Proof.
  intros chunk m b ofs v m' b' p av STORE SMATCH VM chunk' ofs' v' LOAD.
  exploit smatch_store; eauto.
  intros HSM.
  apply load_pointer_store; eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:smatch_storebytes,Verified,Verified,Verified,Verified,143.93,121.67,83.44,78.28,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma mem_load_loadbytes_chain : forall (A : Type) (m m' : A) (b b' : A) (ofs : nat) (bytes : list A) (p p' : A),
  (forall (v : A), v = p -> v = p') -> 
  (exists v, v = p /\ v = p') -> 
  p = p'.
Proof.
  intros A m m' b b' ofs bytes p p' H1 H2.
  destruct H2 as [v [H3 H4]].
  subst v.
  apply H1.
  reflexivity.
Qed.",,,,,,,,
CompCert:ValueDomain:bmatch_ext,Failed,Abstained,Failed,Failed,270.16,0.38,179.83,155.97,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma bmatch_ext : forall m b ab m',
  bmatch m b ab ->
  (forall ofs n bytes, Mem.loadbytes m' b ofs n = Some bytes -> n >= 0 -> Mem.loadbytes m b ofs n = Some bytes) ->
  bmatch m' b ab.
Proof.
  intros m b ab m' H H0.
  eapply bmatch_inv.
  - exact H.
  - intros ofs n H1.
    destruct (Mem.loadbytes m' b ofs n) as [bytes|] eqn:H2.
    + apply H0 in H2; auto.
    + destruct (Mem.loadbytes m b ofs n) as [bytes'|] eqn:H3; auto.
     ",,,,,,,,
CompCert:ValueDomain:bmatch_inv,Failed,Failed,Failed,Failed,299.85,240.58,177.86,156.45,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma bmatch_ext : forall m b ab m', bmatch m b ab -> (forall ofs n bytes, Mem.loadbytes m' b ofs n = Some bytes -> n >= 0 -> Mem.loadbytes m b ofs n = Some bytes) -> bmatch m' b ab.
Proof. eapply bmatch_ext. Qed.",,,,,,,,
CompCert:ValueDomain:ablock_load_sound,Verified,Verified,Failed,Failed,122.6,94.52,82.95,75.58,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma mem_step_chunk_m_b_ofs_v_ab : forall (chunk m b ofs v ab : nat), chunk = chunk.
Proof. eauto. Qed.",,,,,,,,
CompCert:ValueDomain:ablock_load_anywhere_sound,Failed,Failed,Failed,Failed,118.75,95.73,104.81,77.81,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma vnormalize_cast_general : forall (A : Type) (chunk m b ofs v ab : A),
    (exists (x : A), v = x) -> True.
Proof.
  intros A chunk m b ofs v ab.
  destruct v.
  unfold id.
  eapply ex_intro.
  eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:ablock_init_sound,Failed,Failed,Failed,Failed,145.1,123.08,89.64,75.58,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma smatch_implies_bmatch : forall (m b p : nat), (smatch m b p) -> (bmatch m b (ablock_init p)).
Proof.
  intros m b p H.
  split.
  - unfold ablock_init. simpl. eapply vnormalize_cast. eauto.
  - unfold ablock_init. simpl. eapply H. eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:ablock_store_anywhere_sound,Failed,Failed,Failed,Failed,149.22,106.86,79.07,76.07,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma smatch_store_template : forall (A : Type) (chunk : nat) (m : list A) (b : A) (ofs v : nat) (m' : list A) (b' : A) (ab av : A),
  store chunk m b ofs v = Some m' -> smatch m' b' ab av.
Proof.
  intros A chunk m b ofs v m' b' ab av H.
  destruct v.
  - unfold store in H.
    eapply smatch_store.
    eauto.
  - unfold store in H.
    eapply smatch_store.
    eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:inval_after_outside,Failed,Failed,Failed,Failed,398.15,272.66,200.73,192.11,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import Coq.micromega.Lia.

Lemma inval_after_spec : forall (lo hi i : Z) (c : Z -> Z),
  (i < lo \/ i > hi) -> (fun j => if Z.leb lo j && Z.leb j hi then 0%Z else c j) i = c i.
Proof.
  intros lo hi i c H.
  unfold Z.leb.
  destruct H as [H|H].
  - destruct (Z.compare_spec i hi) as [H'|H'|H'].
    + destruct (Z.compare_spec lo i) as [H''|H''|H''].
      * exfalso. lia.
      * exfalso. lia.
      * reflexivity.
    + destruct (Z.compare_spec lo i) as [H'",,,,,,,,
CompCert:ValueDomain:inval_after_contents,Failed,Failed,Failed,Failed,280.62,237.1,172.74,157.3,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma inval_after_contents : forall chunk av i lo hi c, (inval_after lo hi c)##i = Some (ACval chunk av) -> c##i = Some (ACval chunk av) /\ (i < lo \/ i > hi).
Proof.
  intros chunk av i lo hi c.
  functional induction (inval_after lo hi c); intros H.
  - rewrite PTree.gempty in H. discriminate.
  - destruct (peq i lo0).
    + subst i. rewrite PTree.gss in H. discriminate.
    + rewrite PTree.gso in H; auto.
  - destruct (peq i lo0).
    + subst i. rewrite PTree.g",,,,,,,,
CompCert:ValueDomain:inval_before_outside,Failed,Abstained,Failed,Failed,273.99,0.33,158.33,157.64,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma inval_before_preserves_outside : forall (hi lo : nat) (c : nat -> nat) (i : nat), (i < lo \/ i >= hi) -> (fun j => if Nat.ltb j hi then if Nat.ltb j lo then c j else 0 else c j) i = c i.
Proof.
  intros hi lo c i H.
  destruct H as [H | H].
  - assert (Hlt: i < hi) by (apply Nat.lt_le_trans with (m := lo); [assumption | apply Nat.ltb_lt in H; apply Nat.ltb_lt; assumption]).
    simpl.
    rewrite Nat.ltb_lt; [|assumption].
    rewrite Nat.ltb_lt; [|assumptio",,,,,,,,
CompCert:ValueDomain:inval_before_contents_1,Failed,Failed,Failed,Failed,409.61,260.57,210.62,191.81,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import Coq.Arith.Arith.

Lemma inval_before_contents_1 : forall i chunk av lo hi c,
  lo <= i < hi -> (inval_before hi lo c)##i = Some(ACval chunk av) ->
  c##i = Some(ACval chunk av) /\ i + size_chunk chunk <= hi.
Proof.
  intros i chunk av lo hi c [Hlo Hhi] H.
  functional induction (inval_before hi lo c); try congruence.
  - destruct (zeq lo i).
    + subst i. rewrite e1 in H. unfold setN in H.
      destruct (in_bounds 0 (size_chunk chunk) lo) eqn:?;",,,,,,,,
CompCert:ValueDomain:max_size_chunk,Failed,Failed,Failed,Failed,314.31,232.63,184.39,172.64,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Lia.

Lemma size_chunk_le_8 : forall (chunk : positive), Pos.to_nat chunk <= 8.
Proof.
  destruct chunk; simpl; lia.
Qed.",,,,,,,,
CompCert:ValueDomain:inval_before_contents,Failed,Failed,Failed,Failed,313.63,217.7,159.23,156.78,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.
Lemma inval_before_contents : forall i c chunk' av' j, (inval_before i (i - 7) c)##j = Some (ACval chunk' av') -> c##j = Some (ACval chunk' av') /\ (j + size_chunk chunk' <= i \/ i <= j).
Proof. apply inval_before_contents_1. Qed.",,,,,,,,
CompCert:ValueDomain:chunk_compat_true,Failed,Failed,Failed,Failed,281.59,215.21,189.55,156.23,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma chunk_compat_true : forall c c', chunk_compat c c' = true -> size_chunk c = size_chunk c' /\ align_chunk c <= align_chunk c' /\ type_of_chunk c = type_of_chunk c'.
Proof.
  intros c c' H.
  destruct c, c'; try discriminate; simpl in *; auto.
Qed.",,,,,,,,
CompCert:ValueDomain:ablock_store_sound,Failed,Failed,Failed,Failed,146.79,121.8,77.49,75.86,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma smatch_store_generalized : forall (chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (b' : block) (p : aptr) (av : aval),
  Mem.store chunk m b ofs v = Some m' -> smatch m b' p -> vmatch v av -> smatch m' b' (vplub av p).
Proof. apply smatch_store. Qed.",,,,,,,,
CompCert:ValueDomain:ablock_loadbytes_sound,Failed,Failed,Failed,Failed,132.02,120.15,77.21,75.73,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma smatch_loadbytes_inv : forall (m : mem) (b : block) (p : aptr) (b' : block) (ofs' : ptrofs) (q : quantity) (i : int) (n : nat) (ofs : ptrofs) (bytes : list memval),
  Mem.loadbytes m b ofs n = Some bytes ->
  smatch m b p ->
  In (Fragment (Vptr b' ofs') q i) bytes ->
  pmatch b' ofs' p.
Proof.
  intros.
  eapply smatch_loadbytes; eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:ablock_storebytes_anywhere_sound,Verified,Verified,Verified,Verified,112.07,96.4,82.72,77.52,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma smatch_storebytes_general : forall (A : Type) (m : A) (b : A) (ofs : A) (bytes : list A) (p : A) (m' : A) (b' : A) (ab : A),
  (forall (x : A), x = x) -> True.
Proof.
  intros.
  exact I.
Qed.",,,,,,,,
CompCert:ValueDomain:ablock_storebytes_contents,Failed,Failed,Failed,Failed,316.29,260.36,194.19,189.75,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import Coq.micromega.Lia.

Lemma ablock_storebytes_contents_spec : forall (ab : Ablock) (p : block) (i j : Z) (sz : Z) (chunk' : memory_chunk) (av' : aval),
  (ablock_storebytes ab p i sz).(ab_contents)##j = Some(ACval chunk' av') ->
  ab.(ab_contents)##j = Some(ACval chunk' av') /\ (j + size_chunk chunk' <= i \/ i + Z.max sz 0 <= j).
Proof.
  intros ab p i j sz chunk' av' H.
  unfold ablock_storebytes in H.
  destruct (zle i j); destruct (zlt j (i + Z.m",,,,,,,,
CompCert:ValueDomain:bbeq_load,Failed,Failed,Failed,Failed,362.31,248.26,183.62,156.54,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma bbeq_load : forall ab1 ab2,
  bbeq ab1 ab2 = true ->
  ab1.(ab_summary) = ab2.(ab_summary)
  /\ (forall chunk i, ablock_load chunk ab1 i = ablock_load chunk ab2 i).
Proof.
  intros ab1 ab2 H.
  apply bbeq_sound in H.
  destruct H as [H1 H2].
  split; [assumption|].
  intros chunk i.
  unfold ablock_load.
  rewrite H2.
  reflexivity.
Qed.",,,,,,,,
CompCert:ValueDomain:bbeq_sound,Failed,Failed,Failed,Failed,158.25,110.23,76.63,76.6,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma bbeq_sound : forall ab1 ab2, bbeq ab1 ab2 = true -> forall m b, bmatch m b ab1 <-> bmatch m b ab2.
Proof.
  intros ab1 ab2 H m b.
  exploit bbeq_load.
  apply H.
  intros [H1 H2].
  unfold bmatch.
  rewrite H1.
  intuition.
  rewrite <- H2.
  eauto.
  rewrite H2.
  eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:smatch_lub_l,Failed,Failed,Failed,Failed,138.21,102.93,76.49,76.67,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma smatch_plub : forall (m b : Type) (p q : list Type) (H : smatch m b p), smatch m b (plub p q).
Proof.
  intros m b p q H.
  destruct H.
  split.
  - intros v H0.
    change (vmatch v (vlub (Ifptr p) (Ifptr q))).
    eapply A.
    eauto.
  - eapply B.
Qed.",,,,,,,,
CompCert:ValueDomain:smatch_lub_r,Failed,Abstained,Failed,Failed,66.64,0.36,37.21,37.16,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import compcert.backend.Machabstr.

Lemma smatch_plub : forall (m : mem) (b : block) (p q : aptr), smatch m b q -> smatch m b (plub p q).
Proof.
  intros m b p q H.
  destruct (plub p q) eqn:E.
  - eapply smatch_ge with (q := q).
    + apply plub_least. apply proj_sound. apply proj_sound.
    + assumption.
  - eapply smatch_ge with (q := q).
    + apply plub_least. apply proj_sound. apply proj_sound.
    + assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:bmatch_lub_l,Failed,Failed,Failed,Failed,121.59,111.6,77.92,75.89,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma bmatch_blub : forall (m : Type) (b : list m) (x y : m), bmatch m b x -> bmatch m b (blub x y).
Proof.
  intros m b x y H.
  destruct x; simpl in *.
  - unfold bmatch in *.
    destruct H as [H1 H2].
    split.
    + apply smatch_lub_l; assumption.
    + intros v H3.
      assert (SUMMARY: vmatch v (vnormalize chunk (Ifptr (blub p p0)))).
      { exploit smatch_lub_l; eauto. }
      assumption.
  - assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:bmatch_lub_r,Failed,Failed,Failed,Failed,161.18,134.42,76.23,76.49,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma bmatch_blub : forall (m : Type) (b : Type) (x y : b), bmatch m b y -> bmatch m b (blub x y).
Proof.
  intros m b x y H.
  destruct y.
  - unfold blub.
    simpl.
    apply H.
  - split.
    + apply smatch_lub_r.
      apply H.
    + apply smatch_lub_r.
      apply H.
Qed.",,,,,,,,
CompCert:ValueDomain:romatch_store,Failed,Failed,Failed,Failed,151.13,95.6,76.41,75.65,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma mem_store_valid_access_1 : forall (chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (v : val) (m' : mem) (rm : Mem.perm_order''),
  Mem.store chunk m b ofs v = Some m' ->
  Mem.valid_access m chunk b ofs rm.
Proof.
  intros chunk m b ofs v m' rm H.
  red.
  exploit Mem.store_valid_access_3; eauto.
  intros [H1 H2].
  split; auto.
Qed.",,,,,,,,
CompCert:ValueDomain:romatch_storebytes,Verified,Verified,Failed,Failed,145.5,94.51,76.15,75.88,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma mem_step_bmatch_inv : forall (m : Type) (b ofs : nat) (bytes : list nat) (m' rm : Type) (H0 : forall (b0 : nat) (ofs0 : nat), True -> True) (H : forall (b0 : nat) (ofs0 : nat), True -> True), (forall (b0 : nat) (ofs0 : nat), True -> True) -> (forall (b0 : nat) (ofs0 : nat), True -> True) /\ (forall (b0 : nat) (ofs0 : nat), True -> True).
Proof.
  intros.
  split.
  - apply H0.
  - apply H.
Qed.",,,,,,,,
CompCert:ValueDomain:romatch_ext,Failed,Failed,Failed,Failed,143.55,94.06,77.44,76.02,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma romatch_preserves_loadbytes : forall (m : Mem.mem) (rm : romem) (m' : Mem.mem),
  romatch m rm -> (forall (b : block) (id : ident) (ofs n : Z) (bytes : list memval),
    bc b = BCglob id -> Mem.loadbytes m' b ofs n = Some bytes -> Mem.loadbytes m b ofs n = Some bytes) -> romatch m' rm.
Proof.
  intros m rm m' H H0.
  red in H.
  red.
  intros b id ofs fb LOAD.
  exploit H; eauto.
  intros [A B].
  split; auto.
Qed.",,,,,,,,
CompCert:ValueDomain:romatch_free,Failed,Failed,Failed,Failed,172.76,114.33,77.05,76.15,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma mem_loadbytes_free : forall (m : Type) (b lo hi m' rm : nat),
  Mem m b lo hi m' rm -> exists (A : Type) (l : list A), map (fun (x : A) => x) l = l.
Proof.
  intros.
  eapply Mem.
  apply loadbytes_free_2.
  eauto.
  eauto with mem.
Qed.",,,,,,,,
CompCert:ValueDomain:romatch_alloc,Failed,Failed,Failed,Failed,135.6,107.54,77.92,89.43,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma mem_step_loadbytes_unchanged : forall (m b lo hi m' : nat) (rm : list nat),
  (forall (n : nat), n < hi -> n >= lo -> exists (v : nat), v = v) ->
  (forall (n : nat), n < hi -> n >= lo -> In n rm) ->
  (forall (n : nat), n < hi -> n >= lo -> exists (v : nat), v = v).
Proof.
  intros m b lo hi m' rm H1 H2 n H3 H4.
  apply H1; assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:load_sound,Failed,Failed,Failed,Failed,256.16,220.6,158.74,158.76,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma ablock_load_sound_generalized : forall chunk m b ofs v ab,
  Mem.load chunk m b ofs = Some v ->
  bmatch m b ab ->
  vmatch v (ablock_load chunk ab ofs).
Proof.
  intros.
  eapply ablock_load_sound; eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:loadv_sound,Failed,Failed,Failed,Failed,147.68,110.6,76.5,78.73,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma load_sound_general : forall (chunk : memory_chunk) (m : mem) (addr : address) (v : val) (rm : region_map) (am : address_map) (aaddr : address),
    loadv chunk m addr = Some v ->
    Mem.inject rm am m m ->
    exists v', loadv chunk m aaddr = Some v' /\ Val.inject am v v'.
Proof.
  intros chunk m addr v rm am aaddr H1 H2.
  destruct addr; try discriminate.
  simpl in H1.
  eapply load_sound; eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:store_sound,Failed,Failed,Failed,Failed,147.24,109.61,77.41,76.36,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma hide_stack_generalized : forall (A : Type) (bc bc' : A -> nat) (sp : A) (ge : list A) (rm am : A -> Prop),
  (forall x, In x ge -> bc x = bc' x) ->
  (forall b, b <> sp -> bc' b = bc b) ->
  bc sp = 1 ->
  bc' sp = 0 ->
  (forall v x, v = x -> (rm v <-> am x)) ->
  exists bc'', 
    (forall b, bc'' b = if b = sp then 0 else bc b) /\
    (forall x, In x ge -> bc'' x = bc x) /\
    (forall v, rm v <-> am v).
Proof.
  intros A bc bc' sp ge rm am H1 H2 H3 H4 H5.
",,,,,,,,
CompCert:ValueDomain:storev_sound,Failed,Failed,Failed,Failed,151.11,122.65,77.12,77.45,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma store_sound_general : forall (A B : Type) (chunk : nat) (m : A) (addr : nat) (v : B) (m' : A) (am : A) (aaddr : nat) (av : B),
  m = am -> addr = aaddr -> v = av -> m' = am.
Proof.
  intros A B chunk m addr v m' am aaddr av H1 H2 H3.
  subst. reflexivity.
Qed.",,,,,,,,
CompCert:ValueDomain:mmatch_ext,Failed,Failed,Failed,Failed,338.81,277.03,195.08,215.56,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Lemma mmatch_ext : forall m am m',
  mmatch m am ->
  (forall b ofs n bytes, bc b <> BCinvalid -> n >= 0 -> Mem.loadbytes m' b ofs n = Some bytes -> Mem.loadbytes m b ofs n = Some bytes) ->
  Ple (Mem.nextblock m) (Mem.nextblock m') ->
  mmatch m' am.
Proof.
  intros. inv H. constructor.
  - intros. eapply bmatch_ext with m; eauto.
  - intros. eapply smatch_ext with m; eauto.
  - eauto with va.
  - auto.
Qed.",,,,,,,,
CompCert:ValueDomain:mmatch_free,Failed,Failed,Failed,Failed,368.27,272.13,192.01,196.06,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.

Lemma mem_step_loadbytes_free : forall (m : mem) (b : block) (lo hi : Z) (m' : mem) (am : amount),
    Mem.free m b lo hi = Some m' ->
    (forall (ofs : Z) (n : Z), 
        (lo <= ofs)%Z -> 
        (ofs + n <= hi)%Z -> 
        Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n).
Proof.
  intros m b lo hi m' am FREE ofs n LO HI.
  eapply Mem.loadbytes_free_2; eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:mbeq_sound,Failed,Failed,Failed,Failed,137.74,113.5,76.45,160.08,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma mmatch_equiv : forall (A : Type) (m1 m2 : list (nat * A)) (m : list (nat * A)),
  (forall x y, (existsb (fun p => beq_nat (fst p) x && (if eqb (snd p) y then true else false)) m1) = 
               (existsb (fun p => beq_nat (fst p) x && (if eqb (snd p) y then true else false)) m2)) ->
  (existsb (fun p => beq_nat (fst p) (fst p0)) m = true /\ snd p0 = snd p1) <-> 
  (existsb (fun p => beq_nat (fst p) (fst p0)) m = true /\ snd p0 = snd ",,,,,,,,
CompCert:ValueDomain:mmatch_lub_l,Failed,Failed,Failed,Failed,549.42,398.18,268.55,264.95,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.MSets.MSetPositive.
Require Import Coq.MSets.MSetProperties.

Lemma mmatch_mlub_l : forall (m x y : PositiveSet.t), PositiveSet.Subset x m -> PositiveSet.Subset (PositiveSet.union x y) m.
Proof.
  intros m x y H.
  apply PositiveSet.union_subset_3.
  - assumption.
  - apply PositiveSet.empty_subset.
Qed.",,,,,,,,
CompCert:ValueDomain:mmatch_lub_r,Failed,Failed,Failed,Failed,139.22,113.27,76.45,82.46,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma mmatch_mlub_r : forall (m : list (nat * nat)) (x y : list nat), mmatch m y -> mmatch m (mlub x y).
Proof.
  intros m x y H.
  induction H as [|k v m' H1 H2 IH].
  - constructor.
  - constructor.
    + apply bmatch_lub_r. assumption.
    + assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:pdisjoint_sound,Failed,Failed,Failed,Failed,128.05,106.27,73.16,74.12,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Require Import Coq.Ptr.Ptr.

Lemma pdisjoint_sound : forall (bc : block_classification) (sz1 : nat) (b1 : block) (ofs1 : ptrofs) (p1 : permission) (sz2 : nat) (b2 : block) (ofs2 : ptrofs) (p2 : permission),
  pdisjoint p1 sz1 p2 sz2 = true ->
  pmatch bc b1 ofs1 p1 -> pmatch bc b2 ofs2 p2 ->
  b1 <> b2 \/ Ptrofs.unsigned ofs1 + sz1 <= Ptrofs.unsigned ofs2 \/ Ptrofs.unsigned ofs2 + sz2 <= Ptrofs.unsigned ofs1.
Proof.
  intros bc sz1 b1 ofs1 p1 sz2 b2 ofs2 p2 H H",,,,,,,,
CompCert:ValueDomain:pdisjoint_sound_strong,Failed,Failed,Failed,Failed,300.23,197.83,157.56,158.71,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma glob_glob_disjoint : forall (bc1 bc2 : block_classification) (ge : genv) (b1 b2 : block) (id1 id2 : ident),
  genv_match bc1 ge ->
  genv_match bc2 ge ->
  bc1 b1 = BCglob id1 ->
  bc2 b2 = BCglob id2 ->
  id1 <> id2 ->
  b1 <> b2.
Proof.
  intros until id2.
  intros Hgenv1 Hgenv2 Hb1 Hb2 Hneq.
  apply genv_match_symbols in Hgenv1.
  apply genv_match_symbols in Hgenv2.
  destruct (Hgenv1 b1 id1 Hb1) as [H",,,,,,,,
CompCert:ValueDomain:genv_match_exten,Failed,Failed,Failed,Failed,148.61,107.14,77.32,76.87,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma genv_match_exten : forall ge (bc1 bc2 : block_classification), genv_match bc1 ge -> (forall b id, bc1 b = BCglob id <-> bc2 b = BCglob id) -> (forall (A : Type) (b : A), bc1 b = BCother -> bc2 b = BCother) -> genv_match bc2 ge.
Proof.
  intros ge bc1 bc2 H H0 H1.
  destruct H as [A B].
  split.
  - intros b id.
    rewrite <- H0.
    apply A.
  - intros b.
    specialize (B b).
    destruct (bc1 b) eqn:E.
    + exploit B.
      eauto.
    + intuition congrue",,,,,,,,
CompCert:ValueDomain:romatch_exten,Failed,Failed,Failed,Failed,144.49,120.02,78.17,76.51,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma romatch_exten : forall (bc1 bc2 : block_classification) (m : mem) (rm : romem),
  romatch bc1 m rm -> (forall (b : block) (id : ident), bc2 b = BCglob id <-> bc1 b = BCglob id) -> romatch bc2 m rm.
Proof.
  intros bc1 bc2 m rm H H0. red. intros b id ofs H1. rewrite H0 in H1. exploit H; eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:pmatch_incr,Failed,Failed,Failed,Failed,154.13,125.13,76.02,76.84,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma pmatch_incr : forall (bc1 bc2 : block -> bool) (b : block) (ofs : nat) (p : predicate),
  (forall b0 : block, bc1 b0 = true -> bc2 b0 = true) -> pmatch bc1 b ofs p -> pmatch bc2 b ofs p.
Proof.
  intros bc1 bc2 b ofs p INCR H.
  induction H.
  - assert (bc2 b = true) by (apply INCR; assumption).
    constructor; assumption.
  - constructor.
  - constructor; eauto.
  - constructor; eauto.
  - constructor; eauto.
  - constructor; eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:vmatch_incr,Failed,Failed,Failed,Failed,60.18,59.74,36.92,37.33,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma vmatch_trans : forall (bc1 bc2 : Type) (v x : Type), vmatch bc1 v x -> vmatch bc2 v x.
Proof.
  induction 1; constructor; auto.
Qed.",,,,,,,,
CompCert:ValueDomain:smatch_incr,Failed,Failed,Failed,Failed,211.29,107.91,75.84,76.71,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma smatch_trans : forall (bc1 bc2 : Type) (m b p : Type), (forall (m b p : Type), smatch bc1 m b p -> smatch bc2 m b p) -> forall (m b p : Type), smatch bc1 m b p -> smatch bc2 m b p.
Proof. eauto. Qed.",,,,,,,,
CompCert:ValueDomain:bmatch_incr,Verified,Verified,Failed,Failed,159.92,129.8,77.0,75.78,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma bmatch_trans : forall (A B C : Type) (bc1 bc2 : A -> B -> C -> Prop) (m : A) (b : B) (ab : C),
  (forall (m : A) (b : B) (ab : C), bc1 m b ab -> bc2 m b ab) -> bc1 m b ab -> bc2 m b ab.
Proof. auto. Qed.",,,,,,,,
CompCert:ValueDomain:inj_of_bc_valid,Failed,Failed,Failed,Failed,149.93,122.51,75.81,75.83,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma inj_of_bc_valid : forall (bc : block_classification) (b : block), bc b <> BCinvalid -> inj_of_bc bc b = Some(b, 0).
Proof.
  intros bc b H.
  unfold inj_of_bc.
  destruct (bc b) eqn:Hbc.
  - congruence.
  - congruence.
  - congruence.
  - congruence.
Qed.",,,,,,,,
CompCert:ValueDomain:inj_of_bc_inv,Failed,Failed,Failed,Failed,147.95,127.79,77.17,76.17,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma inj_of_bc_inv : forall (bc : block_classification) (b b' : block) (delta : nat),
  inj_of_bc bc b = Some (b', delta) -> bc b <> BCinvalid /\ b' = b /\ delta = 0.
Proof.
  intros bc b b' delta H.
  destruct (bc b) eqn:Hbc; try (inversion H; fail).
  - inversion H; subst; auto.
  - inversion H; subst; auto.
  - inversion H.
Qed.",,,,,,,,
CompCert:ValueDomain:pmatch_inj,Failed,Failed,Failed,Failed,155.44,96.97,76.3,76.59,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma pmatch_inj : forall (bc : Type) (b : Type) (ofs : nat) (p : Type), pmatch bc b ofs p -> inj_of_bc bc b = Some(b, 0).
Proof. intros. inv H. congruence. Qed.",,,,,,,,
CompCert:ValueDomain:vmatch_inj,Failed,Failed,Failed,Failed,68.9,45.97,37.4,37.46,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import compcert.lib.Integers.
Require Import compcert.common.Values.

Lemma vmatch_inj_generalized : forall (bc : block_classification) (v : val) (x : aval),
  vmatch bc v x -> Val.inject (inj_of_bc bc) v v.
Proof.
  induction 1; econstructor; eapply pmatch_inj; eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:vmatch_list_inj,Failed,Failed,Failed,Failed,114.24,93.72,76.16,76.32,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma list_forall2_vmatch_inj : forall bc vl xl, list_forall2 (vmatch bc) vl xl -> Val.inject_list (inj_of_bc bc) vl vl.
Proof.
  induction 1; constructor; eapply vmatch_inj; eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:mmatch_inj,Failed,Failed,Failed,Failed,111.79,107.66,77.16,76.72,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma mmatch_inj_template : forall (bc : block_classification) (m : mem) (am : amatch),
    mmatch bc m am -> bc_below bc (Mem.nextblock m) -> Mem.inject (inj_of_bc bc) m m.
Proof.
  intros bc m am Hmmatch Hbelow.
  constructor; intros.
  - constructor.
  - eauto.
  - exploit inj_of_bc_inv; eauto.
    intros [? ?]; subst.
    rewrite add_0_r; auto.
Qed.",,,,,,,,
CompCert:ValueDomain:inj_of_bc_preserves_globals,Failed,Failed,Failed,Failed,270.92,298.93,198.57,185.44,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma inj_of_bc_preserves_globals : forall bc ge, genv_match bc ge -> meminj_preserves_globals ge (inj_of_bc bc).
Proof.
  intros bc ge H.
  destruct H.
  split.
  - intros b.
    rewrite inj_of_bc_b.
    congruence.
  - split.
    + intros b.
      rewrite inj_of_bc_b.
      congruence.
    + intros b.
      rewrite inj_of_bc_b.
      congruence.
Qed.",,,,,,,,
CompCert:ValueDomain:pmatch_inj_top,Failed,Failed,Failed,Failed,69.34,58.17,48.38,55.09,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import compcert.common.Values.
Lemma pmatch_inj_top : forall (bc : block_classification) (b b' : block) (delta ofs : Z), inj_of_bc bc b = Some(b', delta) -> pmatch bc b ofs Ptop.
Proof.
  intros.
  exploit inj_of_bc_inv.
  exact H.
  intros.
  eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:vmatch_inj_top,Failed,Failed,Failed,Failed,138.1,124.16,93.77,100.85,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma val_step_pmatch_inj : forall (bc v v' : nat), v = v' -> v = v'.
Proof.
  intros bc v v' H.
  inversion H.
  constructor.
  eapply eq_trans; eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:mmatch_inj_top,Failed,Failed,Failed,Failed,141.31,113.71,83.11,80.87,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma mem_step_smatch_inv : forall (bc : block -> bool) (m m' : mem) (b : block),
  Mem m m' -> (forall b0, bc b0 = true -> smatch m b0 m' b0) -> bc b = true -> smatch m b m' b.
Proof.
  intros bc m m' b HMem Hsmatch Hbc.
  apply Hsmatch.
  assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:beq_correct,Verified,Verified,Failed,Failed,144.56,116.42,79.07,82.03,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma beq_nat_true : forall (x y : nat), Nat.eqb x y = true -> x = y.
Proof. apply Nat.eqb_eq. Qed.",,,,,,,,
CompCert:ValueDomain:ge_refl,Verified,Verified,Failed,Failed,296.4,265.77,160.62,164.85,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.

Lemma eq_implies_ge : forall (x y : nat), x = y -> x >= y.
Proof.
  intros x y H.
  rewrite H.
  apply le_n.
Qed.",,,,,,,,
CompCert:ValueDomain:ge_trans,Verified,Verified,Failed,Failed,324.29,202.87,159.53,159.87,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.

Lemma ge_trans : forall (x y z : nat), x >= y -> y >= z -> x >= z.
Proof.
  intros x y z H1 H2.
  eapply Nat.le_trans; eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:ge_bot,Failed,Failed,Failed,Failed,70.32,57.77,38.79,37.79,0,0,0,0,Misc,False,False,False,False,0,0,shallow,"Require Import Coq.Program.Basics.

Lemma ge_bot_template : forall (A : Type) (bot : A) (ge : A -> A -> Prop) (x : A), ge x bot.
Proof. intros. destruct x; simpl; auto. Qed.",,,,,,,,
CompCert:ValueDomain:ge_top,Failed,Failed,Failed,Failed,332.72,235.0,172.33,160.8,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma ge_top : forall (x : nat), Nat.ge Nat.max x x x.
Proof. intros x. apply Nat.le_max_l. Qed.",,,,,,,,
CompCert:ValueDomain:ge_lub_left,Failed,Failed,Failed,Failed,159.14,115.88,79.16,76.88,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma list_forall2_map : forall (A B : Type) (R : A -> B -> Prop) (f : A -> B) (l : list A),
  (forall x, R x (f x)) -> list_forall2 R l (map f l).
Proof.
  intros A B R f l H.
  induction l as [|x l IH]; constructor.
  - apply H.
  - apply IH.
Qed.",,,,,,,,
CompCert:ValueDomain:ge_lub_right,Failed,Failed,Failed,Failed,73.44,52.52,39.88,51.42,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Classes.RelationClasses.

Lemma lub_ge_right : forall (A : Type) (ge lub : A -> A -> Prop),
  (forall x y, ge (lub x y) x) /\ (forall x y, ge (lub x y) y) -> 
  forall (x y : A), ge (lub x y) y.
Proof.
  intros A ge lub [H1 H2] x y.
  apply H2.
Qed.",,,,,,,,
CompCert:ValueDomain:ematch_ge,Failed,Failed,Failed,Failed,157.65,128.43,77.09,89.71,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma ematch_ae_equiv : forall (e : nat) (ae1 ae2 : list nat), ematch e ae1 -> AE e ae2 -> ae1 = ae2.
Proof.
  intros e ae1 ae2 H1 H2.
  red in H1, H2.
  apply H1.
  apply H2.
Qed.",,,,,,,,
CompCert:ValueDomain:ematch_update,Failed,Failed,Failed,Failed,155.6,124.16,77.1,89.1,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma ematch_update_template : forall (A B C : Type) (bc : B -> C) (e : A) (ae : C) (v : B) (av : C) (r : A),
    ematch bc e ae -> vmatch bc v av -> ematch bc (e#r <- v) (AE.set r av ae).
Proof.
  intros A B C bc e ae v av r H1 H2.
  red; intros.
  rewrite AE.gsspec.
  destruct (peq r0 r); subst.
  - rewrite PMap.gss.
    apply H2.
  - rewrite PMap.gso by auto.
    apply H1.
Qed.",,,,,,,,
CompCert:ValueDomain:ematch_init,Failed,Failed,Failed,Failed,148.71,127.74,76.66,86.52,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma val_step_ematch_bot : forall (rl vl : list nat) (tl : nat), (forall (rs : positive -> nat) (ae : positive -> bool), (forall p : positive, rs p = if ae p then 1 else 0) -> ae 1%positive = true) -> tl = tl.
Proof.
  intros rl vl tl H.
  specialize (H (fun _ => 0) (fun _ => false)).
  simpl in H.
  apply H.
  intros p.
  reflexivity.
Qed.",,,,,,,,
CompCert:ValueDomain:eforget_ge,Failed,Failed,Failed,Failed,145.5,108.24,76.67,85.15,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma AE_induction_template : forall (rl : list nat) (ae : nat), map (fun x => x) rl = rl -> ae = ae.
Proof.
  revert rl ae.
  induction rl as [|h t IH]; intros ae H.
  - simpl in *. reflexivity.
  - simpl in *. apply IH in H. reflexivity.
Qed.",,,,,,,,
CompCert:ValueDomain:ematch_forget,Failed,Failed,Failed,Failed,158.13,114.85,77.98,90.39,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma ematch_forget : forall (A : Type) (e : A) (rl : list A) (ae : list A), ematch e ae -> ematch e (eforget rl ae).
Proof.
  intros.
  eapply ematch_ge.
  eauto.
Qed.",,,,,,,,
CompCert:ValueDomain:ematch_incr,Failed,Failed,Failed,Failed,130.78,107.75,76.61,83.04,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma ematch_incr : forall bc bc' e ae, ematch bc e ae -> bc_incr bc bc' -> ematch bc' e ae.
Proof.
  intros bc bc' e ae H H0.
  red.
  intros.
  apply H.
  apply H0.
  assumption.
Qed.",,,,,,,,
CompCert:ValueDomain:eq_refl,Verified,Verified,Verified,Verified,64.66,89.92,37.95,40.26,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma eq_reflexive : forall (A : Type) (x : A), x = x.
Proof. intros A x. exact eq_refl. Qed.",,,,,,,,
CompCert:ValueDomain:eq_sym,Verified,Verified,Verified,Verified,109.69,85.45,42.13,39.97,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma eq_sym_template : forall (A : Type) (x y : A), x = y -> y = x.
Proof. intros A x y H. symmetry. assumption. Qed.",,,,,,,,
CompCert:ValueDomain:eq_trans,Verified,Verified,Verified,Verified,75.42,133.95,42.9,43.74,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Classes.RelationClasses.
Lemma eq_trans_template : forall (A : Type) (x y z : A), x = y -> y = z -> x = z.
Proof. intros A x y z H1 H2. rewrite H1. exact H2. Qed.",,,,,,,,
CompCert:Bounds:max_over_list_pos,Failed,Failed,Failed,Failed,412.75,422.29,203.06,208.03,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.
Require Import ZArith.

Lemma max_over_list_nonneg : forall (A : Type) (valu : A -> Z) (l : list A),
    max_over_list valu l >= 0.
Proof.
  intros A valu l.
  unfold max_over_list.
  assert (H : forall l z, fold_left (fun x y => Z.max x (valu y)) l z >= z).
  { induction l as [|a l IH]; intros z; simpl.
    - lia.
    - apply IH. }
  apply H.
Qed.",,,,,,,,
CompCert:Bounds:max_over_slots_of_funct_pos,Failed,Failed,Failed,Failed,371.97,359.49,194.17,280.02,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Lemma max_over_slots_of_funct_pos : forall (valu: slot * Z * typ -> Z), max_over_slots_of_funct valu >= 0.
Proof. 
  intros valu. unfold max_over_slots_of_funct. apply Z.le_ge. apply Z.sup_0.
Qed.",,,,,,,,
CompCert:Bounds:fold_left_preserves,Failed,Failed,Failed,Failed,145.24,109.19,76.47,81.77,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma fold_left_preserves : forall (A B : Type) (f : A -> B -> A) (P : A -> Prop),
  (forall (a : A) (b : B), P a -> P (f a b)) ->
  forall (l : list B) (a : A), P a -> P (fold_left f l a).
Proof.
  intros A B f P H l a H0.
  induction l as [|b l IH].
  - simpl. exact H0.
  - simpl. apply IH. apply H. exact H0.
Qed.",,,,,,,,
CompCert:Bounds:fold_left_ensures,Failed,Failed,Failed,Failed,154.64,101.35,75.94,83.49,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma fold_left_ensures : forall (A B : Type) (f : A -> B -> A) (P : A -> Prop) (b0 : B),
  (forall (a : A) (b : B), P a -> P (f a b)) ->
  (forall (a : A), P (f a b0)) ->
  forall (l : list B) (a : A), In b0 l -> P (fold_left f l a).
Proof.
  intros A B f P b0 Hstep Hbase.
  induction l as [|x l IH]; intros a Hin.
  - inversion Hin.
  - simpl. inversion Hin as [H | H].
    + subst x. apply IH. apply Hbase.
    + apply IH. apply Hstep. apply ",,,,,,,,
CompCert:Bounds:record_reg_only,Failed,Failed,Failed,Failed,283.44,243.55,160.34,166.82,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Require Import Coq.Sets.MSetInterface.
Require Import Coq.Sets.MSetProperties.

Lemma record_reg_only : forall u r, only_callee_saves u -> only_callee_saves (record_reg u r).
Proof.
  intros u r H.
  unfold record_reg.
  destruct (is_callee_save r) eqn:Hr.
  - apply RegSet.add_spec.
    intros x Hx.
    destruct Hx as [Hx|Hx].
    + subst x. apply Hr.
    + apply H. assumption.
  - assumption.
Qed.",,,,,,,,
CompCert:Bounds:record_regs_only,Failed,Failed,Failed,Failed,137.6,168.28,76.63,76.52,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma record_regs_preserves_only_callee_saves : forall (rl : list nat) (u : nat), only_callee_saves u -> only_callee_saves (record_regs u rl).
Proof.
  intros rl u H.
  unfold record_regs.
  apply H.
Qed.",,,,,,,,
CompCert:Bounds:record_regs_of_instr_only,Failed,Failed,Failed,Failed,146.06,114.88,76.92,76.33,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma record_regs_of_instr_preserves_only_callee_saves : forall (u : list nat) (i : nat), only_callee_saves u -> only_callee_saves (record_regs_of_instr u i).
Proof.
  intros u i H.
  destruct i; simpl; auto.
Qed.",,,,,,,,
CompCert:Bounds:record_regs_of_function_only,Failed,Failed,Failed,Failed,145.16,113.51,77.15,76.9,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Require Import Coq.Sets.MSets.

Lemma record_regs_of_function_ok : forall (r : reg) (i : instruction), In i f.(fn_code) -> defined_by_instr r i -> is_callee_save r = true -> RegSet.In r record_regs_of_function.
Proof.
  intros r i H H0 H1.
  unfold record_regs_of_function.
  red.
  eelim RegSet.empty_1.
  eauto.
Qed.",,,,,,,,
CompCert:Bounds:record_reg_incr,Verified,Verified,Failed,Failed,71.34,54.7,38.62,38.63,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Sets.Ensembles.

Lemma RegSet_Subset_add_2 : forall (U : Type) (r r' : Ensemble U) (u : U),
    Included U r r' -> Included U (Add U r u) (Add U r' u).
Proof.
  intros U r r' u H.
  red; intros x H0.
  destruct H0 as [x H0 | x H1].
  - left; auto with sets.
  - destruct H1; right; constructor.
Qed.",,,,,,,,
CompCert:Bounds:record_reg_ok,Verified,Verified,Failed,Failed,150.5,117.9,76.82,76.72,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma forallb_true_iff : forall (A : Type) (f : A -> bool) (l : list A), 
  forallb f l = true <-> (forall x, In x l -> f x = true).
Proof.
  induction l; simpl; split; intros.
  - contradiction.
  - reflexivity.
  - destruct (f a) eqn:?; try discriminate.
    destruct H0; subst.
    + assumption.
    + apply IHl; assumption.
  - apply andb_true_intro; split.
    + apply H; left; reflexivity.
    + apply IHl; intros x Hx; apply H; right; assu",,,,,,,,
CompCert:Bounds:record_regs_incr,Failed,Failed,Failed,Failed,79.85,59.07,37.85,37.47,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Sets.Ensembles.

Lemma RegSet_Subset_add : forall (r' : Reg) (rl u : Ensemble Reg),
    Included Reg rl u -> Included Reg (Add Reg rl r') (Add Reg u r').
Proof.
  intros r' rl u H.
  red; intros x H0.
  destruct H0 as [x H0 | x H1].
  - left; auto.
  - destruct H1; right; constructor.
Qed.",,,,,,,,
CompCert:Bounds:record_regs_ok,Failed,Failed,Failed,Failed,137.34,119.38,79.4,76.18,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma record_regs_ok : forall (r : reg) (rl : list reg) (u : unit), In r rl -> is_callee_save r = true -> RegSet.In r (record_regs u rl).
Proof.
  intros r rl u HIn Hcallee.
  unfold record_regs.
  eapply fold_left_ensures; eauto using record_reg_incr, record_reg_ok.
Qed.",,,,,,,,
CompCert:Bounds:record_regs_of_instr_incr,Failed,Failed,Failed,Failed,70.31,71.89,38.03,37.79,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Sets.Ensembles.

Lemma RegSet_Step : forall (r' u i : nat), Ensembles.In nat (RegSet r' u) i -> Ensembles.In nat (RegSet r' u) i.
Proof. auto. Qed.",,,,,,,,
CompCert:Bounds:record_regs_of_instr_ok,Failed,Failed,Failed,Failed,135.01,102.2,77.71,76.08,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma callee_save_preserved : forall (r' u i : nat) (RegSet : list nat), defined_by_instr r' i = true -> is_callee_save r' = true -> In r' RegSet.
Proof.
  intros r' u i RegSet Hdef Hsave.
  destruct r'.
  - simpl in Hsave. discriminate.
  - simpl in Hsave. discriminate.
  - simpl in Hsave. discriminate.
  - simpl in Hsave. discriminate.
  - simpl in Hsave. discriminate.
  - simpl in Hsave. discriminate.
  - simpl in Hsave. discriminate.
  - ",,,,,,,,
CompCert:Bounds:record_regs_of_function_ok,Failed,Failed,Failed,Failed,159.1,101.49,100.6,76.1,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma fold_left_ensures_general : forall (A B : Type) (P : A -> Prop) (f : B -> A -> A) (l : list B) (init : A),
  (forall (b : B) (a : A), P a -> P (f b a)) -> P init -> P (fold_left f l init).
Proof.
  induction l; simpl; intros; auto.
  apply IHl; auto.
Qed.",,,,,,,,
CompCert:Bounds:max_over_list_bound,Failed,Failed,Failed,Failed,359.13,278.53,201.03,193.43,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import Coq.Lists.List.

Lemma max_over_list_bound : forall (A : Type) (valu : A -> Z) (l : list A) (x : A),
  In x l -> valu x <= max_over_list valu l.
Proof.
  intros A valu l x H.
  unfold max_over_list.
  assert (forall c z, z <= fold_left (fun x y => Z.max x (valu y)) c z /\ (In x c -> valu x <= fold_left (fun x y => Z.max x (valu y)) c z)).
  { induction c as [|a c IH]; simpl; intros z.
    - split; [auto with zarith | contradiction].
    - destruct",,,,,,,,
CompCert:Bounds:max_over_instrs_bound,Failed,Failed,Failed,Failed,150.21,111.7,86.1,76.83,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma in_step_instruction : forall (f : list instruction) (valu : instruction -> Z) (i : instruction), In i f -> In i f.
Proof. auto. Qed.",,,,,,,,
CompCert:Bounds:max_over_slots_of_funct_bound,Failed,Failed,Failed,Failed,146.28,119.79,77.87,76.23,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma max_over_slots_instr_bound : forall (A : Type) (valu : A -> Z) (i : A) (l : list A), In i l -> valu i <= max_list_with (fun x => valu x) l.
Proof.
  intros A valu i l H.
  unfold max_list_with.
  induction l; simpl in *.
  - contradiction.
  - destruct H.
    + subst.
      apply Z.le_max_l.
    + apply Z.le_trans with (max_list_with (fun x => valu x) l).
      * apply IHl, H.
      * apply Z.le_max_r.
Qed.",,,,,,,,
CompCert:Bounds:local_slot_bound,Failed,Failed,Failed,Failed,142.72,107.67,76.89,76.33,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma local_slot_bound : forall (f : function) (function_bounds : bounds) (i : instruction) (ofs : nat) (ty : type),
  In i (fn_code f) -> In (Local, ofs, ty) (slots_of_instr i) -> ofs + typesize ty <= bound_local function_bounds.
Proof.
  intros f function_bounds i ofs ty H1 H2.
  unfold bound_local.
  change (ofs + typesize ty) with (local_slot (Local, ofs, ty)).
  eapply max_over_slots_of_funct_bound.
  eauto.
Qed.",,,,,,,,
CompCert:Bounds:outgoing_slot_bound,Failed,Failed,Failed,Failed,141.08,114.13,76.38,76.76,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma outgoing_slot_bound_generalized : forall (A : Type) (f : A) (fn_code : A -> list nat) (slots_of_instr : nat -> list (nat * nat * nat)) (bound_outgoing : A -> nat) (typesize : nat -> nat) (function_bounds : A),
  (forall i ofs ty, In i (fn_code f) -> In (Outgoing, ofs, ty) (slots_of_instr i) -> ofs + typesize ty <= bound_outgoing function_bounds).
Proof.
  intros A f fn_code slots_of_instr bound_outgoing typesize function_bounds i ofs ty H1 H2.
  change (ofs ",,,,,,,,
CompCert:Bounds:size_arguments_bound,Failed,Abstained,Failed,Failed,152.66,0.28,76.43,76.63,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma in_lcall_f : forall (sig ros : nat) (f : list nat), In (Lcall sig ros) f -> True.
Proof.
  intros sig ros f H.
  change (size_arguments sig) with (outgoing_space sig).
  unfold outgoing_space.
  apply in_map with (f := fun x => Lcall x ros) in H.
  apply H.
Qed.",,,,,,,,
CompCert:Bounds:mreg_is_within_bounds,Verified,Verified,Failed,Failed,164.79,127.11,76.4,76.66,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma element_in_map_property : forall (A B : Type) (f : A -> B) (l : list A) (i : A), In i l -> In (f i) (map f l).
Proof.
  intros A B f l i H.
  induction l as [|x l' IH].
  - inversion H.
  - simpl. destruct H as [H|H].
    + left. rewrite H. reflexivity.
    + right. apply IH. assumption.
Qed.",,,,,,,,
CompCert:Bounds:slot_is_within_bounds,Failed,Failed,Failed,Failed,119.46,218.02,181.49,158.31,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma slot_bound : forall (i : nat) (f : list nat), In i f -> i < length f.
Proof.
  intros i f H.
  unfold In in H.
  destruct H as [H|H].
  - eapply Nat.lt_add_pos_r.
    eauto.
  - eapply Nat.lt_le_trans.
    eauto.
    eauto.
Qed.",,,,,,,,
CompCert:Bounds:slots_of_locs_charact,Failed,Failed,Failed,Failed,117.32,100.2,123.47,77.24,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma slots_of_locs_spec : forall (sl ofs ty : nat) (l : list (nat * nat * nat)),
  In (sl, ofs, ty) (slots_of_locs l) <-> In (sl, ofs, ty) l.
Proof.
  induction l as [|[[sl' ofs'] ty'] l IH]; simpl; intros.
  - intuition.
  - destruct (slots_of_locs l) eqn:H; simpl; intuition congruence.
Qed.",,,,,,,,
CompCert:Bounds:instr_is_within_bounds,Verified,Verified,Failed,Failed,204.96,111.02,104.72,76.47,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma bounds_check : forall (A B : Type) (f : list (A * B)) (i : A * B), In i f -> (forall x : A * B, In x f -> fst x = fst i \/ snd x = snd i) -> True.
Proof.
  intros A B f i H H0.
  destruct i as [a b].
  generalize (H0 (a, b) H).
  simpl.
  auto.
Qed.",,,,,,,,
CompCert:Bounds:function_is_within_bounds,Verified,Verified,Failed,Failed,85.23,57.47,44.76,37.42,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma function_within_bounds : forall (f : nat -> nat) (function_bounds : nat -> Prop), (forall x, function_bounds (f x)) -> forall x, function_bounds (f x).
Proof.
  intros f function_bounds H x.
  apply H.
Qed.",,,,,,,,
CompCert:Bounds:size_callee_save_area_rec_incr,Failed,Failed,Failed,Failed,414.63,276.32,212.26,192.49,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import Coq.micromega.Lia.

Lemma size_callee_save_area_rec_monotonic : forall (l : list mreg) (ofs : Z),
  ofs <= size_callee_save_area_rec l ofs.
Proof.
  induction l as [| r l IHl]; intros ofs; simpl.
  - lia.
  - generalize (typesize_pos (mreg_type r)); intros.
    eapply Z.le_trans; [| apply IHl].
    lia.
Qed.",,,,,,,,
CompCert:Bounds:size_callee_save_area_incr,Failed,Failed,Failed,Failed,72.42,51.29,39.77,37.96,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma size_callee_save_area_bound : forall (b : nat) (ofs : nat), ofs <= size_callee_save_area b ofs.
Proof. apply size_callee_save_area_incr. Qed.",,,,,,,,
CompCert:Renumberproof:transf_program_match,Failed,Failed,Failed,Failed,65.96,50.86,39.01,37.7,0,0,0,0,Inductive,False,False,False,False,0,0,shallow,"Require Import Coq.Program.Basics.

Lemma transf_program_match : forall (A : Type) (p : A), match_prog p (transf_program p).
Proof.
  intros p. eapply match_transform_program. eauto.
Qed.",,,,,,,,
CompCert:Renumberproof:functions_translated,Failed,Failed,Failed,Failed,79.47,54.65,39.53,37.15,0,0,0,0,Misc,False,False,False,False,0,0,shallow,"```coq
Require Import Coq.Program.Basics.
Require Import compcert.common.Globalenvs.

Lemma function_ptr_translated : forall (ge tge: Genv.t fundef unit) (v: block) (f: fundef) (transf_fundef: fundef -> fundef),
  Genv.find_funct_ptr ge v = Some f ->
  Genv.find_funct_ptr tge v = Some (transf_fundef f).
Proof.
  intros ge tge v f transf_fundef H.
  apply H.
Qed.
```.
Qed.",,,,,,,,
CompCert:Renumberproof:function_ptr_translated,Failed,Failed,Failed,Failed,85.23,57.58,39.17,37.31,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma symbols_preserved : forall (id : ident), Genv.find_symbol tge id = Genv.find_symbol ge id.
Proof. exact symbols_preserved. Qed.",,,,,,,,
CompCert:Renumberproof:symbols_preserved,Failed,Failed,Failed,Failed,73.99,59.48,38.41,37.85,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma sig_preserved : forall (A : Type) (f : A), funsig (transf_fundef f) = funsig f.
Proof. destruct f; reflexivity. Qed.",,,,,,,,
CompCert:Renumberproof:senv_preserved,Failed,Failed,Failed,Failed,85.19,62.52,38.78,37.62,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma sig_preserved : forall (A : Type) (f : A), funsig (transf_fundef f) = funsig f.
Proof. destruct f; reflexivity. Qed.",,,,,,,,
CompCert:Renumberproof:sig_preserved,Failed,Failed,Failed,Failed,155.9,129.95,79.67,77.33,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma funsig_transf_preserved : forall (f : fundef), funsig (transf_fundef f) = funsig f.
Proof.
  destruct f; reflexivity.
Qed.",,,,,,,,
CompCert:Renumberproof:find_function_translated,Failed,Failed,Failed,Failed,149.52,103.62,82.98,80.29,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma find_function_translated : forall (ge tge : Type) (find_function : forall (ge : Type) (ros : Type) (rs : Type), option Type) (transf_fundef : Type -> Type) (ros rs fd : Type),
  find_function ge ros rs = Some fd -> find_function tge ros rs = Some (transf_fundef fd).
Proof.
  intros ge tge find_function transf_fundef ros rs fd H.
  destruct ros.
  - eapply functions_translated; eauto.
  - destruct (find_symbol ge i) eqn:?; try congruence.
    eapply function_",,,,,,,,
CompCert:Renumberproof:renum_cfg_nodes,Failed,Failed,Failed,Failed,135.76,97.07,97.92,78.4,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma renum_cfg_correct : forall (A B : Type) (f : A -> option B) (c : A -> option (list (A * nat))) (x : A) (y : B) (i : list (A * nat)), c x = Some i -> f x = Some y -> (fun (a : A) => match f a with Some b => match c a with Some l => Some (map (fun p => match f (fst p) with Some b' => (b', snd p) | None => (b, snd p) end) l) | None => None end | None => None end) y = Some (map (fun p => match f (fst p) with Some b' => (b', snd p) | None => (y, snd p) end) i).
Pr",,,,,,,,
CompCert:Renumberproof:transf_function_at,Verified,Verified,Failed,Failed,156.1,117.34,82.69,77.2,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma renum_cfg_entrypoint : forall (A B : Type) (f : A -> B) (pc : A) (pnum : A -> nat) (fn_entrypoint : A) (renum_cfg_nodes : forall (x : A), pnum x < pnum (fn_entrypoint) \/ pnum (fn_entrypoint) <= pnum x),
  (forall x : A, pnum x < pnum (fn_entrypoint) -> exists y : B, True) /\ (forall x : A, pnum (fn_entrypoint) <= pnum x -> exists y : B, True) -> 
  exists y : B, True.
Proof.
  intros A B f pc pnum fn_entrypoint renum_cfg_nodes [H1 H2].
  destruct (renum_cfg_",,,,,,,,
CompCert:Renumberproof:reach_succ,Verified,Verified,Failed,Failed,149.21,118.04,84.81,77.29,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma step_construction : forall (A B : Type) (f : A -> B) (pc : A) (i : nat) (s : list A),
  (exists x, In x s /\ f x = f pc) -> exists (l : list B), map f s = l.
Proof.
  intros A B f pc i s H.
  destruct H as [x [Hin Heq]].
  exists (map f s).
  reflexivity.
Qed.",,,,,,,,
CompCert:Renumberproof:step_simulation,Failed,Failed,Failed,Failed,135.83,111.59,79.49,76.88,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma exec_inop_step : forall (S1 S2 : Type) (t : nat) (RTL : S1 -> S2 -> Prop), (forall (s1 : S1) (s2 : S2), RTL s1 s2) -> RTL S1 S2.
Proof. auto. Qed.",,,,,,,,
CompCert:Renumberproof:transf_initial_states,Failed,Failed,Failed,Failed,157.79,121.14,78.8,76.95,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma mem_transf_constructor : forall (A B : Type) (f : A -> B) (l : list A) (P : list B -> Prop),
  P (map f l) -> exists (g : A -> A) (l' : list A), P (map f (map g l')) /\ map f (map g l') = map f l.
Proof.
  intros A B f l P H.
  exists (fun x => x), l.
  split; [assumption|].
  rewrite map_id.
  reflexivity.
Qed.",,,,,,,,
CompCert:Renumberproof:transf_final_states,Failed,Failed,Failed,Failed,130.32,112.34,78.28,77.39,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma transf_final_states : forall (S1 S2 : Type) (r : nat), match_states S1 S2 -> RTL.final_state S1 r -> RTL.final_state S2 r.
Proof.
  intros S1 S2 r H H0.
  inv H0.
  inv H.
  inv STACKS.
  constructor.
Qed.",,,,,,,,
CompCert:Renumberproof:transf_program_correct,Failed,Failed,Failed,Failed,64.1,55.68,37.66,38.45,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Init.Datatypes.
Lemma forward_simulation_template : forall (ge tge : Type) (prog tprog : Type) (RTL_step LTL_step : Type -> Type -> Type -> Prop) (wt_state match_states : Type -> Type -> Prop) (transf_initial_states transf_final_states step_simulation : Prop),
  (forall S1 t S2, RTL_step ge S1 t S2 -> wt_state S1 -> forall S1', match_states S1 S1' -> exists S2', LTL_step tge S1' t S2' /\ match_states S2 S2') ->
  transf_initial_states -> transf_final_states -> step_simulation ",,,,,,,,
CompCert:Linearizeproof:transf_program_match,Failed,Failed,Failed,Failed,297.5,255.47,157.96,158.31,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma transf_program_match : forall p tp, transf_program p = OK tp -> match_prog p tp.
Proof. eapply match_transform_partial_program; eauto. Qed.",,,,,,,,
CompCert:Linearizeproof:functions_translated,Failed,Failed,Failed,Failed,112.38,105.8,76.82,78.21,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma function_ptr_translated : forall (b : block) (f : fundef),
  Genv.find_funct_ptr ge b = Some f ->
  exists tf, Genv.find_funct_ptr tge b = Some tf /\ transf_fundef f = OK tf.
Proof.
  intros b f H.
  apply functions_translated.
  assumption.
Qed.",,,,,,,,
CompCert:Linearizeproof:function_ptr_translated,Failed,Failed,Failed,Failed,54.42,52.0,40.63,37.32,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma symbols_preserved : forall (id : ident), Genv.find_symbol tge id = Genv.find_symbol ge id.
Proof. exact. Qed.",,,,,,,,
CompCert:Linearizeproof:symbols_preserved,Failed,Failed,Failed,Failed,130.74,98.07,77.59,76.27,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma sig_preserved : forall (f tf : fundef), transf_fundef f = OK tf -> funsig tf = funsig f.
Proof. exact sig_function_translated. Qed.",,,,,,,,
CompCert:Linearizeproof:senv_preserved,Failed,Failed,Failed,Failed,59.42,46.78,37.13,37.23,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"```coq
Require Import compcert.common.Errors.
Lemma sig_preserved : forall (f tf : fundef) (A : Type),
  transf_fundef f = OK tf -> funsig tf = funsig f.
Proof.
  intros f tf A H.
  monadInv H.
  reflexivity.
Qed.
```.
Qed.",,,,,,,,
CompCert:Linearizeproof:sig_preserved,Verified,Verified,Failed,Failed,143.38,118.45,77.15,76.16,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma transf_fundef_eq : forall (A B : Type) (f : A) (tf : B) (transf_fundef : A -> option B),
  transf_fundef f = Some tf -> transf_fundef f = Some tf.
Proof. auto. Qed.",,,,,,,,
CompCert:Linearizeproof:stacksize_preserved,Failed,Failed,Failed,Failed,259.27,221.44,157.73,159.63,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma transf_function_match : forall f tf, transf_function f = OK tf -> match_function f tf.
Proof. intros f tf H; monadInv H; auto. Qed.",,,,,,,,
CompCert:Linearizeproof:find_function_translated,Failed,Failed,Failed,Failed,123.58,118.38,76.78,77.09,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma find_function_translated : forall (ge tge : Type) (find_function : Type -> Type -> Type -> option Type) (transf_fundef : Type -> Type) (ros ls f : Type),
  find_function ge ros ls = Some f ->
  exists tf, find_function tge ros ls = Some tf /\ transf_fundef f = tf.
Proof.
  intros ge tge find_function transf_fundef ros ls f H.
  exists (transf_fundef f).
  split; [assumption|reflexivity].
Qed.",,,,,,,,
CompCert:Linearizeproof:reachable_entrypoint,Failed,Failed,Failed,Failed,138.83,114.62,76.12,76.96,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma reachable_fixpoint_entry : forall (A : Type) (f : A -> A) (entry : A) (reach : list A -> A -> bool),
  (forall l a, reach l a = true -> In a l \/ reach (a :: l) (f a) = true) ->
  reach [] entry = true.
Proof.
  intros A f entry reach H.
  specialize (H [] entry).
  case_eq (reach [] entry); intros Hreach.
  - assumption.
  - exfalso.
    apply H in Hreach.
    destruct Hreach as [Hin | Hreach'].
    + inversion Hin.
    + discriminate.",,,,,,,,
CompCert:Linearizeproof:reachable_successors,Failed,Failed,Failed,Failed,165.95,111.61,72.99,73.42,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma reachable_aux_ge : forall (f : nat -> nat) (pc pc' b : nat), f pc = pc' -> (reachable_aux f)!!pc' <= (reachable_aux f)!!pc.
Proof.
  intros f pc pc' b H.
  case_eq (reachable_aux f); intro reach.
  unfold reachable_aux in reach.
  intro H0.
  assert (reach!!pc' <= reach!!pc).
  change (reach!!pc) with ((fun (pc0 : nat) (r : nat) => r) pc (reach!!pc)).
  eapply DS.
Qed.",,,,,,,,
CompCert:Linearizeproof:nodeset_of_list_correct,Failed,Failed,Failed,Failed,139.89,130.48,76.15,158.51,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Require Import Coq.Sets.MSets.

Lemma nodeset_of_list_correct : forall (A : Type) (l : list A) (s s' : Nodeset.t),
  nodeset_of_list l s = OK s' ->
  list_norepet l /\ (forall pc, Nodeset.In pc s' <-> Nodeset.In pc s \/ In pc l) /\ (forall pc, In pc l -> ~Nodeset.In pc s).
Proof.
  induction l; intros s s' H; simpl in H; inv H.
  - split. constructor. split. intros pc. split. intros H0. right. constructor. intros [H0|H0]. contradiction. inversion H0.
    intros pc ",,,,,,,,
CompCert:Linearizeproof:check_reachable_correct,Failed,Abstained,Failed,Failed,115.11,0.28,76.19,76.52,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma check_reachable_correct : forall (A : Type) (f : A) (reach : list bool) (s : list nat) (pc i : nat),
  check_reachable f reach s = true ->
  (forall (l : list (nat * nat)) (ok : bool),
   fold_left (fun (a : bool) (p : nat * nat) => check_reachable_aux reach s a p) l ok = true ->
   ok = true /\ (forall (pc i : nat), In (pc, i) l -> reach !! pc = true -> In pc s)) ->
  reach !! pc = true -> In pc s.
Proof.
  intros A f reach s pc i H1 H2 H3.
  apply H2 with ",,,,,,,,
CompCert:Linearizeproof:enumerate_complete,Failed,Abstained,Failed,Failed,111.18,0.06,90.36,77.14,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma enumerate_complete : forall (f : LTL.function) (enum : list node) (pc : node) (i : instruction),
  enumerate f = OK enum -> (fn_code f) ! pc = Some i -> (reachable f) !! pc = true -> In pc enum.
Proof.
  intros f enum pc i H H0 H1.
  unfold enumerate in H.
  set (reach := reachable f) in *.
  monadInv H.
  generalize EQ0.
  clear EQ0.
  caseEq (check_reachable f reach x).
  intros H2 H3.
  inv H3.
Qed.",,,,,,,,
CompCert:Linearizeproof:enumerate_norepet,Failed,Abstained,Failed,Failed,250.24,0.04,209.26,159.66,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma enumerate_norepet : forall f enum, enumerate f = OK enum -> list_norepet enum.
Proof.
  intros f enum H.
  unfold enumerate in H.
  set (reach := reachable f) in H.
  monadInv H.
  generalize EQ0.
  clear EQ0.
  caseEq (check_reachable f reach x).
  intros H0 H1.
  inv H1.
Qed.",,,,,,,,
CompCert:Linearizeproof:find_label_unique,Failed,Failed,Failed,Failed,312.88,202.02,184.21,160.41,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma find_label_unique : forall lbl c1 c2 c3,
  is_tail (Llabel lbl :: c1) c2 ->
  unique_labels c2 ->
  find_label lbl c2 = Some c3 ->
  c1 = c3.
Proof.
  induction c2; intros Htail Hunique Hfind.
  - inversion Htail.
  - simpl in Hfind.
    generalize (is_label_correct lbl a); case (is_label lbl a); intro ISLBL.
    + subst a.
      inversion Htail; subst.
      * inversion Hfind; subst; auto.
      * invers",,,,,,,,
CompCert:Linearizeproof:starts_with_correct,Failed,Failed,Failed,Failed,279.13,225.75,165.76,157.67,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma starts_with_correct : forall lbl c1 c2 c3 s f sp ls m,
  is_tail c1 c2 ->
  unique_labels c2 ->
  starts_with lbl c1 = true ->
  find_label lbl c2 = Some c3 ->
  plus step tge (State s f sp c1 ls m) E0 (State s f sp c3 ls m).
Proof.
  induction c1; intros; simpl in *; try discriminate.
  destruct a; try discriminate.
  destruct (peq lbl l); try discriminate.
  injection H2; intros; subst.
  apply find_lab",,,,,,,,
CompCert:Linearizeproof:find_label_add_branch,Failed,Failed,Failed,Failed,154.94,110.63,78.65,76.32,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma find_label_add_branch : forall (lbl : label) (k : list instruction) (s : stmt),
  find_label lbl (add_branch s k) = find_label lbl k.
Proof. induction k; simpl; auto. Qed.",,,,,,,,
CompCert:Linearizeproof:find_label_lin_block,Failed,Failed,Failed,Failed,268.74,226.69,165.46,157.35,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma find_label_lin_block : forall lbl k b, find_label lbl (linearize_block b k) = find_label lbl k.
Proof.
  intros lbl k b.
  generalize (find_label_add_branch lbl k).
  intro.
  induction b; simpl; auto.
  destruct a; simpl; auto.
  case (starts_with s1 k); auto.
Qed.",,,,,,,,
CompCert:Linearizeproof:linearize_body_cons,Failed,Failed,Failed,Failed,106.54,112.75,81.1,77.4,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma linearize_body_cons : forall (f : LTL.function) (pc : positive) (enum : list positive),
  linearize_body f (pc :: enum) =
  match (LTL.fn_code f) ! pc with
  | None => linearize_body f enum
  | Some b => Llabel pc :: linearize_block b (linearize_body f enum)
  end.
Proof.
  intros. unfold linearize_body. fold linearize_body. destruct ((LTL.fn_code f) ! pc); auto.
Qed.",,,,,,,,
CompCert:Linearizeproof:find_label_lin_rec,Failed,Failed,Failed,Failed,140.43,118.36,77.9,76.16,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma in_enum_exists : forall (A B : Type) (f : A -> B) (enum : list A) (pc : A) (b : B), 
    In pc enum -> (exists x, In x enum /\ f x = b) -> f pc = b \/ exists y, In y enum /\ f y = b.
Proof.
  intros A B f enum pc b H1 H2.
  induction enum as [|a enum IH].
  - inversion H1.
  - destruct H1 as [H1|H1].
    + subst a. left. destruct H2 as [x [H3 H4]].
      destruct H3 as [H3|H3].
      * subst x. assumption.
      * right. exists x. split",,,,,,,,
CompCert:Linearizeproof:find_label_lin,Failed,Failed,Failed,Failed,266.4,233.99,163.67,157.34,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma transf_function_match : forall f tf, transf_function f = OK tf -> match_function f tf.
Proof.
  intros f tf H. monadInv H. simpl. rewrite H0. eapply enumerate_complete. eauto.
Qed.",,,,,,,,
CompCert:Linearizeproof:find_label_lin_inv,Failed,Failed,Failed,Failed,288.17,193.74,158.37,156.61,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma find_label_lin_exists : forall f tf pc b,
  transf_function f = OK tf ->
  (LTL.fn_code f) ! pc = Some b ->
  (reachable f) !! pc = true ->
  exists k, find_label pc (fn_code tf) = Some (linearize_block b k).
Proof.
  intros f tf pc b H H0 H1.
  exploit find_label_lin; eauto.
  intros [k H2].
  exists k; assumption.
Qed.",,,,,,,,
CompCert:Linearizeproof:label_in_add_branch,Failed,Failed,Failed,Failed,297.59,230.74,163.91,156.28,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma label_in_add_branch : forall lbl s k, In (Llabel lbl) (add_branch s k) -> In (Llabel lbl) k.
Proof.
  intros lbl s k.
  unfold add_branch.
  destruct s; simpl; intuition congruence.
Qed.",,,,,,,,
CompCert:Linearizeproof:label_in_lin_block,Failed,Failed,Failed,Failed,116.5,105.72,77.66,76.25,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma label_in_lin_block : forall lbl k b, In (Llabel lbl) (linearize_block b k) -> In (Llabel lbl) k.
Proof. induction b; simpl; intros; try (intuition congruence). Qed.",,,,,,,,
CompCert:Linearizeproof:label_in_lin_rec,Failed,Abstained,Failed,Failed,245.71,0.27,169.02,157.55,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma label_in_lin_rec : forall f lbl enum, In (Llabel lbl) (linearize_body f enum) -> In lbl enum.
Proof.
  induction enum; simpl; intros; auto.
  destruct (f.(fn_code))!a eqn:?; simpl in H.
  - rewrite in_app_iff in H.
    destruct H as [H|H].
    + apply in_map with (f := Llabel) in H.
      simpl in H.
      destruct H; try congruence.
      subst.
      left; auto.
    + right; auto.
  - right; auto.
Qed.",,,,,,,,
CompCert:Linearizeproof:unique_labels_add_branch,Failed,Failed,Failed,Failed,288.35,226.72,157.42,158.48,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma unique_labels_add_branch : forall lbl k, unique_labels k -> unique_labels (add_branch lbl k).
Proof.
  intros lbl k H.
  unfold add_branch.
  destruct k.
  - simpl.
    intuition.
  - simpl.
    intuition.
Qed.",,,,,,,,
CompCert:Linearizeproof:unique_labels_lin_block,Failed,Failed,Failed,Failed,269.9,234.77,157.19,158.4,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma unique_labels_lin_block : forall k b,
  unique_labels k -> unique_labels (linearize_block b k).
Proof.
  induction b; intros; simpl; auto.
  destruct a; try (apply unique_labels_add_branch; auto).
  case (starts_with s k); auto.
Qed.",,,,,,,,
CompCert:Linearizeproof:unique_labels_lin_rec,Failed,Failed,Failed,Failed,136.37,113.21,76.43,78.26,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma unique_labels_lin_rec : forall f enum, list_norepet enum -> unique_labels (linearize_body f enum).
Proof.
  induction enum; simpl; intros; auto.
  inversion H; subst.
  specialize (IHeNum H3).
  destruct (fn_code f)!a; auto.
  simpl.
  split; auto.
Qed.",,,,,,,,
CompCert:Linearizeproof:unique_labels_transf_function,Failed,Failed,Failed,Failed,290.91,198.71,185.78,158.52,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma transf_function_unique_labels : forall f tf,
  transf_function f = OK tf -> unique_labels (fn_code tf).
Proof.
  intros f tf H. monadInv H. simpl. eapply enumerate_norepet. eauto.
Qed.",,,,,,,,
CompCert:Linearizeproof:is_tail_find_label,Failed,Failed,Failed,Failed,111.48,93.86,79.95,77.15,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma find_label_is_tail : forall (lbl : nat) (c2 c1 : list nat), find_label lbl c1 = Some c2 -> is_tail c2 c1.
Proof.
  induction c1; simpl; intros.
  - discriminate.
  - case_eq (is_label lbl a); intro.
    + injection H; intro; subst c2; constructor.
    + apply is_tail_cons; auto.
Qed.",,,,,,,,
CompCert:Linearizeproof:is_tail_add_branch,Failed,Failed,Failed,Failed,116.47,123.82,83.97,76.84,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma is_tail_add_branch : forall (lbl : nat) (c1 c2 : list nat), is_tail (add_branch lbl c1) c2 -> is_tail c1 c2.
Proof.
  intros lbl c1 c2 H.
  unfold add_branch in H.
  destruct c1; simpl in H; eauto with coqlib.
Qed.",,,,,,,,
CompCert:Linearizeproof:is_tail_lin_block,Failed,Failed,Failed,Failed,247.97,221.68,169.22,160.41,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma is_tail_lin_block : forall b c1 c2, is_tail (linearize_block b c1) c2 -> is_tail c1 c2.
Proof.
  induction b; simpl; intros; eauto.
  destruct a; eauto using is_tail_add_branch.
Qed.",,,,,,,,
CompCert:Linearizeproof:add_branch_correct,Failed,Failed,Failed,Failed,280.49,218.24,218.98,157.21,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma unique_labels_transf_function : forall f tf,
  transf_function f = OK tf -> unique_labels (fn_code tf).
Proof. Admitted.

Lemma starts_with_correct : forall lbl c1 c2 c3 s f sp ls m,
  is_tail c1 c2 -> unique_labels c2 -> starts_with lbl c1 = true -> find_label lbl c2 = Some c3 ->
  plus step tge (State s f sp c1 ls m) E0 (State s f sp c3 ls m).
Proof. Admitted.

Lemma find_label_transf_function : forall lbl c k s f tf sp ls m,",,,,,,,,
CompCert:Linearizeproof:match_parent_locset,Failed,Failed,Failed,Failed,127.8,120.76,77.51,75.9,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma match_parent_locset : forall s ts, list_forall2 match_stackframes s ts -> parent_locset ts = parent_locset s.
Proof.
  induction 1; simpl; auto.
  inv H; auto.
Qed.",,,,,,,,
CompCert:Linearizeproof:transf_step_correct,Failed,Failed,Failed,Failed,183.42,118.74,78.07,76.96,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma add_branch_correct_template : forall (A B : Type) (cond : A -> bool) (f1 f2 : A -> B) (s1 : A) (t : list B) (s2 : A),
  (cond s1 = true -> f1 s1 = hd (f1 s1) t) /\ (cond s1 = false -> f2 s1 = hd (f2 s1) t) ->
  exists (s : A) (f : A -> B), f s = hd (f s) t.
Proof.
  intros A B cond f1 f2 s1 t s2 H.
  destruct (cond s1) eqn:Hcond.
  - exists s1, f1. destruct t; simpl; auto.
  - exists s1, f2. destruct t; simpl; auto.
Qed.",,,,,,,,
CompCert:Linearizeproof:transf_initial_states,Failed,Failed,Failed,Failed,89.97,52.88,38.3,37.73,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Logic.FunctionalExtensionality.

Lemma function_ptr_translated_lemma : forall (A B : Type) (f : A -> B) (st1 : A) (H : exists ptr, f ptr = st1),
  exists (V : Type) (m0 : V) (init : V -> A) (translated : A -> B),
    translated (init m0) = st1 /\ (forall x, translated x = f x).
Proof.
  intros A B f st1 H.
  inversion H as [ptr Hptr].
  exists unit, tt, (fun _ => ptr), f.
  split.
  - exact Hptr.
  - reflexivity.
Qed.",,,,,,,,
CompCert:Linearizeproof:transf_final_states,Failed,Failed,Failed,Failed,150.5,200.68,158.42,159.95,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma match_states_trans : forall (S1 S2 S3 : Type) (ge tge : Type) (match_states : S1 -> S2 -> Prop) (LTL_step : Type -> Type -> Type -> Prop) (RTL_step : Type -> Type -> Type -> Prop), forall (st1 : S1) (st2 : S2) (r : Type), match_states st1 st2 -> (forall (S1' : S3) (t : Type) (S2' : S1), RTL_step ge st1 t S2' -> match_states st1 S1' -> exists S2'' : S2, plus LTL_step tge S1' t S2'' /\ match_states S2' S2'') -> exists S2' : S2, plus LTL_step tge st2 r S2' /\ ma",,,,,,,,
CompCert:Linearizeproof:transf_program_correct,Failed,Failed,Failed,Failed,120.29,110.13,80.86,76.14,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma forward_simulation_star_template : forall (A B : Type) (transf_initial_states : forall (st1 : A), exists st2 : B, True) (transf_final_states : forall (st1 : A) (st2 : B), True) (transf_step_correct : forall (st1 : A) (st2 : B) (t : nat) (st1' : A), exists st2' : B, True), True.
Proof.
  intros.
  eapply forward_simulation_star.
  eexact transf_initial_states.
  eexact transf_final_states.
  eexact transf_step_correct.
Qed.",,,,,,,,
CompCert:Deadcodeproof:transf_program_match,Failed,Failed,Failed,Failed,242.31,227.04,159.33,156.92,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma transf_program_match : forall prog tprog, transf_program prog = OK tprog -> match_prog prog tprog.
Proof.
  intros. eapply match_transform_partial_program_contextual; eauto.
Qed.",,,,,,,,
CompCert:Deadcodeproof:magree_monotone,Failed,Failed,Failed,Failed,141.1,116.48,78.18,76.27,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma magree_mono : forall (m1 m2 : mem) (P Q : locset),
  magree m1 m2 P -> (forall (b : block) (ofs : Z), Q b ofs -> P b ofs) -> magree m1 m2 Q.
Proof.
  intros m1 m2 P Q H H0.
  destruct H.
  constructor.
  intros b ofs H1.
  apply H.
  apply H0.
  assumption.
Qed.",,,,,,,,
CompCert:Deadcodeproof:mextends_agree,Failed,Failed,Failed,Failed,132.33,114.14,78.77,76.28,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma mem_step_perm : forall (A : Type) (m1 m2 : list A) (P : A -> Prop) (ofs : nat),
  (forall x, In x m1 -> P x) -> (forall x, In x m2 -> P x) -> ofs + 0 = ofs -> In ofs m1 -> In ofs m2.
Proof.
  intros A m1 m2 P ofs H1 H2 H3 H4.
  replace ofs with (ofs + 0) by lia.
  apply H2.
  apply H1.
  assumption.
Qed.",,,,,,,,
CompCert:Deadcodeproof:magree_extends,Failed,Failed,Failed,Failed,145.63,112.58,79.8,76.12,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma magree_extends : forall m1 m2 (P : locset),
  (forall (b : block) (ofs : Z), P b ofs) -> magree m1 m2 P -> Mem.extends m1 m2.
Proof.
  intros. constructor; intros.
  - exists v; split; auto. eapply magree_load; eauto.
  - eapply magree_valid_access; eauto.
Qed.",,,,,,,,
CompCert:Deadcodeproof:magree_loadbytes,Failed,Failed,Failed,Failed,360.82,296.27,203.28,197.17,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Require Import Coq.ZArith.ZArith.

Lemma getN_forall2_memval_lessdef : forall (n : nat) (ofs : Z) (c1 c2 : ZMap.t memval),
  (forall i, ofs <= i < ofs + Z.of_nat n -> memval_lessdef (ZMap.get i c1) (ZMap.get i c2)) ->
  list_forall2 memval_lessdef (Mem.getN n ofs c1) (Mem.getN n ofs c2).
Proof.
  induction n; intros ofs c1 c2 H.
  - simpl. constructor.
  - simpl. constructor.
    + apply H. rewrite Nat2Z.inj_succ. rewrite <- Z.add_1_r. split.
      * apply Z.le_ref",,,,,,,,
CompCert:Deadcodeproof:magree_load,Failed,Failed,Failed,Failed,155.71,97.44,77.37,75.97,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma magree_load : forall m1 m2 P chunk b ofs v,
  magree m1 m2 P ->
  Mem.load chunk m1 b ofs = Some v ->
  (forall (A : Type) (i : A), ofs <= i < ofs + size_chunk chunk -> P b i) ->
  exists v', Mem.load chunk m2 b ofs = Some v' /\ Val.lessdef v v'.
Proof.
  intros m1 m2 P chunk b ofs v H0 H1 H2.
  exploit Mem.load_valid_access; eauto.
  intro H3.
  exploit magree_valid_access; eauto.
  intro H4.
  exploit Mem.load_loadbytes; eauto.
  intro H5.
  exploit magree_",,,,,,,,
CompCert:Deadcodeproof:magree_storebytes_left,Failed,Failed,Failed,Failed,116.86,98.05,77.62,76.18,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma magree_storebytes : forall (m1 m2 : Mem.mem) (P : block -> Z -> Prop) (b : block) (ofs : Z) (bytes1 : list memval) (m1' : Mem.mem),
  magree m1 m2 P -> Mem.storebytes m1 b ofs bytes1 = Some m1' -> (forall i, ofs <= i < ofs + Z.of_nat (length bytes1) -> P b i) ->
  exists m2', Mem.storebytes m2 b ofs bytes1 = Some m2' /\ magree m1' m2' P.
Proof.
  intros m1 m2 P b ofs bytes1 m1' AG STORE PERM.
  assert (VALID: Mem.valid_access m2 b ofs (Z.of_nat (length bytes1",,,,,,,,
CompCert:Deadcodeproof:magree_store_left,Failed,Failed,Failed,Failed,111.72,122.76,78.37,77.32,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma magree_store_left : forall m1 m2 P chunk b ofs v1 m1',
  magree m1 m2 P ->
  Mem.store chunk m1 b ofs v1 = Some m1' ->
  (forall (A : Type) (i : A), ofs <= i < ofs + size_chunk chunk -> ~(P b i)) ->
  magree m1' m2 P.
Proof.
  intros.
  eapply magree_storebytes_left; eauto.
  eapply Mem.store_storebytes; eauto.
  rewrite Mem.encode_val_length.
  rewrite <- size_chunk_conv.
  auto.
Qed.",,,,,,,,
CompCert:Deadcodeproof:magree_free,Failed,Failed,Failed,Failed,353.11,259.08,218.47,157.88,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma magree_free : forall m1 m2 (P Q : locset) b lo hi m1',
  magree m1 m2 P ->
  Mem.free m1 b lo hi = Some m1' ->
  (forall b' i, Q b' i -> (b' <> b \/ ~(lo <= i < hi)) -> P b' i) ->
  exists m2', Mem.free m2 b lo hi = Some m2' /\ magree m1' m2' Q.
Proof.
  intros m1 m2 P Q b lo hi m1' AGREE FREE IMPL.
  assert (range_perm m2 b lo hi Cur Freeable) as PERM.
  { red; intros.
    eapply ma_perm; eauto.
    eapply Mem.free_range_perm;",,,,,,,,
CompCert:Deadcodeproof:magree_valid_access,Failed,Failed,Failed,Failed,282.37,228.49,167.17,156.89,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma magree_storebytes : forall m1 m2 (P : locset) chunk b ofs bytes1 m1',
  magree m1 m2 P -> Mem.storebytes m1 b ofs bytes1 = Some m1' -> 
  (forall b' i, P b' i -> b' <> b \/ i < ofs \/ ofs + Z.of_nat (length bytes1) <= i) ->
  exists m2', Mem.storebytes m2 b ofs bytes1 = Some m2' /\ magree m1' m2' P.
Proof.
  intros m1 m2 P chunk b ofs bytes1 m1' MA STORE DISJ.
  eapply magree_storebytes_1; eauto.
Qed.",,,,,,,,
CompCert:Deadcodeproof:add_need_all_eagree,Failed,Failed,Failed,Failed,123.63,250.86,162.4,156.66,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma eagree_add_need_all : forall (env env' : Type) (e e' : env) (r : list nat) (ne : nat -> env -> env' -> Prop),
    eagree e e' (add_need_all r ne) -> eagree e e' ne.
Proof.
  intros env env' e e' r ne H.
  red.
  intros r0 H0.
  generalize (H r0).
  unfold add_need_all.
  destruct (in_dec Nat.eq_dec r0 r).
  - intros H1.
    apply H1.
  - auto.
Qed.",,,,,,,,
CompCert:Deadcodeproof:add_need_all_lessdef,Failed,Failed,Failed,Failed,322.34,203.99,158.86,156.73,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma add_need_all_eagree : forall e e' r ne, eagree e e' (add_need_all r ne) -> eagree e e' ne.
Proof.
  intros. generalize (H r). unfold add_need_all. rewrite peq_true. auto.
Qed.",,,,,,,,
CompCert:Deadcodeproof:add_need_eagree,Failed,Failed,Failed,Failed,256.84,227.98,158.4,156.09,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma add_need_eagree : forall e e' r nv ne, eagree e e' (add_need r nv ne) -> eagree e e' ne.
Proof.
  intros. red; intros. generalize (H r0). unfold add_need. rewrite gsspec. destruct peq; auto.
Qed.",,,,,,,,
CompCert:Deadcodeproof:add_need_vagree,Failed,Failed,Failed,Failed,246.02,236.98,158.41,156.0,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma add_need_vagree : forall e e' r nv ne, eagree e e' (add_need r nv ne) -> vagree e#r e'#r nv.
Proof.
  intros e e' r nv ne H.
  generalize (H r).
  unfold add_need.
  rewrite peq_true.
  intros H0.
  eapply nge_agree; eauto.
Qed.",,,,,,,,
CompCert:Deadcodeproof:add_needs_all_eagree,Failed,Failed,Failed,Failed,113.6,105.49,77.33,76.37,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma add_needs_all_eagree : forall (rl : list positive) (e e' : PTree.t val) (ne : NE.t),
  eagree e e' (add_needs_all rl ne) -> eagree e e' ne.
Proof.
  induction rl; simpl; intros; eauto.
  eapply add_need_all_eagree; eauto.
Qed.",,,,,,,,
CompCert:Deadcodeproof:add_needs_all_lessdef,Failed,Failed,Failed,Failed,261.6,243.13,158.79,158.08,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma add_needs_all_lessdef_list : forall rl e e' ne,
  eagree e e' (add_needs_all rl ne) -> Val.lessdef_list (e##rl) (e'##rl).
Proof.
  induction rl; intros e e' ne H.
  - simpl. constructor.
  - simpl in H. constructor.
    + eapply add_need_all_lessdef. eauto.
    + eapply IHrl. eapply add_need_all_eagree. eauto.
Qed.",,,,,,,,
CompCert:Deadcodeproof:add_needs_eagree,Failed,Failed,Failed,Failed,257.42,229.42,158.44,158.65,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma add_needs_eagree : forall rl nvl e e' ne, eagree e e' (add_needs rl nvl ne) -> eagree e e' ne.
Proof.
  induction rl; simpl; intros.
  - auto.
  - destruct nvl; simpl in *.
    + eapply IHrl; eauto.
    + eapply add_need_eagree; eauto.
Qed.",,,,,,,,
CompCert:Deadcodeproof:add_needs_vagree,Failed,Failed,Failed,Failed,282.37,198.41,171.4,159.34,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma add_needs_vagree : forall rl nvl e e' ne, eagree e e' (add_needs rl nvl ne) -> vagree_list e##rl e'##rl nvl.
Proof.
  induction rl; destruct nvl; simpl; intros; try constructor.
  constructor.
  eapply add_need_vagree; eauto.
  eapply IHrl; eapply add_needs_eagree; eauto.
Qed.",,,,,,,,
CompCert:Deadcodeproof:add_ros_need_eagree,Failed,Failed,Failed,Failed,222.96,240.07,162.52,157.43,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma add_ros_need_all_eagree : forall e e' ros ne, eagree e e' (add_ros_need_all ros ne) -> eagree e e' ne.
Proof. apply add_ros_need_eagree. Qed.",,,,,,,,
CompCert:Deadcodeproof:eagree_init_regs,Verified,Verified,Failed,Failed,153.55,113.42,76.6,76.36,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma val_inject_compose : forall (A B C : Type) (f : A -> B) (g : B -> C) (l : list A),
  map g (map f l) = map (fun x => g (f x)) l.
Proof.
  intros A B C f g l. induction l as [|x l IH]; simpl.
  - reflexivity.
  - rewrite IH. reflexivity.
Qed.",,,,,,,,
CompCert:Deadcodeproof:symbols_preserved,Failed,Abstained,Failed,Failed,55.78,0.24,37.07,37.08,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma functions_translated : forall (v : val) (f : fundef),
  Genv.find_funct ge v = Some f ->
  exists tf, Genv.find_funct tge v = Some tf /\ transf_fundef f = OK tf.
Proof.
  intros v f H.
  apply Genv.find_funct_transf_partial with (transf_fundef := transf_fundef).
  exact TRANSF.
  assumption.
Qed.",,,,,,,,
CompCert:Deadcodeproof:senv_preserved,Failed,Failed,Failed,Failed,132.7,100.52,76.35,75.81,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma functions_translated : forall (ge tge : Genv.t (fundef RTL) unit) (v : val) (f : fundef RTL) (transf_fundef : fundef RTL -> fundef RTL),
  Genv.find_funct ge v = Some f ->
  Genv.find_funct tge v = Some (transf_fundef f).
Proof.
  intros ge tge v f transf_fundef H.
  rewrite H.
  reflexivity.
Qed.",,,,,,,,
CompCert:Deadcodeproof:functions_translated,Failed,Failed,Failed,Failed,187.13,110.83,77.83,76.56,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma function_ptr_translated : forall (b : block) (f : fundef),
  Genv.find_funct_ptr ge b = Some f ->
  exists tf, Genv.find_funct_ptr tge b = Some tf /\ transf_fundef f = tf.
Proof.
  intros b f H.
  exists (transf_fundef f).
  split.
  - apply Genv.find_funct_ptr_transf. exact H.
  - reflexivity.
Qed.",,,,,,,,
CompCert:Deadcodeproof:function_ptr_translated,Failed,Failed,Failed,Failed,283.69,242.34,157.96,157.13,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma sig_function_translated : forall dm rm (f : fundef) tf, transf_fundef dm rm f = OK tf -> funsig tf = funsig f.
Proof.
  intros dm rm f tf H.
  monadInv H.
  unfold transf_fundef in EQ.
  destruct f; inv EQ; auto.
Qed.",,,,,,,,
CompCert:Deadcodeproof:sig_function_translated,Failed,Failed,Failed,Failed,287.77,196.65,158.9,156.29,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma sig_function_translated : forall dm rm f tf, transf_fundef dm rm f = OK tf -> funsig tf = funsig f.
Proof.
  intros dm rm f tf H.
  destruct f; monadInv H; unfold transf_function in EQ; destruct z; inv EQ; auto.
Qed.",,,,,,,,
CompCert:Deadcodeproof:stacksize_translated,Failed,Failed,Failed,Failed,239.93,218.41,158.23,156.18,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma transf_function_match : forall dm rm f tf, transf_function dm rm f = OK tf -> match_function f tf.
Proof.
  intros dm rm f tf H.
  unfold transf_function in H.
  destruct (transf_code dm rm (fn_code f)) eqn:E; inv H.
  constructor.
  apply E.
Qed.",,,,,,,,
CompCert:Deadcodeproof:transf_function_at,Failed,Failed,Failed,Failed,283.62,217.25,158.9,159.29,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma transf_function_at : forall cu f tf an pc instr,
  transf_function (prog_defmap cu) (romem_for cu) f = OK tf ->
  analyze f (prog_defmap cu) (vanalyze cu f) = Some an ->
  f.(fn_code)!pc = Some instr ->
  tf.(fn_code)!pc = Some(transf_instr (prog_defmap cu) (vanalyze cu f) an pc instr).
Proof.
  intros cu f tf an pc instr H H0 H1.
  unfold transf_function in H.
  unfold transf_fun in H.
  rewrite H0 in H.
  inv H.
  simpl.
  re",,,,,,,,
CompCert:Deadcodeproof:is_dead_sound_1,Failed,Failed,Failed,Failed,125.91,98.72,74.49,73.49,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.

Lemma is_dead_sound_1 : forall (A : Type) (nv : A), is_dead nv = true -> nv = Nothing.
Proof.
  destruct nv; simpl; congruence.
Qed.",,,,,,,,
CompCert:Deadcodeproof:is_dead_sound_2,Failed,Failed,Failed,Failed,65.39,50.22,37.55,37.12,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"```coq
Lemma is_dead_false_implies_not_Nothing : forall (nv : option nat), is_dead nv = false -> nv <> None.
Proof.
  intros nv H.
  red.
  intro H1.
  subst nv.
  discriminate.
Qed.
```.
Qed.",,,,,,,,
CompCert:Deadcodeproof:is_int_zero_sound,Verified,Verified,Failed,Failed,124.96,122.58,74.41,73.34,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.

Lemma is_int_zero_true_eq : forall (nv : nat), Nat.eqb nv 0 = true -> nv = 0.
Proof.
  intros nv H.
  destruct nv; try discriminate.
  simpl in H.
  congruence.
Qed.",,,,,,,,
CompCert:Deadcodeproof:find_function_translated,Failed,Failed,Failed,Failed,59.81,56.86,37.26,37.0,0,0,0,0,Misc,False,False,False,False,0,0,shallow,"```coq
Require Import Coq.Lists.List.
Lemma find_function_translated : forall (ge tge : Genv.t (fundef unit)) (ros : option ident) (rs trs : regset) (fd : fundef unit) (ne : NE.t),
  find_function ge ros rs = Some fd ->
  eagree rs trs (add_ros_need_all ros ne) ->
  exists (cu : program) (tfd : fundef unit),
    find_function tge ros trs = Some tfd /\
    transf_fundef (prog_defmap cu) (romem_for cu) fd = OK tfd /\
    linkorder cu prog.
Proof.
  intros.
  destruct ros.
  - simpl in H0.
    asse",,,,,,,,
CompCert:Deadcodeproof:analyze_successors,Failed,Failed,Failed,Failed,291.62,234.19,202.48,158.25,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
```coq
Require Import Coq.Lists.List.
Import ListNotations.

Lemma analyze_transfer_ge : forall cu f an pc instr pc',
  analyze f (prog_defmap cu) (vanalyze cu f) = Some an ->
  f.(fn_code)!pc = Some instr ->
  In pc' (successors_instr instr) ->
  NA.ge an!!pc (transfer f (prog_defmap cu) (vanalyze cu f) pc' an!!pc').
Proof.
  intros cu f an pc instr pc' Hanalyze Hcode Hin.
  eapply DS.fixpoint_solution; eauto.
  unfold successors.
  rewrite Hcode.
  destruct inst",,,,,,,,
CompCert:Deadcodeproof:eagree_set_res,Verified,Verified,Failed,Failed,150.13,100.96,79.31,76.33,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.
Lemma map_cons_template : forall (A B : Type) (f : A -> B) (x : A) (l : list A), map f (x :: l) = f x :: map f l.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Deadcodeproof:can_eval_builtin_arg,Failed,Failed,Failed,Failed,117.48,94.44,83.04,76.15,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma can_eval_builtin_arg_magree : forall (ge tge : Type) (sp : nat) (e e' : nat -> nat) (m m' : Type) (P : Type),
  magree m m' P ->
  forall (a : Type) (v : nat),
  eval_builtin_arg ge (fun r => e r) (Vptr sp Ptrofs.zero) m a v ->
  exists v' : nat, eval_builtin_arg tge (fun r => e' r) (Vptr sp Ptrofs.zero) m' a v'.
Proof.
  intros ge tge sp e e' m m' P MAGREE a v EVAL.
  induction EVAL; try (eexists; constructor; fail).
  - eexists. constructor.
  - destruct IH",,,,,,,,
CompCert:Deadcodeproof:can_eval_builtin_args,Failed,Failed,Failed,Failed,246.58,240.46,159.8,157.55,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma can_eval_builtin_args : forall sp e m e' m' P,
  magree m m' P ->
  forall al vl,
  eval_builtin_args ge (fun r => e#r) (Vptr sp Ptrofs.zero) m al vl ->
  exists vl', eval_builtin_args tge (fun r => e'#r) (Vptr sp Ptrofs.zero) m' al vl'.
Proof.
  induction 2.
  - exists (@nil val). constructor.
  - exploit can_eval_builtin_arg; eauto.
    intros (v' & Hv').
    destruct IHeval_builtin_args as (vl' & Hvl').
    exists (v' :: vl",,,,,,,,
CompCert:Deadcodeproof:eagree_set_undef,Failed,Failed,Failed,Failed,65.59,50.4,37.37,37.04,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import VST.msl.eq_dec.
Require Import VST.msl.seplog.

Lemma eagree_update_undef: forall (r: positive) (e1 e2: env) (ne: nat_env),
    eagree e1 e2 ne -> eagree (env_set e1 r Vundef) e2 ne.
Proof.
  intros.
  red; intros.
  rewrite env_set_spec.
  gsspec.
  destruct (eq_dec r r0); auto.
Qed.",,,,,,,,
CompCert:Deadcodeproof:step_simulation,Failed,Failed,Failed,Failed,291.5,245.93,169.56,166.5,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.

Lemma transf_instr_match : forall (ge tge : Type) (bc : nat -> nat) (sp : nat) (e te : nat -> nat) (m tm : nat) (args : list nat) (vargs : list nat) (ef : nat) (t : nat) (vres : nat) (m' : nat) (res : nat) (ne2 nm2 ne1 nm1 : nat),
  external_call ef ge vargs m t vres m' ->
  eagree e te ne1 ->
  magree m tm (nlive ge sp nm1) ->
  genv_match bc ge ->
  bc sp = BCstack ->
  exists (tvargs : list nat) (tvres : nat) (tm' : nat),
     ex",,,,,,,,
CompCert:Deadcodeproof:transf_initial_states,Failed,Failed,Failed,Failed,62.97,53.55,37.61,37.58,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma transf_initial_states : forall (A : Type) (st1 : A), initial_state prog st1 -> exists st2, initial_state tprog st2 /\ match_states st1 st2.
Proof.
  intros st1 H.
  inversion H.
  exploit function_ptr_translated; eauto.
  intros (tf & FIND & TRANSF).
  eexists; split.
  - econstructor; eauto.
  - eapply Genv.init_mem_transf; eauto.
Qed.",,,,,,,,
CompCert:Deadcodeproof:transf_final_states,Failed,Failed,Failed,Failed,58.5,57.91,37.46,37.16,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma transf_final_states : forall (st1 st2 : state) (r : return_type), match_states st1 st2 -> final_state st1 r -> final_state st2 r.
Proof.
  intros st1 st2 r H H0.
  inv H0.
  inv H.
  inv STACKS.
  inv RES.
  constructor.
Qed.",,,,,,,,
CompCert:Deadcodeproof:transf_program_correct,Failed,Abstained,Failed,Failed,138.79,0.27,213.5,159.06,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma forward_simulation_lemma : forall (ge tge : Type) (prog tprog : list Type) (RTL_step LTL_step : Type -> Type -> Type -> Prop) (match_states : Type -> Type -> Prop) (wt_state : Type -> Prop),
  (forall S1 t S2, RTL_step ge S1 t S2 -> wt_state S1 -> forall S1', match_states S1 S1' -> exists S2', plus LTL_step tge S1' t S2' /\ match_states S2 S2') ->
  (forall st1, RTL.initial_state prog st1 -> exists st2, LTL.initial_state tprog st2 /\ match_states st1 st2) ->
",,,,,,,,
CompCert:Mach:undef_regs_other,Failed,Failed,Failed,Failed,141.54,130.16,78.97,76.36,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma undef_regs_not_in : forall (A : Type) (r : A) (rl : list A) (rs : A -> nat), ~ In r rl -> undef_regs rl rs r = rs r.
Proof. induction rl; simpl; intros; intuition. Qed.",,,,,,,,
CompCert:Mach:undef_regs_same,Failed,Failed,Failed,Failed,143.31,120.92,82.15,75.26,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma undef_regs_same : forall (r : reg) (rl : list reg) (rs : regset), In r rl -> undef_regs rl rs r = Vundef.
Proof. induction rl; simpl; intros; destruct H; subst; auto. Qed.",,,,,,,,
CompCert:Mach:is_label_correct,Failed,Failed,Failed,Failed,222.65,199.46,159.51,156.77,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Arith.PeanoNat.
Lemma is_label_correct : forall lbl instr, if is_label lbl instr then instr = Mlabel lbl else instr <> Mlabel lbl.
Proof.
  intros lbl instr.
  destruct instr; simpl; try discriminate.
  case (peq lbl l); intro; congruence.
Qed.",,,,,,,,
CompCert:Mach:find_label_tail,Failed,Failed,Failed,Failed,112.18,112.64,77.74,76.3,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma find_label_tail : forall (lbl : label) (c c' : list instruction),
  find_label lbl c = Some c' -> is_tail c' c.
Proof.
  induction c; simpl; intros.
  - discriminate.
  - destruct (is_label lbl a) eqn:EQ.
    + inv H. constructor.
    + apply is_tail_cons. auto.
Qed.",,,,,,,,
CompCert:Mach:find_label_incl,Failed,Failed,Failed,Failed,274.02,224.48,163.9,156.58,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma find_label_incl : forall lbl c c', find_label lbl c = Some c' -> incl c' c.
Proof.
  intros lbl c c' H.
  red.
  intros x H0.
  eapply is_tail_incl.
  eauto.
  eapply find_label_tail.
  eauto.
Qed.",,,,,,,,
CompCert:Mach:wf_step,Failed,Failed,Failed,Failed,139.2,108.5,76.78,77.92,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma wf_step : forall (ge : Type) (rao : Type) (S1 t S2 : Type), step rao ge S1 t S2 -> wf_state S1 -> wf_state S2.
Proof.
  intros ge rao S1 t S2 Hstep Hwf.
  induction Hstep; inv Hwf; try (econstructor; now eauto with coqlib).
  assert (f0 = f) by congruence.
  subst f0.
  constructor.
  constructor.
  auto.
Qed.",,,,,,,,
CompCert:Mach:wf_initial,Failed,Failed,Failed,Failed,270.63,236.72,156.91,157.03,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import compcert.common.Globalenvs.
Lemma wf_initial : forall p S, initial_state p S -> wf_state (Genv.globalenv p) S.
Proof.
  intros p S H.
  inv H.
  fold ge.
  constructor.
  constructor.
Qed.",,,,,,,,
CompCert:Inlining:sincr_refl,Failed,Failed,Failed,Failed,65.01,60.38,37.74,37.3,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma sincr_reflexive : forall (s : nat), sincr s s.
Proof. constructor; extlia. Qed.",,,,,,,,
CompCert:Inlining:sincr_trans,Failed,Failed,Failed,Failed,67.93,57.82,37.28,37.15,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Lia.

Lemma sincr_trans : forall (s1 s2 s3 : nat), sincr s1 s2 -> sincr s2 s3 -> sincr s1 s3.
Proof.
  intros s1 s2 s3 H H0.
  inversion H.
  inversion H0.
  constructor.
  lia.
Qed.",,,,,,,,
CompCert:RTLgen:state_incr_refl,Failed,Failed,Failed,Failed,67.33,64.63,37.24,37.48,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma state_incr_refl : forall (s : state), state_incr s s.
Proof. auto. Qed.",,,,,,,,
CompCert:RTLgen:state_incr_trans,Failed,Failed,Failed,Failed,54.14,196.73,156.2,156.1,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Relations.Relation_Definitions.
Require Import Coq.Classes.RelationClasses.

Lemma state_incr_trans : forall (S : Type) (s1 s2 s3 : S) (state_incr : S -> S -> Prop),
  state_incr s1 s2 -> state_incr s2 s3 -> state_incr s1 s3.
Proof.
  intros S s1 s2 s3 state_incr H H0.
  apply (transitivity _ _ _ _ H H0).
Qed.",,,,,,,,
CompCert:RTLgen:init_state_wf,Failed,Failed,Failed,Failed,116.43,107.01,84.97,85.37,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.PArith.PArith.

Lemma pc_plt_or_none : forall (pc : positive), Plt pc 1%positive \/ (PTree.empty instruction) ! pc = None.
Proof.
  intros pc. destruct (peq pc 1%positive).
  - subst. right. apply PTree.gempty.
  - left. apply Plt_ne. auto.
Qed.",,,,,,,,
CompCert:RTLgen:add_instr_wf,Failed,Failed,Failed,Failed,96.02,121.37,73.04,73.82,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma step_pc_neq : forall (s : nat) (i : nat) (pc : nat), let n := s in pc <> n -> (pc + i) <> n.
Proof.
  intros s i pc n H.
  intro H1.
  apply H.
  rewrite H1.
  reflexivity.
Qed.",,,,,,,,
CompCert:RTLgen:add_instr_incr,Verified,Verified,Failed,Failed,112.79,108.45,75.64,76.13,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma list_map_id : forall (A : Type) (l : list A), map (fun (x : A) => x) l = l.
Proof.
  induction l; simpl; f_equal; auto.
Qed.",,,,,,,,
CompCert:RTLgen:reserve_instr_wf,Failed,Failed,Failed,Failed,107.92,105.27,72.99,74.38,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma step_lemma : forall (s : nat) (pc : nat), Plt pc (Pos.succ s) -> Plt pc s \/ pc = s.
Proof.
  intros s pc H.
  elim (st_wf s pc).
  intro H1.
  left.
  apply H1.
  intro H2.
  right.
  apply H2.
Qed.",,,,,,,,
CompCert:RTLgen:reserve_instr_incr,Verified,Abstained,Failed,Failed,114.41,0.29,75.66,76.09,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma forall_s_n_s : forall (s : nat), let n := s in n = s.
Proof. intros s n. reflexivity. Qed.",,,,,,,,
CompCert:RTLgen:update_instr_wf,Failed,Failed,Failed,Failed,121.36,109.8,73.16,73.57,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma step_plt_proof : forall (s n pc : nat), Plt n s -> Plt pc s -> (pc = n \/ Plt pc n) \/ Plt pc s.
Proof.
  intros s n pc H1 H2.
  case (peq pc n); intro.
  - subst pc. left. left. reflexivity.
  - left. right. apply Plt_ne in H. apply Nat.lt_lt_eq_dec in H2. destruct H2; [assumption | contradiction].
Qed.",,,,,,,,
CompCert:RTLgen:update_instr_incr,Failed,Failed,Failed,Failed,250.58,248.73,155.33,157.17,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma step_lt_proof : forall (s n i : nat) (LT: n < s), (i + n) < (i + s).
Proof. intros. apply Nat.add_lt_mono_r. assumption. Qed.",,,,,,,,
CompCert:RTLgen:new_reg_incr,Failed,Failed,Failed,Failed,118.94,115.75,72.34,73.08,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma state_incr_mkstate : forall (s : nat), s <= Pos.succ s.
Proof. intros s. apply Nat.le_succ_diag_r. Qed.",,,,,,,,
CompCert:Locations:slot_eq,Failed,Failed,Failed,Failed,153.11,92.39,72.27,73.03,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Peano_dec.

Lemma slot_eq : forall (p q : slot), {p = q} + {p <> q}.
Proof. decide equality. Defined.
Qed.",,,,,,,,
CompCert:Locations:typesize_pos,Failed,Failed,Failed,Failed,205.13,197.32,155.41,156.46,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.

Lemma typesize_positive : forall (ty : typ), typesize ty > 0.
Proof.
  destruct ty; compute; auto.
Qed.",,,,,,,,
CompCert:Locations:typealign_pos,Failed,Failed,Failed,Failed,107.18,118.44,72.74,73.51,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma typealign_positive : forall (ty : nat), ty > 0.
Proof. destruct ty; compute; auto. Qed.",,,,,,,,
CompCert:Locations:typealign_typesize,Failed,Failed,Failed,Failed,306.18,271.12,193.79,191.58,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import Coq.Arith.PeanoNat.

Lemma typealign_divides_typesize : forall (ty : nat), (typealign ty | typesize ty).
Proof.
  intros ty.
  exists (typesize ty / typealign ty).
  reflexivity.
Qed.",,,,,,,,
CompCert:Locations:eq,Verified,Verified,Failed,Failed,127.04,106.81,74.19,73.25,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Peano_dec.
Lemma loc_dec : forall (p q : nat), {p = q} + {p <> q}.
Proof. apply eq_nat_dec. Qed.",,,,,,,,
CompCert:Locations:same_not_diff,Failed,Failed,Failed,Failed,65.62,53.41,37.72,37.22,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Lia.

Lemma diff_irreflexive : forall (l : nat), ~(l <> l).
Proof.
  intro l.
  red.
  intro H.
  apply H.
  reflexivity.
Qed.",,,,,,,,
CompCert:Locations:diff_not_eq,Failed,Failed,Failed,Failed,129.17,112.37,78.23,75.95,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma diff_neq : forall (A : Type) (l1 l2 : list A), diff l1 l2 -> l1 <> l2.
Proof.
  intros A l1 l2 H. intro H_eq. subst l2. elim (same_not_diff l1 H).
Qed.",,,,,,,,
CompCert:Locations:diff_sym,Failed,Failed,Failed,Failed,150.61,144.97,77.84,76.3,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma diff_symmetric : forall (A : Type) (l1 l2 : list A), diff l1 l2 -> diff l2 l1.
Proof.
  intros A l1 l2 H.
  destruct H.
  destruct H.
  unfold diff.
  intuition.
Qed.",,,,,,,,
CompCert:Locations:notin_iff,Failed,Failed,Failed,Failed,169.42,141.64,76.7,76.15,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma notin_spec : forall (A : Type) (l : A) (ll : list A), 
  (forall (l' : A), In l' ll -> l <> l') <-> ~ In l ll.
Proof.
  induction ll; simpl; split; intros; try tauto.
  - intuition. apply H; auto.
  - intros l' [H1|H1]; subst; intuition.
Qed.",,,,,,,,
CompCert:Locations:notin_not_in,Failed,Failed,Failed,Failed,102.86,95.11,77.07,75.55,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Import ListNotations.

Lemma notin_not_in : forall (A : Type) (l : A) (ll : list A), notin l ll -> ~ In l ll.
Proof.
  intros A l ll H.
  red.
  intro H1.
  rewrite in_equiv in H1.
  elim (diff_not_eq l l).
  auto.
Qed.",,,,,,,,
CompCert:Locations:notin_dec,Verified,Abstained,Failed,Failed,105.86,0.23,75.78,75.98,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Definition notin {A : Type} (x : A) (l : list A) := ~ In x l.

Lemma notin_dec_template : forall (A : Type) (eq_dec : forall (x y : A), {x = y} + {x <> y}) (l : A) (ll : list A), {notin l ll} + {~ notin l ll}.
Proof.
  intros A eq_dec l ll.
  induction ll as [|x xs IHxs].
  - left. unfold notin. intros H. inversion H.
  - destruct IHxs as [H|H].
    + destruct (eq_dec l x) as [Heq|Hneq].
      * right. unfold notin. intros H1. apply H1. left.",,,,,,,,
CompCert:Locations:disjoint_cons_left,Failed,Failed,Failed,Failed,127.88,96.83,75.95,76.5,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma disjoint_cons_l : forall (A : Type) (a : A) (l1 l2 : list A), disjoint (a :: l1) l2 -> disjoint l1 l2.
Proof.
  intros A a l1 l2 H.
  unfold disjoint in *.
  intros x H1 H2.
  apply H.
  right; assumption.
  assumption.
Qed.",,,,,,,,
CompCert:Locations:disjoint_cons_right,Failed,Failed,Failed,Failed,117.9,117.58,76.29,75.48,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma disjoint_cons_r : forall (A : Type) (a : A) (l1 l2 : list A), disjoint l1 (a :: l2) -> disjoint l1 l2.
Proof.
  intros A a l1 l2 H.
  unfold disjoint in *.
  intros x H1 H2.
  apply H; auto.
  right; auto.
Qed.",,,,,,,,
CompCert:Locations:disjoint_sym,Verified,Verified,Verified,Verified,126.74,211.36,77.19,77.68,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma disjoint_sym : forall (A : Type) (l1 l2 : list A), (forall x, In x l1 -> ~ In x l2) -> (forall x, In x l2 -> ~ In x l1).
Proof.
  intros A l1 l2 H x H1 H2.
  apply (H x H2 H1).
Qed.",,,,,,,,
CompCert:Locations:in_notin_diff,Verified,Verified,Verified,Verified,130.17,140.01,77.16,76.81,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma notin_in_diff : forall (A : Type) (l1 l2 : A) (ll : list A), ~ In l1 ll -> In l2 ll -> l1 <> l2.
Proof.
  intros A l1 l2 ll H1 H2.
  intro H3.
  rewrite H3 in H1.
  contradiction.
Qed.",,,,,,,,
CompCert:Locations:notin_disjoint,Failed,Failed,Failed,Failed,139.77,123.4,76.29,75.5,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Import ListNotations.

Lemma disjoint_intro : forall (A : Type) (l1 l2 : list A), (forall (x : A), In x l1 -> ~ In x l2) -> disjoint l1 l2.
Proof.
  intros A l1 l2 H.
  red.
  intros x H1 H2.
  apply H with x; eauto.
Qed.",,,,,,,,
CompCert:Locations:disjoint_notin,Verified,Verified,Verified,Verified,140.76,146.05,78.1,77.07,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Import ListNotations.

Lemma disjoint_notin : forall (A : Type) (l1 l2 : list A) (x : A), 
  (forall x, In x l1 -> ~ In x l2) -> In x l1 -> ~ In x l2.
Proof.
  intros A l1 l2 x H H0.
  apply H; assumption.
Qed.",,,,,,,,
CompCert:Locations:norepet_dec,Verified,Verified,Verified,Verified,153.2,137.38,80.99,80.61,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma list_norepet_dec_template : forall (A : Type) (eq_dec : forall (x y : A), {x = y} + {x <> y}) (l : list A), {List.NoDup l} + {~List.NoDup l}.
Proof.
  induction l as [|x l IH].
  - left; constructor.
  - destruct IH as [H|H].
    + destruct (In_dec eq_dec x l) as [Hin|Hin].
      * right; intro H'; inversion H'; contradiction.
      * left; constructor; assumption.
    + right; intro H'; inversion H'; contradiction.
Qed.",,,,,,,,
CompCert:Locations:gss,Failed,Failed,Failed,Failed,108.48,134.94,75.59,76.46,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma set_spec : forall (A : Type) (l : list A) (v : A) (m : list A), 
  (set l v m) l = match l with
  | nil => v
  | cons h t => v
  end.
Proof.
  intros A l v m. unfold set. destruct l; reflexivity.
Qed.",,,,,,,,
CompCert:Locations:gss_reg,Failed,Failed,Failed,Failed,102.48,97.8,76.93,75.95,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma set_same_reg : forall (reg : Type) (r : reg) (v : nat) (m : reg -> nat), (fun (r' : reg) => if eq_dec r r' then v else m r') r = v.
Proof.
  intros reg r v m.
  unfold eq_dec.
  destruct (eq_dec r r) as [H|H].
  - reflexivity.
  - exfalso; apply H; reflexivity.
Qed.",,,,,,,,
CompCert:Locations:gss_typed,Failed,Failed,Failed,Failed,103.7,95.44,77.49,76.12,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma load_result_same_template : forall (l : list nat) (v m : nat), nth m l v = v.
Proof.
  intros l v m.
  destruct (lt_dec m (length l)); [apply nth_indep; auto|].
  rewrite nth_overflow by auto.
  reflexivity.
Qed.",,,,,,,,
CompCert:Locations:gso,Verified,Verified,Failed,Failed,136.95,92.85,75.07,72.98,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma loc_step_elim : forall (l v m p : nat), l = p -> l <> p -> False.
Proof. intros l v m p H1 H2. apply H2 in H1. contradiction. Qed.",,,,,,,,
CompCert:Locations:guo,Verified,Verified,Verified,Verified,124.46,122.92,80.39,77.28,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma loc_step_lemma : forall (A : Type) (ll l m : list A), 
  (forall x, In x ll -> In x l) -> (forall x, In x ll -> In x m) -> 
  (forall x, In x ll -> In x l /\ In x m).
Proof.
  intros A ll l m H1 H2 x H3.
  split; [apply H1 | apply H2]; assumption.
Qed.",,,,,,,,
CompCert:Locations:gus,Failed,Failed,Failed,Failed,131.78,104.8,79.13,75.57,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma undef_in : forall (A : Type) (ll : list (A -> nat)) (l : A) (m : A -> nat),
  In l (map (fun f x => f x) ll) -> (fold_left (fun acc f => fun x => if eq_dec x l then Vundef else acc x) ll m) l = Vundef.
Proof.
  induction ll as [|f ll IH]; simpl; intros l m H.
  - contradiction.
  - destruct H as [H|H].
    + subst. destruct (eq_dec l l); [reflexivity|contradiction].
    + apply IH. assumption.
Qed.",,,,,,,,
CompCert:Locations:getpair_exten,Failed,Failed,Failed,Failed,123.1,109.49,79.41,76.16,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma getpair_exten : forall (A : Type) (p : A) (ls1 ls2 : A -> A),
    (forall l, In l (regs_of_rpair p) -> ls2 l = ls1 l) ->
    getpair p ls2 = getpair p ls1.
Proof.
  intros A p ls1 ls2 H.
  destruct p; simpl.
  - f_equal. apply H. simpl. auto.
  - f_equal.
    + apply H. simpl. auto.
    + apply H. simpl. auto.
Qed.",,,,,,,,
CompCert:Locations:gpo,Failed,Failed,Failed,Failed,129.2,105.1,76.37,75.94,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma setpair_diff : forall p v m l,
  forall_rpair (fun r => Loc.diff l (R r)) p -> setpair p v m l = m l.
Proof. apply gpo. Qed.",,,,,,,,
CompCert:Locations:index_inj,Failed,Failed,Failed,Failed,144.03,111.36,76.31,74.47,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma index_inj : forall (x y : nat), index x = index y -> x = y.
Proof. apply Nat.index_inj. Qed.",,,,,,,,
CompCert:Locations:eq_refl,Verified,Verified,Verified,Verified,80.43,60.84,41.95,40.27,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Classes.RelationClasses.

Lemma eq_trans_poly : forall (A : Type) (x y z : A), eq x y -> eq y z -> eq x z.
Proof. apply eq_trans. Qed.",,,,,,,,
CompCert:Locations:eq_sym,Failed,Failed,Failed,Failed,69.68,61.35,40.65,38.93,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Classes.RelationClasses.

Lemma eq_sym : forall (t : Type) (x y : t), eq x y -> eq y x.
Proof. apply eq_symmetry. Qed.",,,,,,,,
CompCert:Locations:eq_trans,Verified,Verified,Failed,Failed,59.28,59.44,38.42,37.12,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma eq_trans : forall (t : Type) (x y z : t), eq x y -> eq y z -> eq x z.
Proof. intros t x y z H1 H2; rewrite H1; exact H2. Qed.",,,,,,,,
CompCert:Locations:lt_trans,Verified,Verified,Failed,Failed,114.18,110.04,72.88,73.04,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma lt_trans : forall (x y z : nat), x < y -> y < z -> x < z.
Proof. apply Nat.lt_trans. Qed.",,,,,,,,
CompCert:Locations:lt_not_eq,Verified,Verified,Verified,Verified,57.88,217.31,157.88,157.75,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Classes.RelationClasses.

Lemma lt_neq : forall (A : Type) (eq lt : A -> A -> Prop)
  (H1 : StrictOrder lt) (H2 : Equivalence eq) (H3 : subrelation lt (complement eq)),
  forall (x y : A), lt x y -> ~ eq x y.
Proof.
  intros A eq lt H1 H2 H3 x y H4 H5.
  apply H3 in H4.
  contradiction.
Qed.",,,,,,,,
CompCert:Locations:outside_interval_diff,Failed,Failed,Failed,Failed,263.82,224.89,156.44,156.75,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma loc_step_diff_bound : forall (l l' : Loc) (mr mr' : mreg),
  (l' < diff_low_bound l \/ diff_high_bound l < l') -> Loc.diff l l'.
Proof.
  intros l l' mr mr' H.
  destruct l as [r1|r1]; destruct l' as [r2|r2]; simpl in *; auto.
  destruct H; [left|right]; omega.
Qed.",,,,,,,,
CompCert:Locations:diff_outside_interval,Failed,Failed,Failed,Failed,130.17,101.5,84.61,72.81,0,0,0,0,Arithmetic,False,False,False,False,0,0,shallow,"Require Import Coq.Arith.Compare_dec.
Require Import Coq.Program.Basics.

Lemma indexed_compare_eq : forall (A : Type) (mr mr' : A) (index : A -> nat),
  (compare (index mr) (index mr')%nat eqn) = Eq -> mr = mr'.
Proof.
  intros A mr mr' index H.
  unfold compare in H.
  destruct (lt_eq_lt_dec (index mr) (index mr')) as [[Hlt|Heq]|Hgt].
  - inversion H.
  - f_equal. apply Nat.compare_eq_iff. assumption.
  - inversion H.
Qed.",,,,,,,,
CompCert:CSEdomain:rhs_compat_sym,Failed,Failed,Failed,Failed,59.81,57.71,38.32,37.23,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma rhs_compat_sym : forall (rh1 rh2 : Type), rhs_compat rh1 rh2 -> rhs_compat rh2 rh1.
Proof. intros rh1 rh2 H. destruct H. constructor. Qed.",,,,,,,,
CompCert:CSEdomain:compat_rhs_sound,Failed,Failed,Failed,Failed,79.01,62.7,40.22,38.28,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Bool.Bool.

Lemma compat_rhs_implies_rhs_compat : forall (r1 r2 : bool), compat_rhs r1 r2 = true -> rhs_compat r1 r2.
Proof.
  intros r1 r2 H.
  unfold compat_rhs in H.
  destruct r1; destruct r2; try discriminate; InvBooleans; subst; constructor.
Qed.",,,,,,,,
CompCert:CSEdomain:rhs_eval_to_compat,Failed,Failed,Failed,Failed,63.21,63.13,38.21,37.08,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import compcert.backend.RTL.
Lemma rhs_eval_compat : forall (valu : valnum -> val) (ge : genv) (sp : val) (m : mem) (rh rh' : rhs) (v : val), rhs_eval_to valu ge sp m rh v -> rhs_compat rh rh' -> rhs_eval_to valu ge sp m rh' v.
Proof.
  intros.
  inv H.
  inv H0.
  econstructor.
  eauto.
Qed.",,,,,,,,
CompCert:CSEdomain:empty_numbering_holds,Failed,Failed,Failed,Failed,57.41,60.23,38.16,36.91,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma empty_numbering_holds : forall (valu : valnum -> value) (ge : genv) (sp : val) (rs : regset) (m : mem), numbering_holds valu ge sp rs m empty_numbering.
Proof.
  intros.
  unfold numbering_holds.
  split.
  - intros.
    unfold empty_numbering in H.
    simpl in H.
    contradiction.
  - intros.
    unfold empty_numbering in H.
    rewrite PTree.gempty in H.
    discriminate.
Qed.",,,,,,,,
CompCert:CSEdomain:combine_comparison_cmp_sound,Failed,Failed,Failed,Failed,304.43,258.55,159.86,155.86,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma combine_comparison_cmp_sound : forall (valu: valnum -> val) (c : comparison) (x y : valnum) (res res' : bool), combine_comparison c x y = Some res' -> Val.cmp_bool c (valu x) (valu y) = Some res -> res = res'.
Proof.
  intros valu c x y res res' H H0.
  destruct (combine_comparison c x y) eqn:E.
  - inv H.
    destruct (Val.cmp_bool c (valu x) (valu y)) eqn:F.
    + inv H0. reflexivity.
    + inv H0.
  - inv H.
Qed.",,,,,,,,
CompCert:CSEdomain:combine_comparison_cmpu_sound,Failed,Failed,Failed,Failed,281.81,274.73,197.26,155.42,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma combine_comparison_cmpu_sound : forall (valu: valnum -> val) (m : mem) (c : comparison) (x y : valnum) (res res' : bool),
  combine_comparison c x y = Some res' ->
  Val.cmpu_bool (Mem.valid_pointer m) c (valu x) (valu y) = Some res ->
  res = res'.
Proof.
  intros valu m c x y res res' H H0.
  unfold combine_comparison in H.
  destruct (valnum_eq x y).
  - inv H.
    destruct c; simpl in H0; try discriminate; inv H0; reflexivity.
  - destruct (valnum_eq x y",,,,,,,,
CompCert:CSEdomain:combine_comparison_cmpl_sound,Failed,Failed,Failed,Failed,244.49,256.69,158.05,156.16,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma combine_comparison_cmp_sound : forall (valu: valnum -> val) (c : comparison) (x y : valnum) (res res' : bool), combine_comparison c x y = Some res' -> Val.cmp_bool c (valu x) (valu y) = Some res -> res = res'.
Proof.
  intros valu c x y res res' H H0.
  destruct (combine_comparison c x y) eqn:E; [|discriminate].
  injection H as H.
  rewrite H in *.
  destruct (Val.cmp_bool c (valu x) (valu y)) eqn:F; [|discriminate].
  injection H0 as H0.
  rewrite H0.
  re",,,,,,,,
CompCert:CSEdomain:combine_comparison_cmplu_sound,Failed,Failed,Failed,Failed,272.0,236.96,157.88,156.13,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma combine_comparison_cmplu_sound : forall (valu : valnum -> val) (m : mem) (c : comparison) (x y : valnum) (res res' : bool),
  combine_comparison c x y = Some res' -> Val.cmplu_bool (Mem.valid_pointer m) c (valu x) (valu y) = Some res -> res = res'.
Proof.
  intros valu m c x y res res' H H0.
  destruct (valu x) eqn:?; destruct (valu y) eqn:?; try discriminate.
  inv H0.
Qed.",,,,,,,,
CompCert:Inliningspec:funenv_program_compat,Failed,Failed,Failed,Failed,572.25,416.07,289.49,286.73,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Require Import Coq.MSets.MSetPositive.
Require Import Coq.PArith.PArith.
Require Import Coq.FSets.FMapPositive.

Lemma fenv_compat_update : forall (dm : PTree.t (globdef fundef unit)) (fenv : PTree.t function) (id : positive) (g : globdef fundef unit),
  (forall id f, fenv!id = Some f -> dm!id = Some (Gfun (Internal f))) ->
  forall id' f', (PTree.remove id fenv)!id' = Some f' -> (PTree.set id g dm)!id' = Some (Gfun (Internal f')).
Proof.
  intros dm fenv id g H id",,,,,,,,
CompCert:Inliningspec:fenv_compat_linkorder,Failed,Abstained,Failed,Failed,83.78,0.23,36.98,37.26,0,0,0,0,Boolean,False,False,False,False,0,0,shallow,"Require Import compcert.common.Globalenvs.
Lemma fenv_compat_linkorder : forall (cunit prog : program) (fenv : funenv), linkorder cunit prog -> fenv_compat cunit fenv -> fenv_compat prog fenv.
Proof.
  intros cunit prog fenv H H0.
  red.
  intros id fd H1.
  destruct (find_funct_ptr_inv _ _ _ H1) as [b [H2 H3]].
  inv H3.
  inv H0.
  apply H4 with (b := b).
  assumption.
Qed.",,,,,,,,
CompCert:Inliningspec:shiftpos_eq,Failed,Failed,Failed,Failed,290.28,302.78,189.93,191.09,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import Coq.PArith.BinPos.

Lemma shiftpos_eq : forall (x y : positive), Z.pos (shiftpos x y) = (Z.pos x + Z.pos y) - 1.
Proof.
  intros x y.
  unfold shiftpos.
  zify.
  rewrite ?Pos2Z.inj_add.
  rewrite ?Pos2Z.inj_sub.
  lia.
Qed.",,,,,,,,
CompCert:Inliningspec:shiftpos_inj,Failed,Failed,Failed,Failed,329.44,267.66,193.25,195.11,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import Lia.

Lemma shiftpos_injective : forall (x y : positive) (n : positive), shiftpos x n = shiftpos y n -> x = y.
Proof.
  intros x y n H.
  assert (Zpos (shiftpos x n) = Zpos (shiftpos y n)) by (rewrite H; reflexivity).
  rewrite !shiftpos_eq in H0.
  assert (Zpos x = Zpos y) by lia.
  congruence.
Qed.",,,,,,,,
CompCert:Inliningspec:shiftpos_diff,Failed,Failed,Failed,Failed,135.22,114.93,74.98,74.05,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma shiftpos_neq : forall (x y n : nat), x <> y -> shiftpos x n <> shiftpos y n.
Proof. intros x y n H. red. intros H0. apply H. eapply shiftpos_inj. eauto. Qed.",,,,,,,,
CompCert:Inliningspec:shiftpos_above,Failed,Failed,Failed,Failed,59.79,50.37,37.16,37.47,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma shiftpos_ple : forall (x n : positive), Ple n (shiftpos x n).
Proof.
  intros x n.
  unfold Ple.
  zify.
  rewrite Pos2Z.inj_add.
  extlia.
Qed.",,,,,,,,
CompCert:Inliningspec:shiftpos_not_below,Failed,Failed,Failed,Failed,132.25,117.89,76.53,77.58,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.PArith.BinPos.
Lemma shiftpos_not_below : forall (x n : positive), Plt (shiftpos x n) n -> False.
Proof. intros x n H. generalize (shiftpos_above x n). intros H0. extlia. Qed.",,,,,,,,
CompCert:Inliningspec:shiftpos_below,Failed,Failed,Failed,Failed,365.92,296.37,191.02,191.78,0,0,0,0,Misc,False,False,False,False,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import Coq.Program.Basics.

Lemma shiftpos_below : forall (x n : positive), Plt (shiftpos x n) (Pos.add x n).
Proof.
  intros x n.
  unfold shiftpos.
  zify.
  rewrite Pos2Z.inj_add.
  lia.
Qed.",,,,,,,,
CompCert:Inliningspec:shiftpos_le,Failed,Failed,Failed,Failed,308.29,266.82,193.09,190.99,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import Coq.omega.Omega.

Lemma shiftpos_ple_monotone : forall (x y n : positive), Ple x y -> Ple (shiftpos x n) (shiftpos y n).
Proof.
  intros x y n H.
  unfold Ple, shiftpos in *.
  zify.
  rewrite !Pos2Z.inj_add.
  omega.
Qed.",,,,,,,,
CompCert:Inliningspec:bind_inversion,Failed,Failed,Failed,Failed,144.4,119.83,77.26,77.03,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma bind_inversion : forall (A B : Type) (f : mon A) (g : A -> mon B) (y : B) (s1 s3 : state) (i : sincr s1 s3), bind f g s1 = R y s3 i -> exists (x : A) (s2 : state) (i1 : sincr s1 s2) (i2 : sincr s2 s3), f s1 = R x s2 i1 /\ g x s2 = R y s3 i2.
Proof.
  intros A B f g y s1 s3 i H.
  destruct (f s1) eqn:E.
  - destruct (g a s0) eqn:E2.
    + inversion H; subst.
      exists a, s0, s1, s2.
      split; auto.
    + inversion H.
  - inversion H.
Qed.",,,,,,,,
CompCert:Inliningspec:mlist_iter2_fold,Failed,Failed,Failed,Failed,148.15,231.06,158.41,157.32,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma mlist_iter2_fold : forall (A B : Type) (f : A -> B -> mon unit) (l : list (A * B)) (s : S),
  exists (i : I), mlist_iter2 f l s = R tt (fold_left (fun a p => match f (fst p) (snd p) a with R _ s2 _ => s2 end) l s) i.
Proof.
  induction l; intros s; simpl.
  - exists i0. reflexivity.
  - destruct a as [a b]. simpl.
    destruct (f a b s) as [ [] s' | ] eqn:H.
    + destruct (IHl s') as [i' IH].
      exists i'. rewrite IH. reflexivity.
 ",,,,,,,,
CompCert:Inliningspec:ptree_mfold_spec,Failed,Failed,Failed,Failed,424.18,323.67,205.72,204.74,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.PArith.BinPos.
Require Import Coq.Structures.Orders.
Require Import Coq.FSets.FMapInterface.
Require Import Coq.FSets.FMapPositive.

Lemma ptree_mfold_spec : forall (A : Type) (f : positive -> A -> mon unit) t s x s' i,
  ptree_mfold f t s = R x s' i ->
  exists i', mlist_iter2 f (PTree.elements t) s = R tt s' i'.
Proof.
  intros A f t s x s' i H.
  destruct (mlist_iter2_fold A unit f (PTree.elements t) s) as [i' EQ].
  unfold ptree_mfold in H.
  rewrite EQ in H.
  inversion H",,,,,,,,
CompCert:Inliningspec:add_moves_unchanged,Failed,Failed,Failed,Failed,366.34,206.3,160.22,158.93,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Require Import Coq.Arith.PeanoNat.

Lemma add_moves_plt : forall srcs dsts pc2 s pc1 s' i pc,
  add_moves srcs dsts pc2 s = R pc1 s' i ->
  Plt pc (st_nextnode s) ->
  Plt pc (st_nextnode s').
Proof.
  induction srcs; intros dsts pc2 s pc1 s' i pc H H0.
  - simpl in H. monadInv H. auto.
  - simpl in H. destruct dsts.
    + monadInv H. auto.
    + monadInv H. eapply IHsrcs in EQ0.
      * eapply Plt_trans; eauto.
      * eauto.
Qed.",,,,,,,,
CompCert:Inliningspec:add_moves_spec,Failed,Abstained,Failed,Failed,257.08,0.21,177.1,159.89,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Require Import Coq.Arith.PeanoNat.

Lemma add_moves_unchanged_spec : forall srcs dsts pc2 s pc1 s' i pc,
  add_moves srcs dsts pc2 s = R pc1 s' i ->
  Plt pc s.(st_nextnode) \/ Ple s'.(st_nextnode) pc ->
  s'.(st_code)!pc = s.(st_code)!pc.
Proof.
  induction srcs; intros dsts pc2 s pc1 s' i pc H H0.
  - simpl in H. monadInv H. auto.
  - simpl in H. destruct dsts; try discriminate.
    monadInv H. apply IHsrcs with (dsts := dsts) (pc2",,,,,,,,
CompCert:Inliningspec:set_instr_other,Failed,Failed,Failed,Failed,57.98,57.47,37.91,37.36,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import compcert.common.Errors.
Require Import compcert.lib.Maps.

Lemma set_instr_other : forall pc instr s x s' i pc',
  set_instr pc instr s = R x s' i -> pc' <> pc -> (st_code s') ! pc' = (st_code s) ! pc'.
Proof.
  intros pc instr s x s' i pc' H H0.
  monadInv H.
  simpl.
  apply gso.
  assumption.
Qed.",,,,,,,,
CompCert:Inliningspec:set_instr_same,Failed,Failed,Failed,Failed,277.51,237.22,157.1,156.9,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma set_instr_same_pc : forall pc instr s x s' i c,
  set_instr pc instr s = R x s' i -> c!(pc) = s'.(st_code)!(pc).
Proof.
  intros pc instr s x s' i c H.
  monadInv H.
  simpl.
  rewrite gss.
  reflexivity.
Qed.",,,,,,,,
CompCert:Inliningspec:expand_instr_unchanged,Failed,Failed,Failed,Failed,300.93,241.73,155.65,157.12,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma expand_instr_unchanged_spec : forall ctx pc instr s x s' i pc',
  expand_instr fe rec ctx pc instr s = R x s' i ->
  Ple (dpc ctx) (st_nextnode s) ->
  Plt pc' (st_nextnode s) ->
  pc' <> spc ctx pc ->
  s'.(st_code)!pc' = s.(st_code)!pc'.
Proof.
  intros ctx pc instr s x s' i pc' H H0 H1 H2.
  generalize (set_instr_other pc' (spc ctx pc) _ _ H2).
  unfold expand_instr in H.
  destruct instr; try monadInv H; eauto.
Qed.",,,,,,,,
CompCert:Inliningspec:iter_expand_instr_unchanged,Failed,Abstained,Failed,Failed,133.98,0.3,75.22,76.94,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma mlist_iter2_expand_instr_unchanged : forall (ctx : positive) (pc : positive) (l : list (positive * positive)) (s : state) (x : unit) (s' : state) (i : unit),
  mlist_iter2 (expand_instr fe rec ctx) l s = R x s' i ->
  Ple (dpc ctx) (st_nextnode s) ->
  Plt pc (st_nextnode s) ->
  ~In pc (List.map (spc ctx) (List.map (@fst positive positive) l)) ->
  list_norepet (List.map (@fst positive positive) l) ->
  (st_code s') ! pc = (st_code s) ! pc.
Proof.
  inductio",,,,,,,,
CompCert:Inliningspec:expand_cfg_rec_unchanged,Failed,Failed,Failed,Failed,343.13,276.57,179.17,181.62,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.micromega.Lia.

Lemma expand_cfg_rec_unchanged : forall ctx f s x s' i pc,
  expand_cfg_rec fe rec ctx f s = R x s' i ->
  Ple ctx.(dpc) s.(st_nextnode) ->
  Plt pc ctx.(dpc) ->
  s'.(st_code)!pc = s.(st_code)!pc.
Proof.
  intros ctx f s x s' i pc H H0 H1.
  unfold expand_cfg_rec in H.
  monadInv H.
  inversion EQ.
  transitivity ((st_code s0)!pc).
  - exploit ptree_mfold_spec; eauto.
  - eapply iter_expand_instr_u",,,,,,,,
CompCert:Inliningspec:min_alignment_pos,Failed,Failed,Failed,Failed,56.18,47.77,36.97,37.3,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"```coq
Require Import Lia.

Lemma min_alignment_positive : forall (sz : nat), min_alignment sz > 0.
Proof.
  intro sz.
  unfold min_alignment.
  destruct sz.
  - lia.
  - destruct n.
    + lia.
    + destruct n.
      * lia.
      * lia.
Qed.
```.
Qed.",,,,,,,,
CompCert:Inliningspec:expand_cfg_unchanged,Failed,Failed,Failed,Failed,241.19,243.04,157.1,159.29,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma expand_cfg_unchanged_general : forall fe ctx f s x s' i pc,
  expand_cfg fe ctx f s = R x s' i ->
  Ple (dpc ctx) (st_nextnode s) ->
  Plt pc (dpc ctx) ->
  (st_code s') ! pc = (st_code s) ! pc.
Proof.
  intros.
  pattern fe.
  eapply expand_cfg_rec_unchanged.
  eauto.
  assumption.
  assumption.
Qed.",,,,,,,,
CompCert:Inliningspec:tr_function_linkorder,Failed,Failed,Failed,Failed,141.03,118.28,77.69,76.28,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma tr_function_linkorder : forall (cunit prog : Type) (f f' : Type), linkorder cunit prog -> tr_function cunit f f' -> tr_function prog f f'.
Proof.
  intros.
  inv H0.
  econstructor.
  eauto.
  eapply fenv_compat_linkorder.
  eauto.
Qed.",,,,,,,,
CompCert:Inliningspec:transf_function_spec,Failed,Abstained,Failed,Failed,130.85,0.26,77.69,76.24,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma transf_function_tr_function : forall (cunit : Type) (f f' : Type), transf_function (funenv_program cunit) f = OK f' -> tr_function cunit f f'.
Proof.
  intros cunit f f' H.
  set (fenv := funenv_program cunit) in *.
  unfold transf_function in H.
  destruct (zlt _ _); try discriminate.
  destruct (zle _ _); try discriminate.
  monadInv H.
  set (ctx := initcontext _ _ (max_reg_function f)) in *.
  Opaque initstate.
  constructor.
Qed.",,,,,,,,
CompCert:Selectionproof:record_globdefs_sound,Failed,Abstained,Failed,Failed,477.66,0.06,320.4,257.04,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.MSets.MSetPositive.
Require Import Coq.MSets.MSetProperties.
Require Import Coq.MSets.MSetFacts.

Lemma record_globdefs_spec : forall (dm : PTree.t positive) (id : positive) (gd : positive),
  (record_globdefs dm) ! id = Some gd -> dm ! id = Some gd.
Proof.
  intros dm id gd.
  set (f := fun (m : PTree.t positive) (id0 : positive) (gd0 : positive) =>
    if PositiveSet.mem id0 (record_globdefs_obligation_1 gd0)
    then m
    else PTree.remove id0 m) in *.
  set (P := fun (m m",,,,,,,,
CompCert:Selectionproof:lookup_helper_correct_1,Failed,Abstained,Failed,Failed,65.34,0.09,162.1,156.31,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Lists.List.
Require Import Coq.Strings.String.
Require Import Coq.Logic.Eqdep_dec.

Inductive external_function : Type :=
  | EF_runtime : string -> list string -> external_function.

Inductive fundef : Type :=
  | External : external_function -> fundef.

Inductive globdef : Type :=
  | Gfun : fundef -> globdef.

Definition lookup_helper (globs : list (string * globdef)) (name : string) (sg : list string) : option string :=
  match List.find (fun '(id, g) => match g wit",,,,,,,,
CompCert:Selectionproof:lookup_helper_correct,Failed,Failed,Failed,Failed,300.91,247.64,214.1,158.21,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma lookup_helper_correct : forall p name sg id, lookup_helper (record_globdefs (prog_defmap p)) name sg = OK id -> helper_declared p id name sg.
Proof. apply lookup_helper_correct. Qed.",,,,,,,,
CompCert:Selectionproof:get_helpers_correct,Failed,Failed,Failed,Failed,236.08,215.58,260.81,158.12,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma get_helpers_correct : forall p hf, get_helpers (prog_defmap p) = OK hf -> helper_functions_declared p hf.
Proof.
  intros p hf H.
  monadInv H.
  red.
  simpl.
  auto.
Qed.",,,,,,,,
CompCert:Selectionproof:transf_program_match,Failed,Failed,Failed,Failed,263.92,221.01,185.61,157.1,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma transf_program_match : forall p tp, sel_program p = OK tp -> match_prog p tp.
Proof.
  intros p tp H.
  monadInv H.
  eapply match_transform_partial_program_contextual.
  eexact EQ0.
  intros.
  exists (fun x => x).
  split; auto.
Qed.",,,,,,,,
CompCert:Selectionproof:helper_functions_declared_linkorder,Failed,Failed,Failed,Failed,136.91,132.72,87.89,76.01,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma helper_declared_inversion : forall (A B : Type) (p p' : list (A * B)) (id : A) (name : B) (sg : B),
  (exists fd, In (id, fd) p /\ name = sg) -> (exists fd, In (id, fd) p' /\ name = sg) -> p = p'.
Proof.
  intros A B p p' id name sg H H0.
  destruct H as [fd [H H1]].
  destruct H0 as [fd' [H2 H3]].
  induction p as [|x xs IHxs].
  - inversion H.
  - destruct x as [a b].
    simpl in H.
    destruct H as [H|H].
    + inversion H; subst.
",,,,,,,,
CompCert:Selectionproof:wt_prog,Failed,Failed,Failed,Failed,143.28,109.98,77.51,75.88,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma list_forall2_in_left_exploit : forall (A B : Type) (R : A -> B -> Prop) (x : A) (l1 : list A) (l2 : list B),
  list_forall2 R l1 l2 -> In x l1 -> exists y : B, In y l2 /\ R x y.
Proof.
  intros A B R x l1 l2 H H0.
  exploit @list_forall2_in_left; eauto.
Qed.",,,,,,,,
CompCert:Selectionproof:symbols_preserved,Failed,Failed,Failed,Failed,130.56,118.45,76.33,76.23,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma function_ptr_translated : forall (ge tge : Genv.t fundef unit) (b : block) (f : fundef),
  Genv.find_funct_ptr ge b = Some f ->
  exists (transf_fundef : fundef -> fundef) (prog : list (ident * globdef fundef unit)),
  Genv.find_funct_ptr tge b = Some (transf_fundef f) /\ Genv.globalenv prog = tge.
Proof.
  intros ge tge b f H.
  exists (fun x => x), nil.
  split; auto.
Qed.",,,,,,,,
CompCert:Selectionproof:senv_preserved,Failed,Failed,Failed,Failed,150.04,122.12,77.33,76.07,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma function_ptr_translated : forall (b : block) (f : Cminor.fundef) (ge tge : Genv.t Cminor.fundef unit) (cu : comp_unit) (tf : Cminor.fundef),
  Genv.find_funct_ptr ge b = Some f ->
  exists tf : Cminor.fundef, Genv.find_funct_ptr tge b = Some tf /\ match_fundef cu f tf.
Proof.
  intros.
  exists tf.
  split; auto.
Qed.",,,,,,,,
CompCert:Selectionproof:function_ptr_translated,Failed,Failed,Failed,Failed,162.49,101.72,102.73,76.14,0,0,0,0,Misc,False,False,False,False,0,0,shallow,"Require Import Coq.Program.Basics.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma functions_translated : forall (ge tge : Genv.t fundef unit) (cu : program) (v v' : val) (f tf : fundef),
  Genv.find_funct ge v = Some f ->
  Val.lessdef v v' ->
  (exists cunit, Genv.find_funct tge v' = Some tf /\ match_fundef cu f tf /\ linkorder cunit cu).
Proof.
  intros ge tge cu v v' f tf Hfind Hlessdef.
  destruct Hlessdef.
  - rewrite H in Hfind. discriminate.
  - rewrite H in Hfind. inversion ",,,,,,,,
CompCert:Selectionproof:functions_translated,Failed,Failed,Failed,Failed,135.51,105.02,114.72,75.52,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma step_inv_external : forall (ge : Genv.t (fundef unit) unit) (v v' : val) (f : fundef unit) (args : list val) (t : trace) (m : mem) (m' : mem),
  Genv.find_funct ge v = Some f -> external_call f args m t v' m' -> exists b ofs, v = Vptr b ofs.
Proof.
  intros. inv H0. eapply Genv.find_funct_inv in H. destruct H as [b [ofs H]]. exists b, ofs. assumption.
Qed.",,,,,,,,
CompCert:Selectionproof:sig_function_translated,Failed,Failed,Failed,Failed,113.71,132.88,86.75,75.65,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma match_fundef_funsig : forall cu f tf, match_fundef cu f tf -> funsig tf = Cminor.funsig f.
Proof.
  intros cu f tf H.
  destruct H; monadInv H; monadInv EQ; auto.
Qed.",,,,,,,,
CompCert:Selectionproof:stackspace_function_translated,Failed,Failed,Failed,Failed,255.04,252.66,172.24,158.4,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma sel_function_stackspace : forall dm hf f tf, sel_function dm hf f = OK tf -> fn_stackspace tf = Cminor.fn_stackspace f.
Proof.
  intros. monadInv H. auto.
Qed.",,,,,,,,
CompCert:Selectionproof:helper_functions_preserved,Failed,Failed,Failed,Failed,145.46,118.69,77.84,76.97,0,0,0,0,Misc,False,False,False,False,0,0,shallow,"Require Import Coq.Lists.List.
Lemma helper_functions_declared_transfer : forall (prog tprog : program) (hf : ident),
  (forall id name sg, helper_declared prog id name sg -> helper_declared tprog id name sg) ->
  helper_functions_declared prog hf -> helper_functions_declared tprog hf.
Proof.
  intros prog tprog hf H H0.
  unfold helper_functions_declared in *.
  destruct H0 as [name [sg [id [H1 H2]]]].
  exists name, sg, id.
  split; [apply H; exact H1|exact H2].
Qed.",,,,,,,,
CompCert:Selectionproof:eval_condexpr_of_expr,Failed,Failed,Failed,Failed,289.55,273.33,178.42,157.4,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma eval_condexpr_of_expr : forall tge sp e m a le v b,
  eval_expr tge sp e m le a v -> Val.bool_of_val v b -> eval_condexpr tge sp e m le (condexpr_of_expr a) b.
Proof.
  intros tge sp e m a le v b H H0.
  functional induction (condexpr_of_expr a); inv H; econstructor; eauto; simpl in *; inv H6; apply bool_of_val_of_optbool.
Qed.",,,,,,,,
CompCert:Selectionproof:eval_condition_of_expr,Failed,Failed,Failed,Failed,142.5,232.86,161.46,157.06,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma eval_expr_condition_template : forall (A : Type) (tge sp e m le : A) (a : A) (v : A),
  eval_expr tge sp e m le a v -> Val.lessdef (Val.of_optbool (condition_of_expr a)) v.
Proof.
  intros A tge sp e m le a v H.
  functional induction (condition_of_expr a); simpl; try (inv H; eauto).
  - inv H. exists v; split; auto.
  - inv H6.
Qed.",,,,,,,,
CompCert:Selectionproof:eval_load,Failed,Failed,Failed,Failed,140.99,248.65,161.33,157.26,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma eval_load_generalized : forall (tge : Type) (sp e m : Type) (le : list Type) (a : Type) (v chunk v' : Type),
  eval_expr tge sp e m le a v -> Mem.loadv chunk m v = Some v' -> eval_expr tge sp e m le (load chunk a) v'.
Proof.
  intros.
  generalize H0.
  destruct v.
  simpl.
  intro.
  try discriminate.
  unfold load.
  generalize (eval_addressing tge sp e m le a v chunk v' H).
  destruct (eval_addressing tge sp e m le a v chunk v' H).
  intro.
  assumption.
Q",,,,,,,,
CompCert:Selectionproof:eval_store,Failed,Failed,Failed,Failed,161.17,118.86,80.98,77.15,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma eval_store_generalized : forall (chunk : memory_chunk) (a1 a2 : expr) (v1 v2 : val) (f : function) (k : cont) (m' : mem),
  eval_expr tge sp e m nil a1 v1 ->
  eval_expr tge sp e m nil a2 v2 ->
  Mem.storev chunk m v1 v2 = Some m' ->
  step tge (State f (store chunk a1 a2) k sp e m) E0 (State f Sskip k sp e m').
Proof.
  intros chunk a1 a2 v1 v2 f k m' H H0 H1.
  generalize H1.
  destruct v1; try discriminate.
  simpl in H1.
  intro H2.
  unfold store.
  gene",,,,,,,,
CompCert:Selectionproof:eval_sel_unop,Failed,Failed,Failed,Failed,113.52,270.82,161.78,156.99,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma eval_sel_unop : forall (tge : genv) (sp : val) (e : env) (m : mem) (le : temp_env) (op : unary_operation) (a1 : expr) (v1 v : val),
  eval_expr tge sp e m le a1 v1 ->
  eval_unop op v1 = Some v ->
  exists v' : val, eval_expr tge sp e m le (sel_unop op a1) v' /\ Val.lessdef v v'.
Proof.
  intros tge sp e m le op a1 v1 v H H0.
  destruct v1; try discriminate.
  simpl in H0.
  FuncInv.
  try subst v.
  eexists; split; eauto.
  eapply eval_unop_lessdef; eauto.
 ",,,,,,,,
CompCert:Selectionproof:eval_sel_binop,Failed,Failed,Failed,Failed,110.17,216.19,157.93,156.56,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma eval_sel_binop : forall (le : list val) (op : binary_operation) (a1 a2 : expr) (v1 v2 v : val),
  eval_expr tge sp e m le a1 v1 ->
  eval_expr tge sp e m le a2 v2 ->
  eval_binop op v1 v2 m = Some v ->
  exists v' : val, eval_expr tge sp e m le (sel_binop op a1 a2) v' /\ Val.lessdef v v'.
Proof.
  intros.
  FuncInv.
  try subst v.
  eauto.
  eauto.
  eauto.
Qed.",,,,,,,,
CompCert:Selectionproof:eval_sel_select,Failed,Failed,Failed,Failed,114.26,265.64,158.96,156.56,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma eval_sel_select : forall (tge : genv) (sp : val) (e : env) (m : mem) (le : temp_env) (a1 a2 a3 : expr) (v1 v2 v3 : val) (b : bool) (ty : typ),
  eval_expr tge sp e m le a1 v1 -> eval_expr tge sp e m le a2 v2 -> eval_expr tge sp e m le a3 v3 -> Val.bool_of_val v1 b ->
  exists v : val, eval_expr tge sp e m le (sel_select ty a1 a2 a3) v /\ Val.lessdef (Val.select (Some b) v2 v3 ty) v.
Proof.
  intros.
  specialize (eval_condition_of_expr _ _ _ _ H H2).
  destru",,,,,,,,
CompCert:Selectionproof:eval_sel_known_builtin,Failed,Failed,Failed,Failed,266.4,262.22,196.59,156.72,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma eval_sel_known_builtin : forall bf args a vl v le,
  sel_known_builtin bf args = Some a ->
  eval_exprlist tge sp e m le args vl ->
  builtin_function_sem bf vl = Some v ->
  exists v', eval_expr tge sp e m le a v' /\ Val.lessdef v v'.
Proof.
  intros bf args a vl v le H H0 H1.
  destruct bf; try discriminate.
  inv H0; try discriminate.
  inv H; try discriminate.
  exists v; split; auto.
  apply Val.lessdef_refl.
Qed.",,,,,,,,
CompCert:Selectionproof:expr_is_addrof_ident_correct,Failed,Failed,Failed,Failed,275.27,253.56,171.6,156.95,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Ptr.Ptrofs.
Require Import compcert.cminor.Cminor.

Lemma expr_is_addrof_ident_correct : forall e id,
  expr_is_addrof_ident e = Some id ->
  e = Cminor.Econst (Cminor.Oaddrsymbol id Ptrofs.zero).
Proof.
  intros e id H.
  unfold expr_is_addrof_ident in H.
  destruct e; try congruence.
  destruct o; try congruence.
  predSpec Ptrofs.eq Ptrofs.eq_spec i Ptrofs.zero; congruence.
Qed.",,,,,,,,
CompCert:Selectionproof:sel_switch_correct_rec,Failed,Failed,Failed,Failed,299.91,231.71,168.21,157.52,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma sel_switch_correct_rec : forall sp e m varg i x,
  R i varg ->
  forall t arg le,
  wf_comptree modulus t ->
  nth_error le arg = Some varg ->
  comptree_match modulus i t = Some x ->
  eval_exitexpr tge sp e m le (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int arg t) x.
Proof.
  induction t; intros arg le WF NTH MATCH; inv WF; inv MATCH; constructor.
Qed.",,,,,,,,
CompCert:Selectionproof:sel_switch_correct,Failed,Failed,Failed,Failed,275.85,256.27,161.68,166.95,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma sel_switch_correct_generalized : forall modulus dfl cases arg sp e m varg i t le,
  validate_switch modulus dfl cases t = true ->
  eval_expr tge sp e m le arg varg ->
  R i varg ->
  0 <= i < modulus ->
  eval_exitexpr tge sp e m le (XElet arg (sel_switch make_cmp_eq make_cmp_ltu make_sub make_to_int O t)) (switch_target i dfl cases).
Proof.
  intros.
  exploit validate_switch_correct; eauto.
  lia.
  intros.
  econstructor; e",,,,,,,,
CompCert:Selectionproof:sel_switch_int_correct,Failed,Failed,Failed,Failed,432.93,339.49,194.46,191.02,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import Coq.Arith.Compare_dec.

Lemma sel_switch_int_correct_template : forall (dfl : nat) (cases : list (Z * nat)) (arg : expr) (sp : val) (e : env) (m : mem) (i : int) (t : comptree) (le : temp_env),
  validate_switch Int.modulus dfl cases t = true ->
  eval_expr tge sp e m le arg (Vint i) ->
  eval_exitexpr tge sp e m le (XElet arg (sel_switch_int O t)) (switch_target (Int.unsigned i) dfl cases).
Proof. intros; eapply sel_switch_int_correct; eauto. Qed",,,,,,,,
CompCert:Selectionproof:sel_switch_long_correct,Failed,Abstained,Failed,Failed,166.53,0.27,159.75,158.75,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma sel_switch_long_correct_template : forall (dfl : nat) (cases : list (Z * nat)) (arg : nat) (sp : nat) (e : list nat) (m : nat) (i : int64) (t : nat) (le : list nat),
  validate_switch Int64.modulus dfl cases t = true ->
  eval_expr tge sp e m le arg (Vlong i) ->
  eval_exitexpr tge sp e m le (XElet arg (sel_switch_long O t)) (switch_target (Int64.unsigned i) dfl cases).
Proof.
  intros until le.
  intros VALID EVAL.
  eapply sel_switch_",,,,,,,,
CompCert:Selectionproof:eval_unop_lessdef,Failed,Failed,Failed,Failed,504.84,260.19,158.93,157.51,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import compcert.common.Values.

Lemma eval_unop_lessdef : forall op v1 v1' v,
  eval_unop op v1 = Some v -> Val.lessdef v1 v1' ->
  exists v', eval_unop op v1' = Some v' /\ Val.lessdef v v'.
Proof.
  intros op v1 v1' v EV LD.
  inversion LD; subst.
  - exists v. split; auto.
  - destruct op; simpl in *; try discriminate.
    + destruct v1; try discriminate.
      inv EV. eexists; split; eauto.
    + destruct v1; try discriminate.
      inv EV. eexists; spl",,,,,,,,
CompCert:Selectionproof:eval_binop_lessdef,Failed,Failed,Failed,Failed,441.36,291.79,158.79,159.43,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Arith.PeanoNat.
Require Import Coq.Lists.List.
Lemma eval_binop_lessdef : forall op v1 v1' v2 v2' v m m',
  eval_binop op v1 v2 m = Some v ->
  Val.lessdef v1 v1' -> Val.lessdef v2 v2' -> Mem.extends m m' ->
  exists v', eval_binop op v1' v2' m' = Some v' /\ Val.lessdef v v'.
Proof.
  intros op v1 v1' v2 v2' v m m' EVAL LD1 LD2 EXT.
  assert (exists v', eval_binop op v1' v2' m' = Some v' /\ Val.lessdef v v') as H.
  { inv LD1; inv LD2; try (eexi",,,,,,,,
CompCert:Selectionproof:set_var_lessdef,Failed,Failed,Failed,Failed,260.73,125.24,73.46,73.34,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma env_lessdef_lookup : forall (e1 e2 : nat -> nat) (id v1 v2 : nat), (forall x, e1 x = e2 x) -> e1 id = v1 -> exists v2 : nat, e2 id = v2 /\ v1 = v2.
Proof.
  intros e1 e2 id v1 v2 H H0.
  red in H.
  rewrite H0.
  exists (e2 id).
  split.
  - reflexivity.
  - rewrite H.
    reflexivity.
Qed.",,,,,,,,
CompCert:Selectionproof:set_optvar_lessdef,Failed,Failed,Failed,Failed,160.99,141.24,73.8,73.38,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma env_lessdef_val_lessdef : forall (e1 e2 : nat) (optid v1 v2 : nat), e1 = e2 -> v1 = v2.
Proof. intros; subst; auto. Qed.",,,,,,,,
CompCert:Selectionproof:set_params_lessdef,Verified,Abstained,Failed,Failed,178.51,0.27,76.56,76.71,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma val_step_induction : forall (il : list nat) (vl1 vl2 : list nat),
  (forall n, In n il -> nth n vl1 0 = nth n vl2 0) -> 
  (forall n, In n il -> nth n vl1 0 = nth n vl2 0).
Proof.
  induction il; intros vl1 vl2 H n HIn.
  - inversion HIn.
  - simpl in HIn. destruct HIn as [HIn | HIn].
    + subst. apply H. left. reflexivity.
    + apply IHil with (vl1 := vl1) (vl2 := vl2).
      * intros n0 HIn0. apply H. right. assumption.
      * assu",,,,,,,,
CompCert:Selectionproof:set_locals_lessdef,Failed,Failed,Failed,Failed,166.94,127.59,75.96,76.18,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma set_locals_lessdef : forall (e1 e2 : list (positive * type)) (il : list (positive * type)),
    env_lessdef e1 e2 -> env_lessdef (set_locals il e1) (set_locals il e2).
Proof.
  induction il; simpl; auto.
  intros H; apply IHil; constructor; auto.
Qed.",,,,,,,,
CompCert:Selectionproof:sel_expr_correct,Failed,Failed,Failed,Failed,181.72,138.73,77.22,76.19,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma forall_exists_split : forall (A B : Type) (P : A -> B -> Prop) (l : list A),
  (forall x, In x l -> exists y, P x y) -> exists f, forall x, In x l -> P x (f x).
Proof.
  intros A B P l H. induction l as [|a l IH].
  - exists (fun _ => match H with end). intros x H0. inversion H0.
  - destruct IH as [f Hf]. 
    { intros x Hx. apply H. right. assumption. }
    destruct (H a) as [b Hb].
    { left. reflexivity. }
    exists (fun x => if i",,,,,,,,
CompCert:Selectionproof:sel_exprlist_correct,Failed,Failed,Failed,Failed,187.19,135.56,112.79,76.25,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma sel_expr_correct_template : forall sp e m a v,
  (exists v', eval_expr sp e m a v' /\ v' = v) ->
  exists v', eval_expr sp e m a v' /\ v' = v.
Proof.
  intros sp e m a v H.
  destruct H as [v' [H1 H2]].
  exists v'. split; [assumption | assumption].
Qed.",,,,,,,,
CompCert:Selectionproof:sel_builtin_arg_correct,Failed,Failed,Failed,Failed,332.48,269.85,222.59,157.12,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma sel_expr_correct_generalized : forall sp e e' m m' a v c,
  env_lessdef e e' ->
  Mem.extends m m' ->
  eval_expr ge sp e m a v ->
  exists v', eval_expr tge sp e' m' (sel_expr a) v' /\ Val.lessdef v v'.
Proof.
  intros sp e e' m m' a v c H H0 H1.
  exploit sel_expr_correct; eauto.
  intros [v' [H2 H3]].
  exists v'; split; auto.
Qed.",,,,,,,,
CompCert:Selectionproof:sel_builtin_res_correct,Failed,Failed,Failed,Failed,154.31,130.9,137.68,76.79,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma env_lessdef_map_extends : forall (A B : Type) (v v' : A) (e e' : list (A * B)) (oid : nat),
    env_lessdef e e' -> env_lessdef ((oid, v) :: e) ((oid, v') :: e').
Proof.
  intros A B v v' e e' oid H.
  constructor; [constructor|exact H].
Qed.",,,,,,,,
CompCert:Selectionproof:eventually_step,Failed,Abstained,Failed,Failed,152.76,0.29,179.37,158.81,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Logic.Classical.
Lemma eventually_later_lemma : forall (A : Type) (P : A -> Prop) (f s k sp e m n : A), (forall t S', P t -> P S') -> P n.
Proof.
  intros A P f s k sp e m n H.
  apply H with (t := n) (S' := n).
  assumption.
Qed.",,,,,,,,
CompCert:Selectionproof:classify_stmt_wt,Failed,Failed,Failed,Failed,321.1,299.04,243.0,157.08,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma classify_stmt_wt : forall env tyret id a s,
  classify_stmt s = SCassign id a ->
  wt_stmt env tyret s ->
  wt_expr env a (env id).
Proof.
  induction s; simpl; intros; try discriminate.
  - destruct e; try discriminate.
    destruct (ident_eq i i0); inv H.
    inv H0. auto.
  - destruct o; try discriminate.
    inv H. inv H0. auto.
Qed.",,,,,,,,
CompCert:Selectionproof:match_states_skip,Failed,Abstained,Failed,Failed,172.27,0.33,118.49,76.0,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma match_states_skip : forall (cunit prog : Type) (hf f f' : Type) (k k' : Type) (sp : Type) (e e' : Type) (m m' : Type) (env : Type) (LINK : linkorder cunit prog) (HF : helper_functions_declared cunit hf) (TF : sel_function (prog_defmap cunit) hf f = OK f') (TYF : type_function f = OK env) (MC : match_cont cunit hf (known_id f) env k k') (LD : env_lessdef e e') (ME : Mem.extends m m'), match_states (Cminor.State f Cminor.Sskip k sp e m) (State f' Sskip k' sp e'",,,,,,,,
CompCert:Selectionproof:call_cont_commut,Failed,Failed,Failed,Failed,139.14,137.85,102.12,76.0,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma match_cont_call_cont_commut : forall (cunit hf ki env : Type) (k k' : Type),
  match_cont cunit hf ki env k k' -> match_call_cont (Cminor.call_cont k) (call_cont k').
Proof.
  intros.
  induction H; simpl; auto.
  inversion H; subst; auto.
Qed.",,,,,,,,
CompCert:Selectionproof:match_is_call_cont,Failed,Failed,Failed,Failed,175.25,148.85,118.87,76.31,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma match_is_call_cont_poly : forall (A B : Type) (cunit : A) (hf : B) (ki : nat) (env : list B) (k k' : nat),
  match_cont cunit ki env hf k k' -> Cminor.is_call_cont k ->
  match_call_cont k k' /\ is_call_cont k'.
Proof.
  intros A B cunit hf ki env k k' H H0.
  inv H.
  try contradiction.
  split; auto.
Qed.",,,,,,,,
CompCert:Selectionproof:classify_stmt_nolabel,Failed,Failed,Failed,Failed,158.84,137.11,81.94,76.28,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma classify_stmt_nolabel : forall (s : stmt), classify_stmt s <> SCother -> nolabel s.
Proof.
  induction s; simpl; intros H; try congruence;
  repeat (red; auto).
Qed.",,,,,,,,
CompCert:Selectionproof:if_conversion_base_nolabel,Failed,Failed,Failed,Failed,65.75,71.95,38.92,37.0,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import compcert.common.AST.
Lemma if_conversion_base_nolabel : forall (hf: helper_functions) (ki: option typ) (env: unit) (a: expr) (id: ident) (a1 a2: stmt) (kont: stmt) (s: stmt), if_conversion_base ki env a id a1 a2 kont = Some s -> nolabel' s.
Proof.
  intros.
  destruct (if_conversion_base ki env a id a1 a2 kont) eqn:E.
  - inv H. red. auto.
  - discriminate.
Qed.",,,,,,,,
CompCert:Selectionproof:if_conversion_nolabel,Failed,Failed,Failed,Failed,150.23,133.85,78.8,75.78,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma if_conversion_nolabel : forall (hf : helper_functions) (ki : nat) (env : list nat) (a : nat) (s1 s2 : stmt) (kont : option stmt) (s : stmt),
  if_conversion ki env a s1 s2 kont = Some s -> nolabel s1 /\ nolabel s2 /\ nolabel' s.
Proof.
  intros hf ki env a s1 s2 kont s H.
  unfold if_conversion in H.
  conclude.
  split; [apply classify_stmt_nolabel; congruence|].
  split; [apply classify_stmt_nolabel; congruence|].
  eapply if_conversi",,,,,,,,
CompCert:Selectionproof:sel_builtin_nolabel,Failed,Failed,Failed,Failed,146.1,147.2,78.15,75.79,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma sel_builtin_nolabel : forall (helper_functions : Type) (optid : option nat) (ef : nat) (args : list nat), nolabel' (sel_builtin optid ef args).
Proof.
  intros hf optid ef args.
  unfold sel_builtin.
  red.
  intros.
  destruct optid as [id|].
  - destruct ef; auto.
  - destruct ef; auto.
Qed.",,,,,,,,
CompCert:Selectionproof:sel_initial_states,Failed,Failed,Failed,Failed,138.15,284.39,173.15,158.29,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma function_ptr_translated_init_mem_match : forall (S : Type) (TRANSF : S -> Prop) (f : S) (v : S),
  (forall (x : S), TRANSF x -> exists y : S, y = x) ->
  TRANSF f -> TRANSF v -> exists (g : S) (ptr : S), g = f /\ ptr = v.
Proof.
  intros S TRANSF f v Htransf Hf Hv.
  exploit Htransf; eauto.
  intros [g Hg].
  exploit Htransf; eauto.
  intros [ptr Hptr].
  exists g, ptr.
  split; assumption.
Qed.",,,,,,,,
CompCert:Selectionproof:sel_final_states,Failed,Failed,Failed,Failed,84.6,284.26,193.97,156.51,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma match_states_transitive : forall (S R : Type) (r : R), match_states S R -> match_states R S -> match_states S S.
Proof.
  intros S R r H H0.
  inv H0.
  inv H.
  inv MC.
  inv LD.
  constructor.
Qed.",,,,,,,,
CompCert:Selectionproof:transf_program_correct,Failed,Failed,Failed,Failed,151.92,283.07,172.07,158.0,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Logic.Classical.

Lemma forward_simulation_template : forall (ge tge : Type) (S S1 S2 : Type) (t : Type) (RTL_step LTL_step : Type -> Type -> Type -> Prop) (match_states wt_state : Type -> Type -> Prop) (wt_initial_state sel_initial_states : Type -> Prop) (senv_preserved : Prop),
  senv_preserved ->
  (forall S0, wt_initial_state S0 -> wt_state S0) ->
  (forall S0 INIT, sel_initial_states S0 -> exists S0', match_states S0 S0' /\ wt_state S0) ->
  (forall S1 t S2, RTL_step ge S",,,,,,,,
CompCert:SplitLongproof:eval_helper,Failed,Failed,Failed,Failed,118.08,294.01,180.87,157.38,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma eval_helper : forall (ge : Genv.t (fundef unit) unit) (sp : val) (e : env) (m : mem) (bf : builtin_function) (le : temp_env) (id : ident) (name : string) (sg : signature) (args : exprlist) (vargs : list val) (vres : val),
  eval_exprlist ge sp e m le args vargs ->
  helper_declared prog id name sg ->
  lookup_builtin_function name sg = Some bf ->
  builtin_function_sem bf vargs = Some vres ->
  eval_expr ge sp e m le (Eexternal id sg args) vres.
Proof.
  intr",,,,,,,,
CompCert:SplitLongproof:eval_helper_1,Failed,Failed,Failed,Failed,118.11,269.66,170.97,156.94,0,0,0,0,Misc,False,False,False,False,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_helper_1 : forall (ge : genv) (sp : val) (e : env) (m : mem) (prog : program) (bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (arg1 : expr) (varg1 : val) (vres : val),
  eval_expr ge sp e m le arg1 varg1 ->
  helper_declared prog id name sg ->
  lookup_builtin_function name sg = Some bf ->
  builtin_function_sem bf (varg1 :: nil) = Some vres ->
  eval_expr ge sp e m le (Eexternal id sg (arg1 ::: ",,,,,,,,
CompCert:SplitLongproof:eval_helper_2,Failed,Failed,Failed,Failed,130.3,276.05,163.77,157.01,0,0,0,0,Misc,False,False,False,False,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_helper_2 : forall (ge : genv) (sp : val) (e : env) (m : mem) (prog : program) (bf : builtin_function) (le : letenv) (id : ident) (name : ident) (sg : signature) (arg1 arg2 : expr) (varg1 varg2 vres : val),
  eval_expr ge sp e m le arg1 varg1 ->
  eval_expr ge sp e m le arg2 varg2 ->
  helper_declared prog id name sg ->
  lookup_builtin_function name sg = Some bf ->
  builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres ->
  ",,,,,,,,
CompCert:SplitLongproof:eval_builtin_1,Failed,Failed,Failed,Failed,140.47,286.68,160.52,156.87,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_builtin_1 : forall (ge : genv) (sp : val) (e : env) (m : mem) (bf : builtin_function) (le : letenv) (id : ident) (sg : signature) (arg1 : expr) (varg1 vres : val),
  eval_expr ge sp e m le arg1 varg1 ->
  lookup_builtin_function id sg = Some bf ->
  builtin_function_sem bf (varg1 :: nil) = Some vres ->
  eval_expr ge sp e m le (Ebuiltin (EF_builtin id sg) (arg1 ::: Enil)) vres.
Proof.
  intros.
  econstructor; eauto.
  constructor;",,,,,,,,
CompCert:SplitLongproof:eval_builtin_2,Failed,Failed,Failed,Failed,139.34,272.69,187.4,156.87,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_builtin_2 : forall (ge : genv) (sp : val) (e : env) (m : mem) (bf : builtin_function) (le : letenv) (id : ident) (sg : signature) (arg1 arg2 : expr) (varg1 varg2 vres : val),
  eval_expr ge sp e m le arg1 varg1 ->
  eval_expr ge sp e m le arg2 varg2 ->
  lookup_builtin_function id sg = Some bf ->
  builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres ->
  eval_expr ge sp e m le (Ebuiltin (EF_builtin id sg) (arg1 ::: arg2 :::",,,,,,,,
CompCert:SplitLongproof:eval_splitlong,Failed,Abstained,Failed,Abstained,143.12,0.26,180.07,0.43,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_splitlong_general : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : temp_env) (a : expr) (f : expr -> expr -> expr) (v : val) (sem : val -> val),
  (forall (le : temp_env) (a b : expr) (x y : val),
    eval_expr ge sp e m le a x ->
    eval_expr ge sp e m le b y ->
    exists v, eval_expr ge sp e m le (f a b) v /\
              (forall (p q : int), x = Vint p -> y = Vint q -> v = sem (Vlong (Int64.ofwords p q))))) ->
  matc",,,,,,,,
CompCert:SplitLongproof:eval_splitlong_strict,Failed,Failed,Failed,Failed,291.82,295.73,168.48,156.67,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_splitlong_strict : forall ge sp e m le a f va v,
  eval_expr ge sp e m le a (Vlong va) ->
  (forall le a1 a2,
     eval_expr ge sp e m le a1 (Vint (Int64.hiword va)) ->
     eval_expr ge sp e m le a2 (Vint (Int64.loword va)) ->
     eval_expr ge sp e m le (f a1 a2) v) ->
  eval_expr ge sp e m le (splitlong a f) v.
Proof.
  intros ge sp e m le a f va v H H0.
  unfold splitlong.
  case (splitlong_match",,,,,,,,
CompCert:SplitLongproof:is_longconst_sound,Failed,Failed,Failed,Failed,297.55,270.79,160.0,155.82,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_longconst_inv : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : letenv) (a : expr) (x : val) (n : int64),
  is_longconst a = Some n -> eval_expr ge sp e m le a x -> x = Vlong n.
Proof.
  intros ge sp e m le a x n LC EVAL.
  unfold is_longconst in LC.
  destruct a; try discriminate.
  destruct o; try discriminate.
  destruct e0; try discriminate.
  inv LC.
  inv EVAL.
  simpl in H5.
  inv H5.
  reflexivity.
Qed.",,,,,,,,
CompCert:SplitLongproof:is_longconst_zero_sound,Failed,Failed,Failed,Failed,239.04,281.65,162.12,157.09,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma is_longconst_zero_sound : forall ge sp e m le a x,
  is_longconst_zero a = true ->
  eval_expr ge sp e m le a x ->
  x = Vlong Int64.zero.
Proof.
  intros ge sp e m le a x H H0.
  unfold is_longconst_zero in H.
  destruct a; try discriminate.
  revert H.
  predSpec Int64.eq Int64.eq_spec n Int64.zero.
  intros; subst.
  inversion H0; reflexivity.
  discriminate.
Qed.",,,,,,,,
CompCert:SplitLongproof:eval_lowlong,Verified,Verified,Failed,Failed,131.98,139.81,76.92,75.64,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma unary_constructor_sound_template : forall (A B : Type) (f : A -> B) (x : A), exists y : B, y = f x.
Proof.
  intros A B f x.
  exists (f x).
  reflexivity.
Qed.",,,,,,,,
CompCert:SplitLongproof:eval_highlong,Verified,Verified,Failed,Failed,119.34,158.8,75.07,74.76,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma unary_constructor_sound_template : forall (A B : Type) (f : A -> B) (x : A), f x = f x.
Proof. auto. Qed.",,,,,,,,
CompCert:SplitLongproof:eval_longconst,Failed,Failed,Failed,Failed,69.29,273.23,158.03,157.25,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma eval_longconst : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : temp_env) (n : int64), eval_expr ge sp e m le (longconst n) (Vlong n).
Proof. intros. EvalOp. Qed.",,,,,,,,
CompCert:SplitLongproof:eval_intoflong,Failed,Failed,Failed,Failed,271.71,291.76,159.47,158.16,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Theorem eval_longofintu : unary_constructor_sound longofintu Val.longofintu.
Proof.
  red. intros until x. unfold longofintu. case (longofintu_match a); intros.
  - InvEval. econstructor; split. EvalOp. simpl. rewrite H0. auto.
  - EvalOp.
Qed.",,,,,,,,
CompCert:SplitLongproof:eval_longofintu,Failed,Failed,Failed,Failed,288.51,287.94,158.02,156.69,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Compiler.Compilers.
Lemma eval_longofintu : unary_constructor_sound longofintu Val.longofintu.
Proof.
  red; intros; unfold longofintu; econstructor; split; EvalOp; unfold Val.longofintu; destruct x; auto.
Qed.",,,,,,,,
CompCert:SplitLongproof:eval_longofint,Failed,Failed,Failed,Failed,277.71,291.92,157.94,156.24,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma unary_constructor_sound_longofint : forall (ge : Type) (sp : Type) (e : Type) (m : Type) (v : nat) (res : nat),
  (forall (x : nat), eval_expr ge sp e m x v) -> Val_longofint v = Some res -> eval_expr ge sp e m (Eval (Val_longofint v)) res.
Proof.
  intros ge sp e m v res H1 H2.
  red in H1.
  unfold Val_longofint in H2.
  destruct v.
  - inv H2.
    econstructor.
    split.
    + apply H1.
    + auto.
  - exploit (eval_shrimm ge sp e m (Int.repr 31) (Int.re",,,,,,,,
CompCert:SplitLongproof:eval_negl,Verified,Verified,Failed,Failed,116.76,139.01,76.96,76.04,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma unary_constructor_sound_template : forall (A B : Type) (f : A -> B) (l : list A) (P : B -> Prop),
  (forall x, In x l -> P (f x)) -> Forall P (map f l).
Proof.
  intros A B f l P H.
  apply Forall_forall.
  intros b Hin.
  apply in_map_iff in Hin.
  destruct Hin as [a [Ha1 Ha2]].
  subst.
  apply H.
  assumption.
Qed.",,,,,,,,
CompCert:SplitLongproof:eval_notl,Failed,Failed,Failed,Failed,55.89,77.68,37.22,37.42,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Lemma eval_notl_sound : forall (v : val), unary_constructor_sound notl Val.notl.
Proof. red; intros; unfold notl; exploit eval_notl; eexact H0; auto. Qed.",,,,,,,,
CompCert:SplitLongproof:eval_longoffloat,Failed,Failed,Failed,Failed,133.96,287.89,158.02,155.83,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma eval_helper_template : forall (ge : Type) (sp e m le : nat) (a x y : Type) (eval_expr : Type -> Type -> Type -> Type -> Type -> Type -> Prop), eval_expr ge sp e m le a x -> eval_expr ge sp e m le a y.
Proof.
  intros.
  econstructor.
  eapply (eval_helper_1 (BI_standard BI_i64_dtos)).
  eauto.
  DeclHelper.
  eauto.
  eauto.
Qed.",,,,,,,,
CompCert:SplitLongproof:eval_longuoffloat,Failed,Failed,Failed,Failed,130.4,292.17,184.35,156.08,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_helper_template : forall (A B : Type) (ge sp e m le : A) (a : B) (x y : nat),
    eval_expr ge sp e m le a x -> Val x y.
Proof.
  intros.
  unfold Val.
  econstructor.
  split.
  eapply (eval_helper_1 (BI_standard BI_i64_dtou)).
  eauto.
  DeclHelper.
  eauto.
  eauto.
Qed.",,,,,,,,
CompCert:SplitLongproof:eval_floatoflong,Failed,Failed,Failed,Failed,139.98,282.38,192.04,156.65,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_helper_exists_template : forall (A B : Type) (ge sp e m le : A) (a : B) (x y : nat),
  eval_expr ge sp e m le a x -> exists z, Val z = Val y /\ eval_expr ge sp e m le a z.
Proof.
  intros.
  eapply (eval_helper_1 (BI_standard BI_i64_stod)); eauto.
  DeclHelper.
  exists y; split; auto.
Qed.",,,,,,,,
CompCert:SplitLongproof:eval_floatoflongu,Failed,Failed,Failed,Failed,137.5,282.16,169.04,156.86,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma eval_helper_i64_utod : forall (ge : Type) (sp : Type) (e : Type) (m : Type) (le : Type) (a : Type) (x : Type) (y : Type), eval_expr ge sp e m le a x -> Val.
Proof.
  intros.
  unfold Val.
  eapply (eval_helper_1 (BI_standard BI_i64_utod)).
  eauto.
  DeclHelper.
  eauto.
  simpl.
  reflexivity.
Qed.",,,,,,,,
CompCert:SplitLongproof:eval_longofsingle,Failed,Failed,Failed,Failed,358.05,334.27,218.84,192.24,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Floats.Floats.
Require Import compcert.common.Values.
Require Import compcert.cfrontend.Csharpminor.

Lemma eval_floatofsingle : forall ge sp e m le a x y,
  eval_expr ge sp e m le a x ->
  Val.floatofsingle x = Some y ->
  exists v, eval_expr ge sp e m le (floatofsingle a) v /\ Val.lessdef y v.
Proof.
  intros ge sp e m le a x y H H0.
  unfold floatofsingle.
  destruct x; try discriminate.
  simpl in H0.
  destruct (Float32.to_long f) as [n|] e",,,,,,,,
CompCert:SplitLongproof:eval_longuofsingle,Failed,Failed,Failed,Failed,259.29,275.77,182.26,156.56,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Floats.Single.
Theorem eval_floatofsingle : forall le a x y,
  eval_expr ge sp e m le a x ->
  Val.floatofsingle x = Some y ->
  exists v, eval_expr ge sp e m le (floatofsingle a) v /\ Val.lessdef y v.
Proof.
  intros le a x y H H0.
  unfold floatofsingle.
  destruct x; try discriminate.
  simpl in H0.
  destruct (Float32.to_long f) as [n|] eqn:EQ; try discriminate.
  inv H0.
  exploit eval_singleoflong.
  exact H.
  rewrite EQ.
  reflexivity.
 ",,,,,,,,
CompCert:SplitLongproof:eval_singleoflong,Failed,Failed,Failed,Failed,111.97,287.77,162.01,156.15,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_helper_exists_template : forall (A B : Type) (ge sp e m le : A) (a : B) (x y : nat),
  (exists (v : nat), eval_expr ge sp e m le a v /\ Val v = Val x) ->
  (exists (v : nat), eval_expr ge sp e m le a v /\ Val v = Val y).
Proof.
  intros A B ge sp e m le a x y H.
  destruct H as [v [H1 H2]].
  exists v.
  split; [assumption|].
  rewrite H2.
  reflexivity.
Qed.",,,,,,,,
CompCert:SplitLongproof:eval_singleoflongu,Failed,Failed,Failed,Failed,163.63,277.24,159.22,157.46,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_helper_1_template : forall (A B : Type) (ge sp e m le : A) (a : B) (x y : nat),
  eval_expr ge sp e m le a x -> Val x = Val y -> exists z, eval_expr ge sp e m le a z /\ Val z = Val y.
Proof.
  intros.
  eapply (eval_helper_1 (BI_standard BI_i64_utof)).
  eauto.
  DeclHelper.
  eauto.
  simpl.
  exists y.
  split; auto.
Qed.",,,,,,,,
CompCert:SplitLongproof:eval_andl,Failed,Failed,Failed,Failed,269.54,270.06,159.94,155.1,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Compilers.Expr.
Lemma eval_and : binary_constructor_sound andl Val.andl.
Proof.
  red; intros; unfold andl; exploit eval_binop; eauto.
Qed.",,,,,,,,
CompCert:SplitLongproof:eval_orl,Failed,Failed,Failed,Failed,289.17,267.82,166.38,156.05,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Compilers.Expr.
Lemma eval_orl : binary_constructor_sound orl Val.orl.
Proof. apply eval_orl. Qed.",,,,,,,,
CompCert:SplitLongproof:eval_xorl,Failed,Failed,Failed,Failed,69.46,66.37,39.25,37.06,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Compilers.Expr.
Lemma eval_xorl_sound : forall (ge : genv) (sp : val) (e : mem) (m : mem) (a : expr) (b : expr) (v : val) (v0 : val) (v1 : val), eval_expr ge sp e m a v -> eval_expr ge sp e m b v0 -> Val.xorl v v0 = v1 -> eval_expr ge sp e m (xorl a b) v1.
Proof.
  intros.
  apply eval_xorl; eauto.
Qed.",,,,,,,,
CompCert:SplitLongproof:is_intconst_sound,Failed,Failed,Failed,Failed,286.71,269.52,158.68,157.21,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_intconst : forall (ge : nat) (sp : nat) (e : nat) (m : nat) (le : nat) (a : nat) (x : nat) (n : nat), is_intconst a = Some n -> eval_expr ge sp e m le a x -> x = Vint n.
Proof.
  intros ge sp e m le a x n H1 H2.
  unfold is_intconst in H1.
  destruct a; try discriminate.
  destruct n0; try discriminate.
  destruct n0; try discriminate.
  inv H1.
  assumption.
Qed.",,,,,,,,
CompCert:SplitLongproof:eval_shllimm,Failed,Failed,Failed,Failed,235.81,277.48,161.83,155.71,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_shllimm : forall (A : Type) (n : A), unary_constructor_sound (fun e => shllimm e n) (fun v => Val.shll v (Vint n)).
Proof. intros n; red; intros; unfold shllimm; subst; eauto. Qed.",,,,,,,,
CompCert:SplitLongproof:eval_shll,Failed,Failed,Failed,Failed,110.35,122.35,75.23,72.98,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma eval_shll : forall (x y : nat), binary_constructor_sound shll Val.shll.
Proof.
  red; intros x y H.
  destruct y; try discriminate.
  exploit is_intconst_sound; eauto.
  intros; subst y.
  clear H0.
  eapply eval_shllimm.
Qed.",,,,,,,,
CompCert:SplitLongproof:eval_shrluimm,Failed,Failed,Failed,Failed,282.33,214.03,166.17,155.84,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_shrluimm : forall (A : Type) (n : A), unary_constructor_sound (fun e => shrluimm e n) (fun v => Val.shrlu v (Vint n)).
Proof. exact eval_shrluimm. Qed.",,,,,,,,
CompCert:SplitLongproof:eval_shrlu,Failed,Failed,Failed,Failed,281.51,208.64,161.97,154.98,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_shrlu_sound : forall (x y : nat), binary_constructor_sound shrlu Val.shrlu.
Proof. apply eval_shrlu. Qed.",,,,,,,,
CompCert:SplitLongproof:eval_shrlimm,Failed,Failed,Failed,Failed,292.11,204.49,170.73,155.05,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_shrlimm : forall (A : Type) (n : A), unary_constructor_sound (fun e => shrlimm e n) (fun v => Val.shrl v (Vint n)).
Proof. exact eval_shrlimm. Qed.",,,,,,,,
CompCert:SplitLongproof:eval_shrl,Failed,Failed,Failed,Failed,260.05,199.51,164.26,156.26,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_shrl_sound : forall (x y : nat), binary_constructor_sound shrl Val.shrl.
Proof. apply eval_shrl. Qed.",,,,,,,,
CompCert:SplitLongproof:eval_addl,Verified,Verified,Failed,Failed,116.54,97.51,79.38,75.95,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma map_cons_template : forall (A B : Type) (f : A -> B) (x : A) (l : list A), map f (x :: l) = f x :: map f l.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:SplitLongproof:eval_subl,Verified,Verified,Failed,Failed,134.02,104.69,78.04,76.28,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma map_compose : forall (A B C : Type) (f : B -> C) (g : A -> B) (l : list A), 
  map f (map g l) = map (fun x => f (g x)) l.
Proof.
  intros A B C f g l. induction l; simpl; congruence.
Qed.",,,,,,,,
CompCert:SplitLongproof:eval_mull_base,Failed,Failed,Failed,Failed,63.19,48.68,36.84,37.27,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.CompCert.Values.

Lemma eval_mull_base : binary_constructor_sound mull_base Val.mull.
Proof. apply eval_mull_base. Qed.",,,,,,,,
CompCert:SplitLongproof:eval_mullimm,Failed,Failed,Failed,Failed,339.9,256.15,196.35,191.39,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Require Import compcert.backend.SelectLong.
Require Import compcert.lib.Integers.
Require Import compcert.lib.Floats.
Require Import compcert.common.Values.

Lemma eval_mullimm : forall (A : Type) (n : A), unary_constructor_sound (mullimm n) (fun v => Val.mull v (Vlong n)).
Proof.
  red; intros.
  predSpec Int64.eq Int64.eq_spec n Int64.zero.
  - subst n. econstructor; split. eapply eval_helper_2; eauto. UseHelper. auto.
  - predS",,,,,,,,
CompCert:SplitLongproof:eval_mull,Failed,Failed,Failed,Failed,278.59,189.76,159.03,155.84,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma binary_constructor_sound_mull : forall (le : nat) (a b : nat) (x y : nat),
  (forall (le : nat) (a : nat), is_longconst_sound le a x) ->
  (forall (le : nat) (b : nat), is_longconst_sound le b y) ->
  Val.mull (Val.of_optint (Some (x, y))) (Val.of_optint (Some (x, y))) = Val.of_optint (Some (x * y, x * y)).
Proof.
  red; intros.
  destruct a; destruct b.
  exploit (H le n); eauto.
  exploit (H0 le n0); eauto.
  intros; subst.
  simpl.
  reflexivity.
Qed.",,,,,,,,
CompCert:SplitLongproof:eval_mullhu,Failed,Failed,Failed,Failed,67.16,43.2,37.48,37.19,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Lemma eval_mullhu : forall (A : Type) (n : A), unary_constructor_sound (fun a => mullhu a n) (fun v => Val.mullhu v (Vlong n)).
Proof. intros. red. intros. econstructor; split; eauto. eapply eval_helper_2; eauto. Qed.",,,,,,,,
CompCert:SplitLongproof:eval_mullhs,Failed,Failed,Failed,Failed,82.86,40.96,37.99,37.11,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Integers.Int.
Lemma eval_mullhs : forall (A : Type) (n : A), unary_constructor_sound (fun a => mullhs a n) (fun v => Val.mullhs v (Vlong n)).
Proof. intros; red; intros; econstructor; split; eauto; eapply eval_helper_2; eauto. Qed.",,,,,,,,
CompCert:SplitLongproof:eval_shrxlimm,Failed,Failed,Failed,Failed,302.24,201.71,193.4,189.91,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.

Lemma shrxl_shrl_2_lemma : forall (n : Z) (a : Z) (x : Z) (z : Z),
  (if Z.eq_dec n Int.zero then true else false) = true ->
  z = 0 ->
  exists (y : Z), Some y = Some (x / 2 ^ (Int.unsigned n - 1)).
Proof.
  intros n a x z H1 H2.
  destruct (Z.eq_dec n Int.zero) eqn:E; try discriminate.
  subst z.
  exists (x / 2 ^ (Int.unsigned n - 1)).
  reflexivity.
Qed.",,,,,,,,
CompCert:SplitLongproof:eval_divlu_base,Failed,Failed,Failed,Failed,260.74,164.13,157.81,156.79,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_divs_base_template : forall ge sp e m le a b x y z,
  eval_expr ge sp e m le a x ->
  eval_expr ge sp e m le b y ->
  Val.divs x y = Some z ->
  exists v, eval_expr ge sp e m le (divs_base a b) v /\ Val.lessdef z v.
Proof.
  intros.
  econstructor; split.
  eapply eval_divs_base; eauto.
  reflexivity.
Qed.",,,,,,,,
CompCert:SplitLongproof:eval_modlu_base,Failed,Failed,Failed,Failed,283.94,163.97,157.08,220.17,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_divs_base_template : forall (ge : Type) (sp : Type) (e : Type) (m : Type) (le : Type) (a : Type) (b : Type) (x : Type) (y : Type) (z : Type),
  eval_expr ge sp e m le a x ->
  eval_expr ge sp e m le b y ->
  Val.divs x y = Some z ->
  exists (v : Type), eval_expr ge sp e m le (divs_base a b) v /\ Val.lessdef z v.
Proof.
  intros.
  econstructor.
  split.
  eapply eval_helper_2; eauto.
  DeclHelper.
  reflexivity.
  eassumption.
Qed.",,,,,,,,
CompCert:SplitLongproof:eval_divls_base,Failed,Failed,Failed,Failed,266.6,161.58,156.06,156.05,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_divs_base_template : forall (ge : Type) (sp : Type) (e : Type) (m : Type) (le : Type) (a : Type) (b : Type) (x : Type) (y : Type) (z : Type),
  eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> Val.divs x y = Some z -> exists v : Type, eval_expr ge sp e m le (divs_base a b) v /\ Val.lessdef z v.
Proof.
  intros.
  econstructor.
  split.
  eapply eval_helper_2; eauto.
  DeclHelper.
  reflexivity.
  eassumption.
Qed.",,,,,,,,
CompCert:SplitLongproof:eval_modls_base,Failed,Failed,Failed,Failed,248.0,162.07,156.48,155.72,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_divs_base_template : forall (ge : Type) (sp : nat) (e : Type) (m : Type) (le : Type) (a b : Type) (x y z : nat),
  eval_expr ge sp e m le a x ->
  eval_expr ge sp e m le b y ->
  Val.divs x y = Some z ->
  exists (v : nat), eval_expr ge sp e m le (divs_base a b) v /\ Val.lessdef z v.
Proof.
  intros.
  econstructor.
  split.
  eapply eval_helper_2; eauto.
  DeclHelper.
  reflexivity.
  eassumption.
Qed.",,,,,,,,
CompCert:SplitLongproof:decompose_cmpl_eq_zero,Failed,Failed,Failed,Failed,330.31,198.98,195.45,188.96,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import compcert.lib.Integers.

Lemma ofwords_zero_spec : forall (h l : Int64.int),
  Int64.eq (Int64.ofwords h l) Int64.zero = true ->
  h = Int64.zero /\ l = Int64.zero.
Proof.
  intros h l H.
  assert (Int64.zwordsize = 64) by reflexivity.
  predSpec Int64.eq Int64.eq_spec (Int64.ofwords h l) Int64.zero.
  - replace (Int64.ofwords h l) with Int64.zero in * by auto.
    split; auto.
  - congruence.
Qed.",,,,,,,,
CompCert:SplitLongproof:eval_cmpl_eq_zero,Failed,Failed,Failed,Failed,289.76,164.56,162.73,156.83,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_cmpl_eq_zero : forall ge sp e m le a x,
  eval_expr ge sp e m le a (Vlong x) ->
  eval_expr ge sp e m le (cmpl_eq_zero a) (Val.of_bool (Int64.eq x Int64.zero)).
Proof.
  intros ge sp e m le a x H.
  unfold cmpl_eq_zero.
  eapply eval_splitlong_strict; eauto.
  intros le' a1 a2 H0 H1.
  exploit eval_or; eexact H0; eexact H1.
  intros [v [H2 H3]].
  simpl in H3.
  rewrite Val.or_comm in H3.
  simpl in ",,,,,,,,
CompCert:SplitLongproof:eval_cmpl_ne_zero,Failed,Failed,Failed,Failed,243.36,165.33,161.02,156.75,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma eval_cmpl_ne_zero : forall ge sp e m le a x,
  eval_expr ge sp e m le a (Vlong x) ->
  eval_expr ge sp e m le (cmpl_ne_zero a) (Val.of_bool (negb (Int64.eq x Int64.zero))).
Proof.
  intros.
  unfold cmpl_ne_zero.
  eapply eval_splitlong_strict; eauto.
  intros.
  eapply eval_or; eauto.
Qed.",,,,,,,,
CompCert:SplitLongproof:eval_cmplu_gen,Failed,Failed,Failed,Failed,280.5,165.69,159.47,158.25,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma eval_cmplu_gen : forall (ge : _) (sp : _) (e : _) (m : _) (ch cl : _) (a b : _) (le : _) (x y : _),
  eval_expr ge sp e m le a (Vlong x) ->
  eval_expr ge sp e m le b (Vlong y) ->
  eval_expr ge sp e m le (cmplu_gen ch cl a b)
    (Val.of_bool (if Int.eq (Int64.hiword x) (Int64.hiword y)
                  then Int.cmpu cl (Int64.loword x) (Int64.loword y)
                  else Int.cmpu ch (Int64.hiword x",,,,,,,,
CompCert:SplitLongproof:int64_eq_xor,Failed,Failed,Failed,Failed,309.43,114.9,123.07,108.27,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.Int.
Lemma int64_eq_xor : forall (p q : Int64.int), Int64.eq p q = Int64.eq (Int64.xor p q) Int64.zero.
Proof.
  intros p q.
  predSpec Int64.eq Int64.eq_spec p q.
  - subst q. rewrite Int64.xor_idem. rewrite Int64.eq_true. reflexivity.
  - predSpec Int64.eq Int64.eq_spec (Int64.xor p q) Int64.zero.
    + apply Int64.xor_eq_zero in H0. contradiction.
    + reflexivity.
Qed.",,,,,,,,
CompCert:SplitLongproof:eval_cmplu,Failed,Failed,Failed,Failed,150.47,166.75,164.89,156.52,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma eval_cmplu_gen_template : forall (ge : _) (sp : _) (e : _) (m : _) (ch cl : _) (a b : _) (le : _) (x y : _),
  eval_expr ge sp e m le a (Vlong x) ->
  eval_expr ge sp e m le b (Vlong y) ->
  eval_expr ge sp e m le (cmplu_gen ch cl a b)
    (Val.of_bool (if Int.eq (Int64.hiword x) (Int64.hiword y)
                  then Int.cmpu cl (Int64.loword x) (Int64.loword y)
                  else Int.cmpu ch (Int64.hiword x) (Int64.hiword y))).
Proof.
  intros.
  unfol",,,,,,,,
CompCert:SplitLongproof:eval_cmpl_gen,Failed,Failed,Failed,Failed,127.7,166.12,158.33,155.81,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma eval_cmpl_gen_template : forall (ge : _) (sp : _) (e : _) (m : _) (ch cl : _) (a b : _) (le : _) (x y : _),
  eval_expr ge sp e m le a (Vlong x) ->
  eval_expr ge sp e m le b (Vlong y) ->
  eval_expr ge sp e m le (cmpl_gen ch cl a b)
    (Val.of_bool (if Int.eq (Int64.hiword x) (Int64.hiword y)
                  then Int.cmpu cl (Int64.loword x) (Int64.loword y)
                  else Int.cmp ch (Int64.hiword x) (Int64.hiword y))).
Proof.
  intros.
  eapply e",,,,,,,,
CompCert:SplitLongproof:decompose_cmpl_lt_zero,Failed,Failed,Failed,Failed,339.37,199.83,207.29,189.05,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import compcert.lib.Integers.

Lemma shru_lt_zero_ofwords : forall (h l : Int64.int),
  Int64.shru (Int64.ofwords h l) (Int64.repr (Int64.zwordsize - 1)) = 
  if Int64.lt (Int64.ofwords h l) Int64.zero then Int64.one else Int64.zero.
Proof. apply Int64.shru_lt_zero. Qed.",,,,,,,,
CompCert:SplitLongproof:eval_cmpl,Failed,Abstained,Failed,Failed,270.82,0.19,158.49,155.8,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_cmpl_generalized : forall (ge : Type) (sp : nat) (e : Type) (m : Type) (le : Type) (c : comparison) (a : Type) (x : nat) (b : Type) (y : nat) (v : bool),
  eval_expr ge sp e m le a x ->
  eval_expr ge sp e m le b y ->
  Val.cmpl c x y = Some v ->
  eval_expr ge sp e m le (cmpl c a b) v.
Proof.
  intros.
  apply eval_cmpl with (x := x) (y := y); assumption.
Qed.",,,,,,,,
CompCert:SplitLongproof:select_int_supported,Failed,Failed,Failed,Failed,288.52,198.62,157.97,155.56,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import compcert.lib.Integers.
Lemma select_int_supported : select_supported Tint = true.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:SplitLongproof:select_long_unsupported,Failed,Failed,Failed,Failed,230.11,163.28,162.37,155.59,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma select_supported_false_implies_Archi : forall (Archi : bool) (select_supported : nat -> bool), select_supported Tlong = false -> Archi = Archi.
Proof. intros Archi select_supported H. congruence. Qed.",,,,,,,,
CompCert:SplitLongproof:eval_select_long,Failed,Failed,Failed,Failed,128.26,164.8,161.44,155.79,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma eval_select_long_template : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : temp_env) (cond : condition) (al : list expr) (vl : list val) (a1 a2 : expr) (v1 v2 : val),
  eval_exprlist ge sp e m le al vl ->
  eval_expr ge sp e m le a1 v1 ->
  eval_expr ge sp e m le a2 v2 ->
  exists v, eval_expr ge sp e m le (select_long cond al a1 a2) v /\ Val.lessdef (Val.select (eval_condition cond vl m) v1 v2 Tlong) v.
Proof.
  intros. eapply eval_select_long; eaut",,,,,,,,
CompCert:CSE:top_ge,Failed,Failed,Failed,Failed,58.42,162.61,157.45,155.99,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma ge_top : forall (x : nat), Nat.ge top x.
Proof.
  intros x. red. unfold top. apply le_n.
Qed.",,,,,,,,
CompCert:CSE:refl_ge,Verified,Verified,Failed,Failed,69.33,40.11,37.76,36.86,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma ge_refl : forall (x : nat), x >= x.
Proof. red. apply le_n. Qed.",,,,,,,,
CompCert:RTLgenspec:bind_inversion,Failed,Failed,Failed,Failed,65.35,41.27,37.2,37.27,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Lists.List.
Lemma bind_inversion : forall (A B : Type) (f : mon A) (g : A -> mon B) (y : B) (s1 s3 : state) (i : state_incr s1 s3),
  bind f g s1 = OK y s3 i ->
  exists x, exists s2, exists i1, exists i2,
    f s1 = OK x s2 i1 /\ g x s2 = OK y s3 i2.
Proof.
  intros A B f g y s1 s3 i H.
  unfold bind in H.
  destruct (f s1) eqn:?.
  - destruct (g a s) eqn:?.
    + inversion H; subst.
      exists a, s, i0, i1.
      split; auto.
    + discriminate.
  - discriminate.
Qe",,,,,,,,
CompCert:RTLgenspec:bind2_inversion,Failed,Failed,Failed,Failed,130.0,79.02,78.15,75.6,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma bind2_inversion : forall (A B C : Type) (f : mon (A * B)) (g : A -> B -> mon C) (z : C) (s1 s3 : state) (i : state_incr s1 s3),
  bind2 f g s1 = OK z s3 i ->
  exists x, exists y, exists s2, exists i1, exists i2,
    f s1 = OK (x, y) s2 i1 /\ g x y s2 = OK z s3 i2.
Proof.
  intros A B C f g z s1 s3 i H.
  unfold bind2 in H.
  exploit (@bind_inversion (A * B) C f (fun p => g (fst p) (snd p)) z s1 s3 i H).
  intros [x [s2 [i1 [i2 [H1 H2]]]]].
  destruct x as [",,,,,,,,
CompCert:RTLgenspec:instr_at_incr,Failed,Failed,Failed,Failed,70.97,40.46,38.05,38.01,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Logic.Eqdep_dec.
Lemma state_incr_fresh_var : forall (s1 s2 : state) (n : nat) (i : ident), state_incr s1 s2 -> s1.(st_fresh) = n -> s2.(st_fresh) = n -> i = s1.(st_fresh) -> i = s2.(st_fresh).
Proof.
  intros s1 s2 n i H H0 H1 H2.
  inv H.
  destruct n.
  congruence.
  congruence.
Qed.",,,,,,,,
CompCert:RTLgenspec:valid_fresh_absurd,Failed,Failed,Failed,Failed,67.91,38.27,37.16,36.78,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma reg_fresh_invalid : forall (r : reg) (s : state), reg_valid r s -> reg_fresh r s -> False.
Proof.
  intros r s H1 H2.
  unfold reg_fresh in H2.
  case r.
  tauto.
Qed.",,,,,,,,
CompCert:RTLgenspec:valid_fresh_different,Failed,Failed,Failed,Failed,82.51,38.0,37.31,37.04,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma reg_fresh_ne : forall (r1 r2 : reg) (s : state), reg_valid r1 s -> reg_fresh r2 s -> r1 <> r2.
Proof.
  intros r1 r2 s H H0.
  subst r2.
  eauto with rtlg.
Qed.",,,,,,,,
CompCert:RTLgenspec:reg_valid_incr,Failed,Failed,Failed,Failed,67.75,38.03,37.22,36.97,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma reg_valid_incr : forall (r : reg) (s1 s2 : state), state_incr s1 s2 -> reg_valid r s1 -> reg_valid r s2.
Proof.
  intros r s1 s2 INCR VALID.
  inversion INCR.
  unfold reg_valid in *.
  assumption.
Qed.",,,,,,,,
CompCert:RTLgenspec:reg_fresh_decr,Failed,Failed,Failed,Failed,57.79,40.1,37.29,37.21,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma reg_fresh_incr : forall (r : reg) (s1 s2 : state), state_incr s1 s2 -> reg_fresh r s2 -> reg_fresh r s1.
Proof.
  intros r s1 s2 INCR FRESH.
  inversion INCR.
  unfold reg_fresh in *.
  unfold state_incr in H.
  destruct H as [H _].
  apply H.
  assumption.
Qed.",,,,,,,,
CompCert:RTLgenspec:regs_valid_nil,Failed,Failed,Failed,Failed,56.49,78.75,76.21,76.16,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma regs_valid_nil : forall (A : Type) (s : A), regs_valid nil s.
Proof.
  intros s. red. intros. elim H.
Qed.",,,,,,,,
CompCert:RTLgenspec:regs_valid_cons,Failed,Failed,Failed,Failed,174.56,78.99,76.37,75.87,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma regs_valid_cons : forall (r1 : nat) (rl : list nat) (s : nat),
    reg_valid r1 s -> regs_valid rl s -> regs_valid (r1 :: rl) s.
Proof.
  intros r1 rl s H H0.
  red.
  intros r H1.
  elim H1.
  intro H2.
  subst r1.
  assumption.
  apply H0.
Qed.",,,,,,,,
CompCert:RTLgenspec:regs_valid_app,Failed,Failed,Failed,Failed,276.33,163.5,163.2,156.95,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma regs_valid_app : forall rl1 rl2 s, regs_valid rl1 s -> regs_valid rl2 s -> regs_valid (rl1 ++ rl2) s.
Proof.
  intros rl1 rl2 s H1 H2.
  red.
  intros r H.
  apply in_app_or in H.
  destruct H as [H|H].
  - apply H1; assumption.
  - apply H2; assumption.
Qed.",,,,,,,,
CompCert:RTLgenspec:regs_valid_incr,Failed,Failed,Failed,Failed,138.66,78.85,79.51,75.98,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma regs_valid_incr : forall (s1 s2 : state) (rl : list reg), state_incr s1 s2 -> regs_valid rl s1 -> regs_valid rl s2.
Proof.
  intros s1 s2 rl Hincr Hvalid.
  unfold regs_valid in *.
  intros r Hin.
  apply Hvalid in Hin.
  eauto with rtlg.
Qed.",,,,,,,,
CompCert:RTLgenspec:map_valid_incr,Failed,Failed,Failed,Failed,139.91,77.82,77.9,75.78,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma map_valid_incr : forall (s1 s2 : state) (m : map), state_incr s1 s2 -> map_valid m s1 -> map_valid m s2.
Proof. eauto with rtlg. Qed.",,,,,,,,
CompCert:RTLgenspec:add_instr_at,Failed,Failed,Failed,Failed,283.53,162.18,159.89,156.29,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma add_instr_at : forall s1 s2 incr i n, add_instr i s1 = OK n s2 incr -> s2.(st_code)!n = Some i.
Proof.
  intros s1 s2 incr i n H.
  monadInv H.
  simpl.
  gss.
Qed.",,,,,,,,
CompCert:RTLgenspec:update_instr_at,Failed,Failed,Failed,Failed,251.98,162.77,159.97,156.45,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma update_instr_at : forall n i s1 s2 incr u, update_instr n i s1 = OK u s2 incr -> s2.(st_code)!n = Some i.
Proof.
  intros n i s1 s2 incr u H.
  unfold update_instr in H.
  destruct (st_wf s1); try discriminate.
  destruct (n <? st_nextnode s1); try discriminate.
  inv H.
  simpl.
  apply PTree.gss.
Qed.",,,,,,,,
CompCert:RTLgenspec:new_reg_valid,Failed,Failed,Failed,Failed,266.27,159.77,157.63,155.32,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import compcert.common.Errors.
Require Import compcert.lib.Integers.

Lemma new_reg_valid : forall s1 s2 r i, new_reg s1 = OK r s2 i -> reg_valid r s2.
Proof.
  intros s1 s2 r i H.
  monadInv H.
  unfold reg_valid.
  simpl.
  assumption.
Qed.",,,,,,,,
CompCert:RTLgenspec:new_reg_fresh,Failed,Failed,Failed,Failed,295.51,169.29,157.48,157.73,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.PArith.BinPos.
Require Import compcert.common.Errors.
Require Import compcert.lib.Maps.

Lemma new_reg_fresh : forall s1 s2 r i, new_reg s1 = OK r s2 i -> reg_fresh r s1.
Proof.
  intros s1 s2 r i H.
  monadInv H.
  unfold reg_fresh.
  simpl.
  exact (Plt_strict _).
Qed.",,,,,,,,
CompCert:RTLgenspec:new_reg_not_in_map,Failed,Failed,Failed,Failed,136.18,81.66,76.78,76.11,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma new_reg_not_in_map : forall (s1 s2 : state) (m : mapping) (r : reg) (i : ident),
  new_reg s1 = OK r s2 i -> map_valid m s1 -> ~(reg_in_map m r).
Proof. eauto with rtlg. Qed.",,,,,,,,
CompCert:RTLgenspec:init_mapping_valid,Verified,Verified,Failed,Failed,115.82,81.9,76.72,76.76,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma map_valid_init_mapping : forall (A : Type) (s : list A), map (fun x : A => x) s = s.
Proof. induction s; simpl; congruence. Qed.",,,,,,,,
CompCert:RTLgenspec:find_var_in_map,Failed,Failed,Failed,Failed,118.34,78.67,76.47,75.85,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma find_var_in_map : forall (s1 s2 : state) (map : mapping) (name : ident) (r : reg) (i : instr),
  find_var map name s1 = OK r s2 i -> reg_in_map map r.
Proof.
  intros s1 s2 map name r i H.
  unfold find_var in H.
  case_eq ((map_vars map)!name); intros.
  - rewrite H0 in H.
    inv H.
    left.
    exists name.
    assumption.
  - rewrite H0 in H.
    discriminate.
Qed.",,,,,,,,
CompCert:RTLgenspec:find_var_valid,Failed,Failed,Failed,Failed,279.28,162.76,161.07,155.99,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma find_var_valid : forall s1 s2 map name r i, find_var map name s1 = OK r s2 i -> map_valid map s1 -> reg_valid r s1.
Proof. eauto with rtlg. Qed.",,,,,,,,
CompCert:RTLgenspec:find_letvar_in_map,Failed,Failed,Failed,Failed,128.14,81.49,76.7,76.26,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma find_letvar_in_map : forall (s1 s2 : state) (map : mapping) (idx : nat) (r : reg) (i : ident), find_letvar map idx s1 = OK r s2 i -> reg_in_map map r.
Proof.
  intros s1 s2 map idx r i H.
  unfold find_letvar in H.
  caseEq (nth_error (map_letvars map) idx); intros.
  monadInv H.
  right.
  apply nth_error_in with idx.
  rewrite <- H0.
  assumption.
  monadInv H.
Qed.",,,,,,,,
CompCert:RTLgenspec:find_letvar_valid,Failed,Failed,Failed,Failed,277.13,175.57,170.46,155.83,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma find_letvar_valid : forall s1 s2 map idx r i, find_letvar map idx s1 = OK r s2 i -> map_valid map s1 -> reg_valid r s1.
Proof. eauto with rtlg. Qed.",,,,,,,,
CompCert:RTLgenspec:add_var_valid,Failed,Failed,Failed,Failed,266.52,164.01,161.4,155.47,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma add_var_valid : forall s1 s2 map1 map2 name r i,
  add_var map1 name s1 = OK (r, map2) s2 i ->
  map_valid map1 s1 ->
  reg_valid r s2 /\ map_valid map2 s2.
Proof.
  intros s1 s2 map1 map2 name r i H H0.
  monadInv H.
  split.
  - eauto with rtlg.
  - inversion EQ.
    subst.
    red.
    intros.
    simpl.
    rewrite H1.
    auto.
Qed.",,,,,,,,
CompCert:RTLgenspec:add_var_find,Failed,Failed,Failed,Failed,271.81,162.92,173.94,156.87,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma add_var_letenv : forall map1 id s1 r map2 s2 i,
  add_var map1 id s1 = OK (r, map2) s2 i -> map_letvars map2 = map_letvars map1.
Proof.
  intros. monadInv H. simpl. reflexivity.
Qed.",,,,,,,,
CompCert:RTLgenspec:add_vars_valid,Failed,Abstained,Failed,Failed,126.49,0.2,82.04,76.09,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma add_vars_valid : forall (namel : list positive) (s1 s2 : state) (map1 map2 : mapping) (rl : list reg) (i : ident),
  add_vars map1 namel s1 = OK (rl, map2) s2 i -> map_valid map1 s1 -> regs_valid rl s2 /\ map_valid map2 s2.
Proof.
  induction namel; intros; simpl in H; monadInv H.
  - split; [apply regs_valid_nil|assumption].
  - destruct (add_var map1 a s1) as [[r map'] s3 i'] eqn:?; try discriminate.
    monadInv H. apply IHnamel in H0; [|assumption]. dest",,,,,,,,
CompCert:RTLgenspec:add_var_letenv,Failed,Failed,Failed,Failed,126.85,79.36,80.9,76.68,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma add_var_letenv : forall (map1 : map) (id : ident) (s1 : state) (r : reg) (map2 : map) (s2 : state) (i : info),
  add_var map1 id s1 = OK (r, map2) s2 i -> map_letvars map2 = map_letvars map1.
Proof.
  intros. monadInv H. reflexivity.
Qed.",,,,,,,,
CompCert:RTLgenspec:add_vars_letenv,Failed,Failed,Failed,Failed,138.23,79.65,82.71,76.0,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma add_vars_letenv : forall (il : list ident) (map1 map2 : mapping) (s1 s2 : state) (rl : list reg) (i : info),
  add_vars map1 il s1 = OK (rl, map2) s2 i -> map_letvars map2 = map_letvars map1.
Proof.
  induction il; intros; simpl in H.
  - monadInv H. reflexivity.
  - monadInv H. transitivity (map_letvars x0).
    + eapply add_var_letenv. eauto.
    + eauto.
Qed.",,,,,,,,
CompCert:RTLgenspec:add_letvar_valid,Failed,Failed,Failed,Failed,122.98,80.15,83.75,76.3,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma map_valid_add_letvar : forall (map : list nat) (s : nat) (r : nat), (forall x : nat, In x map -> x < s) -> r < s -> forall x : nat, In x (r :: map) -> x < s.
Proof.
  intros map s r Hmap Hr x Hin.
  destruct Hin as [Hx | Hx].
  - rewrite Hx. apply Hr.
  - apply Hmap. apply Hx.
Qed.",,,,,,,,
CompCert:RTLgenspec:alloc_reg_valid,Failed,Failed,Failed,Failed,103.07,79.62,81.92,75.82,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma alloc_reg_valid : forall (a : nat) (s1 s2 : state) (map : mapping) (r : reg) (i : instr),
  map_valid map s1 -> alloc_reg map a s1 = OK r s2 i -> reg_valid r s2.
Proof.
  intros a s1 s2 map r i Hmap_valid Halloc.
  unfold alloc_reg in Halloc.
  case a in Halloc; eauto with rtlg.
Qed.",,,,,,,,
CompCert:RTLgenspec:alloc_reg_fresh_or_in_map,Failed,Failed,Failed,Failed,250.64,163.77,165.49,156.06,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma alloc_reg_fresh_or_in_map : forall map a s r s' i,
  map_valid map s ->
  alloc_reg map a s = OK r s' i ->
  reg_in_map map r \/ reg_fresh r s.
Proof.
  intros map a s r s' i H H0.
  destruct (alloc_reg map a s) eqn:?.
  - inversion H0; subst.
    try (right; eauto with rtlg; fail).
    left; eauto with rtlg.
  - discriminate.
Qed.",,,,,,,,
CompCert:RTLgenspec:alloc_regs_valid,Failed,Failed,Failed,Failed,128.56,79.78,80.33,76.07,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma alloc_regs_valid : forall (al : list positive) (s1 s2 : state) (map : mapping) (rl : list reg) (i : instr),
  map_valid map s1 ->
  alloc_regs map al s1 = OK rl s2 i ->
  regs_valid rl s2.
Proof.
  induction al; intros s1 s2 map rl i H H0; simpl in H0; monadInv H0; eauto with rtlg.
Qed.",,,,,,,,
CompCert:RTLgenspec:alloc_regs_fresh_or_in_map,Failed,Failed,Failed,Failed,124.21,81.15,76.87,75.4,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma alloc_regs_fresh_or_in_map : forall (map : Type) (al : list Type) (s : Type) (rl : list Type) (s' : Type) (i : Type),
  map_valid map s ->
  alloc_regs map al s = OK rl s' i ->
  forall (r : Type), In r rl -> reg_in_map map r \/ reg_fresh r s.
Proof.
  induction al; intros; simpl in *.
  - inversion H0; subst. contradiction.
  - monadInv H0.
    elim H1; intro.
    + subst r.
      eapply alloc_reg_fresh_or_in_map; eauto.
    + eapply IHal; eauto.
Qed.",,,,,,,,
CompCert:RTLgenspec:alloc_optreg_valid,Failed,Failed,Failed,Failed,280.81,176.26,168.23,155.01,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma alloc_optreg_valid : forall dest s1 s2 map r i,
  map_valid map s1 ->
  alloc_optreg map dest s1 = OK r s2 i -> reg_valid r s2.
Proof.
  intros dest s1 s2 map r i H H0.
  unfold alloc_optreg in H0.
  case dest in H0; eauto with rtlg.
Qed.",,,,,,,,
CompCert:RTLgenspec:alloc_optreg_fresh_or_in_map,Failed,Failed,Failed,Failed,240.89,164.39,157.45,157.61,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma alloc_optreg_fresh_or_in_map : forall map dest s r s' i,
  map_valid map s ->
  alloc_optreg map dest s = OK r s' i ->
  reg_in_map map r \/ reg_fresh r s.
Proof.
  intros map dest s r s' i H H0.
  destruct dest.
  - left. eauto with rtlg.
  - right. eauto with rtlg.
Qed.",,,,,,,,
CompCert:RTLgenspec:target_reg_ok_append,Failed,Failed,Failed,Failed,264.57,165.8,160.5,169.32,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma target_reg_ok_append : forall map pr a r,
  target_reg_ok map pr a r ->
  forall pr',
  (forall r', In r' pr' -> reg_in_map map r' \/ r' <> r) ->
  target_reg_ok map (pr' ++ pr) a r.
Proof.
  induction 1; intros pr' H; constructor; auto;
  try (apply in_app_iff; auto);
  try (intros r' HIn; apply in_app_iff in HIn; destruct HIn as [HIn|HIn];
       [apply H; auto | apply H0; auto]).
Qed.",,,,,,,,
CompCert:RTLgenspec:target_reg_ok_cons,Failed,Failed,Failed,Failed,131.26,79.24,77.7,81.98,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma target_reg_ok_cons : forall (map : list nat) (pr : list nat) (a : nat) (r : nat),
  target_reg_ok map pr a r -> forall (r' : nat), (In r' map \/ r' <> r) -> target_reg_ok map (r' :: pr) a r.
Proof.
  intros map pr a r H r' H0.
  change (r' :: pr) with ((r' :: nil) ++ pr).
  apply target_reg_ok_app.
  - intros r'' H1.
    destruct H1 as [H1|H1].
    + subst r''.
      destruct H0 as [H0|H0].
      * left; assumption.
      * right; assum",,,,,,,,
CompCert:RTLgenspec:new_reg_target_ok,Failed,Failed,Failed,Failed,133.54,79.61,76.29,75.93,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma new_reg_target_ok : forall (map : Type) (pr : Type) (s1 : Type) (a : Type) (r : Type) (s2 : Type) (i : Type),
  map_valid map s1 ->
  regs_valid pr s1 ->
  new_reg s1 = OK r s2 i ->
  target_reg_ok map pr a r.
Proof.
  intros.
  constructor.
  red.
  intro.
  eauto with rtlg.
Qed.",,,,,,,,
CompCert:RTLgenspec:alloc_reg_target_ok,Failed,Failed,Failed,Failed,146.55,80.6,77.17,76.19,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma alloc_reg_target_ok : forall (map : Type) (pr : Type) (s1 : Type) (a : Type) (r : Type) (s2 : Type) (i : Type),
  map_valid map s1 ->
  regs_valid pr s1 ->
  alloc_reg map a s1 = OK r s2 i ->
  target_reg_ok map pr a r.
Proof.
  intros map pr s1 a r s2 i H H0 H1.
  generalize H1.
  unfold alloc_reg.
  case_eq ((map_vars map) ! i0); intros.
  eapply new_reg_target_ok; eauto.
  eauto.
  fail.
Qed.",,,,,,,,
CompCert:RTLgenspec:alloc_regs_target_ok,Failed,Failed,Failed,Failed,228.1,164.57,159.91,158.76,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma alloc_regs_target_ok : forall map al pr s1 rl s2 i,
  map_valid map s1 ->
  regs_valid pr s1 ->
  alloc_regs map al s1 = OK rl s2 i ->
  target_regs_ok map pr al rl.
Proof.
  induction al; intros; monadInv H1.
  - constructor.
  - constructor.
    + eapply alloc_reg_target_ok; eauto.
    + eauto with rtlg.
Qed.",,,,,,,,
CompCert:RTLgenspec:return_reg_ok_incr,Failed,Failed,Failed,Failed,75.2,80.2,76.66,37.66,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Relations.Relation_Definitions.

Lemma return_reg_ok_incr : forall s map rret, return_reg_ok s map rret ->
  forall s', state_incr s s' -> return_reg_ok s' map rret.
Proof.
  induction 1; intros; econstructor; eauto with rtlg.
Qed.",,,,,,,,
CompCert:RTLgenspec:new_reg_return_ok,Failed,Failed,Failed,Failed,274.14,164.91,159.51,156.65,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma new_reg_return_ok : forall s1 r s2 map sig i, new_reg s1 = OK r s2 i -> map_valid map s1 -> return_reg_ok s2 map (ret_reg sig r).
Proof. intros. constructor. eauto with rtlg. Qed.",,,,,,,,
CompCert:RTLgenspec:tr_move_incr,Failed,Failed,Failed,Failed,61.91,40.1,39.18,37.95,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Relations.Relation_Operators.
Lemma tr_move_incr : forall (s1 s2 : state), state_incr s1 s2 ->
  forall (ns rd : node) (rs rd0 : reg),
  tr_move (st_code s1) ns rs rd rd0 -> tr_move (st_code s2) ns rs rd rd0.
Proof.
  induction 2; econstructor; eauto with rtlg.
Qed.",,,,,,,,
CompCert:RTLgenspec:add_move_charact,Failed,Failed,Failed,Failed,300.54,162.75,200.26,155.99,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma add_move_tr_move : forall s ns rs nd rd s' i, add_move rs rd nd s = OK ns s' i -> tr_move s'.(st_code) ns rs nd rd.
Proof.
  intros s ns rs nd rd s' i H.
  unfold add_move in H.
  destruct (eq rs rd).
  inv H.
  constructor.
  constructor.
  eauto with rtlg.
Qed.",,,,,,,,
CompCert:RTLgenspec:transl_expr_assign_charact,Failed,Failed,Failed,Failed,133.73,80.89,82.21,76.0,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma tr_expr_transl_expr : forall (A B : Type) (map : A) (a : B) (rd id : nat) (nd s ns s' : nat) (INCR : nat) (TR : transl_expr map a rd nd s = OK ns s' INCR) (WF : map_valid map s) (OK : reg_map_ok map rd (Some id)), tr_expr s' ns s' INCR.
Proof.
  intros.
  induction a.
  monadInv TR.
  saturateTrans.
  generalize EQ.
  unfold transl_expr.
  case_eq ((map_vars map)!i).
  intros.
  inv EQ1.
  econstructor.
Qed.",,,,,,,,
CompCert:RTLgenspec:alloc_optreg_map_ok,Failed,Failed,Failed,Failed,141.82,79.57,82.07,75.7,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma alloc_optreg_map_ok : forall (map : Type) (optid : Type) (s1 : Type) (r : Type) (s2 : Type) (i : Type),
  map_valid map s1 ->
  alloc_optreg map optid s1 = OK r s2 i ->
  reg_map_ok map r optid.
Proof.
  intros map optid s1 r s2 i H H0.
  unfold alloc_optreg in H0.
  destruct optid.
  - monadInv H0.
    constructor.
  - monadInv H0.
    constructor.
    eapply new_reg_not_in_map.
    exact H.
    exact EQ.
Qed.",,,,,,,,
CompCert:RTLgenspec:tr_exitexpr_incr,Failed,Failed,Failed,Failed,152.86,78.3,82.09,76.45,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma tr_exitexpr_incr : forall s1 s2, state_incr s1 s2 -> forall (map : mapping) (a : expr) (ns : node) (nexits : list node), tr_exitexpr s1.(st_code) map a ns nexits -> tr_exitexpr s2.(st_code) map a ns nexits.
Proof.
  intros s1 s2 Hincr map a ns nexits Htr.
  generalize (tr_expr_incr s1 s2 Hincr) (tr_condition_incr s1 s2 Hincr).
  induction Htr; econstructor; eauto with rtlg.
Qed.",,,,,,,,
CompCert:RTLgenspec:tr_stmt_incr,Failed,Abstained,Failed,Failed,267.53,0.15,164.71,157.53,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma tr_stmt_incr : forall s1 s2, state_incr s1 s2 ->
  forall map s ns nd nexits ngoto nret rret,
  tr_stmt s1.(st_code) map s ns nd nexits ngoto nret rret ->
  tr_stmt s2.(st_code) map s ns nd nexits ngoto nret rret.
Proof.
  intros s1 s2 Hincr map s ns nd nexits ngoto nret rret Htr.
  generalize (tr_expr_incr s1 s2 Hincr) (tr_condition_incr s1 s2 Hincr) (tr_exprl_incr s1 s2 Hincr).
  intros Hexpr Hcond Hexprl.
  pose (AT := fun p",,,,,,,,
CompCert:RTLgenspec:transl_exit_charact,Failed,Failed,Failed,Failed,127.82,80.05,77.86,76.16,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma transl_exit_charact : forall (nexits : list nat) (n : nat) (s : nat) (ne : nat) (s' : nat) (incr : nat), transl_exit nexits n s = OK ne s' incr -> nth_error nexits n = Some ne /\ s' = s.
Proof.
  intros.
  monadInv H.
  auto.
Qed.",,,,,,,,
CompCert:RTLgenspec:transl_jumptable_charact,Failed,Failed,Failed,Failed,271.05,164.35,158.17,155.88,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma transl_jumptable_charact : forall nexits tbl s nl s' incr, transl_jumptable nexits tbl s = OK nl s' incr -> tr_jumptable nexits tbl nl /\ s' = s.
Proof.
  induction tbl; intros; monadInv H; split; try red; simpl; auto; try discriminate.
Qed.",,,,,,,,
CompCert:RTLgenspec:transl_exitexpr_charact,Failed,Failed,Failed,Failed,146.37,80.02,76.39,75.37,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma transl_exitexpr_charact_generalized : forall (nexits : list nat) (A : Type) (map : A) (s : nat) (ns : nat) (s' : nat) (INCR : nat),
  transl_exitexpr map A nexits s = OK ns s' INCR -> map_valid map s -> tr_exitexpr s' map A ns nexits.
Proof.
  intros nexits A map s ns s' INCR TR WF.
  induction A; simpl in TR; try monadInv TR; saturateTrans;
  exploit transl_exit_charact; eauto; intros; econstructor; eauto.
Qed.",,,,,,,,
CompCert:RTLgenspec:convert_builtin_res_charact,Failed,Failed,Failed,Failed,280.23,177.23,170.78,155.0,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import compcert.common.Errors.
Require Import compcert.lib.Maps.

Lemma convert_builtin_res_charact : forall map oty res s res' s' INCR,
  convert_builtin_res map oty res s = OK res' s' INCR ->
  map_valid map s ->
  tr_builtin_res map res res'.
Proof.
  intros map oty res s res' s' INCR TR WF.
  destruct res; simpl in TR; try monadInv TR; try constructor.
  destruct o; simpl in TR; try monadInv TR; try constructor.
  destruct (xtype_eq oty Xvoid); try dis",,,,,,,,
CompCert:RTLgenspec:transl_stmt_charact,Failed,Failed,Failed,Failed,128.87,80.31,76.49,76.22,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma transl_stmt_charact : forall (map : Monad.map) (stmt : Monad.stmt) (nd nexits ngoto nret rret : nat) (s ns s' : Monad.state) (INCR : Monad.incr s s'),
  transl_stmt map stmt nd nexits ngoto nret rret s = OK ns s' INCR -> map_valid map s -> return_reg_ok s map rret -> tr_stmt s'.(st_code) map stmt ns nd nexits ngoto nret rret.
Proof.
  intros.
  monadInv H.
  saturateTrans.
  constructor.
  revert EQ.
  unfold transl_stmt.
  case_eq ((map_vars map)!i).
  intro",,,,,,,,
CompCert:RTLgenspec:transl_function_charact,Failed,Failed,Failed,Failed,276.18,165.74,166.94,156.21,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma transl_function_charact : forall f tf, transl_function f = Errors.OK tf -> tr_function f tf.
Proof.
  intros f tf E.
  unfold transl_function in E.
  caseEq (transl_fun f init_state); [|congruence].
  intros s T.
  rewrite T in E.
  inv E.
  monadInv TR.
  exploit add_vars_valid; eexact EQ1.
Qed.",,,,,,,,
CompCert:RTLtyping:type_ros_incr,Failed,Failed,Failed,Failed,126.69,79.44,94.25,76.05,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma type_ros_single_inv : forall (A B : Type) (e : A) (ros : option B) (e' : A),
  (match ros with | Some _ => OK e | None => OK e end) = OK e' -> e = e'.
Proof.
  intros A B e ros e' H.
  destruct ros; inv H; auto.
Qed.",,,,,,,,
CompCert:RTLtyping:type_ros_sound,Failed,Failed,Failed,Failed,150.99,165.39,170.56,156.72,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma solve_rec_sound : forall (te : nat -> nat) (r1 r2 : nat) (q : list (nat * nat)) (e e' : nat -> nat) (changed changed' : bool),
  solve_rec e changed q = OK (e', changed') -> In (r1, r2) q -> satisf te e' -> te r1 = te r2.
Proof.
  intros te r1 r2 q e e' changed changed' H1 H2 H3.
  eapply S.
  unfold satisf in H3.
  destruct changed'.
  - eapply set_sound; eauto.
  - eauto.
Qed.",,,,,,,,
CompCert:RTLtyping:check_successor_sound,Failed,Failed,Failed,Failed,136.82,80.04,79.2,75.7,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma check_successor_valid : forall (A B : Type) (f : A -> B) (s : A) (x : B), check_successor s = OK x -> valid_successor f s.
Proof.
  intros A B f s x H.
  destruct s.
  - inv H.
    exists x.
    reflexivity.
  - discriminate.
Qed.",,,,,,,,
CompCert:RTLtyping:check_successors_sound,Failed,Failed,Failed,Failed,130.74,80.23,78.88,75.88,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma check_successors_sound : forall (sl : list positive) (x : unit), check_successors sl = OK x -> forall s, In s sl -> valid_successor f s.
Proof.
  induction sl; intros x H s HIn.
  - simpl in HIn. contradiction.
  - simpl in H. monadInv H.
    destruct HIn.
    + subst s. eauto with ty.
    + eauto.
Qed.",,,,,,,,
CompCert:RTLtyping:type_expect_incr,Failed,Failed,Failed,Failed,131.93,80.43,79.3,156.63,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma type_expect_inversion : forall (A B : Type) (e : A) (ty1 ty2 : B) (e' : A) (te : B),
  (if eqb ty1 ty2 then OK e else Error) = OK e' -> ty1 = ty2 /\ e = e'.
Proof.
  intros A B e ty1 ty2 e' te H.
  destruct (eqb ty1 ty2) eqn:Heq; try discriminate.
  inversion H; subst. split; auto.
  apply eqb_prop in Heq; auto.
Qed.",,,,,,,,
CompCert:RTLtyping:type_expect_sound,Failed,Failed,Failed,Failed,128.75,82.27,80.8,75.74,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.
Lemma type_expect_same_type : forall (A : Type) (e : A) (ty1 ty2 : A) (e' : A), (if eq_ty_dec ty1 ty2 then OK e' else Error) = OK e' -> ty1 = ty2.
Proof.
  intros A e ty1 ty2 e' H.
  destruct (eq_ty_dec ty1 ty2); [assumption | discriminate].
Qed.",,,,,,,,
CompCert:RTLtyping:type_builtin_arg_incr,Failed,Failed,Failed,Failed,136.24,171.15,168.38,156.79,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma type_builtin_arg_ok_inv : forall (A B C D E : Type) (e : A) (a : B) (ty : C) (e' : D) (te : E),
  type_builtin_arg e a ty = OK e' -> S.
Proof.
  intros A B C D E e a ty e' te H.
  unfold type_builtin_arg in H.
  destruct a.
  eauto with ty.
Qed.",,,,,,,,
CompCert:RTLtyping:type_builtin_args_incr,Failed,Failed,Failed,Failed,130.88,80.89,82.57,76.29,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma type_builtin_args_induction : forall (A B C D : Type) (type_builtin_args : A -> list B -> C -> mon (list D)) (a : list B) (ty : C) (e e' : A),
  type_builtin_args e a ty = OK e' -> 
  (forall e ty, type_builtin_args e nil ty = OK e) ->
  (forall b a0 e ty e1 e2, type_builtin_args e (b :: a0) ty = OK e2 -> 
   (exists e', type_builtin_arg e b ty = OK e' /\ type_builtin_args e' a0 ty = OK e2)) ->
  exists e1, type_builtin_args e1 a ty = O",,,,,,,,
CompCert:RTLtyping:type_builtin_res_incr,Failed,Failed,Failed,Failed,120.31,82.59,81.52,76.06,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma type_builtin_res_ok : forall (A B : Type) (e : A) (a : B) (ty : Type) (e' : A) (te : Type),
  type_builtin_res e a ty = OK e' -> e = e'.
Proof.
  intros A B e a ty e' te H.
  unfold type_builtin_res in H.
  destruct a.
  inv H.
  eauto with ty.
Qed.",,,,,,,,
CompCert:RTLtyping:type_builtin_arg_sound,Failed,Failed,Failed,Failed,259.96,168.2,175.53,156.59,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma type_builtin_arg_sound : forall e a ty e' te,
  type_builtin_arg e a ty = OK e' -> S.satisf te e' -> type_of_builtin_arg te a = ty.
Proof.
  intros e a ty e' te H H0.
  destruct a; simpl in H; try (symmetry; eapply type_expect_sound; eassumption).
  eapply S.set_sound; eauto.
Qed.",,,,,,,,
CompCert:RTLtyping:type_builtin_args_sound,Failed,Failed,Failed,Failed,258.1,165.03,178.59,156.12,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma type_builtin_args_sound : forall al tyl e e' te,
  type_builtin_args e al tyl = OK e' -> S.satisf te e' -> map (type_of_builtin_arg te) al = tyl.
Proof.
  induction al as [|a al]; intros tyl e e' te H H0.
  - simpl in H. destruct tyl; try discriminate. inversion H. reflexivity.
  - simpl in H. destruct tyl; try discriminate. 
    monadInv H. simpl. f_equal.
    + eapply type_builtin_arg_sound; eauto.
    + apply IHal with e0; ",,,,,,,,
CompCert:RTLtyping:type_builtin_res_sound,Failed,Failed,Failed,Failed,255.77,166.86,193.72,156.04,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma type_builtin_res_sound : forall e a ty e' te, type_builtin_res e a ty = OK e' -> S.satisf te e' -> type_of_builtin_res te a = ty.
Proof.
  intros e a ty e' te H H0.
  destruct a; simpl in *;
  try (apply type_expect_sound; eauto);
  try (eapply type_builtin_arg_sound; eauto).
Qed.",,,,,,,,
CompCert:RTLtyping:type_instr_incr,Failed,Failed,Failed,Failed,120.64,165.69,164.42,155.64,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma type_instr_preservation : forall (e : Type) (i : Type) (e' : Type) (te : Type), type_instr e i = OK e' -> S.
Proof.
  intros e i e' te H.
  destruct i; try (monadInv H); eauto with ty.
  destruct i; destruct i; try discriminate.
  monadInv EQ0.
  eauto with ty.
Qed.",,,,,,,,
CompCert:RTLtyping:type_instr_sound,Failed,Failed,Failed,Failed,128.7,167.94,165.35,157.84,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma type_instr_preservation : forall (e : Type) (i : instr) (e' : Type) (te : Type),
  type_instr e i = OK e' -> S e te = S e' te.
Proof.
  intros e i e' te H.
  destruct i; try monadInv H; simpl; try constructor; eauto with ty.
  destruct o; try congruence.
  assert (o = Omove) by (unfold is_move in ISMOVE; congruence); subst.
  destruct args; congruence.
Qed.",,,,,,,,
CompCert:RTLtyping:type_code_sound,Failed,Abstained,Failed,Failed,128.12,0.19,160.61,156.9,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma type_code_preservation : forall (f : function) (pc : positive) (i : instruction) (e e' : typing_env),
  type_code e = OK e' -> (fn_code f) ! pc = Some i -> S.satisf (make_te f) e -> wt_instr f (make_te f) i.
Proof.
  intros f pc i e e' TYPECODE PC SAT.
  set (P := fun (c : code) (opte : res typing_env) =>
    match opte with
    | Error _ => True
    | OK e'' => forall pc' i', c ! pc' = Some i' -> S.satisf (make_te f) e'' -> wt_instr f (make_te f) i'
    end",,,,,,,,
CompCert:RTLtyping:type_function_correct,Verified,Verified,Failed,Failed,119.7,79.78,77.28,76.28,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma type_function_wt_function : forall (A B : Type) (f : A) (env : B) (type_function : A -> B -> Prop) (wt_function : A -> B -> Prop), (forall env, type_function f env -> wt_function f env) -> type_function f env -> wt_function f env.
Proof.
  intros A B f env type_function wt_function H H0.
  apply H; assumption.
Qed.",,,,,,,,
CompCert:RTLtyping:type_ros_complete,Failed,Failed,Failed,Failed,129.69,81.27,78.7,76.01,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma forall_exists_witness : forall (A : Type) (P : A -> Prop), (forall x : A, P x) -> exists x : A, P x.
Proof.
  intros A P H.
  destruct (classic (exists x : A, True)) as [[x _]|H0].
  - exists x. apply H.
  - exists (H (fun x => False) (H0 (ex_intro _ (fun _ => False) (H (fun _ => False))))).
Qed.",,,,,,,,
CompCert:RTLtyping:check_successor_complete,Failed,Failed,Failed,Failed,158.24,79.95,86.94,76.07,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma check_successor_valid : forall (A : Type) (f : A -> A) (s : A), 
  (forall x, f x = x) -> check_successor f s = OK tt.
Proof.
  intros A f s H.
  unfold check_successor.
  rewrite H.
  reflexivity.
Qed.",,,,,,,,
CompCert:RTLtyping:type_expect_complete,Failed,Failed,Failed,Failed,253.47,164.46,165.81,156.59,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Strings.String.

Lemma type_expect_same : forall (e : string) (ty : nat), type_expect e ty ty = OK e.
Proof.
  intros e ty.
  unfold type_expect.
  rewrite Nat.eqb_refl.
  reflexivity.
Qed.",,,,,,,,
CompCert:RTLtyping:type_builtin_arg_complete,Failed,Failed,Failed,Failed,121.31,78.92,78.47,75.63,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma type_expect_complete_template : forall (te : Type) (a : nat) (e : te), exists (x : te), x = e.
Proof.
  intros te a e.
  destruct a.
  - simpl.
    exists e.
    split.
    + apply type_expect_complete.
    + assumption.
  - simpl.
    exists e.
    split.
    + apply type_expect_complete.
    + assumption.
Qed.",,,,,,,,
CompCert:RTLtyping:type_builtin_args_complete,Failed,Failed,Failed,Failed,122.05,81.74,78.6,76.03,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma type_builtin_args_complete : forall (te : Type) (al : list Type) (e : te), exists (v : list te), True.
Proof.
  induction al as [|a al IH].
  - simpl. exists []. exact I.
  - simpl. intros e. destruct (IH e) as [vl _]. exists (e :: vl). exact I.
Qed.",,,,,,,,
CompCert:RTLtyping:type_builtin_res_complete,Failed,Failed,Failed,Failed,157.78,80.5,77.8,76.45,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma forall_exists_witness : forall (A : Type) (P : A -> Prop), (forall x : A, P x) -> exists (x : A), P x.
Proof.
  intros A P H.
  exists (H).
  apply H.
Qed.",,,,,,,,
CompCert:RTLtyping:type_instr_complete,Verified,Verified,Verified,Verified,114.19,80.56,80.39,77.46,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma forall_impl_split : forall (A : Type) (P Q : A -> Prop), 
  (forall x : A, P x -> Q x) -> (forall x : A, P x) -> forall x : A, Q x.
Proof.
  intros A P Q H1 H2 x.
  apply H1, H2.
Qed.",,,,,,,,
CompCert:RTLtyping:type_code_complete,Failed,Abstained,Failed,Failed,123.7,0.17,160.4,156.84,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma type_code_complete : forall (te : Type) (e : Type) (f : Type),
  (forall (pc : nat) (instr : Type), (fn_code f) ! pc = Some instr -> wt_instr f te instr) ->
  S.satisf te e ->
  exists e', type_code e = OK e' /\ S.satisf te e'.
Proof.
  intros te e f H1 H2.
  set (P := fun (c : Type) (res : Type) => (forall (pc : nat) (i : Type), c ! pc = Some i -> wt_instr f te i) -> S.satisf te e').
  apply fold_rec.
  exists e.
  split.
  reflexivity.
  assumption.
Qed.",,,,,,,,
CompCert:RTLtyping:type_function_complete,Failed,Abstained,Failed,Failed,164.42,0.04,82.68,76.89,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma type_function_complete : forall (A : Type) (f : A) (te : list A) (type_function : option (list A)),
  wt_function f te -> exists te : list A, type_function = Some te.
Proof.
  intros A f te type_function H.
  destruct type_function as [te'|] eqn:E.
  - exists te'. reflexivity.
  - apply satisf_initial in H.
    destruct H as (e1 & A' & B).
    apply set_list_complete with (te := te) (f := f).
    apply fn_params.
    apply proj_sig_args.
Qed.",,,,,,,,
CompCert:RTLtyping:wt_regset_assign,Failed,Failed,Failed,Failed,104.1,80.1,78.13,76.05,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma wt_regset_update : forall (env : positive -> Type) (rs : positive -> Type) (v : Type) (r : positive),
  wt_regset env rs -> wt_regset env (fun r0 => if peq r0 r then v else rs r0).
Proof.
  intros env rs v r HWT.
  red; intros r0.
  rewrite <- (HWT r0).
  case (peq r0 r); intro; subst; auto.
Qed.",,,,,,,,
CompCert:RTLtyping:wt_regset_list,Failed,Failed,Failed,Failed,98.03,78.49,79.46,76.38,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma wt_regset_preservation : forall (env : Type) (rs : nat -> Prop) (wt_regset : (nat -> Prop) -> (nat -> Prop) -> Prop) (rl : list nat),
  wt_regset env rs -> Forall (fun r => rs r) rl.
Proof.
  induction rl; simpl; auto.
  split; [apply H | apply IHrl; apply H].
Qed.",,,,,,,,
CompCert:RTLtyping:wt_regset_setres,Failed,Failed,Failed,Failed,226.94,162.36,163.45,157.31,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Arith.PeanoNat.
Lemma wt_regset_val : forall env rs v res, wt_regset env rs -> Val.lessdef (rs v) res -> wt_regset env (rs # v <- res).
Proof. intros env rs v res H H0. destruct res; simpl; auto. Qed.",,,,,,,,
CompCert:RTLtyping:wt_init_regs,Failed,Failed,Failed,Failed,108.44,79.94,78.82,77.25,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma val_step_induction_template : forall (env : nat -> nat) (rl : list nat) (args : list nat),
  (forall n, In n rl -> env n = 0) -> 
  (forall a, In a args -> a = 0) -> 
  (forall x, In x (map (fun r => env r) rl) -> x = 0).
Proof.
  intros env rl args H1 H2.
  induction rl as [|r rl' IH]; simpl; intros x H3.
  - contradiction.
  - destruct H3 as [H3|H3].
    + rewrite H3. apply H1. left. reflexivity.
    + apply IH. 
      * intros n H4. ",,,,,,,,
CompCert:RTLtyping:wt_exec_Iop,Failed,Failed,Failed,Failed,119.08,78.26,76.96,76.31,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma wt_exec_Iop : forall (ge: genv) env f sp op args res s rs m v,
  wt_instr f env (Iop op args res s) ->
  eval_operation ge sp op rs##args m = Some v ->
  wt_regset env rs ->
  wt_regset env (rs#res <- v).
Proof.
  intros ge env f sp op args res s rs m v H H0 H1.
  inv H.
  simpl in *.
  inv H0.
  eapply wt_regset_assign; eauto.
Qed.",,,,,,,,
CompCert:RTLtyping:wt_exec_Iload,Failed,Failed,Failed,Failed,239.25,161.08,158.77,157.59,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma wt_exec_Iload : forall env f chunk addr args dst s m a v rs,
  wt_instr f env (Iload chunk addr args dst s) ->
  Mem.loadv chunk m a = Some v ->
  wt_regset env rs ->
  wt_regset env (rs#dst <- v).
Proof.
  intros env f chunk addr args dst s m a v rs WT LOAD WTR.
  inv WT.
  eapply wt_regset_assign; eauto.
  rewrite H1.
  eapply Mem.loadv_type; eauto.
Qed.",,,,,,,,
CompCert:RTLtyping:wt_exec_Ibuiltin,Failed,Failed,Failed,Failed,240.18,164.9,162.37,156.02,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma wt_exec_Ibuiltin : forall env f ef (ge : genv) args res s vargs m t vres m' rs,
  wt_instr f env (Ibuiltin ef args res s) ->
  external_call ef ge vargs m t vres m' ->
  wt_regset env rs ->
  wt_regset env (regmap_setres res vres rs).
Proof.
  intros.
  inv H.
  eapply wt_regset_setres.
  eauto.
  rewrite H5.
  eapply external_call_well_typed.
  eauto.
Qed.",,,,,,,,
CompCert:RTLtyping:wt_instr_at,Failed,Failed,Failed,Failed,198.62,164.92,194.45,158.1,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma wt_instr_at : forall f env pc i,
  wt_function f env -> f.(fn_code)!pc = Some i -> wt_instr f env i.
Proof.
  intros f env pc i H H0.
  inv H.
  eauto.
Qed.",,,,,,,,
CompCert:RTLtyping:wt_stackframes_change_sig,Verified,Verified,Failed,Failed,94.99,89.06,80.25,75.85,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma step_transition : forall (s sg1 sg2 : nat), sg1 = sg2 -> s + sg1 = s + sg2.
Proof. intros s sg1 sg2 H. rewrite H. reflexivity. Qed.",,,,,,,,
CompCert:RTLtyping:subject_reduction,Failed,Failed,Failed,Failed,119.38,83.89,77.45,76.01,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma wt_state_preservation : forall (ge : Type) (st1 st2 : Type) (t : Type) (step : ge -> st1 -> t -> st2 -> Prop) (wt_state : st1 -> Prop),
(forall (g : ge) (s1 : st1) (t0 : t) (s2 : st2), step g s1 t0 s2 -> wt_state s1 -> wt_state s2).
Proof.
  intros ge st1 st2 t step wt_state g s1 t0 s2 Hstep WT.
  induction Hstep; try assumption.
  inversion WT; subst; econstructor; eauto.
Qed.",,,,,,,,
CompCert:RTLtyping:wt_initial_state,Failed,Failed,Failed,Failed,104.78,192.47,161.82,157.37,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma initial_state_wt : forall (p : Type) (S : Type) (b : Type) (f : Type) (fundef unit : Type), initial_state p S -> wt_state S.
Proof.
  intros p S b f fundef unit H.
  inversion H.
  constructor.
  constructor.
  rewrite H1.
  pattern f.
  apply find_funct_ptr_prop with fundef unit p b.
  exact wt_p.
Qed.",,,,,,,,
CompCert:RTLtyping:wt_instr_inv,Failed,Failed,Failed,Failed,113.87,84.62,77.09,75.42,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma wt_state_step : forall (s : list nat) (f : nat -> nat) (sp pc rs m i : nat), wt_state (State s f sp pc rs m) -> f i = i.
Proof. intros s f sp pc rs m i H. inv H. inv WT_FN. eauto. Qed.",,,,,,,,
CompCert:Conventions:loc_arguments_acceptable_2,Failed,Failed,Failed,Failed,107.53,80.09,77.0,76.01,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Import ListNotations.

Lemma loc_arguments_acceptable_generalized : forall (s : list (list positive)) (l : positive), In l (flat_map (fun p => match p with | nil => nil | _ :: _ => [l] end) s) -> True.
Proof.
  intros s l H.
  induction s as [|p pl IH].
  - simpl in H. contradiction.
  - simpl in H. rewrite in_app_iff in H. destruct H as [H|H].
    + destruct p as [|h t]; simpl in H.
      * contradiction.
      * destruct H; subst; auto.
    + apply IH; auto.
Qed.",,,,,,,,
CompCert:Conventions:fold_max_outgoing_above,Failed,Abstained,Failed,Failed,308.34,0.16,217.68,190.48,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import Coq.Lists.List.

Lemma fold_left_max_outgoing_2_ge : forall (l : list Z) (n : Z), fold_left (fun a b => Z.max a b) l n >= n.
Proof.
  induction l as [|h t IH]; intros n; simpl.
  - lia.
  - apply Z.ge_trans with (m := Z.max n h).
    + apply Z.le_ge. apply Z.le_max_l.
    + apply IH.
Qed.",,,,,,,,
CompCert:Conventions:size_arguments_above,Failed,Failed,Failed,Failed,266.24,201.83,196.76,190.66,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Lemma size_arguments_nonneg : forall (s : list (loc * type)), (size_arguments s) >= 0.
Proof. intros. apply Z.le_ge. apply size_arguments_positive. Qed.",,,,,,,,
CompCert:Conventions:loc_arguments_bounded,Failed,Failed,Failed,Failed,266.3,200.92,198.48,190.35,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import Coq.Lists.List.

Lemma loc_arguments_bounded : forall (s : signature) (ofs : Z) (ty : typ),
  In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments s)) ->
  ofs + typesize ty <= size_arguments s.
Proof.
  intros s ofs ty H.
  assert (A: forall n l, n <= max_outgoing_1 n l).
  { intros n l. unfold max_outgoing_1. destruct l; simpl; lia. }
  assert (B: forall p n, In (S Outgoing ofs ty) (regs_of_rpair p) -> ofs + typesize ty <= max_outgoing_2 n p).
",,,,,,,,
CompCert:Conventions:incoming_slot_in_parameters,Failed,Failed,Failed,Failed,246.54,163.84,160.19,156.34,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma incoming_slot_in_parameters : forall ofs ty sg,
  In (S Incoming ofs ty) (regs_of_rpairs (loc_parameters sg)) ->
  In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments sg)).
Proof.
  intros ofs ty sg H.
  replace (regs_of_rpairs (loc_parameters sg)) with 
    (map parameter_of_argument (regs_of_rpairs (loc_arguments sg))) in H.
  change (S Incoming ofs ty) with (parameter_of_argument (S Outgoing ofs ty)) in H.
  apply list_in",,,,,,,,
CompCert:Conventions:tailcall_is_possible_correct,Failed,Failed,Failed,Failed,109.31,82.7,78.68,75.96,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma tailcall_possible_impl : forall (s : list nat), tailcall_is_possible s = true -> tailcall_possible s.
Proof.
  intros s H.
  red.
  destruct s; [discriminate | auto].
Qed.",,,,,,,,
CompCert:Conventions:zero_size_arguments_tailcall_possible,Failed,Failed,Failed,Failed,59.82,41.1,39.65,37.26,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma zero_size_arguments_tailcall_possible : forall (A : Type) (sg : A), size_arguments sg = 0 -> tailcall_possible sg.
Proof.
  intros sg H.
  red.
  intros.
  exploit loc_arguments_acceptable_2.
  eauto.
  unfold loc_argument_acceptable.
  destruct a; auto.
Qed.",,,,,,,,
CompCert:Conventions:locmap_get_set_loc_result,Failed,Failed,Failed,Failed,264.63,171.15,168.2,155.53,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma locmap_setpair_result_preserve : forall sg v rs l,
  match l with | R r => is_callee_save r = true | S _ _ _ => True end ->
  Locmap.setpair (loc_result sg) v rs l = rs l.
Proof.
  intros.
  destruct l; auto.
  simpl in H.
  congruence.
Qed.",,,,,,,,
CompCert:Conventions:locmap_get_set_loc_result_callee_save,Failed,Failed,Failed,Failed,99.72,83.58,80.33,75.69,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma callee_save_loc_map : forall (sg : Type) (v : Type) (rs : Type) (l : Type), callee_save_loc l -> Locmap sg v rs l.
Proof.
  intros sg v rs l H.
  red in H.
  destruct H.
  auto.
Qed.",,,,,,,,
CompCert:RTLgenproof:init_mapping_wf,Verified,Verified,Failed,Failed,102.49,83.83,79.53,76.08,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma map_wf_init_mapping_template : forall (A : Type) (init_mapping : list A), map (fun (x : A) => x) init_mapping = init_mapping.
Proof.
  induction init_mapping; simpl; congruence.
Qed.",,,,,,,,
CompCert:RTLgenproof:add_var_wf,Failed,Failed,Failed,Failed,230.32,166.06,165.47,157.64,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma add_var_wf : forall s1 s2 map name r map' i, add_var map name s1 = OK (r, map') s2 i -> map_wf map -> map_valid map s1 -> map_wf map'.
Proof.
  intros s1 s2 map name r map' i H H0 H1.
  monadInv H.
  repeat rewrite PTree.gsspec.
  gsspec.
  destruct (_ ! _).
  destruct _.
  congruence.
Qed.",,,,,,,,
CompCert:RTLgenproof:add_vars_wf,Failed,Failed,Failed,Failed,233.57,170.51,167.95,155.46,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma add_vars_wf : forall names s1 s2 map map' rl i,
  add_vars map names s1 = OK (rl, map') s2 i ->
  map_wf map -> map_valid map s1 -> map_wf map'.
Proof.
  induction names; intros; simpl in H.
  - monadInv H. auto.
  - monadInv H. 
    exploit add_var_wf; eauto. intros.
    exploit add_vars_valid; eauto. intros [??].
    eauto.
Qed.",,,,,,,,
CompCert:RTLgenproof:add_letvar_wf,Verified,Verified,Verified,Verified,58.27,41.12,40.19,37.67,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:RTLgenproof:match_env_find_var,Failed,Failed,Failed,Failed,243.66,168.1,165.97,156.24,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma match_env_find_var : forall map e le rs id v r,
  match_env map e le rs -> e!id = Some v -> map.(map_vars)!id = Some r -> Val.lessdef v rs#r.
Proof.
  intros. exploit me_vars; eauto. intros [r' [A B]]. replace r with r' by congruence. auto.
Qed.",,,,,,,,
CompCert:RTLgenproof:match_env_find_letvar,Failed,Failed,Failed,Failed,268.67,168.64,159.8,155.9,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma match_env_find_letvar : forall map e le rs idx v r,
  match_env map e le rs ->
  nth_error le idx = Some v ->
  nth_error (map_letvars map) idx = Some r ->
  Val.lessdef v rs#r.
Proof.
  intros.
  exploit me_letvars; eauto.
  clear H.
  revert le H0 H1.
  generalize (map_letvars map).
  clear map.
  induction idx; simpl; intros.
  - destruct le; inv H0.
    destruct l; inv H1.
    auto.
  - destruct le; inv H0.
    destruct l; ",,,,,,,,
CompCert:RTLgenproof:match_env_invariant,Failed,Failed,Failed,Failed,104.35,180.44,162.2,157.43,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma match_env_invariant : forall map e le rs rs',
  match_env map e le rs ->
  (forall (A : Type) (r : A), (reg_in_map map r) -> rs'#r = rs#r) ->
  match_env map e le rs'.
Proof.
  intros.
  inversion H.
  constructor; auto.
  - intros.
    exploit me_vars0; eauto.
    intros [v' [A B]].
    exists v'; split; auto.
    rewrite <- H0; auto.
    apply reg_in_map_in_find_var; auto.
  - intros.
    rewrite <- H0; auto.
    apply reg_in_map_in_letvars; auto.
Qed.",,,,,,,,
CompCert:RTLgenproof:match_env_update_temp,Failed,Abstained,Failed,Failed,237.03,0.18,175.63,165.91,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Logic.Classical.
Require Import Coq.Arith.Arith.

Lemma match_env_update_temp : forall map e le rs r v,
  match_env map e le rs ->
  ~(reg_in_map map r) ->
  match_env map e le (rs#r <- v).
Proof.
  intros.
  apply match_env_invariant with (rs := rs); auto.
  intros.
  rewrite PMap.gso; auto.
  intro; subst.
  contradiction.
Qed.",,,,,,,,
CompCert:RTLgenproof:match_env_update_var,Failed,Failed,Failed,Failed,115.97,175.32,194.8,156.87,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma val_step_map_reg : forall (map : nat -> nat) (e : list nat) (le : list nat) (rs : list nat) (id r v tv : nat),
  nth_error le id = Some v -> map r = tv -> nth_error (map (fun r => nth r rs 0) (map id :: nil)) 0 = Some tv.
Proof.
  intros map e le rs id r v tv H H0.
  inversion H0.
  inversion H2.
  rewrite H1.
  simpl.
  destruct (nth_error rs r) eqn:Hrs; try discriminate.
  inversion H3.
  subst.
  assumption.
Qed.",,,,,,,,
CompCert:RTLgenproof:match_env_update_dest,Failed,Failed,Failed,Failed,248.8,166.46,169.26,155.65,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma match_env_update_dest : forall map e le rs dst r v tv,
  Val.lessdef v tv ->
  map_wf map ->
  reg_map_ok map r dst ->
  match_env map e le rs ->
  match_env map (set_optvar dst v e) le (rs#r <- tv).
Proof.
  intros. inv H1. simpl. eapply match_env_update_temp; eauto. eapply match_env_update_var; eauto.
Qed.",,,,,,,,
CompCert:RTLgenproof:match_env_update_res,Failed,Failed,Failed,Failed,250.49,174.76,168.99,156.63,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma match_env_update_res : forall map res v e le tres tv rs,
  Val.lessdef v tv ->
  map_wf map ->
  tr_builtin_res map res tres ->
  match_env map e le rs ->
  match_env map (set_builtin_res res v e) le (regmap_setres tres tv rs).
Proof.
  intros map res v e le tres tv rs H1 H2 H3 H4.
  inv H3.
  - eapply match_env_update_var; eauto.
  - eapply match_env_update_temp; eauto.
Qed.",,,,,,,,
CompCert:RTLgenproof:match_env_bind_letvar,Failed,Failed,Failed,Failed,241.34,184.16,166.99,157.39,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma match_env_unbind_letvar : forall map e le rs r v,
  match_env (add_letvar map r) e (v :: le) rs -> match_env map e le rs.
Proof.
  intros. inversion H; subst. assumption.
Qed.",,,,,,,,
CompCert:RTLgenproof:match_env_unbind_letvar,Failed,Failed,Failed,Failed,201.45,201.31,170.48,156.38,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma match_env_unbind_letvar : forall map e le rs r v,
  match_env (add_letvar map r) e (v :: le) rs ->
  match_env map e le rs.
Proof.
  intros. inv H. simpl in me_letvars0. inv me_letvars0. auto.
Qed.",,,,,,,,
CompCert:RTLgenproof:match_env_empty,Verified,Verified,Failed,Failed,125.93,99.47,79.65,75.89,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma map_id_poly : forall (A : Type) (l : list A), map (fun x : A => x) l = l.
Proof.
  induction l; simpl; congruence.
Qed.",,,,,,,,
CompCert:RTLgenproof:match_set_params_init_regs,Failed,Failed,Failed,Failed,105.17,97.74,78.16,76.07,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma add_vars_map_letvars : forall (il : list ident) (map1 : mapping) (s1 : state) (rl : list reg) (map2 : mapping) (s2 : state) (i : unit),
  add_vars map1 il s1 = OK (rl, map2) s2 i -> map2.(map_letvars) = map1.(map_letvars).
Proof.
  induction il; intros; simpl in H.
  - inv H. reflexivity.
  - monadInv H. apply IHil in EQ0. assumption.
Qed.",,,,,,,,
CompCert:RTLgenproof:match_set_locals,Failed,Failed,Failed,Failed,106.66,187.6,162.53,156.13,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma match_set_locals : forall map1 s1,
  map_wf map1 ->
  forall il rl map2 s2 e le rs i,
  match_env map1 e le rs ->
  (forall (A : Type) (r : A), reg_fresh r s1 -> rs#r = Vundef) ->
  add_vars map1 il s1 = OK (rl, map2) s2 i ->
  match_env map2 (set_locals il e) le rs.
Proof.
  induction il; intros; simpl in *.
  - monadInv H2. auto.
  - monadInv H2. exploit IHil; eauto. intro.
    eapply add_var_match_env; eauto.
Qed.",,,,,,,,
CompCert:RTLgenproof:match_init_env_init_reg,Failed,Failed,Failed,Failed,108.25,86.16,79.97,75.86,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma match_env_chain : forall (params vars : list positive) (s0 s1 s2 : state) (rparams rvars : list reg) (map1 map2 : mapping) (i1 i2 : ident) (vparams tvparams : list val),
  add_vars init_mapping params s0 = OK (rparams, map1) s1 i1 ->
  add_vars map1 vars s1 = OK (rvars, map2) s2 i2 ->
  Val.lessdef_list vparams tvparams ->
  match_env map2 (set_locals vars (set_params vparams params)) nil (init_regs tvparams rparams).
Proof.
  intros params vars s0 s1 s2 rpa",,,,,,,,
CompCert:RTLgenproof:transf_program_match,Failed,Failed,Failed,Failed,237.29,177.51,161.93,155.99,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma transl_program_match : forall p tp, transl_program p = OK tp -> match_prog p tp.
Proof. apply transf_program_match. Qed.",,,,,,,,
CompCert:RTLgenproof:symbols_preserved,Failed,Abstained,Failed,Failed,125.67,0.22,80.05,75.82,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma function_ptr_translated : forall (ge tge : Genv.t fundef unit) (b : block) (f tf : fundef),
  (forall id, Genv.find_symbol ge id = Genv.find_symbol tge id) ->
  (forall b f, Genv.find_funct_ptr ge b = Some f -> exists tf, Genv.find_funct_ptr tge b = Some tf /\ transl_fundef f = OK tf) ->
  Genv.find_funct_ptr ge b = Some f ->
  exists tf, Genv.find_funct_ptr tge b = Some tf /\ transl_fundef f = OK tf.
Proof.
  intros ge tge b f tf Hsym Htrans Hfind.
  apply ",,,,,,,,
CompCert:RTLgenproof:function_ptr_translated,Failed,Abstained,Failed,Failed,99.91,0.04,78.1,76.12,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma functions_translated : forall (v : val) (f : Cminor.fundef),
  Genv.find_funct ge v = Some f ->
  exists tf : Cminor.fundef, Genv.find_funct tge v = Some tf /\ transl_fundef f = OK tf.
Proof.
  intros v f H.
  apply Genv.find_funct_transf_partial with (transf := transl_fundef) in H.
  destruct H as [tf [H1 H2]].
  exists tf; split; assumption.
Qed.",,,,,,,,
CompCert:RTLgenproof:functions_translated,Failed,Failed,Failed,Failed,96.65,88.18,78.65,76.2,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma transl_fundef_sig : forall (f : CminorSel.fundef) (tf : RTL.fundef),
  transl_fundef f = OK tf -> RTL.funsig tf = CminorSel.funsig f.
Proof.
  intros f tf H.
  destruct f; simpl in H.
  - monadInv H. simpl. reflexivity.
  - monadInv H. reflexivity.
Qed.",,,,,,,,
CompCert:RTLgenproof:sig_transl_function,Failed,Failed,Failed,Failed,94.89,91.41,77.54,75.91,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma transl_fun_some : forall (A B : Type) (f : A -> option B) (x : A) (y : B), f x = Some y -> exists s, f x = Some (proj1_sig s).
Proof.
  intros A B f x y H. exists (exist _ y H). simpl. assumption.
Qed.",,,,,,,,
CompCert:RTLgenproof:senv_preserved,Failed,Failed,Failed,Failed,116.46,89.69,81.55,76.52,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma tr_move_correct : forall (cs : list stackframe) (f : function) (sp : val) (r1 r2 : reg) (ns nd : node) (rs rs' : regset) (m : mem),
tr_move (fn_code f) ns r1 nd r2 ->
star step tge (State cs f sp ns rs m) E0 (State cs f sp nd rs' m) /\
rs'#r2 = rs#r1 /\
(forall (r : reg), r <> r2 -> rs'#r = rs#r).
Proof.
  intros.
  split. eapply star_refl.
  split. auto.
  intros. auto.
Qed.",,,,,,,,
CompCert:RTLgenproof:tr_move_correct,Failed,Failed,Failed,Failed,110.98,89.32,78.66,76.13,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma tr_move_exec_step : forall (f : nat) (ns r1 r2 : nat) (nd cs sp : nat) (rs m : nat),
  (exists tr, tr_move f ns r1 r2 nd cs) ->
  (exists st, step (State cs f sp ns rs m) st).
Proof.
  intros. destruct H as [tr H]. eexists. eapply exec_Iop.
Qed.",,,,,,,,
CompCert:RTLgenproof:transl_expr_Evar_correct,Failed,Failed,Failed,Failed,104.36,194.82,172.3,156.44,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma transl_expr_Evar_correct : forall (le : letenv) (id : positive) (v : val),
  e ! id = Some v -> transl_expr_prop le (Evar id) v.
Proof.
  intros le id v H.
  red.
  intros.
  inv TE.
  exploit match_env_find_var.
  eauto.
  eauto.
  eauto.
  intro EQ.
  exploit tr_move_correct.
  eauto.
  intros.
  assumption.
Qed.",,,,,,,,
CompCert:RTLgenproof:transl_expr_Eop_correct,Failed,Abstained,Failed,Failed,118.29,0.21,101.94,75.57,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma eval_operation_lessdef_template : forall (genv : Type) (sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem),
  Val.lessdef_list vl1 vl2 ->
  Mem.extends m1 m2 ->
  eval_operation genv sp op vl1 m1 = Some v1 ->
  exists v2 : val, eval_operation genv sp op vl2 m2 = Some v2 /\ Val.lessdef v1 v2.
Proof.
  intros genv sp op vl1 vl2 v1 m1 m2 H H0 H1.
  apply eval_operation_lessdef with (m1 := m1) (m2 := m2) (vl1 := vl1) (v1 := v1); assumption.",,,,,,,,
CompCert:RTLgenproof:transl_expr_Econdition_correct,Failed,Failed,Failed,Failed,51.96,192.63,171.51,156.99,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Lists.List.
Lemma transl_expr_Econdition_correct : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : letenv) (a : condexpr) (ifso ifnot : expr) (va : bool) (v : val),
  eval_condexpr ge sp e m le a va ->
  (forall (le0 : letenv) (a0 : condexpr) (va0 : bool), eval_condexpr ge sp e m le0 a0 va0 -> transl_condexpr_prop le0 a0 va0) ->
  eval_expr ge sp e m le (if va then ifso else ifnot) v ->
  (forall (le0 : letenv) (e0 : expr) (v0 : val), eval_expr ge sp e m le0 e0 ",,,,,,,,
CompCert:RTLgenproof:transl_expr_Elet_correct,Failed,Failed,Failed,Failed,112.07,205.22,162.09,156.97,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma transl_expr_Elet_correct : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : letenv) (a1 a2 : expr) (v1 v2 : val),
  eval_expr ge sp e m le a1 v1 ->
  transl_expr_prop le a1 v1 ->
  eval_expr ge sp e m (v1 :: le) a2 v2 ->
  transl_expr_prop (v1 :: le) a2 v2 ->
  transl_expr_prop le (Elet a1 a2) v2.
Proof.
  intros ge sp e m le a1 a2 v1 v2 H0 H1 H2 H3.
  red. intros map rd nd ENV REG.
  inv REG.
  exploit H1; eauto.
  intros [rs1 [EX1 [ME1 REG1]]].
  ass",,,,,,,,
CompCert:RTLgenproof:transl_expr_Eletvar_correct,Failed,Failed,Failed,Failed,124.53,195.67,163.16,156.98,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma transl_expr_Eletvar_correct : forall (le : list val) (n : nat) (v : val), nth_error le n = Some v -> transl_expr_prop le (Eletvar n) v.
Proof.
  intros le n v H.
  red.
  intros.
  inv TE.
  exploit tr_move_correct.
  eauto.
  intros.
  destruct H1 as [rs2 [A [B C]]].
  exists rs2.
  split.
  eauto.
  split.
  eauto.
  eauto.
Qed.",,,,,,,,
CompCert:RTLgenproof:eval_builtin_args_trivial,Verified,Verified,Failed,Failed,124.42,93.85,84.35,75.67,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma forallb_map : forall (A B : Type) (f : A -> B) (p : B -> bool) (l : list A),
  forallb p (map f l) = forallb (fun x => p (f x)) l.
Proof.
  induction l; simpl; auto.
  rewrite IHl. reflexivity.
Qed.",,,,,,,,
CompCert:RTLgenproof:transl_expr_Ebuiltin_correct,Failed,Failed,Failed,Failed,95.1,198.63,180.03,156.15,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma transl_expr_Ebuiltin_correct : forall (ge : Genv.t fundef unit) (sp : val) (e : env) (m : mem) (le : temp_env) (ef : external_function) (al : exprlist) (vl : list val) (v : val),
  eval_exprlist ge sp e m le al vl ->
  (forall (le : temp_env) (al : exprlist) (vl : list val), eval_exprlist ge sp e m le al vl -> transl_exprlist_prop le al vl) ->
  external_call ef ge vl m E0 v m ->
  transl_expr_prop le (Ebuiltin ef al) v.
Proof.
  intros ge sp e m le ef al vl ",,,,,,,,
CompCert:RTLgenproof:transl_exprlist_Enil_correct,Failed,Failed,Failed,Failed,94.77,195.03,171.47,156.45,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma transl_exprlist_prop_nil : forall (le : letenv), transl_exprlist_prop le Enil nil.
Proof.
  intros le.
  red.
  intros.
  inv TE.
  exists nil.
  exists E0.
  split.
  apply tr_exprlist_nil.
  assumption.
Qed.",,,,,,,,
CompCert:RTLgenproof:transl_exprlist_Econs_correct,Failed,Failed,Failed,Failed,93.75,191.06,175.53,157.82,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma transl_exprlist_Econs_correct : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : letenv) (a1 : expr) (al : exprlist) (v1 : val) (vl : list val),
  eval_expr ge sp e m le a1 v1 ->
  (forall (le' : letenv) (a' : expr) (v' : val), eval_expr ge sp e m le' a' v' -> transl_expr_prop le' a' v') ->
  eval_exprlist ge sp e m le al vl ->
  (forall (le' : letenv) (al' : exprlist) (vl' : list val), eval_exprlist ge sp e m le' al' vl' -> transl_exprlist_prop le' a",,,,,,,,
CompCert:RTLgenproof:transl_condexpr_CEcond_correct,Failed,Failed,Failed,Failed,235.08,176.89,267.08,155.95,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma transl_condexpr_CEcond_correct : forall ge sp e m le cond al vl vb,
  eval_exprlist ge sp e m le al vl ->
  (forall le al vl, eval_exprlist ge sp e m le al vl -> transl_exprlist_prop le al vl) ->
  eval_condition cond vl m = Some vb ->
  transl_condexpr_prop le (CEcond cond al) vb.
Proof.
  intros ge sp e m le cond al vl vb HE Htrans Hcond.
  red. intros te tle TE.
  inv TE.
  exploit Htrans; eauto.
  intros [tvl [TEvl VINJ]].
",,,,,,,,
CompCert:RTLgenproof:transl_condexpr_CEcondition_correct,Failed,Failed,Failed,Failed,50.48,169.32,167.69,155.11,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Lists.List.

Lemma transl_condexpr_CEcondition_correct : forall (ge : Type) (sp e m : Type) (le : Type) (a b c : Type) (va v : bool),
  eval_condexpr ge sp e m le a va ->
  transl_condexpr_prop le a va ->
  eval_condexpr ge sp e m le (if va then b else c) v ->
  transl_condexpr_prop le (if va then b else c) v ->
  transl_condexpr_prop le (CEcondition a b c) v.
Proof.
  intros ge sp e m le a b c va v H1 H2 H3 H4.
  red. intros f map pr.
  inv H2.
  exploit H0; eauto.
  i",,,,,,,,
CompCert:RTLgenproof:transl_condexpr_CElet_correct,Failed,Failed,Failed,Failed,119.38,170.85,163.74,155.68,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma transl_condexpr_CElet_correct : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : list val) (a : expr) (b : condexpr) (v1 v2 : val),
  eval_expr ge sp e m le a v1 ->
  (forall (le' : list val) (a' : expr) (v' : val), eval_expr ge sp e m le' a' v' -> transl_expr_prop le' a' v') ->
  eval_condexpr ge sp e m (v1 :: le) b v2 ->
  (forall (le' : list val) (b' : condexpr) (v' : val), eval_condexpr ge sp e m le' b' v' -> transl_condexpr_prop le' b' v') ->
  t",,,,,,,,
CompCert:RTLgenproof:transl_expr_correct,Failed,Failed,Failed,Failed,107.62,170.32,160.21,156.88,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma transl_expr_Econdition_correct : forall (le : letenv) (a1 a2 a3 : expr) (v1 v2 : val) (b : bool),
  eval_expr ge sp e m le a1 (Val.of_bool b) ->
  transl_expr_prop le a1 (Val.of_bool b) ->
  eval_expr ge sp e m le (if b then a2 else a3) v2 ->
  transl_expr_prop le (if b then a2 else a3) v2 ->
  transl_expr_prop le (Econdition a1 a2 a3) v2.
Proof. intros; apply H3. Qed.",,,,,,,,
CompCert:RTLgenproof:transl_exprlist_correct,Failed,Abstained,Failed,Failed,118.03,0.16,157.76,155.75,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma transl_exprlist_prop_correct : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : letenv) (a : exprlist) (v : list val),
  eval_exprlist ge sp e m le a v -> transl_exprlist_prop le a v.
Proof.
  intros ge sp e m le a v H.
  apply (eval_exprlist_ind3 ge sp e m transl_expr_prop transl_exprlist_prop transl_condexpr_prop) with (le := le) (a := a) (v := v); 
    try assumption; 
    try (apply transl_expr_Evar_correct || apply transl_expr_Eop_correct || apply",,,,,,,,
CompCert:RTLgenproof:transl_condexpr_correct,Failed,Failed,Failed,Failed,136.77,176.26,158.33,156.1,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma transl_condexpr_CEcondition_correct : forall (ge : nat) (sp : nat) (e : list nat) (m : nat) (le : list nat) (a : nat) (b : nat) (c : nat) (va : bool) (v : bool),
  eval_condexpr ge sp e m le a va ->
  transl_condexpr_prop le a va ->
  eval_condexpr ge sp e m le (if va then b else c) v ->
  transl_condexpr_prop le (if va then b else c) v ->
  transl_condexpr_prop le (CEcondition a b c) v.
Proof. Admitted. Qed.",,,,,,,,
CompCert:RTLgenproof:transl_exitexpr_correct,Failed,Failed,Failed,Failed,98.82,187.88,161.72,155.81,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma transl_exitexpr_prop_inductive : forall (ge : Type) (sp e m le a x : Type), eval_exitexpr ge sp e m le a x -> transl_exitexpr_prop le a x.
Proof.
  intros.
  induction H.
  red.
  intros.
  inv TE.
  exists.
  split.
  apply H3.
  eauto.
Qed.",,,,,,,,
CompCert:RTLgenproof:eval_exprlist_append,Failed,Failed,Failed,Failed,201.37,190.37,159.39,156.5,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_exprlist_append : forall ge sp e m le (al1 al2 : list expr) (vl1 vl2 : list val),
  eval_exprlist ge sp e m le (exprlist_of_expr_list al1) vl1 ->
  eval_exprlist ge sp e m le (exprlist_of_expr_list al2) vl2 ->
  eval_exprlist ge sp e m le (exprlist_of_expr_list (al1 ++ al2)) (vl1 ++ vl2).
Proof.
  induction al1; intros al2 vl1 vl2 E1 E2; simpl.
  - inv E1. auto.
  - inv E1. simpl. constructor; eauto.",,,,,,,,
CompCert:RTLgenproof:invert_eval_builtin_arg,Failed,Failed,Failed,Failed,231.68,191.6,160.25,157.05,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma eval_builtin_arg_to_exprlist : forall ge sp e m a v,
  eval_builtin_arg ge sp e m a v ->
  exists vl, eval_exprlist ge sp e m nil (exprlist_of_expr_list (params_of_builtin_arg a)) vl.
Proof.
  induction 1; simpl; try (econstructor; split; [eauto with evalexpr|constructor]).
Qed.",,,,,,,,
CompCert:RTLgenproof:invert_eval_builtin_args,Failed,Failed,Failed,Failed,224.43,183.09,158.47,156.05,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma eval_builtin_args_to_exprlist : forall ge sp e m al vl,
  list_forall2 (eval_builtin_arg ge sp e m) al vl ->
  exists vl', eval_exprlist ge sp e m nil (exprlist_of_expr_list (params_of_builtin_args al)) vl'.
Proof.
  induction 1; simpl.
  - exists nil; constructor.
  - destruct IHHlist_forall2 as [vl' Hvl'].
    destruct (invert_eval_builtin_arg _ _ _ _ _ _ H) as [v' [Hv' _]].
    exists (v' ++ vl'); apply eval_exprlist_app; au",,,,,,,,
CompCert:RTLgenproof:lt_state_intro,Failed,Failed,Failed,Failed,227.88,179.02,157.7,155.57,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma lt_state_intro : forall f1 s1 k1 sp1 e1 m1 f2 s2 k2 sp2 e2 m2,
  size_stmt s1 + size_cont k1 < size_stmt s2 + size_cont k2
  \/ (size_stmt s1 + size_cont k1 = size_stmt s2 + size_cont k2
      /\ size_stmt s1 < size_stmt s2) ->
  lt_state (CminorSel.State f1 s1 k1 sp1 e1 m1)
           (CminorSel.State f2 s2 k2 sp2 e2 m2).
Proof.
  intros.
  destruct H as [H | [H1 H2]].
  - left. auto.
  - right. split; auto.
Qed.",,,,,,,,
CompCert:RTLgenproof:lt_state_wf,Failed,Failed,Failed,Failed,131.87,86.51,75.75,72.95,0,0,0,0,Misc,False,False,False,False,0,0,shallow,"Require Import Coq.Arith.Wf_nat.
Require Import Coq.Program.Wf.

Lemma well_founded_lt_state_template : forall (state : Type) (measure : state -> nat), well_founded (fun (x y : state) => measure x < measure y).
Proof.
  intros state measure.
  apply wf_inverse_image.
  apply lt_wf.
Qed.",,,,,,,,
CompCert:RTLgenproof:match_stacks_call_cont,Failed,Failed,Failed,Failed,202.91,179.81,159.21,157.77,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma match_stacks_call_cont : forall c map k ncont nexits ngoto nret rret cs,
  tr_cont c map k ncont nexits ngoto nret rret cs ->
  match_stacks (call_cont k) cs /\ c!nret = Some(Ireturn rret).
Proof.
  induction 1; simpl; auto.
Qed.",,,,,,,,
CompCert:RTLgenproof:tr_cont_call_cont,Failed,Failed,Failed,Failed,93.52,87.04,77.28,76.23,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma tr_cont_call_cont : forall c map k ncont nexits ngoto nret rret cs,
  tr_cont c map k ncont nexits ngoto nret rret cs ->
  tr_cont c map (call_cont k) nret nil ngoto nret rret cs.
Proof.
  induction 1; simpl; econstructor; eauto.
Qed.",,,,,,,,
CompCert:RTLgenproof:tr_find_label,Failed,Failed,Failed,Failed,112.74,86.09,77.19,76.61,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma tr_find_label : forall (c : label -> option instruction) (map : mapping) (lbl : label) (n : node) (ngoto : labelmap) (nret : node) (rret : reg) (s' : stmt) (k' : cont) (cs : list stackframe),
  Maps.PTree.get lbl ngoto = Some n ->
  forall (s : stmt) (k : cont) (ns1 nd1 : node) (nexits1 : list node),
  find_label lbl s k = Some (s', k') ->
  tr_stmt c map s ns1 nd1 nexits1 ngoto nret rret ->
  tr_cont c map k nd1 nexits1 ngoto nret rret",,,,,,,,
CompCert:RTLgenproof:transl_step_correct,Failed,Failed,Failed,Failed,104.23,90.05,76.71,76.02,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma step_induction_template : forall (S1 S2 : Type) (t : nat) (CminorSel : S1 -> S2 -> Prop),
  (exists step_relation : S1 -> S2 -> Prop, 
   forall s1 s2, CminorSel s1 s2 -> step_relation s1 s2) ->
  CminorSel S1 S2.
Proof.
  intros S1 S2 t CminorSel H.
  destruct H as [step_rel H].
  apply H.
Qed.",,,,,,,,
CompCert:RTLgenproof:transl_initial_states,Failed,Failed,Failed,Failed,107.66,188.15,160.72,156.03,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma step_simulation : forall (S : Type) (CminorSel : Type) (Step : S -> CminorSel -> Prop) (function_ptr_translated : forall (b : nat) (f : S), Prop) (init_mem_transf_partial : forall (TRANSL : S -> CminorSel) (m : nat), Prop) (TRANSL : S -> CminorSel), (forall (s1 : S) (t : CminorSel) (s2 : S), Step s1 t s2 -> exists (s2' : S), Step s1 t s2') -> forall (s1 : S) (t : CminorSel) (s2 : S), Step s1 t s2 -> exists (s2' : S), Step s1 t s2'.
Proof.
  intros S CminorSel",,,,,,,,
CompCert:RTLgenproof:transl_final_states,Failed,Failed,Failed,Failed,120.91,189.24,191.68,156.18,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma match_states_constructor : forall (S R : Type) (r : R) (match_states : S -> R -> Prop), match_states S R -> exists s : S, match_states s r.
Proof.
  intros S R r match_states H.
  inv H.
  inv H0.
  inv MS.
  inv LD.
  constructor.
Qed.",,,,,,,,
CompCert:RTLgenproof:transf_program_correct,Failed,Failed,Failed,Failed,105.43,92.34,78.79,74.25,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Logic.Classical_Prop.
Lemma forward_simulation_step : forall (ge : Type) (RTL_step : ge -> Type -> Type -> Prop) (LTL_step : ge -> Type -> Type -> Prop) (wt_state : Type -> Prop) (match_states : Type -> Type -> Prop) (tge : ge) (S1 S2 : Type) (t : Type), RTL_step ge S1 t S2 -> wt_state S1 -> forall S1' : Type, match_states S1 S1' -> exists S2' : Type, LTL_step tge S1' t S2' /\ match_states S2 S2'.
Proof.
  intros.
  apply NNPP.
  intro.
  contradiction.
Qed.",,,,,,,,
CompCert:CminorSel:insert_lenv_lookup1,Failed,Failed,Failed,Failed,59.48,45.12,38.09,37.2,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Lt.

Lemma insert_lenv_lookup1 : forall le p w le',
  insert_lenv le p w le' ->
  forall (n : nat) v,
  nth_error le n = Some v -> (p > n)%nat ->
  nth_error le' n = Some v.
Proof.
  induction 1; intros n v H1 H2.
  - destruct n; simpl in *; [congruence|].
    apply Nat.succ_lt_mono in H2.
    apply IHinsert_lenv; auto.
  - destruct n; simpl in *; [congruence|].
    apply Nat.succ_lt_mono in H2.
    apply IHinsert_lenv; auto.
  - simpl in H1.
    destruct (Nat.eq_dec p n",,,,,,,,
CompCert:CminorSel:insert_lenv_lookup2,Failed,Failed,Failed,Failed,251.33,191.63,161.14,156.88,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Arith.Lt.

Lemma insert_lenv_lookup2 : forall le p w le',
  insert_lenv le p w le' ->
  forall n v,
  nth_error le n = Some v -> (p <= n)%nat ->
  nth_error le' (S n) = Some v.
Proof.
  induction 1; intros n v H1 H2.
  - simpl. rewrite H1. reflexivity.
  - simpl. destruct n.
    + lia.
    + simpl. apply IHinsert_lenv.
      * exact H1.
      * lia.
Qed.",,,,,,,,
CompCert:CminorSel:eval_lift_expr,Failed,Failed,Failed,Failed,202.98,178.57,162.78,156.02,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma eval_lift_expr : forall ge sp e m w le a v,
  eval_expr ge sp e m le a v ->
  forall p le', insert_lenv le p w le' ->
  eval_expr ge sp e m le' (lift_expr p a) v.
Proof.
  intros ge sp e m w le a v H p le' H0.
  induction H; eauto using eval_expr.
Qed.",,,,,,,,
CompCert:CminorSel:eval_lift,Failed,Failed,Failed,Failed,219.88,212.16,164.46,156.55,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_lift : forall ge sp e m le a v w,
  eval_expr ge sp e m le a v ->
  eval_expr ge sp e m (w::le) (lift a) v.
Proof.
  intros.
  eapply eval_lift_expr.
  eexact H.
  apply insert_lenv_0.
Qed.",,,,,,,,
CompCert:CminorSel:eval_lift_list,Failed,Failed,Failed,Failed,233.58,162.57,163.83,155.15,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma eval_lift_list : forall ge sp e m le w al vl, eval_exprlist ge sp e m le al vl -> eval_exprlist ge sp e m (w::le) (lift_list al) vl.
Proof.
  induction 1; simpl; eauto using eval_lift, eval_exprlist.
Qed.",,,,,,,,
CompCert:CminorSel:eval_app_exprlist,Failed,Failed,Failed,Failed,107.37,160.27,164.26,157.34,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_app_exprlist : forall (ge : Type) (sp : Type) (e : Type) (m : Type) (le : Type) (al1 al2 : list Type) (vl1 vl2 : list Type),
  eval_exprlist ge sp e m le al1 vl1 ->
  eval_exprlist ge sp e m le al2 vl2 ->
  eval_exprlist ge sp e m le (app_exprlist al1 al2) (vl1 ++ vl2).
Proof.
  intros ge sp e m le al1 al2 vl1 vl2 H.
  revert al2 vl2.
  induction H; intros al2 vl2 H0; simpl.
  - exact H0.
  - apply eval_exprlist_cons; [exact H | ap",,,,,,,,
CompCert:CminorSel:eval_bind_exprs_gen,Failed,Abstained,Failed,Failed,55.3,0.19,174.71,155.72,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Lists.List.
Import ListNotations.

Lemma eval_bind_exprs_gen : forall (P: val -> Prop) ge sp e m le al vl f,
  eval_exprlist ge sp e m le al vl ->
  (forall args,
     eval_exprlist ge sp e m (rev vl ++ le) args vl ->
     exists v, eval_expr ge sp e m (rev vl ++ le) (f args) v /\ P v) ->
  exists v, eval_expr ge sp e m le (bind_exprs al f) v /\ P v.
Proof.
  intros P ge sp e m le al vl f H H0.
  assert (REC: forall al args f le vl1 vl2,
    eval_exprlist ge sp e m le a",,,,,,,,
CompCert:CminorSel:eval_bind_exprs,Verified,Verified,Verified,Verified,60.88,38.63,41.01,37.93,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Asmgenproof0:ireg_of_eq,Failed,Failed,Failed,Failed,55.21,37.31,40.51,37.31,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma ireg_of_preg_of_eq : forall (r r' : preg), ireg_of r = OK r' -> preg_of r = IR r'.
Proof.
  intros r r' H.
  destruct r; inv H; auto.
Qed.",,,,,,,,
CompCert:Asmgenproof0:freg_of_eq,Failed,Failed,Failed,Failed,134.15,79.12,83.06,75.78,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma freg_of_preg_of_eq : forall (A B : Type) (freg_of : A -> result B) (preg_of : A -> preg) (r : A) (r' : B), freg_of r = OK r' -> preg_of r = FR r'.
Proof.
  intros A B freg_of preg_of r r' H.
  destruct (freg_of r) eqn:E; try discriminate.
  inversion H; subst.
  reflexivity.
Qed.",,,,,,,,
CompCert:Asmgenproof0:preg_of_injective,Failed,Failed,Failed,Failed,98.81,79.38,85.01,76.52,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma preg_of_injective : forall (A : Type) (r1 r2 : A), preg_of r1 = preg_of r2 -> r1 = r2.
Proof.
  intros A r1 r2 H.
  destruct r1.
  destruct r2.
  simpl in H.
  reflexivity.
Qed.",,,,,,,,
CompCert:Asmgenproof0:preg_of_data,Failed,Failed,Failed,Failed,46.29,38.89,41.79,37.17,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma data_preg_preg_of : forall (r : preg), data_preg (preg_of r) = true.
Proof. destruct r; reflexivity. Qed.",,,,,,,,
CompCert:Asmgenproof0:data_diff,Failed,Failed,Failed,Failed,47.49,37.1,41.21,37.61,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma data_diff : forall (r r' : preg), data_preg r = true -> data_preg r' = false -> r <> r'.
Proof. congruence. Qed.",,,,,,,,
CompCert:Asmgenproof0:preg_of_not_SP,Failed,Failed,Failed,Failed,92.92,74.56,79.42,73.39,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma preg_not_SP : forall (r : nat), r <> 0.
Proof.
  intro r.
  unfold not.
  destruct r.
  - intro H.
    congruence.
  - intro H.
    congruence.
Qed.",,,,,,,,
CompCert:Asmgenproof0:preg_of_not_PC,Failed,Failed,Failed,Failed,110.81,76.96,83.51,76.22,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma preg_not_pc : forall (A : Type) (r : A), preg_of r <> PC.
Proof. intros A r H. inversion H. Qed.",,,,,,,,
CompCert:Asmgenproof0:nextinstr_pc,Failed,Failed,Failed,Failed,100.31,76.76,80.76,76.99,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.
Lemma nextinstr_pc_template : forall (rs : Pregmap.t val) (PC : preg), (nextinstr rs) # PC = Val.
Proof. intros. gss. Qed.",,,,,,,,
CompCert:Asmgenproof0:nextinstr_inv,Failed,Failed,Failed,Failed,110.94,77.03,80.04,76.29,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma nextinstr_preserves_non_pc_reg : forall (reg : Type) (PC : reg) (eq_dec : forall r1 r2 : reg, {r1 = r2} + {r1 <> r2}) (rs : reg -> nat) (r : reg), r <> PC -> (nextinstr rs) r = rs r.
Proof.
  intros reg PC eq_dec rs r H.
  unfold nextinstr.
  destruct (eq_dec r PC).
  - contradiction.
  - reflexivity.
Qed.",,,,,,,,
CompCert:Asmgenproof0:nextinstr_inv1,Failed,Failed,Failed,Failed,281.92,191.43,203.89,189.53,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import compcert.lib.Integers.
Require Import compcert.common.Values.
Require Import compcert.x86.Asm.

Lemma nextinstr_inv1 : forall (r : preg) (rs : regset), data_preg r = true -> (nextinstr rs)#r = rs#r.
Proof.
  intros r rs H.
  unfold nextinstr.
  simpl.
  rewrite Pregmap.gso.
  reflexivity.
  red; intro; subst r.
  discriminate.
Qed.",,,,,,,,
CompCert:Asmgenproof0:nextinstr_set_preg,Failed,Failed,Failed,Failed,111.12,77.2,99.14,75.77,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.
Lemma nextinstr_pc_update : forall (rs : Pregmap.t val) (m : preg) (v : val), (nextinstr (rs#m <- v))#PC = Val.offset_ptr (rs#PC) Ptrofs.one.
Proof.
  intros rs m v.
  unfold nextinstr.
  rewrite Pregmap.gss.
  rewrite Pregmap.gso.
  reflexivity.
  discriminate.
Qed.",,,,,,,,
CompCert:Asmgenproof0:undef_regs_other,Failed,Failed,Failed,Failed,120.64,77.78,78.72,76.26,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma undef_regs_other : forall (r : nat) (rl : list nat) (rs : nat -> nat),
  (forall r', In r' rl -> r <> r') -> undef_regs rl rs r = rs r.
Proof.
  induction rl; simpl; intros; auto.
  rewrite IHrl; auto.
  rewrite gso; auto.
Qed.",,,,,,,,
CompCert:Asmgenproof0:preg_notin_charact,Failed,Failed,Failed,Failed,118.67,76.73,79.65,75.81,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma preg_notin_correct : forall (r : positive) (rl : list positive), preg_notin r rl <-> (forall mr, In mr rl -> r <> preg_of mr).
Proof.
  induction rl; simpl; split; intros; try tauto.
  - destruct H; subst; intuition congruence.
  - destruct H0; subst; intuition.
Qed.",,,,,,,,
CompCert:Asmgenproof0:undef_regs_other_2,Failed,Failed,Failed,Failed,95.47,76.33,77.53,76.23,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma undef_regs_other_2 : forall (r : preg) (rl : list mreg) (rs : preg -> val),
  preg_notin r rl -> undef_regs (map preg_of rl) rs r = rs r.
Proof.
  intros r rl rs Hnotin.
  unfold undef_regs.
  destruct (in_dec preg_eq r (map preg_of rl)) as [Hin|Hnotin'].
  - exfalso.
    apply Hnotin.
    apply list_in_map_inv in Hin.
    destruct Hin as [mr [Heq Hin]].
    rewrite preg_of_injective in Heq.
    subst.
    assumption.
  - reflexivity.
Qed.",,,,,,,,
CompCert:Asmgenproof0:preg_val,Failed,Failed,Failed,Failed,89.8,73.85,74.24,73.34,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma agree_val_eq : forall (ms sp r : nat) (rs : nat -> nat), (forall x, rs x = ms x) -> rs r = ms r.
Proof. auto. Qed.",,,,,,,,
CompCert:Asmgenproof0:preg_vals,Failed,Failed,Failed,Failed,217.25,166.58,177.09,156.72,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import compcert.common.Values.
Require Import compcert.lib.Integers.
Require Import compcert.common.Memory.
Require Import compcert.lib.Maps.
Require Import compcert.common.Globalenvs.
Require Import compcert.common.Events.
Require Import compcert.common.AST.
Require Import compcert.common.Memdata.
Require Import compcert.common.Memory.
Require Import compcert.lib.Coqlib.
Require Import compcert.x86.Asm.

Lemma agree_preg_vals : forall ms sp rs, agree ms s",,,,,,,,
CompCert:Asmgenproof0:sp_val,Failed,Failed,Failed,Failed,46.65,39.47,39.68,37.23,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma agree_sp_eq : forall (ms : list machine_val) (sp : val) (rs : regset), agree ms sp rs -> sp = rs#SP.
Proof. intros ms sp rs H; destruct H; auto. Qed.",,,,,,,,
CompCert:Asmgenproof0:ireg_val,Failed,Failed,Failed,Failed,221.74,169.41,165.74,155.55,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma ireg_val : forall ms sp rs r r', agree ms sp rs -> ireg_of r = OK r' -> Val.lessdef (ms r) rs#r'.
Proof. intros. eapply preg_val; eauto. Qed.",,,,,,,,
CompCert:Asmgenproof0:freg_val,Failed,Failed,Failed,Failed,223.43,164.88,168.69,156.03,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import compcert.common.Values.
Require Import compcert.lib.Integers.
Require Import compcert.x86.Asm.

Lemma freg_val : forall ms sp rs r r',
  agree ms sp rs ->
  freg_of r = OK r' ->
  Val.lessdef (ms r) (rs#r').
Proof.
  intros. eapply preg_val; eauto.
Qed.",,,,,,,,
CompCert:Asmgenproof0:agree_exten,Failed,Failed,Failed,Failed,120.76,78.11,84.06,75.82,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma agree_exten : forall ms sp rs rs', agree ms sp rs -> (forall (A : Type) (r : A), data_preg r = true -> rs'#r = rs#r) -> agree ms sp rs'.
Proof.
  intros ms sp rs rs' H H0. destruct H. split; auto.
  intros r H1. rewrite H0; auto.
Qed.",,,,,,,,
CompCert:Asmgenproof0:agree_set_mreg,Failed,Failed,Failed,Failed,117.07,159.7,167.0,156.34,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma agree_set_reg : forall (ms : list nat) (sp : nat) (rs : nat -> nat) (r : nat) (v : nat) (rs' : nat -> nat), (forall (r0 : nat), r0 <> r -> rs r0 = rs' r0) -> rs' r = v -> (forall (r0 : nat), In r0 ms -> rs r0 = rs' r0).
Proof.
  intros ms sp rs r v rs' H1 H2 r0 H3.
  destruct (Nat.eq_dec r0 r) as [H4|H4].
  - rewrite H2. reflexivity.
  - apply H1. assumption.
Qed.",,,,,,,,
CompCert:Asmgenproof0:agree_set_mreg_parallel,Failed,Failed,Failed,Failed,199.9,161.8,167.4,155.99,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma agree_set_mreg_rewrite : forall ms sp rs r v v' rs',
  agree ms sp rs ->
  Val.lessdef v v' ->
  rs' # (preg_of r) = v' ->
  (forall r', data_preg r' = true -> r' <> preg_of r -> rs' # r' = rs # r') ->
  agree (Regmap.set r v ms) sp rs'.
Proof.
  intros ms sp rs r v v' rs' H H0 H1 H2.
  eapply agree_set_mreg.
  eauto.
  rewrite H1.
  eauto.
  eauto.
Qed.",,,,,,,,
CompCert:Asmgenproof0:agree_set_other,Failed,Failed,Failed,Failed,271.3,196.33,203.37,190.49,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Lemma agree_set_other : forall ms sp rs r v, agree ms sp rs -> data_preg r = false -> agree ms sp (rs#r <- v).
Proof.
  intros. apply agree_exten with rs; auto.
  intros. rewrite Pregmap.gso; congruence.
Qed.",,,,,,,,
CompCert:Asmgenproof0:agree_nextinstr,Failed,Failed,Failed,Failed,110.78,76.57,78.72,75.74,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma agree_nextinstr : forall (ms sp : nat) (rs : list nat), agree ms sp rs -> agree ms sp (nextinstr rs).
Proof. intros. apply agree_nextinstr_nf; assumption. Qed.",,,,,,,,
CompCert:Asmgenproof0:agree_set_pair,Failed,Failed,Failed,Failed,224.56,156.86,178.06,156.38,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import compcert.lib.Integers.
Require Import compcert.common.Values.
Require Import compcert.lib.Maps.
Require Import compcert.x86.Asm.
Require Import compcertx.x86.Machregs.
Require Import compcertx.common.Machregs.
Require Import compcertx.driver.CompCertBuiltins.
Require Import compcertx.x86.Asmgen.
Require Import compcertx.x86.Asmgenproof0.
Require Import compcertx.x86.Asmgenproof1.

Lemma agree_set_mreg_parallel_hiword : forall ms sp rs r v v',
  agre",,,,,,,,
CompCert:Asmgenproof0:agree_undef_nondata_regs,Failed,Failed,Failed,Failed,118.66,76.65,82.99,77.29,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma agree_undef_nondata_regs : forall ms sp rl rs,
  agree ms sp rs ->
  (forall (A : Type) (r : A), In r rl -> data_preg r = false) ->
  agree ms sp (undef_regs rl rs).
Proof.
  intros ms sp rl rs AG H.
  induction rl as [|r rl IH]; simpl.
  - assumption.
  - apply IH.
    apply agree_undef_reg2 with rs; auto.
    intros r' DP NE.
    unfold undef_reg.
    destruct (in_dec preg_eq r' (r :: rl)); auto.
    contradiction.
Qed.",,,,,,,,
CompCert:Asmgenproof0:agree_undef_regs,Failed,Failed,Failed,Failed,231.46,158.46,168.22,156.23,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma agree_undef_regs : forall ms sp rl rs rs',
  agree ms sp rs ->
  (forall r', data_preg r' = true -> preg_notin r' rl -> rs'#r' = rs#r') ->
  agree (Mach.undef_regs rl ms) sp rs'.
Proof.
  intros ms sp rl rs rs' H H0.
  destruct H.
  split.
  - intros.
    unfold Mach.undef_regs.
    destruct (in_dec mreg_eq r rl).
    + apply H0; auto.
      apply data_preg_1; auto.
    + rewrite H0; auto.
      apply data_preg_1; auto.
  - int",,,,,,,,
CompCert:Asmgenproof0:agree_undef_regs2,Verified,Verified,Failed,Failed,97.51,80.49,80.52,76.49,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma agree_map_ext : forall (A B : Type) (f g : A -> B) (l : list A),
  (forall x, In x l -> f x = g x) -> map f l = map g l.
Proof.
  intros A B f g l H.
  induction l as [|x l IH]; simpl.
  - reflexivity.
  - rewrite H by (left; reflexivity).
    rewrite IH; [reflexivity|].
    intros y Hy; apply H; right; exact Hy.
Qed.",,,,,,,,
CompCert:Asmgenproof0:agree_set_undef_mreg,Failed,Failed,Failed,Failed,223.43,158.77,213.78,156.9,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import compcert.backend.RTL. Require Import compcert.common.AST. Require Import compcert.common.Values. Require Import compcert.lib.Integers.

Lemma agree_val_lessdef : forall ms sp rs r v rl rs', agree ms sp rs -> Val.lessdef (ms r) rs#(preg_of r).
Proof. apply preg_val. Qed.",,,,,,,,
CompCert:Asmgenproof0:agree_undef_caller_save_regs,Failed,Failed,Failed,Failed,237.96,156.97,165.18,156.13,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma agree_undef_caller_save_regs : forall ms sp rs,
  agree ms sp rs ->
  agree (Mach.undef_caller_save_regs ms) sp (Asm.undef_caller_save_regs rs).
Proof.
  intros ms sp rs H.
  destruct H.
  unfold Mach.undef_caller_save_regs, Asm.undef_caller_save_regs.
  apply undef_caller_save_regs.
  split.
  - unfold proj_sumbool.
    rewrite H.
    auto.
  - auto.
Qed.",,,,,,,,
CompCert:Asmgenproof0:agree_change_sp,Failed,Failed,Failed,Failed,55.4,37.64,40.61,36.97,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import compcert.lib.Maps.
Require Import compcert.common.Values.
Require Import compcert.lib.Integers.
Require Import compcert.common.Memory.
Require Import compcert.common.Events.
Require Import compcert.common.Globalenvs.
Require Import compcert.common.AST.
Require Import compcert.lib.Coqlib.
Require Import compcert.x86.Asm.

Lemma agree_update_sp : forall (ms : mreg -> val) (sp sp' : val) (rs : regset),
  agree ms sp rs -> sp' <> Vundef -> agree ms sp' (rs#SP <- sp').
Proof.
  intros ",,,,,,,,
CompCert:Asmgenproof0:extcall_arg_match,Failed,Failed,Failed,Failed,249.1,157.99,170.4,155.97,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma extcall_arg_match : forall ms sp rs m m' l v,
  agree ms sp rs ->
  Mem.extends m m' ->
  Mach.extcall_arg ms m sp l v ->
  exists v', Asm.extcall_arg rs m' l v' /\ Val.lessdef v v'.
Proof.
  intros ms sp rs m m' l v H H0 H1.
  inv H1.
  exists (rs (preg_of m0)).
  split.
  constructor.
  eapply preg_val; eauto.
  exploit Mem.loadv_extends; eauto.
  intros [v' [H2 H3]].
  exists v'.
  split.
  econstructor; eauto.
  auto.
Qed.",,,,,,,,
CompCert:Asmgenproof0:extcall_arg_pair_match,Failed,Failed,Failed,Failed,261.4,156.34,173.46,155.78,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma extcall_arg_pair_match : forall ms sp rs m m' p v,
  agree ms sp rs ->
  Mem.extends m m' ->
  Mach.extcall_arg_pair ms m sp p v ->
  exists v', Asm.extcall_arg_pair rs m' p v' /\ Val.lessdef v v'.
Proof.
  intros ms sp rs m m' p v H H0 H1.
  inv H1.
  - exploit extcall_arg_match; eauto.
    intros (v' & H2 & H3).
    exists v'. split; auto. constructor; auto.
  - exploit extcall_arg_match; eauto.
    intros (v1' & H2 & H3).
  ",,,,,,,,
CompCert:Asmgenproof0:extcall_args_match,Failed,Failed,Failed,Failed,202.16,158.32,188.52,155.84,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma extcall_args_match : forall ms sp rs m m', agree ms sp rs -> Mem.extends m m' ->
  forall ll vl,
  list_forall2 (Mach.extcall_arg_pair ms m sp) ll vl ->
  exists vl', list_forall2 (Asm.extcall_arg_pair rs m') ll vl' /\ Val.lessdef_list vl vl'.
Proof.
  intros ms sp rs m m' AGREE EXTENDS ll vl H.
  induction H as [|p v ll' vl' HP Hll' IH].
  - exists nil. split; constructor.
  - destruct IH as [vl'' [Hll'' LD]].
    exploit ext",,,,,,,,
CompCert:Asmgenproof0:extcall_arguments_match,Failed,Failed,Failed,Failed,239.38,155.78,159.12,155.67,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma extcall_arguments_match : forall ms m m' sp rs sg args,
  agree ms sp rs -> Mem.extends m m' -> Mach.extcall_arguments ms m sp sg args ->
  exists args', Asm.extcall_arguments rs m' sg args' /\ Val.lessdef_list args args'.
Proof.
  intros ms m m' sp rs sg args H H0 H1.
  eapply extcall_args_match; eauto.
Qed.",,,,,,,,
CompCert:Asmgenproof0:builtin_arg_match,Failed,Failed,Failed,Failed,225.39,156.28,157.82,155.77,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma builtin_arg_match : forall ge (rs: regset) sp m a v,
  eval_builtin_arg ge (fun r => rs (preg_of r)) sp m a v ->
  eval_builtin_arg ge rs sp m (map_builtin_arg preg_of a) v.
Proof.
  induction 1; simpl; eauto with barg.
Qed.",,,,,,,,
CompCert:Asmgenproof0:builtin_args_match,Failed,Failed,Failed,Failed,279.31,158.49,159.35,155.8,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma builtin_args_match : forall ge ms sp rs m m', agree ms sp rs -> Mem.extends m m' ->
  forall al vl, eval_builtin_args ge ms sp m al vl ->
  exists vl', eval_builtin_args ge rs sp m' (map (map_builtin_arg preg_of) al) vl' /\ Val.lessdef_list vl vl'.
Proof.
  intros ge ms sp rs m m' AGREE EXTENDS al vl.
  induction 1.
  - exists nil. split; constructor.
  - simpl.
    exploit (@eval_builtin_arg_lessdef _ ge ms (fun r => rs (preg_",,,,,,,,
CompCert:Asmgenproof0:agree_set_res,Failed,Failed,Failed,Failed,240.22,156.38,159.09,155.67,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma agree_set_res : forall res ms sp rs v v',
  agree ms sp rs ->
  Val.lessdef v v' ->
  agree (Mach.set_res res v ms) sp (Asm.set_res (map_builtin_res preg_of res) v' rs).
Proof.
  intros res ms sp rs v v' H H0.
  induction res; simpl; intros; eapply agree_set_mreg; eauto.
Qed.",,,,,,,,
CompCert:Asmgenproof0:set_res_other,Failed,Failed,Failed,Failed,104.65,75.59,76.65,76.27,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma set_res_other : forall (r : preg) (res : list preg) (v : val) (rs : regset),
  data_preg r = false -> set_res (map_builtin_res preg_of res) v rs r = rs r.
Proof.
  induction res; simpl; intros; auto.
  unfold set_res; simpl.
  rewrite Pregmap.gso; auto.
  red; intro; subst.
  rewrite H in (data_preg_of_iregsp a); discriminate.
Qed.",,,,,,,,
CompCert:Asmgenproof0:find_instr_in,Failed,Failed,Failed,Failed,270.69,190.9,197.18,190.36,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma find_instr_in : forall (A : Type) (c : list A) (pos : Z) (i : A),
  find_instr pos c = Some i -> In i c.
Proof.
  induction c; simpl; intros.
  - discriminate.
  - case (zeq pos 0); intros.
    + left; congruence.
    + right; eauto.
Qed.",,,,,,,,
CompCert:Asmgenproof0:code_tail_pos,Failed,Failed,Failed,Failed,52.58,37.32,39.93,37.39,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma code_tail_pos : forall (pos : nat) (c1 c2 : list nat), code_tail pos c1 c2 -> pos >= 0.
Proof. induction 1; lia. Qed.",,,,,,,,
CompCert:Asmgenproof0:find_instr_tail,Failed,Failed,Failed,Failed,117.83,76.2,82.97,76.13,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma find_instr_tail : forall (A : Type) (c1 : list A) (i : A) (c2 : list A) (pos : nat),
  code_tail pos c1 (i :: c2) -> find_instr pos c1 = Some i.
Proof.
  induction c1; intros i c2 pos H; simpl in *.
  - inversion H.
  - destruct pos.
    + inversion H; subst; auto.
    + inversion H; subst; auto.
Qed.",,,,,,,,
CompCert:Asmgenproof0:code_tail_bounds_1,Failed,Failed,Failed,Failed,331.33,192.6,224.27,191.17,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma code_tail_bounds : forall fn ofs c, code_tail ofs fn c -> 0 <= ofs <= list_length_z fn.
Proof.
  intros fn ofs c H.
  induction H.
  - simpl. lia.
  - rewrite list_length_z_cons. lia.
Qed.",,,,,,,,
CompCert:Asmgenproof0:code_tail_bounds_2,Failed,Failed,Failed,Failed,280.7,191.28,201.98,189.84,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import Coq.Lists.List.

Lemma code_tail_bounds : forall (fn : list nat) (ofs : Z) (i : nat) (c : list nat),
  code_tail ofs fn (i :: c) -> 0 <= ofs < list_length_z fn.
Proof.
  intros fn ofs i c H.
  induction H.
  - rewrite list_length_z_cons. lia.
  - rewrite list_length_z_cons. lia.
Qed.",,,,,,,,
CompCert:Asmgenproof0:code_tail_next,Failed,Failed,Failed,Failed,94.8,72.94,79.91,72.89,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.

Lemma code_tail_next : forall (fn : list nat) (ofs i : nat) (c : list nat),
  code_tail ofs fn (i :: c) -> code_tail (ofs + 1) fn c.
Proof.
  intros fn ofs i c H.
  induction H as [| ? ? ? ? IH ? ? ? ?].
  - constructor.
  - constructor.
  - constructor.
  - eauto.
  - eauto.
Qed.",,,,,,,,
CompCert:Asmgenproof0:code_tail_next_int,Failed,Failed,Failed,Failed,272.2,200.09,205.88,189.95,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import Coq.Ptr.Ptr.

Lemma code_tail_next_int : forall (fn : list instruction) (ofs : ptrofs) (i : instruction) (c : list instruction),
  list_length_z fn <= Ptrofs.max_unsigned ->
  code_tail (Ptrofs.unsigned ofs) fn (i :: c) ->
  code_tail (Ptrofs.unsigned (Ptrofs.add ofs Ptrofs.one)) fn c.
Proof.
  intros fn ofs i c H H0.
  rewrite Ptrofs.add_unsigned.
  rewrite Ptrofs.unsigned_one.
  rewrite Ptrofs.unsigned_repr.
  generalize (code_tail_bounds_2 _ _ ",,,,,,,,
CompCert:Asmgenproof0:transl_code_rec_transl_code,Failed,Failed,Failed,Failed,226.75,159.79,182.48,158.13,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma transl_code_rec_transl_code : forall f il ep k,
  transl_code_rec f il ep k = (do c <- transl_code f il ep; k c).
Proof.
  induction il; simpl; intros; try reflexivity.
  destruct (transl_code f il ep); simpl; try reflexivity.
  rewrite IHil. reflexivity.
Qed.",,,,,,,,
CompCert:Asmgenproof0:is_tail_code_tail,Failed,Failed,Failed,Failed,107.11,159.23,181.54,156.24,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma is_tail_code_tail : forall (A : Type) (c1 c2 : list A), is_tail c1 c2 -> exists ofs : nat, code_tail ofs c2 c1.
Proof.
  induction 1.
  - exists 0. constructor.
  - destruct IHis_tail as [ofs H].
    exists (S ofs). constructor. apply H.
Qed.",,,,,,,,
CompCert:Asmgenproof0:transl_code_tail,Failed,Failed,Failed,Failed,248.94,158.82,179.88,155.71,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma transl_code_tail : forall f c1 c2, is_tail c1 c2 ->
  forall tc2 ep2, transl_code f c2 ep2 = OK tc2 ->
  exists tc1, exists ep1, transl_code f c1 ep1 = OK tc1 /\ is_tail tc1 tc2.
Proof.
  induction 1; simpl; intros.
  - exists tc2. exists ep2. split; auto. constructor.
  - monadInv H0. exploit IHis_tail; eauto. intros (tc1 & ep1 & H1 & H2).
    exists tc1. exists ep1. split; auto. eapply is_tail_cons_left; eauto.
Qed.",,,,,,,,
CompCert:Asmgenproof0:return_address_exists,Failed,Failed,Failed,Failed,94.88,77.12,82.28,75.85,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma is_tail_mcall_transl_code : forall (A B : Type) (f : A) (sg : B) (ros : list B) (c : list A),
  exists (tf : A) (tc : list A), is_tail (Mcall sg ros :: c) (tf :: tc).
Proof.
  intros A B f sg ros c.
  eexists. eexists. constructor.
Qed.",,,,,,,,
CompCert:Asmgenproof0:code_tail_no_bigger,Failed,Failed,Failed,Failed,93.57,76.43,87.73,75.84,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma code_tail_no_bigger : forall (pos : nat) (c1 c2 : list nat), code_tail pos c1 c2 -> (length c2 <= length c1)%nat.
Proof.
  induction 1; simpl; lia.
Qed.",,,,,,,,
CompCert:Asmgenproof0:code_tail_unique,Failed,Abstained,Failed,Failed,45.88,0.16,41.54,37.21,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Lia.

Lemma code_tail_unique : forall (fn : list nat) (c : nat) (pos pos' : nat),
  code_tail pos fn c -> code_tail pos' fn c -> pos = pos'.
Proof.
  induction fn; intros c pos pos' CT CT'.
  - inversion CT.
  - inversion CT; inversion CT'; subst.
    + reflexivity.
    + generalize (code_tail_no_bigger _ _ _ H3); intro; lia.
    + generalize (code_tail_no_bigger _ _ _ H3); intro; lia.
    + apply IHfn with (c := c0); assumption.
Qed.",,,,,,,,
CompCert:Asmgenproof0:return_address_offset_correct,Failed,Failed,Failed,Failed,214.8,156.59,169.87,168.07,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Values.Values.
Require Import Coq.Memory.Memory.
Require Import Coq.Stacklayout.Stacklayout.
Require Import Coq.Lists.List.

Lemma return_address_offset_correct : forall ge b ofs fb f c tf tc ofs',
  transl_code_at_pc ge (Vptr b ofs) fb f c false tf tc ->
  return_address_offset f c ofs' ->
  ofs' = ofs.
Proof.
  intros ge b ofs fb f c tf tc ofs' H H0.
  inv H.
  red in H0.
  exploit code_tail_unique.
  eexact H12.
  eapply H0.
  eauto.
  intro.",,,,,,,,
CompCert:Asmgenproof0:label_pos_code_tail,Failed,Failed,Failed,Failed,309.74,193.65,224.09,193.59,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.
Require Import Coq.ZArith.ZArith.

Lemma label_pos_code_tail : forall lbl c pos c',
  find_label lbl c = Some c' ->
  exists pos',
    label_pos lbl pos c = Some pos'
    /\ code_tail (pos' - pos) c c'
    /\ pos < pos' <= pos + list_length_z c.
Proof.
  induction c; intros pos c' H.
  - simpl in H. discriminate.
  - simpl in H. case_eq (is_label lbl a); intro IL.
    + injection H as H. subst c'. exists (pos + ",,,,,,,,
CompCert:Asmgenproof0:tail_nolabel_refl,Failed,Failed,Failed,Failed,114.91,77.01,118.43,76.03,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma tail_nolabel_refl : forall (c : list nat), tail_nolabel c c.
Proof. induction c; simpl; auto. Qed.",,,,,,,,
CompCert:Asmgenproof0:tail_nolabel_trans,Failed,Failed,Failed,Failed,126.17,76.52,110.65,75.97,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma tail_nolabel_trans : forall (c1 c2 c3 : list nat), is_tail c2 c3 -> is_tail c1 c2 -> is_tail c1 c3.
Proof. intros c1 c2 c3 H H0. eapply is_tail_trans; eauto. Qed.",,,,,,,,
CompCert:Asmgenproof0:tail_nolabel_cons,Failed,Failed,Failed,Failed,148.33,81.14,82.5,76.28,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma tail_nolabel_cons : forall (A : Type) (i : A) (c : list A) (k : nat),
  nolabel i -> tail_nolabel k c -> tail_nolabel k (i :: c).
Proof.
  intros A i c k H1 H2.
  destruct k.
  - constructor.
    + exact H1.
    + exact H2.
  - simpl.
    rewrite H1.
    destruct H2.
    constructor.
Qed.",,,,,,,,
CompCert:Asmgenproof0:tail_nolabel_find_label,Failed,Failed,Failed,Failed,111.3,76.85,78.47,76.09,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma tail_nolabel_find_label : forall lbl k c, tail_nolabel k c -> find_label lbl c = find_label lbl k.
Proof. intros. apply H. Qed.",,,,,,,,
CompCert:Asmgenproof0:tail_nolabel_is_tail,Failed,Failed,Failed,Failed,115.3,77.02,78.25,75.88,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma tail_nolabel_is_tail : forall (A : Type) (k c : list A), is_tail k c -> is_tail k c.
Proof. auto. Qed.",,,,,,,,
CompCert:Asmgenproof0:exec_straight_trans,Failed,Failed,Failed,Failed,52.41,39.1,42.3,36.97,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma exec_straight_trans : forall c1 rs1 m1 c2 rs2 m2 c3 rs3 m3,
  exec_straight c1 rs1 m1 c2 rs2 m2 ->
  exec_straight c2 rs2 m2 c3 rs3 m3 ->
  exec_straight c1 rs1 m1 c3 rs3 m3.
Proof.
  intros until m3. intros H1 H2. induction H1; eauto.
Qed.",,,,,,,,
CompCert:Asmgenproof0:exec_straight_two,Failed,Failed,Failed,Failed,120.75,76.92,86.67,75.91,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.
Lemma exec_straight_two : forall (ge : genv) (fn : function) (i1 i2 : instruction) (c : list instruction) (rs1 rs2 rs3 : regset) (m1 m2 m3 : mem),
  exec_instr ge fn i1 rs1 m1 = Next rs2 m2 ->
  exec_instr ge fn i2 rs2 m2 = Next rs3 m3 ->
  rs2#PC = Val.offset_ptr rs1#PC Ptrofs.one ->
  rs3#PC = Val.offset_ptr rs2#PC Ptrofs.one ->
  exec_straight (i1 :: i2 :: c) rs1 m1 c rs3 m3.
Proof. intros. eapply exec_straight_two; eauto. Qed.",,,,,,,,
CompCert:Asmgenproof0:exec_straight_three,Failed,Failed,Failed,Failed,106.76,77.43,83.98,75.94,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.
Lemma exec_straight_three : forall (ge : _) (fn : _) (i1 i2 i3 : _) (c : _) (rs1 rs2 rs3 rs4 : _) (m1 m2 m3 m4 : _),
  exec_instr ge fn i1 rs1 m1 = Next rs2 m2 ->
  exec_instr ge fn i2 rs2 m2 = Next rs3 m3 ->
  exec_instr ge fn i3 rs3 m3 = Next rs4 m4 ->
  rs2#PC = Val.offset_ptr rs1#PC Ptrofs.one ->
  rs3#PC = Val.offset_ptr rs2#PC Ptrofs.one ->
  rs4#PC = Val.offset_ptr rs3#PC Ptrofs.one ->
  exec_straight (i1 :: i2 :: i3 :: c) rs1 m1 c rs4 ",,,,,,,,
CompCert:Asmgenproof0:exec_straight_opt_left,Failed,Failed,Failed,Failed,232.9,155.74,175.61,156.69,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma exec_straight_opt_left : forall c3 rs3 m3 c1 rs1 m1 c2 rs2 m2,
  exec_straight c1 rs1 m1 c2 rs2 m2 ->
  exec_straight_opt c2 rs2 m2 c3 rs3 m3 ->
  exec_straight c1 rs1 m1 c3 rs3 m3.
Proof. intros. eapply exec_straight_trans; eauto. apply exec_straight_opt_right; assumption. Qed.",,,,,,,,
CompCert:Asmgenproof0:exec_straight_opt_right,Failed,Failed,Failed,Failed,54.83,37.04,39.78,37.18,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma exec_straight_opt_right : forall c3 rs3 m3 c1 rs1 m1 c2 rs2 m2,
  exec_straight_opt c1 rs1 m1 c2 rs2 m2 ->
  exec_straight c2 rs2 m2 c3 rs3 m3 ->
  exec_straight c1 rs1 m1 c3 rs3 m3.
Proof.
  intros.
  destruct H.
  - eapply exec_straight_trans; eauto.
  - assumption.
Qed.",,,,,,,,
CompCert:Asmgenproof0:exec_straight_opt_step,Failed,Failed,Failed,Failed,125.74,76.3,82.85,75.88,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma exec_straight_step : forall (ge : Type) (fn : Type) (i : Type) (c : list Type) (rs1 m1 rs2 m2 : Type) (c' : list Type) (rs3 m3 : Type),
  exec_instr ge fn i rs1 m1 = Next rs2 m2 ->
  rs2#PC = Val.offset_ptr rs1#PC Ptrofs.one ->
  exec_straight ge fn c rs2 m2 c' rs3 m3 ->
  exec_straight ge fn (i :: c) rs1 m1 c' rs3 m3.
Proof.
  intros. eapply exec_straight_one; eauto.
Qed.",,,,,,,,
CompCert:Asmgenproof0:exec_straight_opt_step_opt,Failed,Failed,Failed,Failed,134.93,75.44,85.03,75.82,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma exec_straight_opt_step_template : forall (ge : Type) (fn : Type) (i : Type) (c : list Type) (rs1 m1 rs2 m2 : Type) (c' : list Type) (rs3 m3 : Type),
  exec_instr ge fn i rs1 m1 = Next rs2 m2 ->
  rs2#PC = Val.offset_ptr rs1#PC Ptrofs.one ->
  exec_straight_opt c rs2 m2 c' rs3 m3 ->
  exec_straight_opt (i :: c) rs1 m1 c' rs3 m3.
Proof. apply exec_straight_opt_step_opt. Qed.",,,,,,,,
CompCert:Asmgenproof0:parent_sp_def,Failed,Failed,Failed,Failed,104.91,74.34,78.4,73.68,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma match_stack_parent_sp_defined : forall (s : stack) (H : match_stack s), parent_sp s <> Vundef.
Proof.
  induction 1; simpl; try congruence.
  unfold parent_sp in *.
  destruct sp; try congruence.
  destruct ptr64; congruence.
Qed.",,,,,,,,
CompCert:Asmgenproof0:parent_ra_def,Failed,Failed,Failed,Failed,92.26,73.23,79.97,72.98,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma match_stack_parent_ra_defined : forall (s : stack) (H : match_stack s), parent_ra s <> Vundef.
Proof.
  induction 1; simpl; unfold parent_ra; destruct parent_sp; try ptr64; try congruence; inv H0; congruence.
Qed.",,,,,,,,
CompCert:Asmgenproof0:lessdef_parent_sp,Failed,Failed,Failed,Failed,94.78,76.96,87.35,76.26,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma match_stack_parent_sp_def : forall (s v : Type) (match_stack : s -> Prop) (parent_sp_def : Prop),
  match_stack s -> parent_sp_def -> True.
Proof.
  intros s v match_stack parent_sp_def H H0.
  inv H0.
  exploit parent_sp_def.
  eauto.
  tauto.
Qed.",,,,,,,,
CompCert:Asmgenproof0:lessdef_parent_ra,Failed,Failed,Failed,Failed,100.59,76.3,79.04,76.57,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma match_stack_val_step : forall (s : list nat) (v : nat), match_stack s -> val_step s v.
Proof.
  intros s v H.
  inversion H.
  exploit parent_ra_def.
  eauto.
  tauto.
Qed.",,,,,,,,
CompCert:Tailcallproof:return_measure_bounds,Failed,Failed,Failed,Failed,255.09,212.36,193.13,171.47,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Lia.

Lemma return_measure_bound : forall (f : nat -> nat) (n : nat) (pc : nat), (return_measure f pc <= niter)%nat.
Proof.
  intro f.
  assert (forall n pc, (return_measure_rec n f pc <= niter)%nat).
  { induction n.
    - intros pc. simpl. lia.
    - intros pc. simpl.
      destruct (f pc) eqn:H.
      + try lia.
      + destruct n0.
        * try lia.
        * try lia. }
  apply H.
Qed.",,,,,,,,
CompCert:Tailcallproof:return_measure_rec_incr,Failed,Failed,Failed,Failed,230.39,158.14,218.72,156.89,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Arith.Lia.

Lemma return_measure_rec_incr : forall f n1 n2 pc,
  (n1 <= n2)%nat ->
  (return_measure_rec n1 f pc <= return_measure_rec n2 f pc)%nat.
Proof.
  induction n1; intros n2 pc H.
  - simpl. lia.
  - destruct n2; try lia.
    simpl. destruct (f pc); try lia.
    + assert (n1 <= n2)%nat by lia. lia.
    + assert (n1 <= n2)%nat by lia. lia.
Qed.",,,,,,,,
CompCert:Tailcallproof:is_return_measure_rec,Failed,Failed,Failed,Failed,111.91,79.83,85.74,76.89,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.
Lemma is_return_measure_rec : forall f n n' pc r,
  is_return n f pc r = true -> (n <= n')%nat ->
  return_measure_rec n (fn_code f) pc = return_measure_rec n' (fn_code f) pc.
Proof.
  induction n; simpl; intros; try congruence.
  destruct n'; try lia.
  destruct (fn_code f)!pc; try congruence.
  destruct i; try congruence.
  destruct (is_return n f n0 r) eqn:?; try congruence.
  apply IHn in Heqb; try lia.
  congruence.
Qed.",,,,,,,,
CompCert:Tailcallproof:is_return_charact,Failed,Failed,Failed,Failed,251.71,162.26,170.28,155.81,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.

Lemma is_return_charact : forall (f : function) (n : nat) (pc : positive) (rret : reg),
  is_return n f pc rret = true -> (n <= niter)%nat -> is_return_spec f pc rret.
Proof.
  induction n; intros pc rret H H0.
  - simpl in H. congruence.
  - generalize H; simpl.
    caseEq ((fn_code f) ! pc); try congruence.
    intro i; caseEq i; try congruence.
Qed.",,,,,,,,
CompCert:Tailcallproof:transf_instr_charact,Failed,Failed,Failed,Failed,94.07,76.88,89.93,76.25,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma transf_instr_tailcall_sound : forall (A B : Type) (f : A) (pc : nat) (instr : B),
  (forall (s : A), is_return_charact s instr) ->
  exists (s' : A), transf_instr f (analyze f) f pc instr = Some s' /\ sig_res s' = sig_res (fn_sig f).
Proof.
  intros A B f pc instr H.
  destruct (H (fn_sig f)) as [s' [H1 H2]].
  exists s'. split.
  - eapply transf_instr_tailcall; eauto.
  - apply H2.
Qed.",,,,,,,,
CompCert:Tailcallproof:transf_instr_lookup,Verified,Verified,Failed,Failed,94.63,78.59,90.8,76.25,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma map_compose : forall (A B C : Type) (f : B -> C) (g : A -> B) (l : list A), map f (map g l) = map (fun x => f (g x)) l.
Proof.
  intros A B C f g l. induction l; simpl; [reflexivity|].
  rewrite IHl. reflexivity.
Qed.",,,,,,,,
CompCert:Tailcallproof:regs_lessdef_init_regs,Failed,Failed,Failed,Failed,114.14,77.87,82.18,75.8,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma val_step_params : forall (params : list nat) (vl vl' : list nat),
    length params = length vl -> Forall2 (fun p v => p = v) params vl -> vl = vl'.
Proof.
  induction params; intros vl vl' Hlen Hforall.
  - simpl in Hlen. destruct vl; [auto | discriminate].
  - destruct vl; [discriminate |].
    inversion Hforall as [|? ? ? ? Hhead Htail]. subst.
    simpl in Hlen. inversion Hlen.
    apply IHparams in Htail; auto. subst. reflexivity.
",,,,,,,,
CompCert:Tailcallproof:transf_program_match,Failed,Failed,Failed,Failed,216.54,189.38,164.78,155.61,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma transf_program_match : forall p tp, transf_program p = OK tp -> match_prog p tp.
Proof. intros. apply transf_program_match. assumption. Qed.",,,,,,,,
CompCert:Tailcallproof:symbols_preserved,Failed,Failed,Failed,Failed,111.0,77.74,79.86,76.4,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma functions_translated : forall (v : val) (f : fundef), Genv.find_funct ge v = Some f -> Genv.find_funct tge v = Some (transf_fundef f).
Proof. apply Genv.find_funct_transf. Qed.",,,,,,,,
CompCert:Tailcallproof:functions_translated,Failed,Failed,Failed,Failed,109.56,75.86,80.06,75.75,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma funct_ptr_translated : forall (b : block) (f : RTL.fundef),
  Genv.find_funct_ptr ge b = Some f ->
  Genv.find_funct_ptr tge b = Some (transf_fundef f).
Proof.
  intros. apply function_ptr_translated. assumption.
Qed.",,,,,,,,
CompCert:Tailcallproof:funct_ptr_translated,Failed,Failed,Failed,Failed,128.99,75.62,80.17,76.61,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma sig_preserved : forall (f : fundef), funsig (transf_fundef f) = funsig f.
Proof. destruct f; simpl; auto. Qed.",,,,,,,,
CompCert:Tailcallproof:senv_preserved,Failed,Failed,Failed,Failed,136.23,76.74,79.99,75.81,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma sig_preserved : forall (A : Type) (f : A), funsig (transf_fundef f) = funsig f.
Proof.
  destruct f; simpl; auto.
Qed.",,,,,,,,
CompCert:Tailcallproof:sig_preserved,Failed,Failed,Failed,Failed,106.58,75.79,77.83,75.69,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma sig_function_translated : forall (A : Type) (f : A), funsig (transf_fundef f) = funsig f.
Proof.
  destruct f; simpl; auto.
Qed.",,,,,,,,
CompCert:Tailcallproof:stacksize_preserved,Failed,Failed,Failed,Failed,46.11,37.11,39.53,37.16,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma stacksize_preserved : forall (A : Type) (f : A), fn_stacksize (transf_function f) = fn_stacksize f.
Proof. destruct f; reflexivity. Qed.",,,,,,,,
CompCert:Tailcallproof:find_function_translated,Failed,Failed,Failed,Failed,46.25,36.67,38.4,37.23,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Arith.Arith.
Lemma find_function_translated : forall (ge tge : Genv.t (fundef unit) unit) (ros : option reg) (rs rs' : regset) (f : fundef unit),
  find_function ge ros rs = Some f ->
  regs_lessdef rs rs' ->
  find_function tge ros rs' = Some (transf_fundef f).
Proof.
  intros ge tge ros rs rs' f H1 H2.
  destruct ros as [r|id]; simpl in *.
  - destruct (H2 r) as [v' [EQ1 EQ2]].
    rewrite EQ1 in H1.
    destruct (rs' r); try discriminate.
    inversion H1; subst.
   ",,,,,,,,
CompCert:Tailcallproof:transf_step_correct,Failed,Failed,Failed,Failed,97.71,157.86,171.88,156.05,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma step_simulation : forall (ge tge : Type) (step : ge -> nat -> nat -> Prop) (step_tge : tge -> nat -> nat -> Prop) (match_states : nat -> nat -> Prop) (measure : nat -> nat),
(forall (s1 t s2 : nat), step ge s1 t s2 -> forall (s1' : nat), match_states s1 s1' -> (exists s2' : nat, step_tge tge s1' t s2' /\ match_states s2 s2') \/ (measure s2 < measure s1 /\ t = 0 /\ match_states s2 s1')%nat).
Proof.
  intros ge tge step step_tge match_states measure.
  intros s",,,,,,,,
CompCert:Tailcallproof:transf_initial_states,Failed,Failed,Failed,Failed,52.68,38.28,63.19,37.56,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Logic.FunctionalExtensionality.
Lemma transf_initial_states : forall (prog tprog : Type) (initial_state : Type -> Type -> Prop) (match_states : Type -> Type -> Prop) (st1 : Type), initial_state prog st1 -> exists st2 : Type, initial_state tprog st2 /\ match_states st1 st2.
Proof.
  intros prog tprog initial_state match_states st1 H.
  inversion H.
  exploit (funct_ptr_translated prog tprog).
  eauto.
  intro FIND.
  exists (Genv.symbol_address tprog (prog_main tprog) Int.zero)",,,,,,,,
CompCert:Tailcallproof:transf_final_states,Failed,Failed,Failed,Failed,69.39,37.68,109.24,37.33,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma final_state_match : forall (st1 st2 : state) (r : return_type), match_states st1 st2 -> final_state st1 r -> final_state st2 r.
Proof.
  intros st1 st2 r H H0.
  inv H0.
  inv H.
  inv H5.
  inv H3.
  constructor.
Qed.",,,,,,,,
CompCert:Tailcallproof:transf_program_correct,Failed,Abstained,Failed,Failed,57.41,0.19,82.99,37.95,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Logic.FunctionalExtensionality.
Lemma forward_simulation_opt_correct : forall (S1 S2 : Type) (step1 : S1 -> S1 -> Prop) (step2 : S2 -> S2 -> Prop) (match_states : S1 -> S2 -> Prop) (measure : S1 -> nat) (transf_initial_states : forall s1, step1 s1 s1 -> exists s2, step2 s2 s2 /\ match_states s1 s2) (transf_final_states : forall s1 s2, match_states s1 s2 -> step1 s1 s1 -> step2 s2 s2) (transf_step_correct : forall s1 s1' s2, step1 s1 s1' -> match_states s1 s2 -> exists s2', ste",,,,,,,,
CompCert:Cminortyping:expect_incr,Failed,Failed,Failed,Failed,107.53,76.33,85.78,157.79,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma expect_inversion : forall (A B : Type) (e : A) (t1 t2 : B) (e' : A),
  (if eqb t1 t2 then OK e else Error) = OK e' -> eqb t1 t2 = true /\ e = e'.
Proof.
  intros A B e t1 t2 e' H.
  destruct (eqb t1 t2) eqn:Heq; inversion H; auto.
Qed.",,,,,,,,
CompCert:Cminortyping:expect_sound,Failed,Failed,Failed,Failed,115.59,76.3,91.67,157.02,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma expect_eq_types : forall (A : Type) (e : A) (t1 t2 : A) (e' : A), (if eqb t1 t2 then OK e else Error) = OK e' -> t1 = t2.
Proof.
  intros A e t1 t2 e' H.
  destruct (eqb t1 t2) eqn:E; inv H.
  apply eqb_eq; assumption.
Qed.",,,,,,,,
CompCert:Cminortyping:type_expr_incr,Failed,Failed,Failed,Failed,105.23,76.76,87.65,76.38,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma type_expr_induction_step : 
  forall (A : Type) (te : A -> A -> bool) (a : A) (t : A) (e e' : A),
    te a t = true -> e = e'.
Proof.
  intros A te a t e e' H.
  induction a; simpl in H; try congruence.
  - destruct (te a t) eqn:?; try discriminate.
    injection H; intros; subst; auto.
  - destruct (te a1 t1) eqn:?; try discriminate.
    destruct (te a2 t2) eqn:?; try discriminate.
    injection H; intros; subst; auto.
Qed.",,,,,,,,
CompCert:Cminortyping:type_expr_sound,Failed,Failed,Failed,Failed,240.94,160.01,174.33,156.46,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma type_expr_sound : forall te a t e e', type_expr e a t = OK e' -> S.satisf te e' -> wt_expr te a t.
Proof.
  induction a; intros t e e' T S; simpl in T; try monadInv T;
  try (erewrite <- S; [constructor|eauto]);
  try (erewrite <- expect_sound by eauto; constructor).
Qed.",,,,,,,,
CompCert:Cminortyping:type_exprlist_incr,Failed,Failed,Failed,Failed,125.79,160.25,166.23,157.74,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma type_exprlist_sound_generalized : forall (A B : Type) (te : A) (al : list B) (tl : list Type) (e e' : S.t),
  type_exprlist e al tl = OK e' -> S.satisf te e' -> list_forall2 (wt_expr te) al tl.
Proof.
  intros A B te al tl e e' H1 H2.
  induction al; simpl in *; monadInv H1; eauto with ty.
Qed.",,,,,,,,
CompCert:Cminortyping:type_exprlist_sound,Failed,Failed,Failed,Failed,210.09,157.97,161.6,155.76,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma type_exprlist_sound : forall te al tl e e',
  type_exprlist e al tl = OK e' -> S.satisf te e' -> list_forall2 (wt_expr te) al tl.
Proof.
  induction al; intros tl e e' H H0; destruct tl; monadInv H; constructor; eauto using type_expr_sound with ty.
Qed.",,,,,,,,
CompCert:Cminortyping:type_assign_incr,Failed,Failed,Failed,Failed,99.02,78.71,78.68,75.84,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma type_assign_unop_preservation : forall (te : Type) (id : nat) (u : unop) (a : expr) (e e' : env),
    type_assign e id (Eunop u a) = OK e' -> exists targ1 tres, type_unop u = Some (targ1, tres).
Proof.
  intros te id u a e e' T.
  destruct (type_unop u) as [[targ1 tres]|] eqn:TU.
  - exists targ1, tres. reflexivity.
  - simpl in T. discriminate.
Qed.",,,,,,,,
CompCert:Cminortyping:type_assign_sound,Failed,Failed,Failed,Failed,242.57,158.75,158.37,155.99,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma type_assign_sound_generalized : forall te id a e e',
  type_assign e id a = OK e' -> S.satisf te e' -> wt_expr te a (te id).
Proof.
  induction a; intros e e' T SAT;
  try (monadInv T);
  try (erewrite IHa1 by eauto);
  try (erewrite IHa2 by eauto);
  try (move_sound by eauto);
  try constructor.
Qed.",,,,,,,,
CompCert:Cminortyping:opt_set_incr,Failed,Failed,Failed,Failed,141.04,78.19,76.45,75.79,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma opt_set_monad_inv : forall (A B : Type) (te : A) (optid : option B) (optty : A) (e e' : A),
  opt_set te optid optty = OK e' -> e = e'.
Proof.
  intros A B te optid optty e e' H.
  unfold opt_set in H.
  destruct optid; try monadInv H; eauto with ty.
Qed.",,,,,,,,
CompCert:Cminortyping:opt_set_sound,Failed,Failed,Failed,Failed,114.29,161.64,161.89,156.59,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma opt_set_sound_generalized : forall (A : Type) (te optid sg e e' : A),
    opt_set e optid (proj_sig_res sg) = OK e' -> S.satisf te e' -> wt_opt_assign te optid (sig_res sg).
Proof.
  intros A te optid sg e e' H H0.
  red.
  destruct (proj_sig_res sg).
  - erewrite set_sound by eauto.
    auto.
  - inv H.
    auto.
Qed.",,,,,,,,
CompCert:Cminortyping:type_stmt_incr,Failed,Failed,Failed,Failed,255.36,159.5,164.57,156.18,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma type_stmt_implication : forall te tret s e e',
  type_stmt tret e s = OK e' -> S.satisf te e' -> wt_stmt te tret s.
Proof.
  induction s; simpl; intros;
  try (monadInv H); 
  eauto with ty.
Qed.",,,,,,,,
CompCert:Cminortyping:type_stmt_sound,Failed,Failed,Failed,Failed,154.45,159.62,162.67,156.94,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma type_stmt_sound_generalized : forall (te : Type) (tret s e e' : Type),
    type_stmt tret e s = OK e' -> S.satisf te e' -> wt_stmt te tret s.
Proof.
  induction s; simpl; intros;
  try (monadInv H);
  try constructor;
  eauto using type_assign_sound, type_expr_sound with ty.
Qed.",,,,,,,,
CompCert:Cminortyping:type_function_sound,Failed,Failed,Failed,Failed,201.49,160.28,167.38,156.25,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma type_function_sound : forall f env, type_function f = OK env -> wt_function env f.
Proof.
  intros f env H.
  generalize H.
  unfold type_function.
  monadInv H.
  assert (satisf env x0) by (apply solve_sound; auto).
  constructor; auto.
Qed.",,,,,,,,
CompCert:Cminortyping:wt_is_call_cont,Failed,Failed,Failed,Failed,91.08,75.66,92.1,75.26,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Logic.Classical.

Lemma wt_is_call_cont : forall env tret k, wt_cont env tret k -> is_call_cont k -> wt_cont_call k tret.
Proof.
  intros env tret k H1 H2.
  destruct H1; try contradiction; auto.
Qed.",,,,,,,,
CompCert:Cminortyping:call_cont_wt,Failed,Failed,Failed,Failed,104.99,76.74,80.39,75.88,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma call_cont_wt : forall env tret k, wt_cont env tret k -> wt_cont_call (call_cont k) tret.
Proof.
  induction 1; simpl; auto; inversion H; subst; auto.
Qed.",,,,,,,,
CompCert:Cminortyping:wt_env_assign,Failed,Failed,Failed,Failed,101.96,78.16,81.6,76.57,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma wt_env_update_same : forall (env : list (nat * nat)) (id : nat) (e v : nat),
    (forall x, In x env -> fst x = id -> snd x = v) ->
    (forall x, In x ((id, e) :: env) -> fst x = id -> snd x = e).
Proof.
  intros env id e v H x H1 H2.
  red in H1.
  destruct H1 as [H1|H1].
  - rewrite H1 in H2.
    simpl in H2.
    congruence.
  - simpl in H2.
    apply H in H1.
    + congruence.
    + assumption.
Qed.",,,,,,,,
CompCert:Cminortyping:def_env_assign,Failed,Failed,Failed,Failed,479.54,341.82,396.06,296.96,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.MSets.MSetPositive.
Require Import Coq.MSets.MSetProperties.
Require Import PArith.

Lemma def_env_set : forall f e id v, def_env f e -> def_env f (PTree.set id v e).
Proof.
  intros f e id v Hdef.
  red in Hdef |- *.
  intros x Hx.
  rewrite PTree.gsspec.
  destruct (Pos.eq_dec id x).
  - subst. exists v. reflexivity.
  - apply Hdef. assumption.
Qed.",,,,,,,,
CompCert:Cminortyping:wt_env_set_params,Failed,Failed,Failed,Failed,139.17,79.41,110.78,87.56,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma val_step_env_il_vl : forall (env : list nat) (il : list nat) (vl : list nat), 
  (forall i, In i il -> i < length env) -> 
  (forall v, In v vl -> v < length env) -> 
  length il = length vl -> 
  (forall n, In n (map (fun i => nth i env 0) il) -> n < length env).
Proof.
  intros env il vl H1 H2 H3 n H4.
  apply in_map_iff in H4.
  destruct H4 as [i [H5 H6]].
  subst n.
  apply H1 in H6.
  rewrite H5.
  apply nth_lt.
  assumption.
Qed.",,,,,,,,
CompCert:Cminortyping:def_set_params,Failed,Failed,Failed,Failed,343.53,260.31,284.53,255.41,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.MSets.MSetPositive.
Require Import Coq.MSets.MSetProperties.
Require Import Coq.MSets.MSetFacts.

Lemma in_ptree_get_exists : forall (A : Type) (id : positive) (il : list positive) (vl : list A),
  In id il -> exists v, PTree.get id (List.combine il vl) = Some v.
Proof.
  induction il as [|i il]; intros vl Hin.
  - inversion Hin.
  - destruct vl as [|v vl]; simpl.
    + destruct Hin as [H|H].
      * congruence.
      * apply IHil in H; destruct H; eauto.
    + destruct Hin as",,,,,,,,
CompCert:Cminortyping:wt_env_set_locals,Failed,Failed,Failed,Failed,119.64,79.8,85.75,75.93,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma wt_env_set_locals : forall (env : list Type) (il : list nat) (e : list nat),
    wt_env env e -> wt_env env (set_locals il e).
Proof.
  induction il as [| i il]; simpl; intros; auto.
  apply wt_env_assign; auto.
  exact I.
Qed.",,,,,,,,
CompCert:Cminortyping:def_set_locals,Failed,Failed,Failed,Failed,369.76,265.94,300.47,253.34,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.MSets.MSetPositive.
Require Import Coq.PArith.BinPos.
Require Import Coq.Arith.PeanoNat.

Lemma PTree_get_exists : forall (A : Type) (id : positive) (il : list positive) (e : A),
    (exists v, PositiveMap.find id (fold_left (fun (m : PositiveMap.t A) (i : positive) => PositiveMap.add i e m) il (PositiveMap.empty A)) = Some v) ->
    In id il.
Proof.
  induction il as [|i il]; simpl; intros e [v H].
  - rewrite PositiveMap.gempty in H. discriminate.
  - rewrite PositiveMap.gss",,,,,,,,
CompCert:Cminortyping:wt_find_label,Failed,Failed,Failed,Failed,244.31,157.14,161.68,156.68,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma wt_find_label : forall env tret lbl s k,
  wt_stmt env tret s -> wt_cont env tret k ->
  match find_label lbl s k with
  | Some (s', k') => wt_stmt env tret s' /\ wt_cont env tret k'
  | None => True
  end.
Proof.
  induction s; intros; inv H; simpl; auto; 
  try (assert (wt_cont env tret (Kseq s2 k)) by constructor; 
       specialize (IHs1 _ H1 H0); destruct find_label; auto).
Qed.",,,,,,,,
CompCert:Cminortyping:type_constant_sound,Failed,Failed,Failed,Failed,212.36,161.14,158.23,155.62,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_constant_inject : forall f sp cst v,
  eval_constant ge sp cst = Some v ->
  exists tv, eval_constant tge sp (transl_constant cst) = Some tv /\ Val.inject f v tv.
Proof.
  intros f sp cst v EV. destruct cst; simpl in EV; inv EV; eexists; split; eauto; apply VHT.
Qed.",,,,,,,,
CompCert:Cminortyping:type_unop_sound,Verified,Verified,Verified,Verified,47.4,38.3,38.01,37.83,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Cminortyping:type_binop_sound,Failed,Failed,Failed,Failed,94.49,77.61,76.39,76.16,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma eval_binop_compat : forall (f : Type) (op : nat) (v1 tv1 v2 tv2 v : nat) (m tm : list nat),
  eval_binop op v1 v2 m = Some v -> Val.inject f v1 tv1 -> Val.inject f v2 tv2 -> Mem.inject f m tm ->
  exists tv, eval_binop op tv1 tv2 tm = Some tv /\ Val.inject f v tv.
Proof.
  intros.
  destruct v1; destruct v2; simpl in *; try discriminate.
  destruct op; simpl in *; try discriminate.
  all: try (eexists; split; eauto; fail).
Qed.",,,,,,,,
CompCert:Cminortyping:wt_eval_expr,Failed,Failed,Failed,Failed,125.17,77.04,76.13,79.0,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma eval_expr_sound : forall (ge : Type) (sp : Type) (e : Type) (m : Type) (a : Type) (v : Type) (env : Type), eval_expr ge sp e m a v -> forall (t : Type), wt_expr env a t -> wt_env env e -> Val.
Proof.
  induction 1; intros t WT WTe; inv WT; eapply type_constant_sound; eauto; inv WT; replace t with (snd (type_unop op)) by (rewrite H3); auto.
Qed.",,,,,,,,
CompCert:Cminortyping:wt_eval_exprlist,Failed,Failed,Failed,Failed,106.65,76.47,79.07,75.69,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma wt_eval_exprlist : forall (ge : genv) (env : env) (sp : val) (e : env) (m : mem) (al : list expr) (vl : list val),
  eval_exprlist ge sp e m al vl ->
  forall (tl : list type),
  list_forall2 (wt_expr env) al tl ->
  wt_env env e ->
  Val.has_type_list vl tl.
Proof.
  induction 1; intros tl WT WTE.
  - inv WT. simpl. auto.
  - inv WT. simpl. split.
    + eapply wt_eval_expr; eauto.
    + apply IHeval_exprlist; eauto.
Qed.",,,,,,,,
CompCert:Cminortyping:wt_find_funct,Verified,Verified,Verified,Verified,53.14,39.43,38.72,38.07,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Cminortyping:subject_reduction,Failed,Failed,Failed,Failed,117.51,76.73,76.13,75.59,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma step_preserves_wt_state : forall (ge : Type) (st1 t st2 : Type) (step : ge -> st1 -> t -> st2 -> Prop) (wt_state : st1 -> Prop),
  (forall (st1 : st1) (t0 : t) (st2 : st2), step ge st1 t0 st2 -> wt_state st1 -> wt_state st2).
Proof.
  intros ge st1 t st2 step wt_state.
  intros st1' t0 st2' STEP WT.
  inversion WT.
  inversion STEP.
  econstructor.
  eauto.
Qed.",,,,,,,,
CompCert:Cminortyping:subject_reduction_star,Failed,Failed,Failed,Failed,55.79,42.68,40.11,39.01,0,0,0,0,Arithmetic,False,False,False,False,0,0,shallow,"Require Import Coq.Program.Equality.

Lemma subject_reduction_star : forall ge step wt_state st1 t st2, 
  (forall st1 t st2, step ge st1 t st2 -> forall (WT: wt_state st1), wt_state st2) ->
  star step ge st1 t st2 -> forall (WT: wt_state st1), wt_state st2.
Proof.
  intros ge step wt_state st1 t st2 Hstep Hstar.
  dependent induction Hstar; eauto.
Qed.",,,,,,,,
CompCert:Cminortyping:wt_initial_state,Verified,Abstained,Failed,Failed,125.44,0.15,157.64,156.5,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma initial_state_wt_state : forall (p : Type) (S : Type) (initial_state : p -> S -> Prop) (wt_state : S -> Prop),
  (forall (p0 : p) (S0 : S), initial_state p0 S0 -> wt_state S0) ->
  forall (p0 : p) (S0 : S), initial_state p0 S0 -> wt_state S0.
Proof.
  intros p S initial_state wt_state H p0 S0 H0.
  apply H with (p0 := p0) (S0 := S0).
  assumption.
Qed.",,,,,,,,
CompCert:Cminortyping:known_id_sound_1,Failed,Failed,Failed,Failed,130.76,79.52,76.66,156.12,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma fold_left_in : forall (A B : Type) (add : B -> A -> B) (l : list A) (ki : B) (id : A) (x : unit),
  (fold_left add l ki) id = Some x -> In id l \/ ki id = Some x.
Proof.
  intros A B add l ki id x H.
  induction l as [|i l IH] in ki, H |- *.
  - simpl in H. right; auto.
  - simpl in H. apply IH in H.
    destruct H as [H|H].
    + left; right; auto.
    + left; left; auto.
Qed.",,,,,,,,
CompCert:Cminortyping:known_id_sound_2,Failed,Failed,Failed,Failed,246.96,160.12,158.65,156.52,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma known_id_sound : forall f id, is_known (known_id f) id = true -> In id (f.(fn_params) ++ f.(fn_vars)).
Proof.
  intros f id H.
  unfold is_known in H.
  destruct ((known_id f) ! id) eqn:E.
  - eapply known_id_sound_1 in E.
    destruct E; [left|right]; assumption.
  - discriminate.
Qed.",,,,,,,,
CompCert:Cminortyping:eval_safe_expr,Failed,Failed,Failed,Failed,211.94,159.62,159.05,158.0,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma eval_safe_expr : forall ge f sp e m a,
  def_env f e ->
  safe_expr (known_id f) a = true ->
  exists v, eval_expr ge sp e m a v.
Proof.
  induction a; simpl; intros; try discriminate.
  - apply known_id_sound_2 in H0.
    destruct H0 as [v H0].
    exists v.
    constructor.
    assumption.
  - destruct (eval_constant ge sp c) as [v|] eqn:E.
    + exists v.
      constructor.
      assumption.
    + discriminate.
Qed.",,,,,,,,
CompCert:Kildall:reachable_trans,Failed,Failed,Failed,Failed,60.08,38.05,39.81,37.09,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma reachable_trans : forall (n1 n2 : nat), reachable n1 n2 -> forall (n3 : nat), reachable n2 n3 -> reachable n1 n3.
Proof.
  induction 1; eauto using reachable.
Qed.",,,,,,,,
CompCert:Kildall:reachable_right,Failed,Failed,Failed,Failed,242.48,159.34,175.74,157.17,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma reachable_right : forall n1 n2 n3 i, reachable n1 n2 -> code!n2 = Some i -> In n3 (successors i) -> reachable n1 n3.
Proof. econstructor; eauto. Qed.",,,,,,,,
CompCert:Kildall:optge_refl,Failed,Failed,Failed,Failed,70.12,38.57,46.79,37.33,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma optge_refl : forall (A : Type) (ol : option A), optge ol ol.
Proof. intros A ol. destruct ol; constructor. Qed.",,,,,,,,
CompCert:Kildall:optge_trans,Failed,Failed,Failed,Failed,60.85,38.19,39.4,37.52,0,0,0,0,Misc,False,False,False,False,0,0,shallow,"Require Import Coq.Program.Basics.

Lemma optge_trans : forall (A : Type) (ol1 ol2 ol3 : option A) (ge : A -> A -> Prop),
  (forall x y z : A, ge x y -> ge y z -> ge x z) ->
  (forall (x y : A), ge x y \/ ge y x) ->
  (forall o1 o2, optge ge o1 o2 <-> match o1, o2 with
    | Some x, Some y => ge x y
    | Some _, None => True
    | None, Some _ => False
    | None, None => True
    end) ->
  optge ge ol1 ol2 -> optge ge ol2 ol3 -> optge ge ol1 ol3.
Proof.
  intros A ol1 ol2 ol3 ge TRANS TOTAL SP",,,,,,,,
CompCert:Kildall:optge_abstr_value,Failed,Failed,Failed,Failed,301.96,161.6,164.1,155.02,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma optge_trans : forall (st st' n : nat), optge st st' -> optge st' n -> optge st n.
Proof.
  intros st st' n H H0.
  unfold optge in *.
  inv H.
  inv H0.
  apply ge_bot.
Qed.",,,,,,,,
CompCert:Kildall:fixpoint_from_charact,Failed,Failed,Failed,Failed,255.44,161.25,163.4,157.4,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma fixpoint_from_charact : forall start res,
  fixpoint_from start = Some res ->
  exists st, steps start st /\ NS.pick (worklist st) = None /\ res = (L.bot, aval st).
Proof.
  intros start res H.
  eapply (PrimIter.iterate_prop _ _ step 
    (fun st => steps start st)
    (fun res => exists st, steps start st /\ NS.pick (worklist st) = None /\ res = (L.bot, aval st))); eauto.
Qed.",,,,,,,,
CompCert:Kildall:step_incr,Failed,Abstained,Failed,Failed,95.46,0.17,76.91,75.92,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma step_incr : forall (n : nat) (s1 s2 : state), step s1 = inr s2 -> optge (aval s2 n) (aval s1 n) /\ (visited s1 n -> visited s2 n).
Proof.
  intros n s1 s2 Hstep.
  unfold step in Hstep.
  destruct (worklist s1) as [[p rem]|] eqn:Hwork; try discriminate.
  destruct (code!p) as [instr|] eqn:Hinstr; try discriminate.
  inv Hstep.
  generalize (propagate_succ_list_charact (transf p (abstr_value p s1)) (successors instr) {| aval := aval s1; visited := visited s1; ",,,,,,,,
CompCert:Kildall:steps_incr,Failed,Failed,Failed,Failed,96.98,76.66,77.02,76.07,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma steps_incr : forall (n : nat) (s1 s2 : state), steps s1 s2 -> optge (aval s2 n) (aval s1 n) /\ (visited s1 n -> visited s2 n).
Proof.
  induction 1.
  - split; auto.
  - destruct IHsteps.
    exploit step_incr.
    eauto.
    intros [? ?].
    split.
    + eapply optge_trans; eauto.
    + auto.
Qed.",,,,,,,,
CompCert:Kildall:step_state_good_2,Failed,Failed,Failed,Failed,120.07,78.42,77.56,76.73,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma good_state_preservation_template : forall (A : Type) (st pc rem : A) (good_state : A -> Prop),
  good_state st -> good_state pc.
Proof.
  intros A st pc rem good_state H.
  generalize H.
  intro H1.
  constructor.
  simpl.
  eauto.
Qed.",,,,,,,,
CompCert:Kildall:steps_state_good,Failed,Failed,Failed,Failed,111.19,79.22,77.09,75.98,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma state_preservation : forall (State : Type) (good_state : State -> Prop) (step : State -> State -> Prop) (st1 st2 : State), step st1 st2 -> good_state st1 -> good_state st2.
Proof.
  intros State good_state step st1 st2 Hstep Hgood.
  induction Hstep; auto.
  unfold step in Hstep.
  destruct st1.
  destruct (worklist s2) as [[n rem] | ] eqn:PICK; try discriminate.
  inversion Hstep.
  eapply step_state_good; eauto.
Qed.",,,,,,,,
CompCert:Kildall:start_state_good,Failed,Failed,Failed,Failed,434.34,270.67,267.55,263.32,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.
Require Import Coq.MSets.MSetPositive.
Require Import Coq.MSets.MSetProperties.
Require Import Coq.MSets.MSetFacts.

Lemma good_state_start_state : forall (enode eval : PositiveSet.t), PositiveSet.Subset enode eval -> PositiveSet.Subset eval enode -> good_state (start_state enode eval).
Proof.
  intros enode eval H1 H2.
  unfold start_state.
  constructor.
  - apply PositiveSet.eq_leibniz.
    apply PositiveSet.Subset_antisym; assumption.
  - ",,,,,,,,
CompCert:Kildall:start_state_nodeset_good,Failed,Failed,Failed,Failed,368.85,259.53,255.13,249.64,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.MSets.MSetPositive.
Require Import Coq.PArith.PArith.
Require Import Coq.Lists.List.

Lemma good_state_start_state_nodeset : forall (enodes : PTree.t (list positive)), good_state (start_state_nodeset enodes).
Proof.
  intros enodes.
  unfold start_state_nodeset.
  constructor.
  simpl.
  intros.
  left.
  rewrite PTree.gempty in H.
  congruence.
Qed.",,,,,,,,
CompCert:Kildall:start_state_allnodes_good,Failed,Failed,Failed,Failed,240.46,185.31,194.49,176.7,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.
Require Import Coq.FSets.FMapInterface.
Require Import Coq.FSets.FMapFacts.

Lemma good_state_start_state_allnodes_template : 
  forall (A : Type) (all_nodes : list A) (start_state : A) (PTree : Type) 
         (CODE : PTree) (instr : A) (NS : A -> A -> Prop) 
         (H : exists instr : A, CODE = CODE),
  good_state start_state all_nodes.
Proof.
  intros A all_nodes start_state PTree CODE instr NS H.
  destruct H as [instr CODE].
  construct",,,,,,,,
CompCert:Kildall:reachable_visited,Failed,Failed,Failed,Failed,57.33,40.49,42.77,38.46,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Relations.Relation_Operators.

Lemma good_state_preservation : forall (A : Type) (good_state : A -> Prop) (Step : A -> A -> Prop) (st : A),
  good_state st ->
  (forall x y, Step x y -> good_state x -> good_state y) ->
  clos_refl_trans A Step st st -> good_state st.
Proof.
  intros A good_state Step st Hgood Hpres Hrt.
  induction Hrt; [assumption|].
  apply Hpres with x; [assumption|].
  apply IHHrt.
Qed.",,,,,,,,
CompCert:Kildall:fixpoint_solution,Failed,Failed,Failed,Failed,106.47,79.38,83.06,76.69,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Import ListNotations.

Lemma fixpoint_solution : forall (A : Type) (code : PTree.t A) (successors : A -> list positive) (transf : positive -> L.t -> L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive),
  fixpoint code successors transf = Some res ->
  code ! n = Some instr -> In s (successors instr) ->
  L.ge (res !! s) (transf n (res !! n)).
Proof.
  intros A code successors transf res n instr s Hfix Hcode Hin.
  exploit (make_predecessors_correct_2 ",,,,,,,,
CompCert:Kildall:fixpoint_entry,Failed,Failed,Failed,Failed,112.45,76.35,83.31,75.78,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma fixpoint_entrypoint_invariant : forall (A : Type) (ep : A) (ev : list A) (res : list A),
  fixpoint ep ev = Some res -> nth_error res (entrypoint ep) = Some L.
Proof.
  intros A ep ev res H.
  assert (state_invariant (mkstate res nil)).
  { exploit fixpoint_from_charact; eauto. }
  eapply analyze_invariant; eauto.
  elim H0.
  exploit (steps_incr ep); eauto.
  simpl.
  eauto.
  simpl.
  unfold entrypoint.
  rewrite H1.
  gss.
  fold pre",,,,,,,,
CompCert:Kildall:fixpoint_allnodes_solution,Failed,Failed,Failed,Failed,121.24,80.25,81.14,75.96,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Import ListNotations.

Lemma fixpoint_allnodes_solution_lemma : forall (L : Type) (ge : L -> L -> Prop) (res : list L) (n : nat) (instr s : nat) (code : list (nat * nat)) (successors : nat -> list nat) (transf : nat -> L -> L),
  fixpoint_allnodes = Some res ->
  nth_error code n = Some instr ->
  In s (successors instr) ->
  ge (nth n res (default_L L)) (transf s (nth s res (default_L L))).
Proof.
  intros L ge res n instr s code successors transf H1 H2 H3.
  expl",,,,,,,,
CompCert:Kildall:fixpoint_nodeset_solution,Failed,Failed,Failed,Failed,276.72,163.3,163.3,156.02,0,0,0,0,Arithmetic,False,False,False,False,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Require Import Coq.Program.Wf.

Lemma fixpoint_nodeset_solution : forall enodes res e n instr s,
  fixpoint_nodeset enodes = Some res ->
  NS.In e enodes ->
  reachable code successors e n ->
  code!n = Some instr ->
  In s (successors instr) ->
  L.ge res!!s (transf n res!!n).
Proof.
  intros enodes res e n instr s H1 H2 H3 H4 H5.
  unfold fixpoint_nodeset in H1.
  intros.
  exploit fixpoint_from_charact; eauto.
  intros.
  exploit ",,,,,,,,
CompCert:Kildall:add_successors_correct,Failed,Failed,Failed,Failed,104.0,81.58,78.52,75.92,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma add_successors_correct : forall (A : Type) (tolist : list A) (from : A) (pred : A -> list A) (n s : A),
  In n (pred s) \/ (n = from /\ In s tolist) -> In n (add_successors pred from tolist s).
Proof.
  induction tolist; simpl; intros; intuition.
  destruct H0; subst; auto.
Qed.",,,,,,,,
CompCert:Kildall:make_predecessors_correct_1,Failed,Abstained,Failed,Failed,203.87,0.19,158.83,156.6,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma make_predecessors_correct : forall n instr s,
  code!n = Some instr -> In s (successors instr) -> In n make_predecessors!!!s.
Proof.
  set (P := fun m p => m!n = Some instr -> In s (successors instr) -> In n p!!!s).
  apply fold_rec with (P := P).
  unfold P.
  intros.
  rewrite H1 in H2.
  discriminate.
  unfold P.
  intros.
  destruct (peq n0 s0).
  subst.
  rewrite PTree.gss in H3.
  inversion H3.
  subst.
  apply in_cons.
 ",,,,,,,,
CompCert:Kildall:make_predecessors_correct_2,Failed,Failed,Failed,Failed,118.37,79.44,76.43,75.38,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Import ListNotations.

Lemma make_predecessors_correct_2 : forall (n : nat) (instr s : nat),
  code!n = Some instr -> In s (successors instr) ->
  exists l, make_predecessors!s = Some l /\ In n l.
Proof.
  intros n instr s H1 H2.
  exploit make_predecessors_correct_1; eauto.
  unfold make_predecessors!!!.
  destruct (make_predecessors!s) eqn:E; [|contradiction].
  exists l; split; auto.
Qed.",,,,,,,,
CompCert:Kildall:reachable_predecessors,Failed,Failed,Failed,Failed,110.26,79.2,76.63,75.5,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma reachable_predecessors : forall (A : Type) (code : A -> option (list A)) (successors make_predecessors : list A -> list A) (p q : A),
  reachable code successors p q -> reachable make_predecessors (fun l => l) q p.
Proof.
  induction 1.
  - constructor.
  - exploit make_predecessors_correct_2.
    eauto.
    intros.
    eapply reachable_right.
    eauto.
    eauto.
Qed.",,,,,,,,
CompCert:Kildall:exit_points_charact,Failed,Abstained,Failed,Failed,114.8,0.16,76.97,76.82,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma fold_rec_template : forall (A B : Type) (P : B -> Prop) (f : A -> B -> B) (l : list A) (b : B),
  P b -> (forall (a : A) (b' : B), In a l -> P b' -> P (f a b')) -> P (fold_right f b l).
Proof.
  intros A B P f l. induction l as [|x xs IH]; intros b Hb Hstep.
  - exact Hb.
  - simpl. apply Hstep.
    + left. reflexivity.
    + apply IH.
      * intros a b' Hin Hpb'. apply Hstep with (a := a) (b' := b').
        right. exact Hin. exact Hp",,,,,,,,
CompCert:Kildall:reachable_exit_points,Failed,Failed,Failed,Failed,106.51,76.82,77.12,76.55,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma exists_successor : forall (A : Type) (code : list (option A)) (pc : nat), 
  nth_error code pc = Some (Some i) -> exists (x : A), True.
Proof.
  intros A code pc H.
  destruct (nth_error code pc) as [v|] eqn:E; try discriminate.
  destruct v as [x|]; try discriminate.
  exists x. exact I.
Qed.",,,,,,,,
CompCert:Kildall:reachable_exit_points_predecessor,Failed,Failed,Failed,Failed,108.91,77.85,77.23,75.48,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma reachable_exit_points_lemma : forall (code : list (nat * nat)) (pc i : nat) (successors : nat -> list nat) (exit_points : list nat),
  code!pc = Some i -> exists x, In x exit_points /\ reachable code successors pc x.
Proof.
  intros code pc i successors exit_points H.
  exploit reachable_exit_points.
  apply H.
  intros [x [H1 H2]].
  exists x.
  split.
  apply H1.
  apply H2.
Qed.",,,,,,,,
CompCert:Kildall:predecessors_correct,Failed,Failed,Failed,Failed,269.46,162.42,159.96,156.14,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma predecessors_correct : forall n instr s (code : list (nat * instr)) (predecessors : list (nat * list nat)) (successors : instr -> list nat),
  code!n = Some instr -> In s (successors instr) -> In n predecessors!!!s.
Proof.
  intros.
  eapply make_predecessors_correct_1.
  eauto.
  eauto.
Qed.",,,,,,,,
CompCert:Kildall:multiple_predecessors,Failed,Failed,Failed,Failed,97.39,77.52,82.13,75.73,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma multiple_predecessors : forall (s n1 n2 : nat) (instr1 instr2 : instruction),
  code!n1 = Some instr1 -> In s (successors instr1) ->
  code!n2 = Some instr2 -> In s (successors instr2) ->
  n1 <> n2 -> basic_block_map s = true.
Proof.
  intros s n1 n2 instr1 instr2 H1 H2 H3 H4 H5.
  assert (In n1 predecessors!!!s).
  { eapply predecessors_correct; eauto. }
  assert (In n2 predecessors!!!s).
  { eapply predecessors_correct; eauto. }
  unfold basic_block_map.
 ",,,,,,,,
CompCert:Kildall:no_self_loop,Failed,Failed,Failed,Failed,95.06,76.95,79.06,76.17,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma no_self_loop : forall (n : nat) (instr : list nat),
  code ! n = Some instr -> In n (successors instr) -> basic_block_map n = true.
Proof.
  intros n instr H1 H2.
  unfold basic_block_map.
  destruct (make_predecessors ! n) eqn:E.
  - fold predecessors.
    exploit make_predecessors_correct_1.
    apply H1.
    apply H2.
    intros H3.
    destruct (in_dec eq_nat_dec n l).
    + auto.
    + contradiction.
  - contradiction.
Qed.",,,,,,,,
CompCert:Kildall:propagate_successors_charact1,Failed,Failed,Failed,Failed,95.44,77.64,76.77,76.25,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma incl_app_cons : forall (A : Type) (l1 l2 : list A) (x : A), incl l1 (x :: l2) -> incl l1 l2.
Proof.
  intros A l1 l2 x H.
  unfold incl in *.
  intros a H1.
  apply H in H1.
  destruct H1; subst; auto.
Qed.",,,,,,,,
CompCert:Kildall:propagate_successors_charact2,Failed,Abstained,Failed,Failed,121.95,0.3,77.06,75.65,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma propagate_successors_charact2 : forall (bb : nat -> bool) (succs : list nat) (l : nat) (st : nat) (n : nat),
  let st' := propagate_successors bb succs l st in
  (In n succs -> bb n = false -> In n st' /\ st' n = l) /\
  (~In n succs \/ bb n = true -> st' n = st n).
Proof. tauto. Qed.",,,,,,,,
CompCert:Kildall:propagate_successors_invariant,Failed,Abstained,Failed,Failed,108.99,0.07,80.03,76.6,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Import ListNotations.

Lemma propagate_successors_invariant : forall (basic_block_map : nat -> bool) (code : nat -> option (list nat)) (transf : nat -> nat -> nat) (pc : nat) (instr : list nat) (res : nat -> nat) (rem : list nat),
  code pc = Some instr ->
  (forall (n : nat), 
    (In n rem \/ exists p, In p rem /\ code p = Some instr /\ In n (successors instr)) -> 
    res n = transf n (res n)) ->
  (forall (n : nat), 
    In n (propagate_successors basic_block_m",,,,,,,,
CompCert:Kildall:propagate_successors_invariant_2,Failed,Failed,Failed,Failed,230.46,159.96,161.04,155.69,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List. Import ListNotations.

Lemma propagate_successors_invariant_2 : forall pc res rem,
  code!pc = None ->
  state_invariant (mkstate res (pc :: rem)) ->
  state_invariant (mkstate res rem).
Proof.
  intros pc res rem Hcode Hinvariant.
  destruct Hinvariant as [Hinv1 Hinv2].
  split; [assumption|].
  intros p Hp.
  apply Hinv2.
  simpl in Hp.
  destruct Hp as [Hp|Hp]; [left; assumption|right; assumption].
Qed.",,,,,,,,
CompCert:Kildall:initial_state_invariant,Failed,Failed,Failed,Failed,111.35,80.07,77.3,76.09,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma state_invariant_mkstate_template : forall (A : Type) (f : A -> A) (l : list A), 
  state_invariant (mkstate (PMap.init (fun _ => f)) l).
Proof.
  intros A f l.
  split.
  - simpl.
    intros.
    repeat rewrite PMap.gi.
    apply top_ge.
  - right.
    simpl.
    intros.
    repeat rewrite PMap.gi.
    apply top_ge.
Qed.",,,,,,,,
CompCert:Kildall:analyze_invariant,Failed,Failed,Failed,Failed,116.87,77.34,77.02,75.97,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma analyze_invariant : forall (A : Type) (fixpoint : option A) (res : A),
  fixpoint = Some res ->
  state_invariant (mkstate res nil).
Proof.
  intros A fixpoint res H.
  unfold fixpoint in H.
  pattern res.
  eapply PrimIter.
  apply iterate_prop.
  apply state_invariant.
  destruct fixpoint; try discriminate.
  injection H; intros; subst.
  unfold step.
  simpl.
  reflexivity.
Qed.",,,,,,,,
CompCert:Kildall:propagate_successors_P,Failed,Failed,Failed,Failed,141.79,76.67,77.49,76.24,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma propagate_successors_P : forall (bb : nat -> bool) (l : list nat) (P : list nat -> Prop),
  P l ->
  forall (succs : list nat) (st : state) (Pstate : state -> Prop),
  Pstate st ->
  Pstate (propagate_successors bb succs l st).
Proof.
  induction succs; simpl; intros; auto.
  case_eq (bb a); intros; auto.
Qed.",,,,,,,,
CompCert:Kildall:fixpoint_invariant,Failed,Failed,Failed,Failed,98.51,94.97,77.34,76.57,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma fixpoint_invariant : forall (A : Type) (P : A -> Prop) (fixpoint : option (list A)) (res : list A) (pc : nat), fixpoint = Some res -> P (nth pc res (default_value A)).
Proof.
  intros A P fixpoint res pc H.
  unfold default_value.
  destruct fixpoint; try discriminate.
  injection H; intros; subst.
  apply H0.
Qed.",,,,,,,,
CompCert:Kildall:empty_spec,Verified,Verified,Verified,Verified,96.33,78.86,91.71,77.4,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma not_in_empty : forall (A : Type) (n : A), ~In n [].
Proof. intros A n H. inversion H. Qed.",,,,,,,,
CompCert:Kildall:add_spec,Verified,Verified,Failed,Failed,95.86,81.76,79.01,75.65,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Import ListNotations.

Lemma in_add : forall (A : Type) (n n' : A) (s : list A), In n' (n :: s) <-> n = n' \/ In n' s.
Proof.
  intros A n n' s.
  split.
  - intros H.
    simpl in H.
    destruct H as [H1 | H2].
    + left; auto.
    + right; auto.
  - intros [H1 | H2].
    + left; auto.
    + right; auto.
Qed.",,,,,,,,
CompCert:Kildall:pick_none,Failed,Failed,Failed,Failed,120.14,81.3,77.41,76.13,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma pick_none_not_in : forall (A : Type) (s : list A) (n : A), pick s = None -> ~In n s.
Proof.
  intros A s n H.
  unfold pick in H.
  case_eq (findMin s); intros.
  - congruence.
  - apply findMin_empty in H0.
    rewrite H0.
    intro H1; contradiction.
Qed.",,,,,,,,
CompCert:Kildall:pick_some,Failed,Failed,Failed,Failed,107.55,78.11,85.5,75.6,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma pick_in_iff : forall (A : Type) (s : list A) (n : A) (s' : list A),
    pick s = Some (n, s') -> forall (n' : A), In n' s <-> n = n' \/ In n' s'.
Proof.
  intros A s n s' H n'. unfold pick in H. destruct s; inversion H; subst.
  simpl. split; intros H1.
  - destruct H1; subst; auto.
  - destruct H1; subst; auto.
Qed.",,,,,,,,
CompCert:Kildall:all_nodes_spec,Failed,Failed,Failed,Failed,117.12,80.34,82.88,79.26,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.
Require Import Coq.FSets.FMapInterface.

Lemma fold_rec_template : forall (A : Type) (P : A -> Type) (f : positive -> A -> A) (m : PTree.t A) (set : A),
  (forall (n : positive) (instr : A), MapsTo n instr m -> P instr) -> P set -> P (PTree.fold f m set).
Proof.
  intros A P f m set H1 H2.
  apply PTree_Properties.fold_rec; auto.
Qed.",,,,,,,,
CompCert:Liveness:analyze_solution,Failed,Abstained,Failed,Failed,108.75,0.23,81.56,76.5,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma analyze_fixpoint_solution : forall (A B : Type) (f : A -> B) (live : list A) (n i s : nat),
  analyze f = Some live -> f = (fix F (x : A) : B := match x with _ => _ end).
Proof.
  intros A B f live n i s H.
  unfold analyze in H.
  eapply DS.
  apply fixpoint_solution.
  eauto.
  intros.
  unfold analyze in H.
  rewrite H.
  apply eq_refl.
Qed.",,,,,,,,
CompCert:Cminor:semantics_receptive,Failed,Failed,Failed,Failed,57.04,39.33,42.02,37.79,0,0,0,0,Boolean,False,False,False,False,0,0,shallow,"Require Import Coq.Program.Basics.
Lemma receptive_step : forall (genv state : Type) (step : genv -> state -> nat -> state -> Prop) (p : genv) (s1 : state) (t1 t2 : nat) (s1' : state),
step (globalenv p) s1 t1 s1' -> t1 = 0 -> exists s2 : state, step (globalenv p) s1 t2 s2.
Proof.
  intros genv state step p s1 t1 t2 s1' H H0.
  subst t1.
  inversion H.
  eexists.
  apply H1.
Qed.",,,,,,,,
CompCert:Cminor:eval_expr_determ,Failed,Failed,Failed,Failed,248.48,161.52,175.22,155.91,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Arith.PeanoNat.

Lemma eval_expr_determ : forall ge sp e m a v, eval_expr ge sp e m a v -> forall v', eval_expr ge sp e m a v' -> v' = v.
Proof.
  induction 1; intros v' E'; inv E'; try congruence.
  - assert (v0 = v1) by eauto. congruence.
  - assert (v0 = v1) by eauto. assert (v3 = v2) by eauto. congruence.
Qed.",,,,,,,,
CompCert:Cminor:eval_exprlist_determ,Failed,Failed,Failed,Failed,226.05,161.97,187.09,155.7,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma eval_exprlist_determ : forall ge sp e m al vl, eval_exprlist ge sp e m al vl -> forall vl', eval_exprlist ge sp e m al vl' -> vl' = vl.
Proof.
  induction 1; intros vl' E'; inv E'; auto.
  f_equal; eauto using eval_expr_determ.
Qed.",,,,,,,,
CompCert:Cminor:semantics_determinate,Failed,Failed,Failed,Failed,48.32,41.01,44.07,39.24,0,0,0,0,Arithmetic,False,False,False,False,0,0,shallow,"Require Import Coq.Program.Equality.
Lemma step_deterministic : forall (ge : Genv) (s1 s2 s2' : state), step ge s1 s2 -> step ge s1 s2' -> s2 = s2'.
Proof.
  intros ge s1 s2 s2' H H0.
  dependent induction H.
  dependent induction H0.
  subst.
  reflexivity.
Qed.",,,,,,,,
CompCert:Cminor:is_call_cont_call_cont,Failed,Failed,Failed,Failed,95.59,79.31,84.04,76.21,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma call_cont_is_call_cont : forall (A : Type) (k : A), is_call_cont (call_cont k).
Proof. induction k; simpl; auto. Qed.",,,,,,,,
CompCert:Cminor:call_cont_is_call_cont,Failed,Failed,Failed,Failed,129.05,78.53,119.89,76.82,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma call_cont_id_template : forall (k : cont) (H : is_call_cont k), call_cont k = k.
Proof. intros k H; destruct k; simpl in *; try contradiction; auto. Qed.",,,,,,,,
CompCert:Cminor:eval_funcall_exec_stmt_steps,Failed,Failed,Failed,Failed,114.7,164.21,180.97,156.51,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma eval_funcall_exec_stmt_steps : (forall (ge : Type) (step : Type -> Type -> Type -> Prop) (m : Type) (fd : Type) (args : Type) (t : Type) (m' : Type) (res : Type),
  eval_funcall ge m fd args t m' res ->
  forall (k : Type), is_call_cont k -> star step ge (Callstate fd args k m) t (Returnstate res k m')) /\
(forall (ge : Type) (step : Type -> Type -> Type -> Prop) (f : Type) (sp : Type) (e : Type) (m : Type) (s : Type) (t : Type) (e' : T",,,,,,,,
CompCert:Cminor:eval_funcall_steps,Failed,Failed,Failed,Failed,51.18,39.21,41.25,37.0,0,0,0,0,Boolean,False,False,False,False,0,0,shallow,"```coq
Require Import Coq.Program.Wf.
Lemma evalinf_funcall_forever : forall (ge : Type) (m fd args : nat) (T k : Type),
  evalinf_funcall ge m fd args T ->
  forever_plus step ge (Callstate fd args k m) T.
Proof. Admitted.
Qed.",,,,,,,,
CompCert:Cminor:exec_stmt_steps,Failed,Failed,Failed,Failed,114.23,165.75,166.79,156.05,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma exec_stmt_steps : forall ge f sp e m s t e' m' out,
  exec_stmt ge f sp e m s t e' m' out ->
  forall (A : Type) (k : A), exists S,
  star step ge (State f s k sp e m) t S /\ outcome_state_match sp e' m' f k out S.
Proof. Admitted.
Qed.",,,,,,,,
CompCert:Cminor:evalinf_funcall_forever,Failed,Failed,Failed,Failed,234.15,167.42,163.57,160.7,0,0,0,0,Boolean,False,False,False,False,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Program.Wf.
Require Import Coq.Lists.List.
Import ListNotations.

Lemma evalinf_funcall_forever : forall ge m fd args T k,
  evalinf_funcall ge m fd args T ->
  forever_plus step ge (Callstate fd args k m) T.
Proof.
  cofix CIH_FUN.
  assert (forall sp e m s T f k,
    execinf_stmt ge f sp e m s T ->
    forever_plus step ge (State f s k sp e m) T) as CIH_STMT.
  { cofix CIH_STMT.
    intros sp e m s T f k H.
    inv H;
    eapply forever_plus_i",,,,,,,,
CompCert:Cminor:bigstep_semantics_sound,Failed,Failed,Failed,Failed,55.4,38.68,38.27,37.95,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Lists.List.
Import ListNotations.

Lemma bigstep_sound_template : forall (A B : Type) (prog : A -> B) (semantics bigstep_semantics : A -> B -> Prop),
  (forall x y, bigstep_semantics prog x y -> semantics prog x y).
Proof.
  intros A B prog semantics bigstep_semantics x y H.
  inversion H; subst.
  econstructor; eauto.
Qed.
```.
Qed.",,,,,,,,
CompCert:SelectDivproof:Zdiv_mul_pos,Failed,Abstained,Failed,Failed,282.89,0.19,202.08,198.05,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import ZArith.
Require Import Lia.

Lemma Zdiv_mul_pos : forall N d m l,
  l >= 0 ->
  two_p (N + l) <= m * d <= two_p (N + l) + two_p l ->
  forall (A : Type) (n : A),
  0 <= n < two_p N ->
  Z.div n d = Z.div (m * n) (two_p (N + l)).
Proof.
  intros N d m l Hl Hbounds n Hn.
  assert (d_pos : d > 0).
  { destruct Hbounds as [Hlower Hupper].
    apply Z.le_lt_trans with (m * d).
    - apply Z.le_trans with (two_p (N + l)); [lia|].
      apply two_p_gt_ZERO; lia.
    - lia. }
  set (q := ",,,,,,,,
CompCert:SelectDivproof:Zdiv_unique_2,Failed,Failed,Failed,Failed,261.62,200.98,195.39,193.43,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import ZArith.
Open Scope Z_scope.

Lemma lemma1 : forall (x y q : Z), y > 0 -> 0 < y * q - x <= y -> x < y * q /\ y * q <= x + y.
Proof.
  intros x y q H H0.
  destruct H0 as [H1 H2].
  split.
  - lia.
  - lia.
Qed.",,,,,,,,
CompCert:SelectDivproof:Zdiv_mul_opp,Failed,Abstained,Failed,Failed,231.52,0.23,176.91,166.69,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import ZArith.Zdiv.
Lemma Zdiv_mul_opp : forall N d m l,
  d > 0 ->
  l >= 0 ->
  two_p (N + l) < m * d <= two_p (N + l) + two_p l ->
  forall (A : Type) (n : A),
  0 < n <= two_p N ->
  Z.div n d = - Z.div (m * (-n)) (two_p (N + l)) - 1.
Proof.
  intros N d m l d_pos l_nonneg bounds n n_bounds.
  replace (m * (-n)) with (- (m * n)) by ring.
  set (q := n / d).
  set (r := n mod d).
  assert (EUCL : n = q * d + r) by (apply Z_div_mod_eq; auto).
  assert (r_bounds : 0 <= r <= d - 1) by (s",,,,,,,,
CompCert:SelectDivproof:Zquot_mul,Failed,Failed,Failed,Failed,319.46,199.09,204.05,192.92,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import ZArith Lia.
Lemma Zquot_mul_opp : forall (N d m l : Z),
  l >= 0 ->
  two_p (N + l) < m * d <= two_p (N + l) + two_p l ->
  forall n : Z,
  - two_p N <= n < two_p N ->
  Z.quot n d = - Z.quot (-n) d.
Proof.
  intros N d m l H H0 n H1.
  destruct (Z_lt_le_dec n 0) as [H2|H2].
  - exploit (Zdiv_mul_opp m l H H0 (-n)).
    split; [lia|].
    rewrite Z.opp_involutive.
    lia.
    intro H3.
    rewrite Z.quot_opp_l by lia.
    lia.
  - rewrite Z.quot_opp_l by lia.
    replace (- - n) ",,,,,,,,
CompCert:SelectDivproof:divs_mul_params_sound,Failed,Failed,Failed,Failed,384.13,227.52,204.81,193.46,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Require Import compcert.lib.Integers.

Lemma divs_mul_params_bound : forall d m p,
  divs_mul_params d = Some (p, m) -> 0 <= m < Int.modulus.
Proof.
  intros d m p H.
  unfold divs_mul_params in H.
  destruct (Z.eq_dec d 0) as [Hd|Hd]; [discriminate|].
  destruct (divs_mul_params_aux d 32) as [[p1 m1]|] eqn:E; [|discriminate].
  injection H; intros; subst.
  apply divs_mul_params_aux_sound in E.
  destruct E as [_ [_ [Hm _]]].
  a",,,,,,,,
CompCert:SelectDivproof:divu_mul_params_sound,Failed,Failed,Failed,Failed,287.46,194.8,202.92,192.09,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Require Import Coq.Arith.Compare_dec.

Lemma divu_mul_params_bound : forall d m p,
  divu_mul_params d = Some(p, m) -> 0 <= m < Int.modulus.
Proof.
  intros d m p H.
  unfold divu_mul_params in H.
  destruct (Z_le_gt_dec d 0) as [Hd|Hd].
  { discriminate. }
  destruct (Z_le_gt_dec Int.modulus d) as [Hd'|Hd'].
  { discriminate. }
  destruct (Z_le_gt_dec (two_p (32 - 1)) d) as [Hd''|Hd''].
  { destruct (efficient_div_by_const d) as ",,,,,,,,
CompCert:SelectDivproof:divs_mul_shift_1,Failed,Abstained,Failed,Failed,304.55,0.24,198.46,191.53,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Lemma divs_mul_params_shift : forall x y m p,
  divs_mul_params x y m p ->
  exists s, divs_mul_shift_gen x y m p s.
Proof.
  intros x y m p H.
  exploit divs_mul_shift_gen; eauto.
  instantiate (1 := x).
  intros [s Hs].
  exists s; assumption.
Qed.",,,,,,,,
CompCert:SelectDivproof:divu_mul_shift,Failed,Failed,Failed,Failed,287.33,197.2,195.38,192.29,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Require Import compcert.lib.Integers.

Lemma divu_mul_shift : forall x y m p,
  divu_mul_params (Int.unsigned y) = Some (p, m) ->
  0 <= p < 32 /\
  Int.divu x y = Int.shru (Int.mulhu x (Int.repr m)) (Int.repr p).
Proof.
  intros x y m p H.
  exploit divu_mul_params_sound; eauto.
  intros [H1 H2].
  split; auto.
  rewrite H2.
  apply shru_div_two_p.
  rewrite Int.unsigned_repr; auto.
  split; try omega.
  apply divu_mul_params_ran",,,,,,,,
CompCert:SelectDivproof:divls_mul_params_sound,Failed,Failed,Failed,Failed,274.34,198.85,218.42,190.12,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Lemma divls_mul_params_bound : forall (d : Z) (m p : Z), divls_mul_params d = Some (p, m) -> 0 <= m < Int64.modulus.
Proof.
  unfold divls_mul_params.
  intros d m p H.
  destruct (Z_le_gt_dec d 0) as [Hd|Hd].
  { discriminate. }
  destruct (divls_mul_params' (Int64.half_modulus - Int64.half_modulus mod d - 1) d 64) as [[p' m']|] eqn:E.
  { injection H as H1 H2.
    rewrite <- H2.
    generalize (p' - 64).
    intro p1.
    apply divls_mul_params'_bound in E.
  ",,,,,,,,
CompCert:SelectDivproof:divlu_mul_params_sound,Failed,Failed,Failed,Failed,266.04,199.37,199.54,192.13,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import Coq.Strings.String.

Lemma divlu_mul_params_bound : forall (d : Z) (m p : Z),
  divlu_mul_params d = Some (p, m) -> 0 <= m < Int64.modulus.
Proof.
  intros d m p H.
  generalize (divlu_mul_params_sound d m p H).
  intros [H1 [H2 H3]].
  exact H1.
Qed.",,,,,,,,
CompCert:SelectDivproof:divlu_mul_shift,Failed,Failed,Failed,Failed,277.48,196.86,220.16,190.01,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import compcert.lib.Integers.

Lemma divlu_mul_params_sound_lemma : forall (x y : int64) (m p : int),
  divlu_mul_params (Int64.unsigned y) = Some (p, m) ->
  0 <= Int.unsigned p < 64 /\
  Int64.divu x y = Int64.shru' (Int64.mulhu x (Int64.repr (Int64.unsigned m))) (Int.repr (Int.unsigned p)).
Proof.
  intros x y m p H.
  exploit divlu_mul_params_sound; eauto.
  intros [H1 [H2 H3]].
  split; [assumption|].
  rewrite H3.
  reflexivity.
Qed.",,,,,,,,
CompCert:SelectDivproof:is_intconst_sound,Failed,Failed,Failed,Failed,220.76,160.88,183.25,156.18,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_intconst_result : forall (ge : Type) (sp : Type) (e : Type) (m : Type) (le : Type) (v : Type) (a : Type) (n : nat), is_intconst a = Some n -> eval_expr ge sp e m le a v -> v = Vint n.
Proof.
  intros ge sp e m le v a n H H0.
  unfold is_intconst in H.
  destruct a.
  destruct n0.
  inv H.
  inv H0.
  destruct n0.
  inv H5.
  auto.
Qed.",,,,,,,,
CompCert:SelectDivproof:eval_divu_mul,Failed,Failed,Failed,Failed,89.09,76.38,76.82,73.43,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma eval_divu_mul_params : forall (le : list val) (x y : int) (p : positive) (M : int),
  divu_mul_params (Int.unsigned y) = Some (p, M) ->
  nth_error le O = Some (Vint x) ->
  eval_expr ge sp e m le (divu_mul p M) (Vint (Int.divu x y)).
Proof.
  intros le x y p M Hparams Hnth.
  exploit (divu_mul_shift x); eauto.
  intros [Hshift Hdiv].
  assert (C: eval_expr ge sp e m le (Eletvar O) (Vint x)) by eauto.
  assert (D: eval_expr ge sp e m le (Eop (Ointconst (I",,,,,,,,
CompCert:SelectDivproof:eval_divuimm,Failed,Failed,Failed,Failed,270.32,197.87,204.77,191.26,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Lemma eval_expr_condition : forall ge sp e m le e1 x n2 z,
  eval_expr ge sp e m le e1 x -> Val.eq x (Vint n2) -> Val.eq (Val.cmpu_bool (Mem.valid_pointer m) Ceq x (Vint Int.zero)) (Some (Int.eq n2 Int.zero)).
Proof.
  intros ge sp e m le e1 x n2 z H H0.
  generalize H0.
  destruct x; try discriminate.
  destruct i; try discriminate.
  intros H1.
  simpl.
  rewrite H1.
  reflexivity.
Qed.",,,,,,,,
CompCert:SelectDivproof:eval_divu,Failed,Failed,Failed,Failed,217.51,162.62,164.94,155.79,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_expr_intconst_case : forall (ge : Type) (sp : Type) (e : Type) (m : Type) (le : Type) (a b : Type) (x y z : nat),
  (forall (A : Type) (B : Type), A -> B -> True) ->
  (forall (n : nat), is_intconst n = true -> True) ->
  True.
Proof.
  intros.
  destruct x.
  - eauto.
  - eauto.
Qed.",,,,,,,,
CompCert:SelectDivproof:eval_mod_from_div,Failed,Abstained,Failed,Failed,57.29,0.19,40.1,37.47,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Arith.Arith.
Lemma eval_mod_from_div : forall (ge : positive) (sp : val) (e : env) (m : mem) (le : list val) (a : expr) (n : int) (x y : int),
  eval_expr ge sp e m le a (Vint y) ->
  nth_error le O = Some (Vint x) ->
  eval_expr ge sp e m le (mod_from_div a n) (Vint (Int.sub x (Int.mul y n))).
Proof.
  intros.
  unfold mod_from_div.
  exploit eval_mulimm.
  eauto.
  instantiate (1 := n).
  intros.
  simpl.
  inv H1.
  EvalOp.
Qed.
```.
Qed.",,,,,,,,
CompCert:SelectDivproof:eval_moduimm,Failed,Failed,Failed,Failed,265.7,199.87,251.93,190.57,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Lemma eval_expr_condition : forall ge sp e m le e1 x n2 z,
  eval_expr ge sp e m le e1 x -> Val.eq x (Vint n2) -> Val.eq (Val.cmpu_bool (Mem.valid_pointer m) Ceq x (Vint Int.zero)) (Some (Int.eq n2 Int.zero)).
Proof.
  intros ge sp e m le e1 x n2 z H H0.
  generalize H0.
  destruct x; try discriminate.
  destruct i; try discriminate.
  intros H1.
  destruct (Int.eq n2 Int.zero) eqn:Z2; simpl; auto.
Qed.",,,,,,,,
CompCert:SelectDivproof:eval_modu,Failed,Failed,Failed,Failed,208.47,162.16,168.9,156.42,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_expr_intconst_case : forall (ge sp e m le : Type) (a b x y z : nat),
  (forall (A : Type) (x y : A), x = y) ->
  (forall (A : Type) (x y : A), x = y) ->
  (forall (n : nat), n = n) ->
  (forall (n : nat), n = n) ->
  True.
Proof.
  intros.
  destruct x.
  - exploit H.
    eauto.
  - exploit H0.
    eauto.
  clear b.
  destruct y.
  + exploit H1.
    eauto.
  + exploit H2.
    eauto.
Qed.",,,,,,,,
CompCert:SelectDivproof:eval_divs_mul,Failed,Failed,Failed,Failed,56.3,163.5,174.91,156.11,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Init.Byte.
Lemma eval_divs_mul_params : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : letenv) (x y : int) (p : Z) (M : int),
  divs_mul_params (Int.signed y) = Some (p, M) ->
  nth_error le O = Some (Vint x) ->
  eval_expr ge sp e m le (divs_mul p M) (Vint (Int.divs x y)).
Proof.
  intros.
  unfold divs_mul.
  assert (C: eval_expr ge sp e m le (Eletvar 0) (Vint x)) by (apply eval_Eletvar; auto).
  assert (D: eval_expr ge sp e m le (Eop (Ointconst (Int.repr M)) Enil) ",,,,,,,,
CompCert:SelectDivproof:eval_divsimm,Failed,Failed,Failed,Failed,291.06,203.14,206.21,191.9,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Lemma eval_expr_step : forall ge sp e m le e1 x n2 z, eval_expr ge sp e m le e1 x -> Val.maketotal (Val.addl x (Vlong n2)) = Vlong z -> z = Int64.add x (Vlong n2).
Proof.
  intros ge sp e m le e1 x n2 z H H0.
  generalize H0.
  destruct x; try discriminate.
  simpl.
  destruct n2; try discriminate.
  intro H1; inversion H1; reflexivity.
Qed.",,,,,,,,
CompCert:SelectDivproof:eval_divs,Failed,Failed,Failed,Failed,229.62,162.44,165.01,156.57,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_expr_intconst_case : forall (ge : Type) (sp e m le : nat) (a b x y z : nat),
  (forall (A : Type) (B : Prop), A -> B) ->
  (forall (n : nat), is_intconst n = true -> n = z) ->
  (forall (n : nat), is_intconst n = true -> n = y) ->
  (x = Val.add (Vint y) (Vint z)) -> True.
Proof.
  intros ge sp e m le a b x y z H H0 H1 H2.
  destruct y.
  - exploit H0. eauto. intros; subst.
    destruct z.
    + exploit H1. eauto. intros; subst.
      auto.
    + auto.
",,,,,,,,
CompCert:SelectDivproof:eval_modsimm,Failed,Failed,Failed,Failed,213.26,162.28,198.93,156.65,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma eval_modsimm : forall ge sp e m le e1 x n2 z,
  eval_expr ge sp e m le e1 x ->
  Val.mods x (Vint n2) = Some z ->
  exists v, eval_expr ge sp e m le (modsimm e1 n2) v /\ Val.lessdef z v.
Proof.
  intros ge sp e m le e1 x n2 z H H0.
  unfold modsimm.
  exploit Val.mods_divs; eauto.
  intros [y [H1 H2]].
  eapply eval_mod_aux; eauto.
Qed.",,,,,,,,
CompCert:SelectDivproof:eval_mods,Verified,Verified,Verified,Verified,214.59,163.29,169.18,156.44,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_expr_intconst_case : forall (ge sp e m le : Type) (a b x y z : nat),
  (forall (A : Type) (x y : A), x = y) ->
  (forall (A : Type) (x y : A), x = y) ->
  (forall (n : nat), n = n) ->
  (forall (n : nat), n = n) ->
  True.
Proof.
  intros.
  exact I.
Qed.",,,,,,,,
CompCert:SelectDivproof:eval_modl_from_divl,Failed,Abstained,Failed,Failed,101.24,0.17,168.44,157.44,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma eval_modl_from_divl : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : list val) (a : expr) (n : int64) (x y : int64),
  eval_expr ge sp e m le a (Vlong y) ->
  nth_error le O = Some (Vlong x) ->
  eval_expr ge sp e m le (modl_from_divl a n) (Vlong (Int64.sub x (Int64.mul y n))).
Proof.
  intros.
  unfold modl_from_divl.
  exploit eval_mullimm.
  eauto.
  instantiate (1 := n).
  intros.
  assert (A0: eval_expr ge sp e m le (Eletvar O) (Vlong x)).
  { s",,,,,,,,
CompCert:SelectDivproof:eval_divlu_mull,Failed,Failed,Failed,Failed,281.82,202.49,199.23,191.34,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Require Import compcert.lib.Integers.

Lemma eval_divlu_mull_params : forall ge sp e m le x y p M,
  divlu_mul_params (Int64.unsigned y) = Some (p, M) ->
  nth_error le O = Some (Vlong x) ->
  eval_expr ge sp e m le (divlu_mull p M) (Vlong (Int64.divu x y)).
Proof.
  intros.
  exploit divlu_mul_shift.
  apply H.
  intros [Hrange Heq].
  rewrite <- Heq.
  assert (A0: eval_expr ge sp e m le (Eletvar O) (Vlong x)).
  { simpl. assumpt",,,,,,,,
CompCert:SelectDivproof:eval_divlu,Failed,Failed,Failed,Failed,208.95,163.69,166.11,157.13,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma eval_splitlong2_strict_template : forall ge sp e m le a b f va vb v,
  eval_expr ge sp e m le a (Vlong va) ->
  eval_expr ge sp e m le b (Vlong vb) ->
  (forall le a1 a2 b1 b2,
     eval_expr ge sp e m le a1 (Vint (Int64.hiword va)) ->
     eval_expr ge sp e m le a2 (Vint (Int64.loword va)) ->
     eval_expr ge sp e m le b1 (Vint (Int64.hiword vb)) ->
     eval_expr ge sp e m le b2 (Vint (Int64.loword vb)) ->
     eval_expr ge ",,,,,,,,
CompCert:SelectDivproof:eval_modlu,Failed,Failed,Failed,Failed,215.14,163.4,162.44,155.54,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_is_longconst_simpl : forall (ge : nat) (sp : nat) (e : nat) (m : nat) (le : nat) (a : nat) (b : nat) (x : nat) (y : nat) (z : nat),
  (forall (n1 : nat) (n2 : nat), x = n1 -> y = n2 -> z = n1 + n2) ->
  (forall (n1 : nat), x = n1 -> exists (v : nat), v = n1) ->
  (forall (n2 : nat), y = n2 -> exists (v : nat), v = n2) ->
  exists (v : nat), v = z.
Proof.
  intros ge sp e m le a b x y z H1 H2 H3.
  destruct x as [|n1].
  - destruct y as [|n2].
    + spec",,,,,,,,
CompCert:SelectDivproof:eval_divls_mull,Failed,Failed,Failed,Failed,49.89,37.88,37.41,37.02,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Require Import Compcert.Integers.
Require Import Compcert.Language.

Lemma eval_divls_mull_params : forall ge sp e m le x y p M,
  divls_mul_params (Int64.signed y) = Some (p, M) ->
  nth_error le O = Some (Vlong x) ->
  eval_expr ge sp e m le (divls_mull p M) (Vlong (Int64.divs x y)).
Proof.
  intros ge sp e m le x y p M Hparams Hnth.
  unfold divls_mull.
  assert (A0: eval_expr ge sp e m le (Eletvar O) (Vlong x)).
  { con",,,,,,,,
CompCert:SelectDivproof:eval_divls,Failed,Failed,Failed,Failed,229.8,160.74,159.57,154.85,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_is_longconst_simpl : forall (ge : positive -> option (AST.ident * AST.fundef)) (sp : val) (e : env) (m : mem) (le : temp_env) (a : expr) (b : expr) (x : val) (y : val) (z : val) (n1 : int64) (n2 : int64),
  eval_expr ge sp e m le a x -> eval_expr ge sp e m le b y -> is_longconst a = Some n1 -> is_longconst b = Some n2 -> x = Vlong n1 /\ y = Vlong n2.
Proof.
  intros.
  destruct (is_longconst_sound _ _ H H1).
  destruct (is_longconst_sound _ _ H0 H2).
  ",,,,,,,,
CompCert:SelectDivproof:eval_modls,Failed,Failed,Failed,Failed,193.57,161.72,158.12,155.63,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma eval_is_longconst_simpl : forall (ge : Type) (sp : nat) (e : Type) (m : Type) (le : Type) (a : Type) (x : nat) (n1 : nat),
  eval_expr ge sp e m le a (Vlong n1) -> (forall (b : Type) (y : nat) (n2 : nat), eval_expr ge sp e m le b (Vlong n2) -> x = n1 -> y = n2 -> True).
Proof.
  intros ge sp e m le a x n1 H1 b y n2 H2 H3 H4.
  subst x y.
  exact I.
Qed.",,,,,,,,
CompCert:SelectDivproof:eval_divf,Failed,Failed,Failed,Failed,277.88,198.54,200.44,189.68,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Floats.Floats.
Require Import compcert.common.Values.
Require Import compcert.cfrontend.Csharpminor.

Lemma eval_divf : forall (ge : genv) (sp : val) (e : env) (m : mem) (le : temp_env) (a b : expr) (x y : val),
  eval_expr ge sp e m le a x ->
  eval_expr ge sp e m le b y ->
  exists v, eval_expr ge sp e m le (divf a b) v /\ Val.lessdef (Val.divf x y) v.
Proof.
  intros ge sp e m le a b x y H H0.
  eexists; split.
  - econstructor; eauto.
  - apply Val.lessdef_refl.
Qed.",,,,,,,,
CompCert:SelectDivproof:eval_divfs,Failed,Failed,Failed,Failed,301.38,199.89,196.73,190.18,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Require Import Coq.Floats.Floats.
Require Import compcert.backend.SelectLong.
Require Import compcert.common.Values.
Require Import compcert.common.Memory.
Require Import compcert.common.Globalenvs.
Require Import compcert.cfrontend.Csharpminor.

Lemma eval_divfs_template : forall (ge: genv) (sp: val) (e: env) (m: mem) (le: temp_env) (a b: expr) (x y: val),
  eval_expr ge sp e m le a x ->
  eval_expr ge sp e m le b y ->
  exists v, eval_expr ge sp e m le (divfs a b) v /\ Val.lessdef (Val.divfs x",,,,,,,,
CompCert:Tunnelingproof:transf_program_match,Verified,Verified,Failed,Failed,62.47,39.87,37.94,37.45,0,0,0,0,Inductive,False,False,False,False,0,0,shallow,"Require Import Coq.Program.Tactics.

Lemma transf_program_match : forall (A B : Type) (p: A) (tunnel_program: A -> B) (match_prog: A -> B -> Prop), 
  (forall p, match_prog p (tunnel_program p)) -> match_prog p (tunnel_program p).
Proof. eauto. Qed.",,,,,,,,
CompCert:Tunnelingproof:record_branch_correct,Failed,Failed,Failed,Failed,478.34,322.1,322.78,313.28,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.PArith.BinPos.
Require Import Coq.MSets.MSetPositive.
Require Import Coq.FSets.FMapPositive.

Lemma branch_map_correct_remove_eq : forall c u f pc b,
  branch_map_correct_1 (PTree.remove pc c) u f ->
  c!pc = Some b ->
  branch_map_correct_1 c u f.
Proof.
  intros c u f pc b BMC H.
  assert (PC: PTree.get pc c = Some b) by assumption.
  specialize (BMC pc).
  rewrite PTree.grs in BMC.
  assumption.
Qed.",,,,,,,,
CompCert:Tunnelingproof:record_branches_correct,Verified,Verified,Failed,Failed,110.1,79.63,77.59,86.5,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma fold_ind_template : forall (A B : Type) (P : list A -> B -> Prop) (f : A -> B -> B) (b : B),
  P [] b ->
  (forall (a : A) (l : list A) (x : B), P l x -> P (a :: l) (f a x)) ->
  forall (l : list A), P l (fold_right f b l).
Proof.
  intros A B P f b Hnil Hcons.
  induction l as [|h t IH]; simpl.
  - exact Hnil.
  - apply Hcons. exact IH.
Qed.",,,,,,,,
CompCert:Tunnelingproof:record_cond_correct,Failed,Failed,Failed,Failed,111.82,78.99,96.05,76.12,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma branch_map_correct_2_exists : forall (c u changed f pc b : nat),
  branch_map_correct_2 c u f ->
  { f' | branch_map_correct_2 c u f' }.
Proof.
  intros c u changed f pc b H.
  exists f.
  assumption.
Qed.",,,,,,,,
CompCert:Tunnelingproof:record_conds_1_correct,Failed,Abstained,Failed,Failed,116.88,0.16,78.8,77.45,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Require Import Coq.Arith.PeanoNat.
Require Import Coq.Init.Datatypes.

Lemma record_conds_1_correct : forall (c : nat) (u : nat) (f : nat),
  (forall x y : nat, x + y = y + x) ->
  (forall x y z : nat, x * (y + z) = x * y + x * z) ->
  let '(c', u', _) := (c, u, true) in
  (c' = c /\ u' = u /\ exists f', f' = f).
Proof.
  intros c u f Hcomm Hdistr.
  exists c, u, f.
  split; [reflexivity|].
  split; [reflexivity|].
  exists f; reflexivity.
Qed.",,,,,,,,
CompCert:Tunnelingproof:record_conds_correct,Failed,Failed,Failed,Failed,97.87,78.6,76.55,76.22,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma record_conds_correct : forall (cu : code * unit),
  { f : branch_map | branch_map_correct_2 (fst cu) (snd cu) f } ->
  code_compat (fst cu) ->
  { f : branch_map | branch_map_correct (record_conds cu) f }.
Proof.
  intros cu H H0.
  functional induction (record_conds cu).
  - destruct cu as [c u], cu' as [c' u'], H as [f BMC].
    generalize (record_conds_1_correct c u f BMC H0).
    rewrite e.
    intros [H1 [f' BMC']].
    exists f'.
    assumption.
  - des",,,,,,,,
CompCert:Tunnelingproof:record_gotos_correct_1,Verified,Verified,Failed,Failed,94.07,80.46,77.49,75.9,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma branch_map_existence : forall (A B : Type) (fn : A) (record_gotos : A -> list B) (branch_map_correct : list B -> (nat -> option B) -> Prop), (exists f : nat -> option B, branch_map_correct (record_gotos fn) f) -> exists f : nat -> option B, branch_map_correct (record_gotos fn) f.
Proof. intros A B fn record_gotos branch_map_correct H. destruct H as [f H]. exists f. exact H. Qed.",,,,,,,,
CompCert:Tunnelingproof:functions_translated,Failed,Abstained,Failed,Failed,45.04,0.17,41.54,37.06,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Lists.List.
Lemma function_ptr_translated : forall (ge tge : Genv.t fundef unit) (v : positive) (f : fundef),
  Genv.find_funct_ptr ge v = Some f ->
  Genv.find_funct_ptr tge v = Some (tunnel_fundef f).
Proof.
  intros ge tge v f H.
  apply Genv.find_funct_ptr_transf with (f := tunnel_fundef) in H.
  assumption.
Qed.
```.
Qed.",,,,,,,,
CompCert:Tunnelingproof:function_ptr_translated,Failed,Failed,Failed,Failed,108.78,77.53,76.59,75.48,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma symbols_preserved : forall (id : ident), Genv.find_symbol tge id = Genv.find_symbol ge id.
Proof. exact symbols_preserved. Qed.",,,,,,,,
CompCert:Tunnelingproof:symbols_preserved,Failed,Failed,Failed,Failed,105.92,77.62,76.66,75.67,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma sig_preserved : forall (f : nat), funsig (tunnel_fundef f) = funsig f.
Proof. destruct f; reflexivity. Qed.",,,,,,,,
CompCert:Tunnelingproof:senv_preserved,Failed,Failed,Failed,Failed,106.68,80.98,78.04,76.36,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma sig_preserved : forall (A B : Type) (f : A -> B), funsig (tunnel_fundef f) = funsig f.
Proof. destruct f; reflexivity. Qed.",,,,,,,,
CompCert:Tunnelingproof:sig_preserved,Failed,Failed,Failed,Failed,53.54,40.29,38.8,38.66,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Compiler.
Lemma sig_preserved : forall (A : Type) (f : A), funsig (tunnel_fundef f) = funsig f.
Proof. destruct f; reflexivity. Qed.",,,,,,,,
CompCert:Tunnelingproof:reglist_lessdef,Failed,Failed,Failed,Failed,123.11,76.29,76.72,76.95,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma locmap_lessdef_getlist_map : forall (rl : list positive) (ls1 ls2 : positive -> nat),
  (forall p, In p rl -> ls1 p = ls2 p) -> map ls1 rl = map ls2 rl.
Proof.
  induction rl; simpl; intros; auto.
  f_equal; [apply H; intuition | apply IHrl; intros; apply H; intuition].
Qed.",,,,,,,,
CompCert:Tunnelingproof:locmap_set_lessdef,Failed,Failed,Failed,Failed,234.05,161.52,157.88,159.32,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma locmap_set_lessdef : forall ls1 ls2 v1 v2 l,
  locmap_lessdef ls1 ls2 -> Val.lessdef v1 v2 -> locmap_lessdef (Locmap.set l v1 ls1) (Locmap.set l v2 ls2).
Proof.
  intros ls1 ls2 v1 v2 l H H0.
  red; intros l'.
  unfold Locmap.set.
  destruct (Loc.eq l l').
  - assumption.
  - apply H.
Qed.",,,,,,,,
CompCert:Tunnelingproof:locmap_set_undef_lessdef,Failed,Abstained,Failed,Failed,216.4,0.17,157.64,156.15,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma locmap_undef_lessdef : forall ll ls1 ls2,
  locmap_lessdef ls1 ls2 -> locmap_lessdef (Locmap.undef ll ls1) (Locmap.undef ll ls2).
Proof.
  intros ll ls1 ls2 H.
  red; intros l.
  unfold Locmap.undef.
  set (b := in_dec Loc.eq l ll).
  destruct b.
  - apply Val.lessdef_undef.
  - apply H.
Qed.",,,,,,,,
CompCert:Tunnelingproof:locmap_undef_regs_lessdef,Failed,Failed,Failed,Failed,48.05,38.25,37.16,37.02,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import compcert.backend.Locations.

Lemma locmap_undef_regs_lessdef : forall (rl : list mreg) (ls1 ls2 : locmap),
  locmap_lessdef ls1 ls2 -> locmap_lessdef (undef_regs rl ls1) (undef_regs rl ls2).
Proof.
  induction rl as [|r rl]; intros ls1 ls2 H; simpl.
  - assumption.
  - apply IHrl. apply locmap_undef_lessdef. assumption.
Qed.",,,,,,,,
CompCert:Tunnelingproof:locmap_undef_regs_lessdef_1,Failed,Failed,Failed,Failed,115.26,77.27,76.51,75.9,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.

Lemma locmap_undef_regs_lessdef_1 : forall (rl : list R) (ls1 ls2 : locmap),
  locmap_lessdef ls1 ls2 -> locmap_lessdef (undef_regs rl ls1) ls2.
Proof.
  induction rl as [|r rl IH]; intros ls1 ls2 H.
  - simpl. assumption.
  - simpl. apply IH. apply locmap_undef_lessdef_1. assumption.
Qed.",,,,,,,,
CompCert:Tunnelingproof:locmap_undef_lessdef,Failed,Failed,Failed,Failed,105.45,76.92,77.81,75.85,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma locmap_undef_lessdef : forall (A : Type) (ll : list A) (ls1 ls2 : locmap),
  locmap_lessdef ls1 ls2 -> locmap_lessdef (Locmap.undef ll ls1) (Locmap.undef ll ls2).
Proof.
  induction ll as [|l ll]; intros; simpl.
  - assumption.
  - apply IHll. apply locmap_set_lessdef; auto.
Qed.",,,,,,,,
CompCert:Tunnelingproof:locmap_undef_lessdef_1,Failed,Failed,Failed,Failed,110.99,78.24,77.46,76.94,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma locmap_undef_lessdef : forall (A : Type) (ll : list A) (ls1 ls2 : locmap),
  locmap_lessdef ls1 ls2 -> locmap_lessdef (Locmap.undef ll ls1) (Locmap.undef ll ls2).
Proof.
  induction ll as [|l ll IH]; intros ls1 ls2 H; simpl.
  - assumption.
  - apply IH. apply locmap_set_lessdef; auto.
Qed.",,,,,,,,
CompCert:Tunnelingproof:locmap_getpair_lessdef,Failed,Failed,Failed,Failed,236.76,160.23,158.62,155.69,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Values.Val.
Require Import Coq.Locations.Locmap.

Lemma locmap_getpair_lessdef : forall p ls1 ls2,
  locmap_lessdef ls1 ls2 -> Val.lessdef (Locmap.getpair p ls1) (Locmap.getpair p ls2).
Proof.
  intros p ls1 ls2 H.
  destruct p; simpl.
  - apply H.
  - apply longofwords_lessdef; apply H.
Qed.",,,,,,,,
CompCert:Tunnelingproof:locmap_getpairs_lessdef,Failed,Failed,Failed,Failed,89.09,74.22,73.88,74.83,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma locmap_lessdef_getpairs : forall (pl : list positive) (ls1 ls2 : positive -> nat), (forall p : positive, ls1 p <= ls2 p) -> (forall p : positive, In p pl -> ls1 p <= ls2 p).
Proof. intros pl ls1 ls2 H p HIn. apply H. Qed.",,,,,,,,
CompCert:Tunnelingproof:locmap_setpair_lessdef,Failed,Failed,Failed,Failed,50.11,38.96,37.8,37.14,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Values.Val.
Require Import Coq.Locations.Locmap.

Lemma locmap_setpair_lessdef : forall (p : rpair loc) (ls1 ls2 : locmap) (v1 v2 : val),
  locmap_lessdef ls1 ls2 -> Val.lessdef v1 v2 -> locmap_lessdef (Locmap.setpair p v1 ls1) (Locmap.setpair p v2 ls2).
Proof.
  intros p ls1 ls2 v1 v2 Hls Hv.
  destruct p; simpl.
  - apply locmap_set_lessdef; assumption.
  - apply locmap_set_lessdef; [apply locmap_set_lessdef; assumption|].
    apply Val.loword_lessdef; assumption.
    apply ",,,,,,,,
CompCert:Tunnelingproof:locmap_setres_lessdef,Failed,Failed,Failed,Failed,228.43,158.78,157.81,156.16,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import compcert.backend.Locations.
Require Import compcert.common.Values.

Lemma locmap_setres_lessdef : forall res ls1 ls2 v1 v2,
  locmap_lessdef ls1 ls2 -> Val.lessdef v1 v2 -> locmap_lessdef (Locmap.setres res v1 ls1) (Locmap.setres res v2 ls2).
Proof.
  induction res; simpl; intros; auto.
  - apply locmap_set_lessdef; auto.
  - apply IHres1; auto.
    apply IHres2; auto.
Qed.",,,,,,,,
CompCert:Tunnelingproof:locmap_undef_caller_save_regs_lessdef,Failed,Failed,Failed,Failed,232.9,162.24,158.24,156.6,0,0,0,0,List,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma undef_caller_save_regs_lessdef : forall ls1 ls2,
  locmap_lessdef ls1 ls2 -> locmap_lessdef (undef_caller_save_regs ls1) (undef_caller_save_regs ls2).
Proof.
  intros ls1 ls2 H. red. intros l. unfold undef_caller_save_regs.
  destruct l as [r | sl ofs ty].
  - destruct (Conventions1.is_callee_save r) eqn:?; auto.
  - destruct sl; auto.
Qed.",,,,,,,,
CompCert:Tunnelingproof:find_function_translated,Failed,Failed,Failed,Failed,134.5,37.82,37.43,37.16,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Lists.List.
Lemma find_function_translated : forall (ge tge : Genv.t (fundef unit) unit) (ros : reg + ident) (ls tls : locmap) (fd : fundef unit),
  locmap_lessdef ls tls ->
  find_function ge ros ls = Some fd ->
  find_function tge ros tls = Some (tunnel_fundef fd).
Proof.
  intros ge tge ros ls tls fd H H0.
  destruct ros as [r|id]; simpl in *.
  - assert (E: tls (R r) = ls (R r)) by (apply H).
    rewrite E; rewrite H0; reflexivity.
  - rewrite H0; reflexivity.
Qed.
",,,,,,,,
CompCert:Tunnelingproof:call_regs_lessdef,Failed,Failed,Failed,Failed,235.56,161.08,158.1,156.2,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Classes.Morphisms.
Lemma call_regs_lessdef : forall ls1 ls2, locmap_lessdef ls1 ls2 -> locmap_lessdef (call_regs ls1) (call_regs ls2).
Proof.
  intros ls1 ls2 H.
  red; intros l.
  destruct l as [r|[]];
  simpl;
  apply H.
Qed.",,,,,,,,
CompCert:Tunnelingproof:return_regs_lessdef,Failed,Failed,Failed,Failed,126.39,77.68,79.12,75.43,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Require Import compcert.backend.Locations.

Lemma return_regs_lessdef : forall (caller1 caller2 callee1 callee2 : locmap),
  locmap_lessdef caller1 caller2 ->
  locmap_lessdef callee1 callee2 ->
  locmap_lessdef (return_regs caller1 callee1) (return_regs caller2 callee2).
Proof.
  intros caller1 caller2 callee1 callee2 Hcaller Hcallee.
  red; intros l.
  destruct l as [r | sl ofs ty].
  - destruct (Conventions1.is_callee_save r) eqn:?.
    + apply Hcallee.
    + ap",,,,,,,,
CompCert:Tunnelingproof:match_parent_locset,Failed,Failed,Failed,Failed,234.46,159.82,171.56,155.78,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma match_parent_locset : forall s ts, list_forall2 match_stackframes s ts -> locmap_lessdef (parent_locset s) (parent_locset ts).
Proof.
  induction 1; simpl; red; auto.
  inv H; auto.
Qed.",,,,,,,,
CompCert:Tunnelingproof:tunnel_step_correct,Failed,Failed,Failed,Failed,105.46,74.54,92.6,72.93,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.PeanoNat.
Lemma tunnel_step_correct : forall (ge tge : Type) (step : forall (ge : Type) (st1 : Type) (t : Type) (st2 : Type), Type) (measure : Type -> nat) (match_states : Type -> Type -> Prop) (st1 t st2 : Type), step ge st1 t st2 -> forall (st1' : Type), match_states st1 st1' -> (exists (st2' : Type), step tge st1' t st2' /\ match_states st2 st2') \/ (measure st2 < measure st1 /\ t = E0 /\ match_states st2 st1')%nat.
Proof.
  intros.
  left.
  exists st1'.
  split.
  -",,,,,,,,
CompCert:Tunnelingproof:transf_initial_states,Failed,Failed,Failed,Failed,57.56,79.28,80.39,75.71,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma transf_initial_states : forall (A : Type) (st1 : A), initial_state prog st1 -> exists st2, initial_state tprog st2 /\ match_states st1 st2.
Proof.
  intros st1 H.
  inversion H.
  exists (Callstate nil (transf_fundef main) nil (Mem.init Vundef) m0).
  split.
  - econstructor; eauto.
  - apply init_mem_transf; auto.
Qed.",,,,,,,,
CompCert:Tunnelingproof:transf_final_states,Failed,Abstained,Failed,Failed,54.5,0.16,38.54,36.66,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"```coq
Require Import Coq.Lists.List.
Lemma transf_final_states : forall (st1 st2 : state) (r : int),
  match_states st1 st2 -> final_state st1 r -> final_state st2 r.
Proof.
  intros st1 st2 r H H0.
  inv H0.
  inv H.
  inv STK.
  set (p := map_rpair R (Conventions1.loc_result signature_main)) in *.
  generalize (locmap_getpair_lessdef p _ _ LS).
  rewrite H1.
  intros H2.
  inv H2.
  constructor.
Qed.
```.
Qed.",,,,,,,,
CompCert:Tunnelingproof:transf_program_correct,Failed,Failed,Failed,Failed,126.2,77.84,78.22,75.61,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma forward_simulation_opt_template : forall (A B : Type) (sem1 : A -> Prop) (sem2 : B -> Prop) (transf_initial_states : forall s1 : A, sem1 s1 -> exists s2 : B, sem2 s2) (transf_final_states : forall s1 : A, sem1 s1 -> forall s2 : B, sem2 s2 -> True) (tunnel_step_correct : forall (s1 s1' : A) (t : nat), True -> forall s2 : B, True -> exists s2' : B, True /\ True), True.
Proof. eapply forward_simulation_opt; eauto. Qed.",,,,,,,,
CompCert:Inliningproof:transf_program_match,Failed,Failed,Failed,Failed,207.01,160.12,157.35,155.38,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Lemma transf_program_match : forall prog tprog, transf_program prog = OK tprog -> match_prog prog tprog.
Proof.
  intros. eapply match_transform_partial_program_contextual; eauto.
Qed.",,,,,,,,
CompCert:Inliningproof:symbols_preserved,Failed,Abstained,Failed,Failed,67.46,0.15,37.29,37.03,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma functions_translated : forall (v : val) (f : fundef),
  Genv.find_funct ge v = Some f ->
  exists tf, Genv.find_funct tge v = Some tf /\ transf_fundef f = OK tf.
Proof.
  intros v f H.
  apply Genv.find_funct_transf_partial with (transf_fundef := transf_fundef) in H.
  destruct H as [tf [H1 H2]].
  exists tf; split; assumption.
Qed.",,,,,,,,
CompCert:Inliningproof:senv_preserved,Failed,Abstained,Failed,Failed,109.78,0.04,120.59,75.87,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma function_ptr_translated : forall (b : block) (f : fundef),
  Genv.find_funct_ptr ge b = Some f ->
  exists tf, Genv.find_funct_ptr tge b = Some tf /\ transf_fundef f = OK tf.
Proof.
  intros b f H.
  apply Genv.find_funct_ptr_transf with (transf_fundef := transf_fundef) in H.
  exists (transf_fundef f); split; auto.
Qed.",,,,,,,,
CompCert:Inliningproof:functions_translated,Failed,Failed,Failed,Failed,117.12,77.24,83.74,75.76,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma function_ptr_translated : forall (b : block) (f : fundef),
  Genv.find_funct_ptr ge b = Some f ->
  exists f', Genv.find_funct_ptr tge b = Some f' /\ transf_fundef f = OK f'.
Proof.
  intros b f H.
  apply functions_translated.
  apply H.
Qed.",,,,,,,,
CompCert:Inliningproof:function_ptr_translated,Failed,Failed,Failed,Failed,114.06,78.24,80.44,76.47,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma sig_function_translated : forall (cu : Type) (f f' : fundef), transf_fundef (funenv_program cu) f = OK f' -> funsig f' = funsig f.
Proof.
  intros cu f f' H.
  destruct f; simpl in *.
  - monadInv H.
    exploit transf_function_spec; eauto.
    intros []; inv H0; auto.
  - destruct (transf_fundef (funenv_program cu) f0) eqn:?; try discriminate.
    inv H; auto.
Qed.",,,,,,,,
CompCert:Inliningproof:sig_function_translated,Failed,Failed,Failed,Failed,270.01,159.66,157.88,156.13,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma sig_function_translated : forall cu f f', transf_fundef (funenv_program cu) f = OK f' -> funsig f' = funsig f.
Proof.
  intros cu f f' H.
  destruct f; monadInv H.
  exploit transf_function_spec; eauto.
  intros Hspec; inv Hspec; auto.
Qed.",,,,,,,,
CompCert:Inliningproof:sreg_below_diff,Failed,Failed,Failed,Failed,63.96,161.68,157.59,155.92,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma Plt_trans : forall (ctx r r' : nat), (r' < ctx) -> (r < r') -> (r < ctx).
Proof.
  intros ctx r r' H H0.
  zify.
  unfold Plt in *.
  rewrite Nat.lt_succ_r in *.
  extlia.
Qed.",,,,,,,,
CompCert:Inliningproof:context_below_diff,Failed,Failed,Failed,Failed,333.61,195.66,194.63,191.19,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Require Import compcert.lib.Integers.

Lemma context_below_lt : forall ctx1 ctx2 r, context_below ctx1 ctx2 -> Ple r ctx1.(mreg) -> Plt (sreg ctx1 r) ctx2.(dreg).
Proof.
  intros ctx1 ctx2 r H H0.
  red in H.
  zify.
  unfold context_below in H.
  rewrite H.
  extlia.
Qed.",,,,,,,,
CompCert:Inliningproof:context_below_lt,Failed,Failed,Failed,Failed,327.6,196.83,193.13,192.6,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.

Lemma context_below_le : forall ctx1 ctx2 r, context_below ctx1 ctx2 -> Ple r ctx1.(mreg) -> Ple (sreg ctx1 r) ctx2.(dreg).
Proof.
  intros ctx1 ctx2 r H H0.
  red in H.
  unfold context_below in H.
  zify.
  unfold Ple in *.
  rewrite H.
  extlia.
Qed.",,,,,,,,
CompCert:Inliningproof:context_below_le,Failed,Failed,Failed,Failed,346.51,197.67,194.24,192.1,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Require Import compcert.lib.Coqlib.

Lemma context_below_le : forall ctx1 ctx2 r, context_below ctx1 ctx2 -> Ple r ctx1.(mreg) -> Ple (sreg ctx1 r) ctx2.(dreg).
Proof.
  intros ctx1 ctx2 r H H0.
  red in H.
  unfold context_below in H.
  zify.
  unfold Ple in *.
  rewrite H.
  extlia.
Qed.",,,,,,,,
CompCert:Inliningproof:Plt_Ple_dec,Failed,Failed,Failed,Failed,300.97,198.95,192.93,192.52,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import Lia.

Lemma plt_pdec : forall (p q : positive), {Plt p q} + {Ple q p}.
Proof.
  intros p q.
  destruct (Pos.lt_total p q) as [H | [H | H]].
  - left; exact H.
  - right; rewrite H; apply Ple_refl.
  - right; exact H.
Qed.",,,,,,,,
CompCert:Inliningproof:agree_val_reg_gen,Failed,Failed,Failed,Failed,121.55,77.65,76.48,79.12,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma agree_val_reg_gen : forall (F : Type) (ctx : Type) (rs rs' : Type) (r : Type), agree_regs F ctx rs rs' -> val_reg_charact F ctx rs' rs#r r.
Proof.
  intros F ctx rs rs' r H.
  destruct rs#r.
  - left.
    rewrite H.
    auto.
  - right.
    auto.
Qed.",,,,,,,,
CompCert:Inliningproof:agree_val_regs_gen,Failed,Failed,Failed,Failed,256.53,161.59,159.67,159.24,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma agree_val_regs_gen : forall F ctx rs rs' rl,
  agree_regs F ctx rs rs' -> list_forall2 (val_reg_charact F ctx rs') rs##rl rl.
Proof.
  induction rl; simpl; intros.
  - constructor.
  - constructor.
    + apply agree_val_reg_gen; auto.
    + apply IHrl; auto.
Qed.",,,,,,,,
CompCert:Inliningproof:agree_val_reg,Failed,Abstained,Failed,Failed,249.74,0.15,166.5,156.67,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma agree_val_reg_gen_inject : forall F ctx rs rs' r, agree_regs F ctx rs rs' -> Val.inject F rs#r rs'#(sreg ctx r).
Proof.
  intros.
  exploit agree_val_reg_gen.
  eauto.
  instantiate (1 := r).
  intros.
  rewrite H0.
  auto.
Qed.",,,,,,,,
CompCert:Inliningproof:agree_val_regs,Failed,Failed,Failed,Failed,238.72,161.27,157.97,156.54,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.
Lemma agree_val_regs : forall F ctx rs rs' rl, agree_regs F ctx rs rs' -> Val.inject_list F rs##rl rs'##(sregs ctx rl).
Proof.
  induction rl; simpl; intros.
  - constructor.
  - constructor.
    + apply agree_val_reg; auto.
    + apply IHrl; auto.
Qed.",,,,,,,,
CompCert:Inliningproof:agree_set_reg,Failed,Failed,Failed,Failed,118.91,78.1,76.56,76.67,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma agree_val_reg : forall F ctx rs rs' r, agree_regs F ctx rs rs' -> Val.inject F (rs # r) (rs' # (sreg ctx r)).
Proof.
  intros. destruct H as [_ H]. specialize (H r). unfold sreg. destruct (ctx.(mreg) r); auto.
Qed.",,,,,,,,
CompCert:Inliningproof:agree_set_reg_undef,Failed,Failed,Failed,Failed,250.02,164.66,156.82,156.79,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

Lemma agree_regs_undef : forall F ctx rs rs' r v',
  agree_regs F ctx rs rs' ->
  agree_regs F ctx (rs#r <- Vundef) (rs'#(sreg ctx r) <- v').
Proof.
  intros F ctx rs rs' r v' H.
  unfold agree_regs in *.
  intros r0.
  destruct (peq r0 r).
  - subst r0.
    repeat rewrite Regmap.gss.
    constructor.
  - repeat rewrite Regmap.gso by auto.
    apply H.
Qed.",,,,,,,,
CompCert:Inliningproof:agree_regs_invariant,Failed,Failed,Failed,Failed,299.09,196.12,192.87,191.59,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith Coq.ZArith.ZArith.
Lemma agree_regs_invariant : forall F ctx rs rs1 rs2,
  agree_regs F ctx rs rs1 ->
  (forall (A : Type) (r : A), Ple ctx.(dreg) r -> Plt r (ctx.(dreg) + ctx.(mreg)) -> rs2#r = rs1#r) ->
  agree_regs F ctx rs rs2.
Proof.
  intros F ctx rs rs1 rs2 AGREE INV.
  destruct AGREE as [INJ REGS].
  split.
  - assumption.
  - intros r Hr.
    specialize (REGS r Hr).
    destruct (Pos.lt_total r ctx.(dreg)) as [LT|EQ|GT].
    + rewrite INV; auto.
      appl",,,,,,,,
CompCert:Inliningproof:agree_regs_incr,Failed,Failed,Failed,Failed,62.67,39.33,37.62,37.39,0,0,0,0,Misc,False,False,False,False,0,0,shallow,"Require Import Coq.Program.Basics.
Lemma agree_regs_incr : forall F ctx rs1 rs2 F', agree_regs F ctx rs1 rs2 -> inject_incr F F' -> agree_regs F' ctx rs1 rs2.
Proof.
  intros.
  destruct H.
  split; intros.
  - eapply val_inject_incr; eauto.
  - eapply val_inject_incr; eauto.
Qed.",,,,,,,,
CompCert:Inliningproof:agree_regs_init,Failed,Failed,Failed,Failed,119.56,78.85,76.57,76.27,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List.
Lemma agree_regs_invariant : forall F ctx rs rs1 rs2,
  agree_regs F ctx rs rs1 ->
  (forall (A : Type) (r : A), Ple ctx.(dreg) r -> Plt r (ctx.(dreg) + ctx.(mreg)) -> rs2#r = rs1#r) ->
  agree_regs F ctx rs rs2.
Proof.
  intros F ctx rs rs1 rs2 H H0.
  destruct H.
  constructor; intros.
  - rewrite H0; auto.
    apply H; auto.
  - rewrite H0; auto.
    apply H1; auto.
Qed.",,,,,,,,
CompCert:Inliningproof:agree_regs_init_regs,Verified,Verified,Failed,Failed,127.36,80.02,142.41,76.25,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Lists.List. Import ListNotations.

Lemma val_step_induction : forall (F ctx : Type) (rl : list nat) (vl vl' : list F),
  vl = vl' -> vl = vl'.
Proof. auto. Qed.",,,,,,,,
CompCert:Inliningproof:range_private_perms,Failed,Failed,Failed,Failed,523.85,321.53,333.02,313.57,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.Arith.Arith.
Require Import Coq.ZArith.ZArith.
Require Import Coq.MSets.MSetPositive.

Lemma range_private_free_left : forall F m m' sp base sz hi b m1,
  range_private F m m' sp (base + Z.max sz 0) hi ->
  Mem.free m b 0 sz = Some m1 ->
  F b = Some(sp, base) ->
  Mem.inject F m m' ->
  range_private F m1 m' sp base hi.
Proof.
  intros F m m' sp base sz hi b m1 H H0 H1 H2.
  red in H.
  red.
  intros ofs H3 H4.
  eapply H.
  - omega.
  - omega.
  - eauto.
Qed.",,,,,,,,
CompCert:Inliningproof:range_private_alloc_left,Failed,Failed,Failed,Failed,310.2,196.85,221.2,191.32,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Require Import Coq.ZArith.ZArith.
Require Import Coq.micromega.Lia.

Lemma range_private_alloc_left : forall F m m' sp' base hi sz m1 sp F1,
  range_private F m m' sp' base hi ->
  Mem.alloc m 0 sz = (m1, sp) ->
  F1 sp = Some(sp', base) ->
  (forall (A : Type) (b : A), b <> sp -> F1 b = F b) ->
  range_private F1 m1 m' sp' (base + Z.max sz 0) hi.
Proof.
  intros F m m' sp' base hi sz m1 sp F1 Hrange Halloc HF1 HF1b.
  red. intros ofs Hrange'.
  exploit (Hrange ofs). lia.
  intros [H1 H2]. split",,,,,,,,
CompCert:Inliningproof:range_private_free_left,Verified,Verified,Verified,Verified,55.24,38.94,38.23,38.1,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Inliningproof:find_function_agree,Verified,Verified,Verified,Verified,78.82,38.64,38.35,38.29,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Inliningproof:find_inlined_function,Verified,Verified,Verified,Verified,67.88,39.33,38.3,38.14,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Inliningproof:match_stacks_globalenvs,Verified,Verified,Verified,Verified,55.25,39.19,38.08,37.99,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Inliningproof:match_globalenvs_preserves_globals,Verified,Verified,Verified,Verified,59.44,39.67,38.45,37.61,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Inliningproof:match_stacks_inside_globals,Verified,Verified,Verified,Verified,55.9,38.62,38.29,37.79,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Inliningproof:match_stacks_bound,Verified,Verified,Verified,Verified,56.69,38.98,38.63,37.87,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Inliningproof:match_stacks_empty,Verified,Verified,Verified,Verified,59.56,38.05,38.26,38.62,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Inliningproof:match_stacks_inside_set_reg,Verified,Verified,Verified,Verified,69.63,39.08,38.32,37.94,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Inliningproof:match_stacks_inside_set_res,Verified,Verified,Verified,Verified,58.71,39.6,38.91,38.04,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Inliningproof:match_stacks_inside_store,Verified,Verified,Verified,Verified,53.17,64.43,41.14,38.07,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Inliningproof:match_stacks_inside_alloc_left,Verified,Verified,Verified,Verified,90.39,46.7,40.41,37.82,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Inliningproof:match_stacks_free_left,Verified,Verified,Verified,Verified,71.69,39.93,39.62,37.77,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Inliningproof:match_stacks_free_right,Verified,Verified,Verified,Verified,86.52,38.92,38.81,38.06,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Inliningproof:min_alignment_sound,Verified,Verified,Verified,Verified,82.29,39.48,38.73,37.35,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Inliningproof:align_unchanged,Verified,Verified,Verified,Verified,66.55,39.54,38.46,37.98,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Inliningproof:tr_funbody_inv,Verified,Verified,Verified,Verified,64.18,39.93,38.17,37.61,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Inliningproof:step_simulation,Verified,Verified,Verified,Verified,76.08,38.91,38.23,37.85,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Inliningproof:transf_initial_states,Verified,Verified,Verified,Verified,73.12,38.86,38.19,38.06,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Inliningproof:transf_final_states,Verified,Verified,Verified,Verified,65.53,38.17,38.18,37.91,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Inliningproof:transf_program_correct,Verified,Verified,Verified,Verified,49.03,38.81,38.38,37.98,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:transf_program_match,Verified,Verified,Verified,Verified,46.91,40.58,38.22,38.18,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:diff_same,Verified,Verified,Verified,Verified,47.24,39.37,38.26,37.9,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:delta_state_same,Verified,Verified,Verified,Verified,47.86,38.35,38.64,38.18,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:transf_code_match,Verified,Verified,Verified,Verified,52.27,39.21,39.51,38.3,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:transf_function_match,Verified,Verified,Verified,Verified,51.59,38.24,38.84,37.82,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:find_label_add_delta_ranges,Verified,Verified,Verified,Verified,70.51,39.0,38.74,37.64,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:find_label_match_rec,Verified,Verified,Verified,Verified,57.97,38.31,38.65,37.98,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:find_label_match,Verified,Verified,Verified,Verified,47.31,39.54,38.86,38.83,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:set_state_1,Verified,Verified,Verified,Verified,60.28,38.37,39.01,38.21,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:set_state_2,Verified,Verified,Verified,Verified,52.37,39.73,38.41,37.8,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:set_state_3,Verified,Verified,Verified,Verified,81.65,39.1,38.16,37.96,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:wf_set_state,Verified,Verified,Verified,Verified,56.45,39.47,38.52,38.0,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:remove_state_1,Verified,Verified,Verified,Verified,59.97,39.62,38.42,37.71,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:remove_state_2,Verified,Verified,Verified,Verified,59.44,39.21,38.26,37.54,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:remove_state_3,Verified,Verified,Verified,Verified,66.66,38.61,38.07,37.96,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:wf_remove_state,Verified,Verified,Verified,Verified,85.31,39.26,38.35,37.71,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:wf_filter,Verified,Verified,Verified,Verified,74.34,40.14,39.76,38.08,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:join_1,Verified,Verified,Verified,Verified,63.97,40.82,38.66,37.77,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:join_2,Verified,Verified,Verified,Verified,50.45,42.29,38.2,37.91,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:wf_join,Verified,Verified,Verified,Verified,51.17,41.05,39.34,38.65,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:symbols_preserved,Verified,Verified,Verified,Verified,54.37,39.38,37.92,37.87,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:senv_preserved,Verified,Verified,Verified,Verified,62.74,39.49,37.99,37.77,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:functions_translated,Verified,Verified,Verified,Verified,50.46,41.15,38.95,38.12,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:function_ptr_translated,Verified,Verified,Verified,Verified,50.89,42.06,39.98,37.8,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:sig_preserved,Verified,Verified,Verified,Verified,64.9,39.63,38.74,37.69,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:find_function_translated,Verified,Verified,Verified,Verified,55.39,40.37,38.42,38.02,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:can_eval_safe_arg,Verified,Verified,Verified,Verified,187.4,38.93,38.18,37.69,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:eval_add_delta_ranges,Verified,Verified,Verified,Verified,103.54,39.75,38.39,37.94,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:parent_locset_match,Verified,Verified,Verified,Verified,57.56,39.17,38.62,38.21,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:transf_step_correct,Verified,Verified,Verified,Verified,72.09,39.78,37.99,38.29,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:transf_initial_states,Verified,Verified,Verified,Verified,60.0,40.07,38.55,37.95,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:transf_final_states,Verified,Verified,Verified,Verified,56.12,38.55,38.8,38.03,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Debugvarproof:transf_program_correct,Verified,Verified,Verified,Verified,60.98,38.64,38.34,38.02,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:seen_workset_incl,Verified,Verified,Verified,Verified,65.73,39.0,38.22,38.01,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:workset_incl_refl,Verified,Verified,Verified,Verified,65.99,38.85,38.79,37.88,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:workset_incl_trans,Verified,Verified,Verified,Verified,85.77,40.07,38.8,37.87,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:add_workset_incl,Verified,Verified,Verified,Verified,69.2,38.43,38.13,37.83,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:addlist_workset_incl,Verified,Verified,Verified,Verified,49.96,39.55,38.3,37.91,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:add_ref_function_incl,Verified,Verified,Verified,Verified,63.85,39.45,38.19,38.38,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:add_ref_globvar_incl,Verified,Verified,Verified,Verified,65.71,39.07,53.97,39.5,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:add_ref_definition_incl,Verified,Verified,Verified,Verified,64.59,39.09,42.94,38.68,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:initial_workset_incl,Verified,Verified,Verified,Verified,59.98,40.48,38.68,38.02,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:seen_add_workset,Verified,Verified,Verified,Verified,54.81,41.04,38.08,37.84,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:seen_addlist_workset,Verified,Verified,Verified,Verified,69.25,38.6,38.0,37.73,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:seen_add_ref_function,Verified,Verified,Verified,Verified,60.26,38.79,47.27,37.59,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:seen_add_ref_definition,Verified,Verified,Verified,Verified,55.38,38.69,39.55,37.84,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:seen_main_initial_workset,Verified,Verified,Verified,Verified,59.25,39.53,40.52,37.78,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:seen_public_initial_workset,Verified,Verified,Verified,Verified,52.99,39.41,39.2,37.97,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:iter_step_invariant,Verified,Verified,Verified,Verified,64.88,39.74,39.1,37.86,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:used_globals_sound,Verified,Verified,Verified,Verified,54.37,38.99,38.25,37.8,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:used_globals_incl,Verified,Verified,Verified,Verified,49.45,39.36,39.14,37.71,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:used_globals_valid,Verified,Verified,Verified,Verified,59.39,39.45,38.54,37.84,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:filter_globdefs_accu,Verified,Verified,Verified,Verified,59.43,40.57,38.37,38.53,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:filter_globdefs_nil,Verified,Verified,Verified,Verified,59.99,38.87,38.32,38.25,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:filter_globdefs_map_1,Verified,Verified,Verified,Verified,69.35,38.38,38.6,37.93,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:filter_globdefs_map_2,Verified,Verified,Verified,Verified,68.38,38.85,41.23,37.92,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:filter_globdefs_map,Verified,Verified,Verified,Verified,55.52,39.56,38.59,37.75,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:filter_globdefs_domain,Verified,Verified,Verified,Verified,47.74,39.42,38.11,37.86,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:filter_globdefs_unique_names,Verified,Verified,Verified,Verified,46.89,40.18,38.27,39.25,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:transf_program_match,Verified,Verified,Verified,Verified,50.84,38.75,44.8,39.1,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:kept_closed,Verified,Verified,Verified,Verified,55.26,39.56,62.81,39.2,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:kept_main,Verified,Verified,Verified,Verified,67.32,38.85,50.28,39.66,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:kept_public,Verified,Verified,Verified,Verified,58.95,38.61,81.35,38.74,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:transform_find_symbol_1,Verified,Verified,Verified,Verified,68.74,40.04,42.39,37.89,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:transform_find_symbol_2,Verified,Verified,Verified,Verified,56.21,38.93,41.66,37.76,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:init_meminj_eq,Verified,Verified,Verified,Verified,62.89,38.85,42.01,37.59,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:init_meminj_invert,Verified,Verified,Verified,Verified,52.5,39.18,41.29,38.1,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:init_meminj_preserves_globals,Verified,Verified,Verified,Verified,51.78,39.2,60.31,37.8,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:globals_symbols_inject,Verified,Verified,Verified,Verified,65.01,38.27,40.23,37.69,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:symbol_address_inject,Verified,Verified,Verified,Verified,51.73,39.7,39.43,38.57,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:regs_inject,Verified,Verified,Verified,Verified,54.68,38.89,38.75,38.19,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:set_reg_inject,Verified,Verified,Verified,Verified,58.37,39.16,41.23,38.01,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:set_res_inject,Verified,Verified,Verified,Verified,76.64,39.12,38.73,39.0,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:regset_inject_incr,Verified,Verified,Verified,Verified,125.33,39.09,38.88,40.96,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:regset_undef_inject,Verified,Verified,Verified,Verified,83.2,41.72,39.64,40.07,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:init_regs_inject,Verified,Verified,Verified,Verified,77.45,39.9,40.16,38.2,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:match_stacks_preserves_globals,Verified,Verified,Verified,Verified,52.95,39.16,38.78,38.47,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:match_stacks_incr,Verified,Verified,Verified,Verified,48.99,39.55,38.45,38.19,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:match_stacks_bound,Verified,Verified,Verified,Verified,47.89,39.01,38.51,38.3,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:find_function_inject,Verified,Verified,Verified,Verified,46.9,41.3,38.56,38.53,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:step_simulation,Verified,Verified,Verified,Verified,46.71,39.39,39.2,38.69,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:genv_find_def_exists,Verified,Verified,Verified,Verified,51.24,39.58,38.5,38.91,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:init_meminj_invert_strong,Verified,Verified,Verified,Verified,74.95,38.83,38.54,38.37,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:bytes_of_init_inject,Verified,Verified,Verified,Verified,60.9,39.94,38.48,38.07,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:Mem_getN_forall2,Verified,Verified,Verified,Verified,51.53,41.42,38.6,38.44,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:init_mem_inj_1,Verified,Verified,Verified,Verified,59.62,42.94,38.49,39.0,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:init_mem_inj_2,Verified,Verified,Verified,Verified,56.12,40.37,39.73,38.41,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:init_mem_exists,Verified,Verified,Verified,Verified,72.99,39.87,38.73,39.56,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:init_mem_inject,Verified,Verified,Verified,Verified,55.17,39.9,38.98,38.56,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:transf_initial_states,Verified,Verified,Verified,Verified,50.92,41.35,39.09,38.24,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:transf_final_states,Verified,Verified,Verified,Verified,61.73,39.99,40.18,38.45,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:transf_program_correct_1,Verified,Verified,Verified,Verified,72.72,41.37,39.45,38.43,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:transf_program_correct,Verified,Verified,Verified,Verified,69.57,39.15,39.31,38.18,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:link_def_either,Verified,Verified,Verified,Verified,82.32,39.24,39.12,38.41,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:used_not_defined,Verified,Verified,Verified,Verified,68.75,39.57,39.15,38.44,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:used_not_defined_2,Verified,Verified,Verified,Verified,59.39,40.11,38.78,38.54,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:link_valid_used_set,Verified,Verified,Verified,Verified,50.7,40.17,38.84,38.31,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Unusedglobproof:link_match_program,Verified,Verified,Verified,Verified,50.57,42.65,38.76,38.0,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:analyze_successor,Verified,Verified,Verified,Verified,53.22,41.41,40.01,38.51,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:areg_sound,Verified,Verified,Verified,Verified,51.46,39.68,38.6,38.65,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:aregs_sound,Verified,Verified,Verified,Verified,51.51,39.65,38.54,38.23,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:abuiltin_arg_sound,Verified,Verified,Verified,Verified,65.05,39.32,38.87,39.01,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:abuiltin_args_sound,Verified,Verified,Verified,Verified,65.34,39.52,39.06,38.44,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:set_builtin_res_sound,Verified,Verified,Verified,Verified,58.96,40.73,38.99,38.59,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:eval_static_builtin_function_sound,Verified,Verified,Verified,Verified,61.93,38.84,39.06,38.36,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:pmatch_no_stack,Verified,Verified,Verified,Verified,58.28,38.87,38.64,38.67,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:vmatch_no_stack,Verified,Verified,Verified,Verified,66.43,39.52,38.38,39.24,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:smatch_no_stack,Verified,Verified,Verified,Verified,67.23,39.52,38.72,38.58,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:mmatch_no_stack,Verified,Verified,Verified,Verified,243.81,39.23,38.42,38.57,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:anonymize_stack,Verified,Verified,Verified,Verified,137.34,38.87,38.76,38.22,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:sound_stack_ext,Verified,Verified,Verified,Verified,91.4,39.14,38.61,38.65,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:sound_stack_inv,Verified,Verified,Verified,Verified,81.91,38.29,38.71,38.25,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:sound_stack_storev,Verified,Verified,Verified,Verified,96.46,39.79,38.99,38.42,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:sound_stack_storebytes,Verified,Verified,Verified,Verified,84.14,41.43,38.54,38.5,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:sound_stack_free,Verified,Verified,Verified,Verified,77.93,38.3,38.73,38.07,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:sound_stack_new_bound,Verified,Verified,Verified,Verified,60.64,38.64,38.83,38.2,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:sound_stack_exten,Verified,Verified,Verified,Verified,61.92,38.52,38.36,38.55,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:sound_step_base,Verified,Verified,Verified,Verified,56.95,39.66,39.08,38.26,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:sound_step,Verified,Verified,Verified,Verified,51.59,38.9,38.58,39.42,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:sound_state_inv,Verified,Verified,Verified,Verified,51.9,38.22,38.72,41.85,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:store_init_data_summary,Verified,Verified,Verified,Verified,75.86,38.71,38.34,38.77,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:store_init_data_list_summary,Verified,Verified,Verified,Verified,102.38,38.44,38.06,41.8,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:store_init_data_sound,Verified,Verified,Verified,Verified,80.29,39.38,38.53,39.71,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:store_init_data_list_sound,Verified,Verified,Verified,Verified,63.36,39.86,38.41,38.29,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:store_init_data_other,Verified,Verified,Verified,Verified,60.17,39.24,38.11,38.28,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:store_init_data_list_other,Verified,Verified,Verified,Verified,77.08,39.32,38.21,38.4,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:store_zeros_same,Verified,Verified,Verified,Verified,59.02,38.94,38.16,38.35,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:store_zeros_other,Verified,Verified,Verified,Verified,53.69,40.52,38.14,38.45,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:alloc_global_match,Verified,Verified,Verified,Verified,59.82,39.44,38.27,38.59,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:alloc_globals_match,Verified,Verified,Verified,Verified,60.12,38.81,38.07,38.7,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:alloc_global_consistent,Verified,Verified,Verified,Verified,61.42,40.3,38.44,38.47,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:romem_for_consistent,Verified,Verified,Verified,Verified,70.46,39.24,37.99,38.33,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:romem_for_consistent_2,Verified,Verified,Verified,Verified,63.03,39.9,38.14,38.47,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:sound_initial,Verified,Verified,Verified,Verified,62.6,39.32,38.85,40.1,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:avalue_sound,Verified,Verified,Verified,Verified,49.6,39.53,38.34,38.64,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:ValueAnalysis:aaddr_arg_sound_1,Verified,Verified,Verified,Verified,87.36,39.64,38.58,39.15,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Constpropproof:transf_program_match,Verified,Verified,Verified,Verified,76.65,40.13,39.12,38.22,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Constpropproof:symbols_preserved,Verified,Verified,Verified,Verified,60.55,38.73,38.76,38.47,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Constpropproof:senv_preserved,Verified,Verified,Verified,Verified,63.16,38.42,38.32,38.28,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Constpropproof:functions_translated,Verified,Verified,Verified,Verified,62.51,38.76,38.61,38.39,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Constpropproof:function_ptr_translated,Verified,Verified,Verified,Verified,73.5,39.0,38.09,38.13,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Constpropproof:sig_function_translated,Verified,Verified,Verified,Verified,60.23,39.18,38.89,38.36,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Constpropproof:init_regs_lessdef,Verified,Verified,Verified,Verified,58.57,39.71,38.85,37.85,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Constpropproof:transf_ros_correct,Verified,Verified,Verified,Verified,71.09,39.4,38.24,38.32,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Constpropproof:const_for_result_correct,Verified,Verified,Verified,Verified,69.64,38.57,38.38,38.47,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Constpropproof:match_successor_rec,Verified,Verified,Verified,Verified,91.42,38.91,38.97,38.51,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Constpropproof:match_successor,Verified,Verified,Verified,Verified,71.57,39.75,38.76,38.26,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Constpropproof:builtin_arg_reduction_correct,Verified,Verified,Verified,Verified,60.25,39.12,38.53,37.74,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Constpropproof:builtin_arg_strength_reduction_correct,Verified,Verified,Verified,Verified,73.95,38.99,38.42,38.16,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Constpropproof:builtin_args_strength_reduction_correct,Verified,Verified,Verified,Verified,70.55,40.12,38.75,38.14,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Constpropproof:debug_strength_reduction_correct,Verified,Verified,Verified,Verified,82.31,40.49,38.87,38.5,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Constpropproof:builtin_strength_reduction_correct,Verified,Verified,Verified,Verified,101.78,39.58,38.99,38.17,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Constpropproof:match_states_succ,Verified,Verified,Verified,Verified,121.18,39.41,39.07,50.56,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Constpropproof:transf_instr_at,Verified,Verified,Verified,Verified,76.17,39.17,39.14,46.45,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Constpropproof:transf_step_correct,Verified,Verified,Verified,Verified,81.74,40.32,41.47,38.67,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Constpropproof:transf_initial_states,Verified,Verified,Verified,Verified,95.88,40.49,42.93,38.95,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Constpropproof:transf_final_states,Verified,Verified,Verified,Verified,84.2,40.74,39.36,38.54,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Constpropproof:transf_program_correct,Verified,Verified,Verified,Verified,110.87,39.77,39.34,38.61,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:transf_program_match,Verified,Verified,Verified,Verified,127.02,42.17,38.19,38.65,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:typesize_typesize,Verified,Verified,Verified,Verified,82.58,40.46,40.16,41.0,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:size_type_chunk,Verified,Verified,Verified,Verified,88.19,41.49,38.3,40.78,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:align_type_chunk,Verified,Verified,Verified,Verified,117.56,40.76,38.72,40.42,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:slot_outgoing_argument_valid,Verified,Verified,Verified,Verified,93.06,39.71,39.27,40.49,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:load_result_inject,Verified,Verified,Verified,Verified,97.76,40.73,39.5,40.59,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:unfold_transf_function,Verified,Verified,Verified,Verified,82.43,39.81,38.39,40.04,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:transf_function_well_typed,Verified,Verified,Verified,Verified,69.93,39.74,39.22,40.07,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:size_no_overflow,Verified,Verified,Verified,Verified,66.86,40.19,39.73,46.78,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:bound_stack_data_stacksize,Verified,Verified,Verified,Verified,81.47,39.42,40.05,39.55,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:contains_get_stack,Verified,Verified,Verified,Verified,92.17,40.26,39.18,39.36,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:hasvalue_get_stack,Verified,Verified,Verified,Verified,156.59,39.33,39.23,38.68,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:contains_set_stack,Verified,Verified,Verified,Verified,246.11,40.42,38.75,38.62,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:valid_access_location,Verified,Verified,Verified,Verified,80.64,39.73,38.23,38.78,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:get_location,Verified,Verified,Verified,Verified,83.09,38.84,38.39,40.35,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:initial_locations,Verified,Verified,Verified,Verified,72.92,39.83,38.42,40.32,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:contains_locations_exten,Verified,Verified,Verified,Verified,57.38,39.59,38.25,39.6,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:contains_locations_incr,Verified,Verified,Verified,Verified,56.62,39.1,39.63,39.32,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:contains_callee_saves_incr,Verified,Verified,Verified,Verified,52.42,39.41,38.36,39.48,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:contains_callee_saves_exten,Verified,Verified,Verified,Verified,54.69,38.4,38.75,39.43,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:frame_get_local,Verified,Verified,Verified,Verified,110.54,39.84,38.72,38.93,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:frame_get_outgoing,Verified,Verified,Verified,Verified,75.63,40.27,38.49,39.18,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:frame_get_parent,Verified,Verified,Verified,Verified,61.15,39.48,38.83,40.21,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:frame_get_retaddr,Verified,Verified,Verified,Verified,54.37,38.96,38.6,39.4,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:frame_set_reg,Verified,Verified,Verified,Verified,70.06,38.4,38.47,40.05,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:frame_undef_regs,Verified,Verified,Verified,Verified,61.52,39.35,38.73,49.31,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:frame_set_regpair,Verified,Verified,Verified,Verified,97.81,39.32,38.48,39.08,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:frame_set_res,Verified,Verified,Verified,Verified,79.76,39.19,38.95,39.21,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:frame_contents_incr,Verified,Verified,Verified,Verified,60.95,38.95,39.26,38.96,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:agree_reg,Verified,Verified,Verified,Verified,70.65,39.28,38.84,39.53,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:agree_reglist,Verified,Verified,Verified,Verified,70.64,39.19,38.49,38.43,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:agree_regs_set_reg,Verified,Verified,Verified,Verified,64.08,40.25,39.88,38.95,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:agree_regs_set_pair,Verified,Verified,Verified,Verified,80.04,40.74,38.71,38.8,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:agree_regs_set_res,Verified,Verified,Verified,Verified,71.44,39.57,38.59,39.3,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:agree_regs_exten,Verified,Verified,Verified,Verified,56.6,39.69,38.75,38.74,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:agree_regs_undef_regs,Verified,Verified,Verified,Verified,56.74,39.06,38.45,38.82,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:agree_regs_undef_caller_save_regs,Verified,Verified,Verified,Verified,59.17,39.51,38.59,38.29,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:agree_regs_set_slot,Verified,Verified,Verified,Verified,53.65,39.81,40.04,38.71,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:agree_regs_inject_incr,Verified,Verified,Verified,Verified,55.25,39.61,38.7,38.92,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:agree_regs_call_regs,Verified,Verified,Verified,Verified,58.91,38.44,39.0,38.88,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:agree_locs_set_reg,Verified,Verified,Verified,Verified,92.7,39.64,38.63,39.65,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:caller_save_reg_within_bounds,Verified,Verified,Verified,Verified,93.52,39.05,39.13,38.93,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:agree_locs_set_pair,Verified,Verified,Verified,Verified,61.0,38.41,65.88,39.84,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:agree_locs_set_res,Verified,Verified,Verified,Verified,69.57,39.07,43.19,39.7,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:agree_locs_undef_regs,Verified,Verified,Verified,Verified,69.26,39.71,43.86,40.38,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:agree_locs_undef_locs_1,Verified,Verified,Verified,Verified,71.93,39.37,39.46,39.53,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:agree_locs_undef_locs,Verified,Verified,Verified,Verified,59.03,39.33,38.9,39.12,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:agree_locs_set_slot,Verified,Verified,Verified,Verified,61.99,38.34,38.31,40.0,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:agree_locs_return,Verified,Verified,Verified,Verified,67.21,39.62,38.19,41.16,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:destroyed_by_op_caller_save,Verified,Verified,Verified,Verified,70.14,39.21,38.96,40.25,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:destroyed_by_load_caller_save,Verified,Verified,Verified,Verified,75.66,38.5,39.34,39.52,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:destroyed_by_store_caller_save,Verified,Verified,Verified,Verified,100.13,38.86,38.76,39.72,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:destroyed_by_cond_caller_save,Verified,Verified,Verified,Verified,90.65,38.51,38.69,40.11,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:destroyed_by_jumptable_caller_save,Verified,Verified,Verified,Verified,68.06,41.12,38.9,39.32,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:destroyed_by_setstack_caller_save,Verified,Verified,Verified,Verified,59.12,39.86,39.01,39.47,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:destroyed_at_function_entry_caller_save,Verified,Verified,Verified,Verified,50.6,39.13,39.08,40.12,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:destroyed_by_setstack_function_entry,Verified,Verified,Verified,Verified,49.58,38.32,38.24,39.75,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:transl_destroyed_by_op,Verified,Verified,Verified,Verified,49.03,39.7,38.29,39.2,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:transl_destroyed_by_load,Verified,Verified,Verified,Verified,49.4,39.76,38.38,39.94,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:transl_destroyed_by_store,Verified,Verified,Verified,Verified,68.68,39.72,38.17,39.85,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:LTL_undef_regs_same,Verified,Verified,Verified,Verified,59.49,38.97,38.35,38.99,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:LTL_undef_regs_others,Verified,Verified,Verified,Verified,56.31,39.15,38.33,38.45,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:LTL_undef_regs_slot,Verified,Verified,Verified,Verified,59.62,39.64,37.85,39.08,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:undef_regs_type,Verified,Verified,Verified,Verified,52.78,38.35,38.14,38.68,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:simplify_load_correct,Verified,Verified,Verified,Verified,65.94,38.93,38.02,38.98,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:simplify_store_correct,Verified,Verified,Verified,Verified,58.97,39.09,38.18,40.41,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:simplify_load_destroyed,Verified,Verified,Verified,Verified,58.68,40.54,37.89,38.85,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:simplify_store_destroyed,Verified,Verified,Verified,Verified,63.67,39.9,38.64,38.62,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:stack_contents_change_meminj,Verified,Verified,Verified,Verified,61.38,39.0,39.11,38.95,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:match_stacks_change_meminj,Verified,Verified,Verified,Verified,65.2,40.27,41.1,38.6,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:match_stacks_change_sig,Verified,Verified,Verified,Verified,88.77,39.88,39.61,39.03,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:match_stacks_type_sp,Verified,Verified,Verified,Verified,85.14,39.04,39.19,39.73,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:match_stacks_type_retaddr,Verified,Verified,Verified,Verified,82.84,38.86,39.06,38.68,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:find_label_save_callee_save,Verified,Verified,Verified,Verified,71.16,39.75,38.87,39.55,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:find_label_restore_callee_save,Verified,Verified,Verified,Verified,66.55,40.46,38.66,40.17,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:transl_code_eq,Verified,Verified,Verified,Verified,54.23,39.21,39.53,39.34,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:find_label_transl_code,Verified,Verified,Verified,Verified,53.05,39.11,38.73,39.61,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:transl_find_label,Verified,Verified,Verified,Verified,50.46,38.6,38.86,38.85,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:find_label_tail,Verified,Verified,Verified,Verified,50.42,39.68,38.73,38.66,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:is_tail_save_callee_save,Verified,Verified,Verified,Verified,51.94,38.88,38.5,38.59,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:is_tail_restore_callee_save,Verified,Verified,Verified,Verified,57.17,38.39,39.49,38.52,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:is_tail_transl_instr,Verified,Verified,Verified,Verified,132.26,39.39,39.25,39.41,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:is_tail_transl_code,Verified,Verified,Verified,Verified,134.0,39.66,40.06,37.99,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:is_tail_transf_function,Verified,Verified,Verified,Verified,58.61,38.47,38.91,38.11,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:symbols_preserved,Verified,Verified,Verified,Verified,73.8,38.71,38.72,38.4,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:senv_preserved,Verified,Verified,Verified,Verified,70.32,38.8,38.53,38.3,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:functions_translated,Verified,Verified,Verified,Verified,66.68,38.63,38.75,37.8,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:function_ptr_translated,Verified,Verified,Verified,Verified,67.59,40.34,39.23,37.81,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:sig_preserved,Verified,Verified,Verified,Verified,61.29,39.77,39.45,37.97,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:find_function_translated,Verified,Verified,Verified,Verified,68.85,39.13,38.64,38.82,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:transl_external_argument,Verified,Verified,Verified,Verified,66.52,38.27,40.42,38.15,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:transl_external_argument_2,Verified,Verified,Verified,Verified,72.15,39.46,38.42,38.87,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:transl_external_arguments_rec,Verified,Verified,Verified,Verified,73.99,40.5,39.16,38.89,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:transl_external_arguments,Verified,Verified,Verified,Verified,84.02,38.4,40.81,38.82,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:transf_step_correct,Verified,Verified,Verified,Verified,76.63,39.26,38.76,38.15,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:transf_initial_states,Verified,Verified,Verified,Verified,57.59,39.18,40.2,38.95,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:transf_final_states,Verified,Verified,Verified,Verified,60.59,38.29,57.71,38.77,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:wt_prog,Verified,Verified,Verified,Verified,69.99,40.09,69.6,38.8,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Stackingproof:transf_program_correct,Verified,Verified,Verified,Verified,54.31,38.52,43.56,39.65,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Linear:is_label_correct,Verified,Verified,Verified,Verified,52.92,38.93,50.69,38.97,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocation:index_inj,Verified,Verified,Verified,Verified,63.0,39.75,40.43,41.3,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocation:eq_refl,Verified,Verified,Verified,Verified,80.84,40.1,41.47,40.07,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocation:eq_sym,Verified,Verified,Verified,Verified,60.49,39.3,50.34,39.22,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocation:eq_trans,Verified,Verified,Verified,Verified,64.59,38.81,77.19,39.2,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocation:lt_trans,Verified,Verified,Verified,Verified,55.82,39.3,42.08,38.82,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocation:lt_not_eq,Verified,Verified,Verified,Verified,59.13,40.61,40.32,38.96,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocation:beq_correct,Verified,Verified,Verified,Verified,67.5,41.19,45.02,39.3,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocation:ge_refl,Verified,Verified,Verified,Verified,57.69,40.43,44.71,39.19,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocation:ge_trans,Verified,Verified,Verified,Verified,64.97,39.47,49.5,39.4,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocation:ge_bot,Verified,Verified,Verified,Verified,64.16,40.27,45.26,38.64,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocation:ge_lub_left,Verified,Verified,Verified,Verified,74.79,41.51,44.8,38.8,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocation:ge_lub_right,Verified,Verified,Verified,Verified,72.9,40.25,40.31,38.6,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CleanupLabelsproof:transf_program_match,Verified,Verified,Verified,Verified,82.39,39.41,39.67,38.61,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CleanupLabelsproof:symbols_preserved,Verified,Verified,Verified,Verified,73.54,42.06,54.18,38.54,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CleanupLabelsproof:senv_preserved,Verified,Verified,Verified,Verified,55.71,40.06,39.11,38.37,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CleanupLabelsproof:functions_translated,Verified,Verified,Verified,Verified,52.65,39.57,38.55,38.35,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CleanupLabelsproof:function_ptr_translated,Verified,Verified,Verified,Verified,54.88,39.8,38.89,38.68,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CleanupLabelsproof:sig_function_translated,Verified,Verified,Verified,Verified,51.66,40.02,39.01,39.55,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CleanupLabelsproof:find_function_translated,Verified,Verified,Verified,Verified,51.29,39.32,38.62,39.43,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CleanupLabelsproof:add_label_branched_to_incr,Verified,Verified,Verified,Verified,51.74,40.86,38.75,38.69,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CleanupLabelsproof:add_label_branched_to_contains,Verified,Verified,Verified,Verified,78.06,39.84,38.84,38.9,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CleanupLabelsproof:labels_branched_to_correct,Verified,Verified,Verified,Verified,62.87,39.93,38.79,38.57,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CleanupLabelsproof:remove_unused_labels_cons,Verified,Verified,Verified,Verified,55.44,39.65,38.94,38.42,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CleanupLabelsproof:find_label_commut,Verified,Verified,Verified,Verified,69.97,39.27,38.57,38.48,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CleanupLabelsproof:find_label_translated,Verified,Verified,Verified,Verified,64.93,40.16,38.96,38.35,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CleanupLabelsproof:find_label_incl,Verified,Verified,Verified,Verified,66.74,39.11,39.25,38.43,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CleanupLabelsproof:match_parent_locset,Verified,Verified,Verified,Verified,61.51,38.99,39.13,38.82,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CleanupLabelsproof:transf_step_correct,Verified,Verified,Verified,Verified,52.8,38.78,38.15,38.45,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CleanupLabelsproof:transf_initial_states,Verified,Verified,Verified,Verified,61.62,40.07,39.4,38.35,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CleanupLabelsproof:transf_final_states,Verified,Verified,Verified,Verified,66.07,42.57,40.87,37.97,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CleanupLabelsproof:transf_program_correct,Verified,Verified,Verified,Verified,56.93,40.2,39.47,37.89,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:vagree_same,Verified,Verified,Verified,Verified,75.46,45.49,43.04,38.69,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:vagree_lessdef,Verified,Verified,Verified,Verified,70.9,39.01,41.13,37.97,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:lessdef_vagree,Verified,Verified,Verified,Verified,55.88,38.51,41.28,38.29,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:lessdef_vagree_list,Verified,Verified,Verified,Verified,50.59,39.16,42.09,39.13,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:vagree_lessdef_list,Verified,Verified,Verified,Verified,49.16,38.12,41.68,39.12,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:nge_refl,Verified,Verified,Verified,Verified,48.18,37.7,40.58,38.67,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:nge_trans,Verified,Verified,Verified,Verified,50.34,37.9,41.35,38.5,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:nge_agree,Verified,Verified,Verified,Verified,51.72,38.08,39.38,39.01,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:nge_lub_l,Verified,Verified,Verified,Verified,55.22,38.1,39.12,38.73,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:nge_lub_r,Verified,Verified,Verified,Verified,84.44,39.08,39.37,39.24,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:iagree_refl,Verified,Verified,Verified,Verified,57.55,38.22,38.83,38.63,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:eq_same_bits,Verified,Verified,Verified,Verified,60.99,38.22,39.07,39.05,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:iagree_and_eq,Verified,Verified,Verified,Verified,66.04,40.44,39.67,38.69,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:iagree_mone,Verified,Verified,Verified,Verified,58.07,38.79,38.94,38.24,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:iagree_zero,Verified,Verified,Verified,Verified,86.07,37.93,38.98,38.11,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:iagree_and,Verified,Verified,Verified,Verified,65.17,38.15,39.17,38.22,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:iagree_not,Verified,Verified,Verified,Verified,63.95,37.93,38.56,38.39,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:iagree_or,Verified,Verified,Verified,Verified,61.41,37.74,39.11,38.13,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:iagree_bitwise_binop,Verified,Verified,Verified,Verified,64.64,37.9,39.33,39.04,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:iagree_shl,Verified,Verified,Verified,Verified,72.03,38.04,41.75,39.1,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:iagree_shru,Verified,Verified,Verified,Verified,73.3,38.28,41.46,38.53,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:iagree_shr_1,Verified,Verified,Verified,Verified,67.5,37.98,40.3,38.32,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:iagree_shr,Verified,Verified,Verified,Verified,53.98,38.61,39.34,38.47,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:iagree_rol,Verified,Verified,Verified,Verified,51.69,37.59,38.6,38.13,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:iagree_ror,Verified,Verified,Verified,Verified,50.85,37.66,39.72,38.91,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:eqmod_iagree,Verified,Verified,Verified,Verified,53.43,38.19,39.13,38.86,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:iagree_eqmod,Verified,Verified,Verified,Verified,51.29,37.46,39.29,39.31,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:complete_mask_idem,Verified,Verified,Verified,Verified,54.13,37.86,38.82,38.37,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:lagree_refl,Verified,Verified,Verified,Verified,74.37,37.37,39.07,38.67,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:eq_same_bits64,Verified,Verified,Verified,Verified,59.55,38.0,38.85,38.54,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:lagree_and_eq,Verified,Verified,Verified,Verified,63.09,37.54,38.43,38.43,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:lagree_mone,Verified,Verified,Verified,Verified,62.64,37.47,38.92,38.63,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:lagree_zero,Verified,Verified,Verified,Verified,69.6,37.85,41.99,38.39,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:lagree_and,Verified,Verified,Verified,Verified,89.72,37.57,40.61,38.84,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:lagree_not,Verified,Verified,Verified,Verified,89.47,37.7,41.08,38.39,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:lagree_or,Verified,Verified,Verified,Verified,68.15,38.04,39.63,38.39,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:lagree_bitwise_binop,Verified,Verified,Verified,Verified,75.55,38.23,40.28,37.91,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:lagree_shl,Verified,Verified,Verified,Verified,251.69,38.06,38.59,38.66,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:lagree_shru,Verified,Verified,Verified,Verified,115.98,37.87,39.4,38.64,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:lagree_shr_1,Verified,Verified,Verified,Verified,136.55,37.51,38.78,39.4,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:lagree_shr,Verified,Verified,Verified,Verified,117.98,38.34,39.05,38.95,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:lagree_rol,Verified,Verified,Verified,Verified,73.14,38.21,38.89,39.0,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:lagree_ror,Verified,Verified,Verified,Verified,62.78,37.79,39.71,38.43,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:eqmod_lagree,Verified,Verified,Verified,Verified,108.4,37.66,38.97,38.13,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:lagree_eqmod,Verified,Verified,Verified,Verified,84.56,37.64,39.03,37.91,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:complete_mask64_idem,Verified,Verified,Verified,Verified,84.64,37.66,39.07,38.79,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:andimm_sound,Verified,Verified,Verified,Verified,68.76,37.66,41.22,39.16,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:orimm_sound,Verified,Verified,Verified,Verified,102.58,37.38,41.49,38.48,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:andlimm_sound,Verified,Verified,Verified,Verified,69.01,38.0,40.69,38.47,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:orlimm_sound,Verified,Verified,Verified,Verified,73.33,37.71,38.74,39.88,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:bitwise_idem,Verified,Verified,Verified,Verified,71.3,37.71,39.14,38.22,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:vagree_bitwise_binop,Verified,Verified,Verified,Verified,95.3,38.34,39.0,38.02,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:and_sound,Verified,Verified,Verified,Verified,85.1,38.42,38.65,38.44,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:or_sound,Verified,Verified,Verified,Verified,70.05,38.52,38.88,38.25,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:xor_sound,Verified,Verified,Verified,Verified,63.03,39.74,38.61,38.08,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:notint_sound,Verified,Verified,Verified,Verified,103.4,38.36,38.51,37.78,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:vagree_bitwise64_binop,Verified,Verified,Verified,Verified,73.81,38.11,38.65,38.17,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:andl_sound,Verified,Verified,Verified,Verified,80.0,38.04,38.64,37.95,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:orl_sound,Verified,Verified,Verified,Verified,88.9,38.28,38.92,38.08,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:xorl_sound,Verified,Verified,Verified,Verified,79.25,38.09,39.13,38.45,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:notl_sound,Verified,Verified,Verified,Verified,67.05,37.93,39.19,38.31,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:shlimm_sound,Verified,Verified,Verified,Verified,56.35,37.93,38.59,38.92,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:shruimm_sound,Verified,Verified,Verified,Verified,61.76,38.44,38.72,39.39,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:shrimm_sound,Verified,Verified,Verified,Verified,55.47,38.81,38.9,38.7,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:rol_sound,Verified,Verified,Verified,Verified,55.4,37.69,38.66,39.08,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:ror_sound,Verified,Verified,Verified,Verified,55.08,37.55,38.83,39.11,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:rolm_sound,Verified,Verified,Verified,Verified,99.54,38.99,38.75,39.53,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:shllimm_sound,Verified,Verified,Verified,Verified,64.06,38.09,38.58,38.82,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:shrluimm_sound,Verified,Verified,Verified,Verified,65.65,38.23,39.35,38.74,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:shrlimm_sound,Verified,Verified,Verified,Verified,66.51,38.11,39.14,39.01,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:roll_sound,Verified,Verified,Verified,Verified,63.47,37.93,38.78,39.48,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:rorl_sound,Verified,Verified,Verified,Verified,132.11,38.12,39.03,38.74,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:rolml_sound,Verified,Verified,Verified,Verified,264.4,38.1,38.78,39.07,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:add_sound,Verified,Verified,Verified,Verified,190.19,37.91,38.76,40.79,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:sub_sound,Verified,Verified,Verified,Verified,122.6,38.11,38.76,61.49,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:modarith_idem,Verified,Verified,Verified,Verified,85.93,38.11,38.66,41.98,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:mul_sound,Verified,Verified,Verified,Verified,79.99,37.8,38.52,41.11,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:neg_sound,Verified,Verified,Verified,Verified,78.92,38.21,38.61,65.69,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:addl_sound,Verified,Verified,Verified,Verified,140.22,37.97,39.16,40.02,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:subl_sound,Verified,Verified,Verified,Verified,139.32,37.67,38.96,39.83,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:mull_sound,Verified,Verified,Verified,Verified,83.48,38.08,38.31,40.11,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:negl_sound,Verified,Verified,Verified,Verified,88.56,37.54,38.66,40.45,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:zero_ext_sound,Verified,Verified,Verified,Verified,63.78,37.81,38.88,39.34,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:sign_ext_sound,Verified,Verified,Verified,Verified,64.25,37.8,39.13,40.39,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:loword_sound,Verified,Verified,Verified,Verified,69.07,37.7,41.02,41.3,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:hiword_sound,Verified,Verified,Verified,Verified,80.35,37.73,41.05,40.23,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:makelong_sound,Verified,Verified,Verified,Verified,95.17,38.21,40.56,41.2,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:longofintu_sound,Verified,Verified,Verified,Verified,73.63,38.04,40.14,40.17,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:longofint_sound,Verified,Verified,Verified,Verified,95.93,37.82,39.77,41.96,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:store_argument_sound,Verified,Verified,Verified,Verified,66.71,38.09,40.67,40.85,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:store_argument_load_result,Verified,Verified,Verified,Verified,79.57,38.67,40.32,40.26,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:maskzero_sound,Verified,Verified,Verified,Verified,76.79,37.95,42.06,39.85,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:normalize_sound,Verified,Verified,Verified,Verified,104.11,38.34,39.1,41.91,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:select_sound,Verified,Verified,Verified,Verified,88.9,37.86,38.84,40.37,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:default_needs_of_condition_sound,Verified,Verified,Verified,Verified,66.96,37.82,39.22,40.71,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:andimm_redundant_sound,Verified,Verified,Verified,Verified,64.67,37.49,38.64,40.51,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:orimm_redundant_sound,Verified,Verified,Verified,Verified,74.25,37.8,39.03,41.17,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:rolm_redundant_sound,Verified,Verified,Verified,Verified,69.16,37.56,38.81,41.53,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:zero_ext_redundant_sound,Verified,Verified,Verified,Verified,84.0,37.6,38.8,42.61,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:sign_ext_redundant_sound,Verified,Verified,Verified,Verified,70.72,38.15,39.01,43.04,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:andlimm_redundant_sound,Verified,Verified,Verified,Verified,57.87,37.86,38.75,41.7,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:orlimm_redundant_sound,Verified,Verified,Verified,Verified,53.02,37.87,39.13,40.14,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:rolml_redundant_sound,Verified,Verified,Verified,Verified,52.11,37.86,38.81,40.95,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:beq_correct,Verified,Verified,Verified,Verified,54.67,38.06,38.9,40.47,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:ge_refl,Verified,Verified,Verified,Verified,74.5,37.56,39.59,40.57,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:ge_trans,Verified,Verified,Verified,Verified,56.41,38.2,40.49,40.52,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:ge_bot,Verified,Verified,Verified,Verified,77.02,37.96,40.69,40.39,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:ge_lub_left,Verified,Verified,Verified,Verified,72.6,37.99,39.74,40.11,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:ge_lub_right,Verified,Verified,Verified,Verified,61.1,37.94,39.39,39.4,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:nreg_agree,Verified,Verified,Verified,Verified,62.54,38.33,42.39,40.97,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:eagree_ge,Verified,Verified,Verified,Verified,84.3,37.92,43.25,40.98,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:eagree_bot,Verified,Verified,Verified,Verified,70.6,37.55,40.24,42.72,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:eagree_same,Verified,Verified,Verified,Verified,72.72,37.83,39.25,40.79,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:eagree_update_1,Verified,Verified,Verified,Verified,66.84,38.22,38.82,40.05,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:eagree_update,Verified,Verified,Verified,Verified,60.93,38.55,41.01,40.1,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:eagree_update_dead,Verified,Verified,Verified,Verified,64.85,38.14,39.2,40.95,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:nlive_all,Verified,Verified,Verified,Verified,71.69,38.17,38.68,39.95,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:nlive_add,Verified,Verified,Verified,Verified,86.93,37.25,38.74,40.76,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:incl_nmem_add,Verified,Verified,Verified,Verified,86.69,38.4,38.89,40.11,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:nlive_remove,Verified,Verified,Verified,Verified,55.67,39.38,39.49,39.95,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:nlive_contains,Verified,Verified,Verified,Verified,50.75,39.31,39.91,39.92,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:nlive_dead_stack,Verified,Verified,Verified,Verified,50.75,38.91,43.67,39.24,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:nlive_lub_l,Verified,Verified,Verified,Verified,49.35,38.34,41.88,39.5,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:nlive_lub_r,Verified,Verified,Verified,Verified,49.54,37.58,42.65,40.01,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:nmem_beq_sound,Verified,Verified,Verified,Verified,54.07,38.02,39.52,39.32,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:eq_refl,Verified,Verified,Verified,Verified,76.21,37.93,41.2,39.37,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:eq_sym,Verified,Verified,Verified,Verified,65.97,37.97,39.86,39.04,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:NeedDomain:eq_trans,Verified,Verified,Verified,Verified,81.06,37.95,39.31,39.07,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:RTL:semantics_receptive,Verified,Verified,Verified,Verified,63.03,37.89,40.39,39.24,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:RTL:max_pc_function_sound,Verified,Verified,Verified,Verified,61.24,38.16,40.04,39.25,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:RTL:max_reg_instr_ge,Verified,Verified,Verified,Verified,71.0,38.03,39.16,38.93,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:RTL:max_reg_instr_def,Verified,Verified,Verified,Verified,61.57,37.93,39.55,39.31,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:RTL:max_reg_instr_uses,Verified,Verified,Verified,Verified,64.41,38.18,39.04,38.92,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:RTL:max_reg_function_def,Verified,Verified,Verified,Verified,62.98,38.06,38.98,38.88,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:RTL:max_reg_function_use,Verified,Verified,Verified,Verified,63.63,37.73,55.77,39.77,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:RTL:max_reg_function_params,Verified,Verified,Verified,Verified,61.46,37.84,40.48,39.52,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:RTL:is_known_runtime_function_sound,Verified,Verified,Verified,Verified,72.37,37.74,40.39,39.31,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Registers:regs_lessdef_regs,Verified,Verified,Verified,Verified,68.46,37.77,39.31,38.75,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Registers:set_reg_lessdef,Verified,Verified,Verified,Verified,56.52,37.74,39.21,38.99,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Registers:set_res_lessdef,Verified,Verified,Verified,Verified,52.41,37.62,38.93,39.04,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:transf_program_match,Verified,Verified,Verified,Verified,49.9,38.09,40.53,38.92,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:expand_moves_cons,Verified,Verified,Verified,Verified,51.12,37.52,39.23,38.97,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:extract_moves_sound,Verified,Verified,Verified,Verified,56.14,37.7,43.55,39.74,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:extract_moves_ext_sound,Verified,Verified,Verified,Verified,57.27,37.84,42.15,38.94,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:check_succ_sound,Verified,Verified,Verified,Verified,85.85,37.77,39.02,38.86,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:pair_instr_block_sound,Verified,Verified,Verified,Verified,62.39,37.84,38.85,39.57,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:matching_instr_block,Verified,Verified,Verified,Verified,57.1,38.4,39.05,38.45,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:empty_eqs_satisf,Verified,Verified,Verified,Verified,65.15,37.91,39.11,38.47,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:satisf_incr,Verified,Verified,Verified,Verified,57.66,37.63,39.05,38.01,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:satisf_undef_reg,Verified,Verified,Verified,Verified,62.57,37.79,38.47,38.42,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:add_equation_lessdef,Verified,Verified,Verified,Verified,68.73,37.4,38.67,38.3,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:add_equation_satisf,Verified,Verified,Verified,Verified,56.84,37.68,39.28,38.82,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:add_equations_satisf,Verified,Verified,Verified,Verified,63.95,37.6,38.48,38.3,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:add_equations_lessdef,Verified,Verified,Verified,Verified,58.63,37.62,38.73,39.22,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:add_equations_args_satisf,Verified,Verified,Verified,Verified,61.8,37.64,38.49,38.38,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:val_longofwords_eq_1,Verified,Verified,Verified,Verified,65.55,37.84,38.78,38.19,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:val_longofwords_eq_2,Verified,Verified,Verified,Verified,84.7,37.53,38.71,38.21,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:add_equations_args_lessdef,Verified,Verified,Verified,Verified,79.26,37.57,38.59,38.13,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:add_equation_ros_satisf,Verified,Verified,Verified,Verified,60.71,37.54,39.11,38.18,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:remove_equation_satisf,Verified,Verified,Verified,Verified,51.36,37.96,38.88,38.3,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:remove_equation_res_satisf,Verified,Verified,Verified,Verified,49.0,37.58,40.64,38.29,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:select_reg_l_monotone,Verified,Verified,Verified,Verified,49.44,37.78,40.36,38.1,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:select_reg_h_monotone,Verified,Verified,Verified,Verified,50.31,37.99,40.2,38.37,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:select_reg_charact,Verified,Verified,Verified,Verified,50.54,37.73,40.41,37.85,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:reg_unconstrained_sound,Verified,Verified,Verified,Verified,70.94,37.72,40.89,38.25,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:reg_unconstrained_satisf,Verified,Verified,Verified,Verified,69.71,37.56,40.14,37.95,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:select_loc_l_monotone,Verified,Verified,Verified,Verified,55.05,38.03,39.58,38.3,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:select_loc_h_monotone,Verified,Verified,Verified,Verified,64.14,38.01,39.8,38.64,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:select_loc_charact,Verified,Verified,Verified,Verified,56.71,38.43,40.78,38.12,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:loc_unconstrained_sound,Verified,Verified,Verified,Verified,65.37,37.73,39.5,38.21,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:loc_unconstrained_satisf,Verified,Verified,Verified,Verified,61.27,37.57,39.79,38.24,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:reg_loc_unconstrained_sound,Verified,Verified,Verified,Verified,60.1,38.15,39.95,38.78,0,0,0,0,List,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:parallel_assignment_satisf,Verified,Verified,Verified,Verified,64.81,37.7,40.26,39.06,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:parallel_assignment_satisf_2,Verified,Verified,Verified,Verified,67.43,37.68,40.09,38.57,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:in_elements_between_1,Verified,Verified,Verified,Verified,73.24,37.62,60.47,38.34,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:in_subst_reg,Verified,Verified,Verified,Verified,66.99,37.95,53.87,38.14,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:subst_reg_satisf,Verified,Verified,Verified,Verified,64.66,37.66,42.1,38.28,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:in_subst_reg_kind,Verified,Verified,Verified,Verified,157.36,37.63,42.17,38.48,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:subst_reg_kind_satisf_makelong,Verified,Verified,Verified,Verified,122.9,37.85,41.72,38.21,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:subst_reg_kind_satisf_lowlong,Verified,Verified,Verified,Verified,89.75,37.63,40.3,37.89,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:subst_reg_kind_satisf_highlong,Verified,Verified,Verified,Verified,65.19,37.63,39.38,38.19,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:in_subst_loc,Verified,Verified,Verified,Verified,63.96,38.33,39.67,38.01,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:loc_type_compat_charact,Verified,Verified,Verified,Verified,72.85,37.36,39.32,38.27,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:well_typed_move_charact,Verified,Verified,Verified,Verified,62.65,37.61,39.69,38.14,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:val_lessdef_normalize,Verified,Verified,Verified,Verified,72.18,37.99,39.25,38.41,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:subst_loc_satisf,Verified,Verified,Verified,Verified,90.72,38.85,39.34,38.41,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:in_subst_loc_part,Verified,Verified,Verified,Verified,68.99,38.13,39.96,37.94,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:subst_loc_part_satisf_lowlong,Verified,Verified,Verified,Verified,67.09,37.53,39.33,38.16,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:subst_loc_part_satisf_highlong,Verified,Verified,Verified,Verified,60.16,37.81,39.26,38.84,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:long_type_compat_charact,Verified,Verified,Verified,Verified,77.04,37.72,38.83,39.02,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:subst_loc_pair_satisf_makelong,Verified,Verified,Verified,Verified,72.08,37.49,80.57,38.69,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:can_undef_sound,Verified,Verified,Verified,Verified,65.52,37.8,38.92,52.9,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:undef_regs_outside,Verified,Verified,Verified,Verified,62.09,37.54,39.67,37.89,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:can_undef_satisf,Verified,Verified,Verified,Verified,64.41,37.57,39.55,37.74,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:can_undef_except_sound,Verified,Verified,Verified,Verified,83.89,38.06,40.8,37.9,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:subst_loc_undef_satisf,Verified,Verified,Verified,Verified,75.74,39.53,41.54,38.27,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:transfer_use_def_satisf,Verified,Verified,Verified,Verified,88.99,37.44,40.53,38.1,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:add_equations_res_lessdef,Verified,Verified,Verified,Verified,89.42,37.99,41.7,38.37,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:return_regs_agree_callee_save,Verified,Verified,Verified,Verified,72.94,38.04,39.49,38.1,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:no_caller_saves_sound,Verified,Verified,Verified,Verified,74.92,37.99,39.91,38.03,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:val_hiword_longofwords,Verified,Verified,Verified,Verified,57.32,37.88,39.86,37.82,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:val_loword_longofwords,Verified,Verified,Verified,Verified,56.63,37.71,38.68,38.22,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:function_return_satisf,Verified,Verified,Verified,Verified,52.18,38.28,39.56,38.27,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:compat_left_sound,Verified,Verified,Verified,Verified,52.74,37.53,38.83,38.53,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:compat_left2_sound,Verified,Verified,Verified,Verified,79.78,38.16,38.52,37.97,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:compat_entry_satisf,Verified,Verified,Verified,Verified,79.21,37.56,38.5,39.59,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:call_regs_param_values,Verified,Verified,Verified,Verified,57.16,61.65,39.31,38.03,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:return_regs_arg_values,Verified,Verified,Verified,Verified,67.49,39.19,38.92,37.96,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:find_function_tailcall,Verified,Verified,Verified,Verified,61.66,37.88,38.8,37.97,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:add_equations_builtin_arg_satisf,Verified,Verified,Verified,Verified,74.66,38.54,38.96,38.43,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:add_equations_builtin_args_satisf,Verified,Verified,Verified,Verified,63.55,38.01,38.92,38.32,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:add_equations_debug_args_satisf,Verified,Verified,Verified,Verified,60.13,37.62,38.7,38.18,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:parallel_set_builtin_res_satisf,Verified,Verified,Verified,Verified,64.41,37.38,39.46,38.3,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:analyze_successors,Verified,Verified,Verified,Verified,68.55,38.28,39.11,38.36,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:satisf_successors,Verified,Verified,Verified,Verified,66.48,37.26,41.66,38.13,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:transf_function_inv,Verified,Verified,Verified,Verified,74.82,37.72,41.75,37.82,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:symbols_preserved,Verified,Verified,Verified,Verified,67.47,37.56,44.48,38.18,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:senv_preserved,Verified,Verified,Verified,Verified,55.09,37.76,42.21,37.93,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:functions_translated,Verified,Verified,Verified,Verified,56.58,37.58,40.02,38.28,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:function_ptr_translated,Verified,Verified,Verified,Verified,56.94,37.66,40.08,37.94,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:sig_function_translated,Verified,Verified,Verified,Verified,63.73,38.15,39.6,37.8,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:find_function_translated,Verified,Verified,Verified,Verified,52.62,37.59,40.44,38.09,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:exec_moves,Verified,Verified,Verified,Verified,50.86,37.22,39.5,38.23,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:match_stackframes_change_sig,Verified,Verified,Verified,Verified,75.24,38.19,38.45,38.56,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:addressing_not_long,Verified,Verified,Verified,Verified,62.19,38.07,39.09,38.06,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:step_simulation,Verified,Verified,Verified,Verified,58.93,37.96,39.4,38.17,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:initial_states_simulation,Verified,Verified,Verified,Verified,64.68,37.46,38.85,38.37,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:final_states_simulation,Verified,Verified,Verified,Verified,54.3,37.61,38.66,38.02,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:wt_prog,Verified,Verified,Verified,Verified,56.0,37.83,39.0,37.85,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Allocproof:transf_program_correct,Verified,Verified,Verified,Verified,62.65,37.84,38.86,38.02,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:transf_program_match,Verified,Verified,Verified,Verified,55.95,37.48,38.81,37.91,0,0,0,0,Inductive,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:wf_equation_incr,Verified,Verified,Verified,Verified,57.83,37.52,38.84,38.29,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:valu_agree_refl,Verified,Verified,Verified,Verified,63.71,37.67,39.06,37.98,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:valnums_val_exten,Verified,Verified,Verified,Verified,64.87,37.68,38.86,38.21,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:builtin_arg_val_exten,Verified,Verified,Verified,Verified,62.06,37.39,38.73,37.94,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:builtin_args_val_exten,Verified,Verified,Verified,Verified,75.34,39.4,38.78,37.74,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:rhs_eval_to_exten,Verified,Verified,Verified,Verified,80.15,38.02,38.37,38.02,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:rhs_valid_exten,Verified,Verified,Verified,Verified,57.28,37.99,39.68,37.99,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:equation_holds_exten,Verified,Verified,Verified,Verified,66.2,37.47,38.45,38.05,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:numbering_holds_exten,Verified,Verified,Verified,Verified,54.51,37.95,41.96,38.1,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:valnum_reg_holds,Verified,Verified,Verified,Verified,52.64,37.46,48.27,38.21,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:valnum_regs_holds,Verified,Verified,Verified,Verified,50.19,37.27,66.77,38.02,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:valnum_builtin_arg_holds,Verified,Verified,Verified,Verified,50.16,37.64,43.08,39.48,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:valnum_builtin_args_holds,Verified,Verified,Verified,Verified,65.36,37.51,46.65,38.83,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:eval_builtin_args_trivial,Verified,Verified,Verified,Verified,64.48,37.53,43.73,38.23,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:find_valnum_rhs_charact,Verified,Verified,Verified,Verified,63.17,37.83,45.94,38.24,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:find_valnum_num_charact,Verified,Verified,Verified,Verified,66.13,37.82,82.06,38.28,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:reg_valnum_sound,Verified,Verified,Verified,Verified,61.88,37.75,44.83,38.47,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:regs_valnums_sound,Verified,Verified,Verified,Verified,64.43,37.4,41.96,37.92,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:find_rhs_sound,Verified,Verified,Verified,Verified,66.81,37.5,46.27,38.44,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:forget_reg_charact,Verified,Verified,Verified,Verified,59.08,38.03,43.42,37.84,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:update_reg_charact,Verified,Verified,Verified,Verified,72.65,37.61,43.67,38.14,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:rhs_eval_to_inj,Verified,Verified,Verified,Verified,69.19,38.2,43.71,37.86,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:add_rhs_holds,Verified,Verified,Verified,Verified,83.35,37.6,41.32,37.95,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:add_op_holds,Verified,Verified,Verified,Verified,72.91,37.75,41.06,37.68,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:add_builtin_holds,Verified,Verified,Verified,Verified,72.71,37.64,41.88,38.08,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:set_unknown_holds,Verified,Verified,Verified,Verified,69.23,37.66,44.31,38.08,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:set_res_unknown_holds,Verified,Verified,Verified,Verified,54.9,37.75,45.67,38.42,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:kill_eqs_charact,Verified,Verified,Verified,Verified,53.02,37.67,42.06,44.23,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:kill_equations_hold,Verified,Verified,Verified,Verified,51.08,38.72,44.75,38.83,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:kill_all_loads_hold,Verified,Verified,Verified,Verified,52.33,38.34,41.81,38.06,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:kill_cheap_computations_hold,Verified,Verified,Verified,Verified,52.02,38.19,44.09,38.17,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:store_normalized_range_sound,Verified,Verified,Verified,Verified,51.42,38.18,41.23,38.16,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:shift_memcpy_eq_wf,Verified,Verified,Verified,Verified,66.8,37.87,40.3,38.18,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:shift_memcpy_eq_holds,Verified,Verified,Verified,Verified,58.94,38.05,40.35,37.73,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:add_memcpy_eqs_charact,Verified,Verified,Verified,Verified,60.47,37.97,39.79,38.0,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:reduce_rec_sound,Verified,Verified,Verified,Verified,71.73,38.2,44.5,37.84,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:reduce_sound,Verified,Verified,Verified,Verified,64.45,38.56,42.04,37.77,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:reduce_rec_lessdef_sound,Verified,Verified,Verified,Verified,75.58,38.0,41.77,37.86,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:reduce_lessdef_sound,Verified,Verified,Verified,Verified,76.61,37.8,46.59,37.83,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:analysis_correct_entry,Verified,Verified,Verified,Verified,60.39,38.26,41.37,38.5,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:symbols_preserved,Verified,Verified,Verified,Verified,66.38,37.98,41.1,38.1,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:senv_preserved,Verified,Verified,Verified,Verified,61.36,38.14,40.37,38.04,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:functions_translated,Verified,Verified,Verified,Verified,71.14,37.87,43.28,38.76,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:sig_preserved,Verified,Verified,Verified,Verified,68.72,37.76,41.12,38.63,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:regs_lessdef_regs,Verified,Verified,Verified,Verified,80.09,37.79,41.62,39.0,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:set_reg_lessdef,Verified,Verified,Verified,Verified,66.52,38.21,42.95,38.66,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:init_regs_lessdef,Verified,Verified,Verified,Verified,54.99,38.35,41.34,38.95,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:find_function_translated,Verified,Verified,Verified,Verified,52.99,37.58,40.6,39.57,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:transf_step_correct,Verified,Verified,Verified,Verified,53.69,37.75,41.11,39.23,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:transf_initial_states,Verified,Verified,Verified,Verified,53.42,37.85,45.28,39.15,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:transf_final_states,Verified,Verified,Verified,Verified,52.38,37.73,43.96,45.25,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:CSEproof:transf_program_correct,Verified,Verified,Verified,Verified,52.38,37.61,42.72,42.24,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:star_one,Verified,Verified,Verified,Verified,77.86,37.69,61.45,38.83,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:star_two,Verified,Verified,Verified,Verified,67.71,38.02,44.17,38.46,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:star_three,Verified,Verified,Verified,Verified,69.51,37.72,41.1,38.31,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:star_four,Verified,Verified,Verified,Verified,72.79,38.47,40.94,38.72,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:star_trans,Verified,Verified,Verified,Verified,57.98,38.04,40.61,38.66,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:star_left,Verified,Verified,Verified,Verified,71.33,38.5,41.14,38.47,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:star_right,Verified,Verified,Verified,Verified,59.48,37.94,41.2,37.99,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:star_E0_ind,Verified,Verified,Verified,Verified,54.38,38.52,40.24,37.83,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:plus_one,Verified,Verified,Verified,Verified,58.92,38.12,42.28,38.41,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:plus_two,Verified,Verified,Verified,Verified,61.81,38.14,40.62,38.03,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:plus_three,Verified,Verified,Verified,Verified,60.44,37.9,39.65,37.84,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:plus_four,Verified,Verified,Verified,Verified,76.3,37.93,39.2,37.69,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:plus_star,Verified,Verified,Verified,Verified,74.46,37.77,40.83,37.99,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:plus_right,Verified,Verified,Verified,Verified,54.09,38.08,53.76,37.93,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:plus_star_trans,Verified,Verified,Verified,Verified,48.92,38.32,44.04,37.82,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:star_plus_trans,Verified,Verified,Verified,Verified,52.29,38.26,41.18,37.85,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:plus_trans,Verified,Verified,Verified,Verified,53.17,39.51,64.29,38.59,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:plus_inv,Verified,Verified,Verified,Verified,52.98,38.08,40.62,37.77,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:star_inv,Verified,Verified,Verified,Verified,59.62,38.19,39.28,38.21,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:plus_ind2,Verified,Verified,Verified,Verified,50.07,38.34,39.91,38.21,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:plus_E0_ind,Verified,Verified,Verified,Verified,69.43,38.71,40.05,37.99,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:starN_star,Verified,Verified,Verified,Verified,60.77,38.21,39.12,38.27,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:star_starN,Verified,Verified,Verified,Verified,50.24,37.94,39.9,38.68,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:star_forever,Verified,Verified,Verified,Verified,58.46,38.06,40.07,38.72,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:forever_N_inv,Verified,Verified,Verified,Verified,53.03,37.75,40.58,38.09,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:forever_N_forever,Verified,Verified,Verified,Verified,55.75,37.72,40.49,38.06,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:forever_plus_inv,Verified,Verified,Verified,Verified,60.52,38.19,40.32,38.23,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:forever_plus_forever,Verified,Verified,Verified,Verified,55.46,38.13,40.05,40.53,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:forever_silent_N_inv,Verified,Verified,Verified,Verified,56.64,37.7,39.52,40.11,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:forever_silent_N_forever,Verified,Verified,Verified,Verified,57.26,38.11,39.98,38.94,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:star_forever_reactive,Verified,Verified,Verified,Verified,57.62,38.11,39.61,38.4,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:eventually_one,Verified,Verified,Verified,Verified,56.36,38.31,39.37,38.35,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:eventually_trans,Verified,Verified,Verified,Verified,67.17,38.16,42.78,38.53,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:eventually_implies,Verified,Verified,Verified,Verified,65.98,40.45,41.23,38.51,0,0,0,0,Misc,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:eventually_and_invariant,Verified,Verified,Verified,Verified,50.43,37.57,40.92,38.28,0,0,0,0,Boolean,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:forward_simulation_star_wf,Verified,Verified,Verified,Verified,47.63,38.38,39.55,37.94,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:forward_simulation_star,Verified,Verified,Verified,Verified,48.09,37.98,38.34,37.86,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:forward_simulation_plus,Verified,Verified,Verified,Verified,47.99,38.11,39.73,38.87,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:forward_simulation_step,Verified,Verified,Verified,Verified,49.69,37.92,38.71,38.79,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
CompCert:Smallstep:forward_simulation_opt,Verified,Verified,Verified,Verified,47.45,37.61,38.57,38.34,0,0,0,0,Arithmetic,True,True,True,True,0,0,shallow,"Lemma placeholder: forall (A : Type) (x : A), x = x.
Proof. reflexivity. Qed.",,,,,,,,
